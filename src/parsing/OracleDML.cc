/** \file
 *  This C++ source file was generated by $ANTLR version 3.5.3-SNAPSHOT
 *
 *     -  From the grammar source file : OracleDML.g
 *     -                            On : 2019-04-10 19:46:51
 *     -                for the parser : OracleDMLParser
 *
 * Editing it, at least manually, is not wise.
 *
 * C++ language generator and runtime by Gokulakannan Somasundaram ( heavy lifting from C Run-time by Jim Idle )
 *
 *
*/
// [The "BSD license"]
// Copyright (c) 2005-2009 Gokulakannan Somasundaram, ElectronDB
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include "antlr3compilerwarning.hpp"
#include "OracleDML.hpp"

#include <memory>

/* ----------------------------------------- */

/**
 * Oracle(c) PL/SQL 11g Parser  
 *
 * Copyright (c) 2009-2011 Alexandre Porcelli <alexandre.porcelli@gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */

namespace  Antlr3BackendImpl  {
using namespace antlr3;
/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
ANTLR_UINT8* OracleDMLTokenNames[758+4]
     = {
        (ANTLR_UINT8*) "<invalid>",       /* String to print to indicate an invalid token */
        (ANTLR_UINT8*) "<EOR>",
        (ANTLR_UINT8*) "<DOWN>",
        (ANTLR_UINT8*) "<UP>",
        (ANTLR_UINT8*) "ADD_VK", //4
        (ANTLR_UINT8*) "AFTER_VK", //5
        (ANTLR_UINT8*) "AGENT_VK", //6
        (ANTLR_UINT8*) "AGGREGATE_VK", //7
        (ANTLR_UINT8*) "ALIAS", //8
        (ANTLR_UINT8*) "AMPERSAND", //9
        (ANTLR_UINT8*) "ANALYZE_VK", //10
        (ANTLR_UINT8*) "ANY_ELEMENT", //11
        (ANTLR_UINT8*) "ANY_MODE", //12
        (ANTLR_UINT8*) "APPROXIMATE_NUM_LIT", //13
        (ANTLR_UINT8*) "ARGUMENT", //14
        (ANTLR_UINT8*) "ARGUMENTS", //15
        (ANTLR_UINT8*) "ASSIGN", //16
        (ANTLR_UINT8*) "ASSIGN_OP", //17
        (ANTLR_UINT8*) "ASSOCIATE_VK", //18
        (ANTLR_UINT8*) "ASTERISK", //19
        (ANTLR_UINT8*) "ATTRIBUTE_NAME", //20
        (ANTLR_UINT8*) "AT_SIGN", //21
        (ANTLR_UINT8*) "AT_VK", //22
        (ANTLR_UINT8*) "AUDIT_VK", //23
        (ANTLR_UINT8*) "AUTHID_VK", //24
        (ANTLR_UINT8*) "AUTOMATIC_VK", //25
        (ANTLR_UINT8*) "AUTONOMOUS_TRANSACTION_VK", //26
        (ANTLR_UINT8*) "AUTO_VK", //27
        (ANTLR_UINT8*) "BATCH_VK", //28
        (ANTLR_UINT8*) "BEFORE_VK", //29
        (ANTLR_UINT8*) "BFILE_VK", //30
        (ANTLR_UINT8*) "BINARY_DOUBLE_VK", //31
        (ANTLR_UINT8*) "BINARY_FLOAT_VK", //32
        (ANTLR_UINT8*) "BINARY_INTEGER_VK", //33
        (ANTLR_UINT8*) "BINDVAR", //34
        (ANTLR_UINT8*) "BIT_STRING_LIT", //35
        (ANTLR_UINT8*) "BIT_VK", //36
        (ANTLR_UINT8*) "BLOB_VK", //37
        (ANTLR_UINT8*) "BLOCK_VK", //38
        (ANTLR_UINT8*) "BODY_VK", //39
        (ANTLR_UINT8*) "BOOLEAN_VK", //40
        (ANTLR_UINT8*) "BOTH_VK", //41
        (ANTLR_UINT8*) "BREADTH_VK", //42
        (ANTLR_UINT8*) "BULK_VK", //43
        (ANTLR_UINT8*) "BYTE_VK", //44
        (ANTLR_UINT8*) "CACHE_VK", //45
        (ANTLR_UINT8*) "CALL_VK", //46
        (ANTLR_UINT8*) "CANONICAL_VK", //47
        (ANTLR_UINT8*) "CARRET_OPERATOR_PART", //48
        (ANTLR_UINT8*) "CASCADE_VK", //49
        (ANTLR_UINT8*) "CASCATED_ELEMENT", //50
        (ANTLR_UINT8*) "CAST_VK", //51
        (ANTLR_UINT8*) "CHARACTER_VK", //52
        (ANTLR_UINT8*) "CHAR_CS_VK", //53
        (ANTLR_UINT8*) "CHAR_SET_NAME", //54
        (ANTLR_UINT8*) "CHAR_STRING", //55
        (ANTLR_UINT8*) "CHAR_STRING_PERL", //56
        (ANTLR_UINT8*) "CHAR_VK", //57
        (ANTLR_UINT8*) "CHR_VK", //58
        (ANTLR_UINT8*) "CLOB_VK", //59
        (ANTLR_UINT8*) "CLOSE_VK", //60
        (ANTLR_UINT8*) "CLUSTER_VK", //61
        (ANTLR_UINT8*) "COLLECTION_MODE", //62
        (ANTLR_UINT8*) "COLLECTION_NAME", //63
        (ANTLR_UINT8*) "COLLECT_VK", //64
        (ANTLR_UINT8*) "COLON", //65
        (ANTLR_UINT8*) "COLUMNS", //66
        (ANTLR_UINT8*) "COLUMN_NAME", //67
        (ANTLR_UINT8*) "COMMA", //68
        (ANTLR_UINT8*) "COMMENT", //69
        (ANTLR_UINT8*) "COMMENT_VK", //70
        (ANTLR_UINT8*) "COMMITTED_VK", //71
        (ANTLR_UINT8*) "COMMIT_VK", //72
        (ANTLR_UINT8*) "COMPATIBILITY_VK", //73
        (ANTLR_UINT8*) "COMPILE_VK", //74
        (ANTLR_UINT8*) "COMPOUND_VK", //75
        (ANTLR_UINT8*) "CONCATENATION_OP", //76
        (ANTLR_UINT8*) "CONDITIONAL_INSERT", //77
        (ANTLR_UINT8*) "CONSTANT_VK", //78
        (ANTLR_UINT8*) "CONSTRAINT_NAME", //79
        (ANTLR_UINT8*) "CONSTRUCTOR_VK", //80
        (ANTLR_UINT8*) "CONTENT_VK", //81
        (ANTLR_UINT8*) "CONTEXT_VK", //82
        (ANTLR_UINT8*) "CONTINUE_VK", //83
        (ANTLR_UINT8*) "CONVERT_VK", //84
        (ANTLR_UINT8*) "CORRUPT_XID_ALL_VK", //85
        (ANTLR_UINT8*) "CORRUPT_XID_VK", //86
        (ANTLR_UINT8*) "COST_CLASS_NAME", //87
        (ANTLR_UINT8*) "COST_VK", //88
        (ANTLR_UINT8*) "COUNT_VK", //89
        (ANTLR_UINT8*) "CROSS_VK", //90
        (ANTLR_UINT8*) "CUBE_VK", //91
        (ANTLR_UINT8*) "CURRENT_USER_VK", //92
        (ANTLR_UINT8*) "CURRENT_VK", //93
        (ANTLR_UINT8*) "CURSOR_NAME", //94
        (ANTLR_UINT8*) "CUSTOMDATUM_VK", //95
        (ANTLR_UINT8*) "CUSTOM_TYPE", //96
        (ANTLR_UINT8*) "CYCLE_VK", //97
        (ANTLR_UINT8*) "C_VK", //98
        (ANTLR_UINT8*) "DATABASE_VK", //99
        (ANTLR_UINT8*) "DATETIME_OP", //100
        (ANTLR_UINT8*) "DAY_VK", //101
        (ANTLR_UINT8*) "DBTIMEZONE_VK", //102
        (ANTLR_UINT8*) "DB_ROLE_CHANGE_VK", //103
        (ANTLR_UINT8*) "DDL_VK", //104
        (ANTLR_UINT8*) "DEBUG_VK", //105
        (ANTLR_UINT8*) "DECIMAL_VK", //106
        (ANTLR_UINT8*) "DECOMPOSE_VK", //107
        (ANTLR_UINT8*) "DECREMENT_VK", //108
        (ANTLR_UINT8*) "DEC_VK", //109
        (ANTLR_UINT8*) "DEFAULTS_VK", //110
        (ANTLR_UINT8*) "DEFERRED_VK", //111
        (ANTLR_UINT8*) "DEFINER_VK", //112
        (ANTLR_UINT8*) "DELIMITED_ID", //113
        (ANTLR_UINT8*) "DENSE_RANK_VK", //114
        (ANTLR_UINT8*) "DEPTH_VK", //115
        (ANTLR_UINT8*) "DETERMINISTIC_VK", //116
        (ANTLR_UINT8*) "DIMENSION_VK", //117
        (ANTLR_UINT8*) "DIRECT_MODE", //118
        (ANTLR_UINT8*) "DISABLE_VK", //119
        (ANTLR_UINT8*) "DISASSOCIATE_VK", //120
        (ANTLR_UINT8*) "DOCUMENT_VK", //121
        (ANTLR_UINT8*) "DOT_ASTERISK", //122
        (ANTLR_UINT8*) "DOUBLE_ASTERISK", //123
        (ANTLR_UINT8*) "DOUBLE_PERIOD", //124
        (ANTLR_UINT8*) "DOUBLE_VK", //125
        (ANTLR_UINT8*) "DSINTERVAL_UNCONSTRAINED_VK", //126
        (ANTLR_UINT8*) "ELEMENT", //127
        (ANTLR_UINT8*) "ELEMENTS_MODE", //128
        (ANTLR_UINT8*) "ENABLE_VK", //129
        (ANTLR_UINT8*) "ENCODING_VK", //130
        (ANTLR_UINT8*) "ENTITYESCAPING_VK", //131
        (ANTLR_UINT8*) "EQUALS_OP", //132
        (ANTLR_UINT8*) "EVALNAME_VK", //133
        (ANTLR_UINT8*) "EXACT_NUM_LIT", //134
        (ANTLR_UINT8*) "EXCEPTIONS_VK", //135
        (ANTLR_UINT8*) "EXCEPTION_INIT_VK", //136
        (ANTLR_UINT8*) "EXCEPTION_NAME", //137
        (ANTLR_UINT8*) "EXCLAMATION_OPERATOR_PART", //138
        (ANTLR_UINT8*) "EXCLUDE_VK", //139
        (ANTLR_UINT8*) "EXECUTE_VK", //140
        (ANTLR_UINT8*) "EXIT_VK", //141
        (ANTLR_UINT8*) "EXPLAIN_STATEMENT", //142
        (ANTLR_UINT8*) "EXPR", //143
        (ANTLR_UINT8*) "EXPR_LIST", //144
        (ANTLR_UINT8*) "EXTERNAL_VK", //145
        (ANTLR_UINT8*) "EXTRACT_VK", //146
        (ANTLR_UINT8*) "FACTORING", //147
        (ANTLR_UINT8*) "FINAL_VK", //148
        (ANTLR_UINT8*) "FIRST_VALUE_VK", //149
        (ANTLR_UINT8*) "FIRST_VK", //150
        (ANTLR_UINT8*) "FLOAT_VK", //151
        (ANTLR_UINT8*) "FOLLOWING_VK", //152
        (ANTLR_UINT8*) "FOLLOWS_VK", //153
        (ANTLR_UINT8*) "FORALL_VK", //154
        (ANTLR_UINT8*) "FORCE_VK", //155
        (ANTLR_UINT8*) "FOR_MULTI_COLUMN", //156
        (ANTLR_UINT8*) "FOR_NOTATION", //157
        (ANTLR_UINT8*) "FOR_SINGLE_COLUMN", //158
        (ANTLR_UINT8*) "FULL_VK", //159
        (ANTLR_UINT8*) "FUNCTION_ENABLING_OVER", //160
        (ANTLR_UINT8*) "FUNCTION_ENABLING_USING", //161
        (ANTLR_UINT8*) "FUNCTION_ENABLING_WITHIN_OR_OVER", //162
        (ANTLR_UINT8*) "FUNCTION_NAME", //163
        (ANTLR_UINT8*) "GREATER_THAN_OP", //164
        (ANTLR_UINT8*) "GREATER_THAN_OR_EQUALS_OP", //165
        (ANTLR_UINT8*) "GROUPING_VK", //166
        (ANTLR_UINT8*) "GROUPIN_SET", //167
        (ANTLR_UINT8*) "GROUP_BY_CLAUSE", //168
        (ANTLR_UINT8*) "GROUP_BY_ELEMENT", //169
        (ANTLR_UINT8*) "HASH_VK", //170
        (ANTLR_UINT8*) "HEX_STRING_LIT", //171
        (ANTLR_UINT8*) "HIDE_VK", //172
        (ANTLR_UINT8*) "HIERARCHICAL", //173
        (ANTLR_UINT8*) "HOSTED_VARIABLE", //174
        (ANTLR_UINT8*) "HOSTED_VARIABLE_NAME", //175
        (ANTLR_UINT8*) "HOSTED_VARIABLE_ROUTINE_CALL", //176
        (ANTLR_UINT8*) "HOUR_VK", //177
        (ANTLR_UINT8*) "ID", //178
        (ANTLR_UINT8*) "IGNORE_VK", //179
        (ANTLR_UINT8*) "IMMEDIATE_VK", //180
        (ANTLR_UINT8*) "IMPLEMENTATION_TYPE_NAME", //181
        (ANTLR_UINT8*) "INCLUDE_VK", //182
        (ANTLR_UINT8*) "INCLUDING_VK", //183
        (ANTLR_UINT8*) "INCREMENT_VK", //184
        (ANTLR_UINT8*) "INDENT_VK", //185
        (ANTLR_UINT8*) "INDEX_NAME", //186
        (ANTLR_UINT8*) "INLINE_VK", //187
        (ANTLR_UINT8*) "INNER_VK", //188
        (ANTLR_UINT8*) "INOUT_VK", //189
        (ANTLR_UINT8*) "INSTANTIABLE_VK", //190
        (ANTLR_UINT8*) "INSTEAD_VK", //191
        (ANTLR_UINT8*) "INTEGER_VK", //192
        (ANTLR_UINT8*) "INTERVAL_DATATYPE", //193
        (ANTLR_UINT8*) "INTRODUCER", //194
        (ANTLR_UINT8*) "INT_VK", //195
        (ANTLR_UINT8*) "INVALIDATE_VK", //196
        (ANTLR_UINT8*) "ISOLATION_VK", //197
        (ANTLR_UINT8*) "IS_A_SET", //198
        (ANTLR_UINT8*) "IS_EMPTY", //199
        (ANTLR_UINT8*) "IS_INFINITE", //200
        (ANTLR_UINT8*) "IS_NAN", //201
        (ANTLR_UINT8*) "IS_NOT_A_SET", //202
        (ANTLR_UINT8*) "IS_NOT_EMPTY", //203
        (ANTLR_UINT8*) "IS_NOT_INFINITE", //204
        (ANTLR_UINT8*) "IS_NOT_NAN", //205
        (ANTLR_UINT8*) "IS_NOT_NULL", //206
        (ANTLR_UINT8*) "IS_NOT_OF_TYPE", //207
        (ANTLR_UINT8*) "IS_NOT_PRESENT", //208
        (ANTLR_UINT8*) "IS_NULL", //209
        (ANTLR_UINT8*) "IS_OF_TYPE", //210
        (ANTLR_UINT8*) "IS_PRESENT", //211
        (ANTLR_UINT8*) "ITERATE_VK", //212
        (ANTLR_UINT8*) "JAVA_VK", //213
        (ANTLR_UINT8*) "JOIN_DEF", //214
        (ANTLR_UINT8*) "KEEP_VK", //215
        (ANTLR_UINT8*) "LABEL_NAME", //216
        (ANTLR_UINT8*) "LANGUAGE_VK", //217
        (ANTLR_UINT8*) "LAST_VALUE_VK", //218
        (ANTLR_UINT8*) "LAST_VK", //219
        (ANTLR_UINT8*) "LEADING_VK", //220
        (ANTLR_UINT8*) "LEFT_BRACKET", //221
        (ANTLR_UINT8*) "LEFT_PAREN", //222
        (ANTLR_UINT8*) "LEFT_VK", //223
        (ANTLR_UINT8*) "LESS_THAN_OP", //224
        (ANTLR_UINT8*) "LESS_THAN_OR_EQUALS_OP", //225
        (ANTLR_UINT8*) "LIBRARY_VK", //226
        (ANTLR_UINT8*) "LIKE2_VK", //227
        (ANTLR_UINT8*) "LIKE4_VK", //228
        (ANTLR_UINT8*) "LIKEC_VK", //229
        (ANTLR_UINT8*) "LIMIT_VK", //230
        (ANTLR_UINT8*) "LINK_NAME", //231
        (ANTLR_UINT8*) "LOCAL_VK", //232
        (ANTLR_UINT8*) "LOCK_TABLE_ELEMENT", //233
        (ANTLR_UINT8*) "LOGIC_EXPR", //234
        (ANTLR_UINT8*) "LOGOFF_VK", //235
        (ANTLR_UINT8*) "LOGON_VK", //236
        (ANTLR_UINT8*) "LOG_VK", //237
        (ANTLR_UINT8*) "LONG_VK", //238
        (ANTLR_UINT8*) "LOOP_VK", //239
        (ANTLR_UINT8*) "MAIN_MODEL", //240
        (ANTLR_UINT8*) "MAIN_MODEL_NAME", //241
        (ANTLR_UINT8*) "MAP_VK", //242
        (ANTLR_UINT8*) "MAXVALUE_VK", //243
        (ANTLR_UINT8*) "MEASURES_VK", //244
        (ANTLR_UINT8*) "MEMBER_VK", //245
        (ANTLR_UINT8*) "MERGE_INSERT", //246
        (ANTLR_UINT8*) "MERGE_UPDATE", //247
        (ANTLR_UINT8*) "MERGE_VK", //248
        (ANTLR_UINT8*) "MINUS_SIGN", //249
        (ANTLR_UINT8*) "MINUTE_VK", //250
        (ANTLR_UINT8*) "MINVALUE_VK", //251
        (ANTLR_UINT8*) "MLSLABEL_VK", //252
        (ANTLR_UINT8*) "MODEL_COLUMN", //253
        (ANTLR_UINT8*) "MODEL_COLUMNS", //254
        (ANTLR_UINT8*) "MODEL_EXPRESSION", //255
        (ANTLR_UINT8*) "MODEL_RULE", //256
        (ANTLR_UINT8*) "MODEL_RULES", //257
        (ANTLR_UINT8*) "MODIFY_VK", //258
        (ANTLR_UINT8*) "MONTH_VK", //259
        (ANTLR_UINT8*) "MULTI_TABLE_MODE", //260
        (ANTLR_UINT8*) "NAME_VK", //261
        (ANTLR_UINT8*) "NATIONAL_CHAR_STRING_LIT", //262
        (ANTLR_UINT8*) "NATIVE_DATATYPE", //263
        (ANTLR_UINT8*) "NATURALN_VK", //264
        (ANTLR_UINT8*) "NATURAL_VK", //265
        (ANTLR_UINT8*) "NAV_VK", //266
        (ANTLR_UINT8*) "NCHAR_CS_VK", //267
        (ANTLR_UINT8*) "NCHAR_VK", //268
        (ANTLR_UINT8*) "NCLOB_VK", //269
        (ANTLR_UINT8*) "NESTED_EXPR", //270
        (ANTLR_UINT8*) "NESTED_SUBQUERY", //271
        (ANTLR_UINT8*) "NESTED_VK", //272
        (ANTLR_UINT8*) "NEWLINE", //273
        (ANTLR_UINT8*) "NEW_VK", //274
        (ANTLR_UINT8*) "NEXT_VK", //275
        (ANTLR_UINT8*) "NOAUDIT_VK", //276
        (ANTLR_UINT8*) "NOCACHE_VK", //277
        (ANTLR_UINT8*) "NOCOPY_VK", //278
        (ANTLR_UINT8*) "NOCYCLE_VK", //279
        (ANTLR_UINT8*) "NOENTITYESCAPING_VK", //280
        (ANTLR_UINT8*) "NOMAXVALUE_VK", //281
        (ANTLR_UINT8*) "NOMINVALUE_VK", //282
        (ANTLR_UINT8*) "NOORDER_VK", //283
        (ANTLR_UINT8*) "NOSCHEMACHECK_VK", //284
        (ANTLR_UINT8*) "NOT_BETWEEN", //285
        (ANTLR_UINT8*) "NOT_EQUAL_OP", //286
        (ANTLR_UINT8*) "NOT_IN", //287
        (ANTLR_UINT8*) "NOT_LIKE", //288
        (ANTLR_UINT8*) "NO_VK", //289
        (ANTLR_UINT8*) "NULLS_VK", //290
        (ANTLR_UINT8*) "NUMBER_VK", //291
        (ANTLR_UINT8*) "NUMERIC_VK", //292
        (ANTLR_UINT8*) "NVARCHAR2_VK", //293
        (ANTLR_UINT8*) "OBJECT_VK", //294
        (ANTLR_UINT8*) "OFF_VK", //295
        (ANTLR_UINT8*) "OLD_VK", //296
        (ANTLR_UINT8*) "ONLY_VK", //297
        (ANTLR_UINT8*) "OPEN_VK", //298
        (ANTLR_UINT8*) "ORADATA_VK", //299
        (ANTLR_UINT8*) "ORDER_BY_ELEMENT", //300
        (ANTLR_UINT8*) "ORDER_BY_ELEMENTS", //301
        (ANTLR_UINT8*) "ORDINALITY_VK", //302
        (ANTLR_UINT8*) "OUT_VK", //303
        (ANTLR_UINT8*) "OVERRIDING_VK", //304
        (ANTLR_UINT8*) "OVER_VK", //305
        (ANTLR_UINT8*) "PACKAGE_NAME", //306
        (ANTLR_UINT8*) "PACKAGE_VK", //307
        (ANTLR_UINT8*) "PARALLEL_ENABLE_VK", //308
        (ANTLR_UINT8*) "PARAMETERS_VK", //309
        (ANTLR_UINT8*) "PARAMETER_NAME", //310
        (ANTLR_UINT8*) "PARENT_VK", //311
        (ANTLR_UINT8*) "PARTITION_VK", //312
        (ANTLR_UINT8*) "PASSING_VK", //313
        (ANTLR_UINT8*) "PERCENT", //314
        (ANTLR_UINT8*) "PERCENT_FOUND_VK", //315
        (ANTLR_UINT8*) "PERCENT_ISOPEN_VK", //316
        (ANTLR_UINT8*) "PERCENT_NOTFOUND_VK", //317
        (ANTLR_UINT8*) "PERCENT_ROWCOUNT_VK", //318
        (ANTLR_UINT8*) "PERCENT_ROWTYPE_VK", //319
        (ANTLR_UINT8*) "PERCENT_TYPE_VK", //320
        (ANTLR_UINT8*) "PERCENT_VK", //321
        (ANTLR_UINT8*) "PERIOD", //322
        (ANTLR_UINT8*) "PIPELINED_VK", //323
        (ANTLR_UINT8*) "PIVOT_ALIAS", //324
        (ANTLR_UINT8*) "PIVOT_ELEMENT", //325
        (ANTLR_UINT8*) "PIVOT_IN_ELEMENT", //326
        (ANTLR_UINT8*) "PIVOT_VK", //327
        (ANTLR_UINT8*) "PLSQL_NON_RESERVED_CAST", //328
        (ANTLR_UINT8*) "PLSQL_NON_RESERVED_CONNECT_BY_ROOT", //329
        (ANTLR_UINT8*) "PLSQL_NON_RESERVED_ELSIF", //330
        (ANTLR_UINT8*) "PLSQL_NON_RESERVED_MODEL", //331
        (ANTLR_UINT8*) "PLSQL_NON_RESERVED_MULTISET", //332
        (ANTLR_UINT8*) "PLSQL_NON_RESERVED_PIVOT", //333
        (ANTLR_UINT8*) "PLSQL_NON_RESERVED_UNPIVOT", //334
        (ANTLR_UINT8*) "PLSQL_NON_RESERVED_USING", //335
        (ANTLR_UINT8*) "PLSQL_RESERVED_COLAUTH", //336
        (ANTLR_UINT8*) "PLSQL_RESERVED_COMPRESS", //337
        (ANTLR_UINT8*) "PLSQL_RESERVED_CRASH", //338
        (ANTLR_UINT8*) "PLSQL_RESERVED_EXCLUSIVE", //339
        (ANTLR_UINT8*) "PLSQL_RESERVED_IDENTIFIED", //340
        (ANTLR_UINT8*) "PLSQL_RESERVED_IF", //341
        (ANTLR_UINT8*) "PLSQL_RESERVED_INDEX", //342
        (ANTLR_UINT8*) "PLSQL_RESERVED_INDEXES", //343
        (ANTLR_UINT8*) "PLSQL_RESERVED_LOCK", //344
        (ANTLR_UINT8*) "PLSQL_RESERVED_MINUS", //345
        (ANTLR_UINT8*) "PLSQL_RESERVED_MODE", //346
        (ANTLR_UINT8*) "PLSQL_RESERVED_NOCOMPRESS", //347
        (ANTLR_UINT8*) "PLSQL_RESERVED_NOWAIT", //348
        (ANTLR_UINT8*) "PLSQL_RESERVED_RESOURCE", //349
        (ANTLR_UINT8*) "PLSQL_RESERVED_SHARE", //350
        (ANTLR_UINT8*) "PLSQL_RESERVED_START", //351
        (ANTLR_UINT8*) "PLSQL_RESERVED_TABAUTH", //352
        (ANTLR_UINT8*) "PLSQL_RESERVED_VIEWS", //353
        (ANTLR_UINT8*) "PLS_INTEGER_VK", //354
        (ANTLR_UINT8*) "PLUS_SIGN", //355
        (ANTLR_UINT8*) "POSITIVEN_VK", //356
        (ANTLR_UINT8*) "POSITIVE_VK", //357
        (ANTLR_UINT8*) "PRAGMA_VK", //358
        (ANTLR_UINT8*) "PRECEDING_VK", //359
        (ANTLR_UINT8*) "PRECISION", //360
        (ANTLR_UINT8*) "PRECISION_VK", //361
        (ANTLR_UINT8*) "PREDICTION_FUNCTION", //362
        (ANTLR_UINT8*) "PROCEDURE_NAME", //363
        (ANTLR_UINT8*) "PROMPT", //364
        (ANTLR_UINT8*) "QS_ANGLE", //365
        (ANTLR_UINT8*) "QS_BRACE", //366
        (ANTLR_UINT8*) "QS_BRACK", //367
        (ANTLR_UINT8*) "QS_OTHER", //368
        (ANTLR_UINT8*) "QS_OTHER_CH", //369
        (ANTLR_UINT8*) "QS_PAREN", //370
        (ANTLR_UINT8*) "QUERY_NAME", //371
        (ANTLR_UINT8*) "QUESTION_MARK", //372
        (ANTLR_UINT8*) "QUOTE", //373
        (ANTLR_UINT8*) "RAISE_VK", //374
        (ANTLR_UINT8*) "RANGE_VK", //375
        (ANTLR_UINT8*) "RAW_VK", //376
        (ANTLR_UINT8*) "READ_VK", //377
        (ANTLR_UINT8*) "REAL_VK", //378
        (ANTLR_UINT8*) "RECORD_NAME", //379
        (ANTLR_UINT8*) "REFERENCE_MODEL_NAME", //380
        (ANTLR_UINT8*) "REFERENCE_VK", //381
        (ANTLR_UINT8*) "REFERENCING_VK", //382
        (ANTLR_UINT8*) "REF_VK", //383
        (ANTLR_UINT8*) "REGULAR_ID", //384
        (ANTLR_UINT8*) "REJECT_VK", //385
        (ANTLR_UINT8*) "RELIES_ON_VK", //386
        (ANTLR_UINT8*) "RENAME_VK", //387
        (ANTLR_UINT8*) "REPLACE_VK", //388
        (ANTLR_UINT8*) "RESPECT_VK", //389
        (ANTLR_UINT8*) "RESTRICT_REFERENCES_VK", //390
        (ANTLR_UINT8*) "RESULT_CACHE_VK", //391
        (ANTLR_UINT8*) "RETURN_VK", //392
        (ANTLR_UINT8*) "REUSE_VK", //393
        (ANTLR_UINT8*) "REVERSE_VK", //394
        (ANTLR_UINT8*) "RIGHT_BRACKET", //395
        (ANTLR_UINT8*) "RIGHT_PAREN", //396
        (ANTLR_UINT8*) "RIGHT_VK", //397
        (ANTLR_UINT8*) "ROLLBACK_SEGMENT_NAME", //398
        (ANTLR_UINT8*) "ROLLBACK_VK", //399
        (ANTLR_UINT8*) "ROLLUP_VK", //400
        (ANTLR_UINT8*) "ROUTINE_CALL", //401
        (ANTLR_UINT8*) "ROUTINE_NAME", //402
        (ANTLR_UINT8*) "ROWID_VK", //403
        (ANTLR_UINT8*) "ROWS_VK", //404
        (ANTLR_UINT8*) "ROW_VK", //405
        (ANTLR_UINT8*) "RULES_VK", //406
        (ANTLR_UINT8*) "SAMPLE_VK", //407
        (ANTLR_UINT8*) "SAVEPOINT_NAME", //408
        (ANTLR_UINT8*) "SAVEPOINT_VK", //409
        (ANTLR_UINT8*) "SCHEMACHECK_VK", //410
        (ANTLR_UINT8*) "SCHEMA_NAME", //411
        (ANTLR_UINT8*) "SCHEMA_VK", //412
        (ANTLR_UINT8*) "SCN_VK", //413
        (ANTLR_UINT8*) "SEARCHED_CASE", //414
        (ANTLR_UINT8*) "SEARCH_VK", //415
        (ANTLR_UINT8*) "SECOND_VK", //416
        (ANTLR_UINT8*) "SEED_VK", //417
        (ANTLR_UINT8*) "SELECTED_TABLEVIEW", //418
        (ANTLR_UINT8*) "SELECT_ITEM", //419
        (ANTLR_UINT8*) "SELECT_LIST", //420
        (ANTLR_UINT8*) "SELECT_MODE", //421
        (ANTLR_UINT8*) "SELECT_STATEMENT", //422
        (ANTLR_UINT8*) "SELF_VK", //423
        (ANTLR_UINT8*) "SEMICOLON", //424
        (ANTLR_UINT8*) "SEPARATOR", //425
        (ANTLR_UINT8*) "SEQUENCE_NAME", //426
        (ANTLR_UINT8*) "SEQUENCE_VK", //427
        (ANTLR_UINT8*) "SEQUENTIAL_VK", //428
        (ANTLR_UINT8*) "SERIALIZABLE_VK", //429
        (ANTLR_UINT8*) "SERIALLY_REUSABLE_VK", //430
        (ANTLR_UINT8*) "SERVERERROR_VK", //431
        (ANTLR_UINT8*) "SESSIONTIMEZONE_VK", //432
        (ANTLR_UINT8*) "SET_VK", //433
        (ANTLR_UINT8*) "SHOW_VK", //434
        (ANTLR_UINT8*) "SHUTDOWN_VK", //435
        (ANTLR_UINT8*) "SIBLINGS_VK", //436
        (ANTLR_UINT8*) "SIGNTYPE_VK", //437
        (ANTLR_UINT8*) "SIMPLE_CASE", //438
        (ANTLR_UINT8*) "SIMPLE_INTEGER_VK", //439
        (ANTLR_UINT8*) "SIMPLE_LETTER", //440
        (ANTLR_UINT8*) "SINGLE_TABLE_MODE", //441
        (ANTLR_UINT8*) "SINGLE_VK", //442
        (ANTLR_UINT8*) "SKIP_VK", //443
        (ANTLR_UINT8*) "SMALLINT_VK", //444
        (ANTLR_UINT8*) "SOLIDUS", //445
        (ANTLR_UINT8*) "SOME_VK", //446
        (ANTLR_UINT8*) "SPACE", //447
        (ANTLR_UINT8*) "SPECIFICATION_VK", //448
        (ANTLR_UINT8*) "SQL92_RESERVED_ALL", //449
        (ANTLR_UINT8*) "SQL92_RESERVED_ALTER", //450
        (ANTLR_UINT8*) "SQL92_RESERVED_AND", //451
        (ANTLR_UINT8*) "SQL92_RESERVED_ANY", //452
        (ANTLR_UINT8*) "SQL92_RESERVED_AS", //453
        (ANTLR_UINT8*) "SQL92_RESERVED_ASC", //454
        (ANTLR_UINT8*) "SQL92_RESERVED_BEGIN", //455
        (ANTLR_UINT8*) "SQL92_RESERVED_BETWEEN", //456
        (ANTLR_UINT8*) "SQL92_RESERVED_BY", //457
        (ANTLR_UINT8*) "SQL92_RESERVED_CASE", //458
        (ANTLR_UINT8*) "SQL92_RESERVED_CHECK", //459
        (ANTLR_UINT8*) "SQL92_RESERVED_CONNECT", //460
        (ANTLR_UINT8*) "SQL92_RESERVED_CREATE", //461
        (ANTLR_UINT8*) "SQL92_RESERVED_CURRENT", //462
        (ANTLR_UINT8*) "SQL92_RESERVED_CURSOR", //463
        (ANTLR_UINT8*) "SQL92_RESERVED_DATE", //464
        (ANTLR_UINT8*) "SQL92_RESERVED_DECLARE", //465
        (ANTLR_UINT8*) "SQL92_RESERVED_DEFAULT", //466
        (ANTLR_UINT8*) "SQL92_RESERVED_DELETE", //467
        (ANTLR_UINT8*) "SQL92_RESERVED_DESC", //468
        (ANTLR_UINT8*) "SQL92_RESERVED_DISTINCT", //469
        (ANTLR_UINT8*) "SQL92_RESERVED_DROP", //470
        (ANTLR_UINT8*) "SQL92_RESERVED_ELSE", //471
        (ANTLR_UINT8*) "SQL92_RESERVED_END", //472
        (ANTLR_UINT8*) "SQL92_RESERVED_EXCEPTION", //473
        (ANTLR_UINT8*) "SQL92_RESERVED_EXISTS", //474
        (ANTLR_UINT8*) "SQL92_RESERVED_FALSE", //475
        (ANTLR_UINT8*) "SQL92_RESERVED_FETCH", //476
        (ANTLR_UINT8*) "SQL92_RESERVED_FOR", //477
        (ANTLR_UINT8*) "SQL92_RESERVED_FROM", //478
        (ANTLR_UINT8*) "SQL92_RESERVED_GOTO", //479
        (ANTLR_UINT8*) "SQL92_RESERVED_GRANT", //480
        (ANTLR_UINT8*) "SQL92_RESERVED_GROUP", //481
        (ANTLR_UINT8*) "SQL92_RESERVED_HAVING", //482
        (ANTLR_UINT8*) "SQL92_RESERVED_IN", //483
        (ANTLR_UINT8*) "SQL92_RESERVED_INSERT", //484
        (ANTLR_UINT8*) "SQL92_RESERVED_INTERSECT", //485
        (ANTLR_UINT8*) "SQL92_RESERVED_INTO", //486
        (ANTLR_UINT8*) "SQL92_RESERVED_IS", //487
        (ANTLR_UINT8*) "SQL92_RESERVED_LIKE", //488
        (ANTLR_UINT8*) "SQL92_RESERVED_NOT", //489
        (ANTLR_UINT8*) "SQL92_RESERVED_NULL", //490
        (ANTLR_UINT8*) "SQL92_RESERVED_OF", //491
        (ANTLR_UINT8*) "SQL92_RESERVED_ON", //492
        (ANTLR_UINT8*) "SQL92_RESERVED_OPTION", //493
        (ANTLR_UINT8*) "SQL92_RESERVED_OR", //494
        (ANTLR_UINT8*) "SQL92_RESERVED_ORDER", //495
        (ANTLR_UINT8*) "SQL92_RESERVED_OVERLAPS", //496
        (ANTLR_UINT8*) "SQL92_RESERVED_PRIOR", //497
        (ANTLR_UINT8*) "SQL92_RESERVED_PROCEDURE", //498
        (ANTLR_UINT8*) "SQL92_RESERVED_PUBLIC", //499
        (ANTLR_UINT8*) "SQL92_RESERVED_REVOKE", //500
        (ANTLR_UINT8*) "SQL92_RESERVED_SELECT", //501
        (ANTLR_UINT8*) "SQL92_RESERVED_SIZE", //502
        (ANTLR_UINT8*) "SQL92_RESERVED_TABLE", //503
        (ANTLR_UINT8*) "SQL92_RESERVED_THE", //504
        (ANTLR_UINT8*) "SQL92_RESERVED_THEN", //505
        (ANTLR_UINT8*) "SQL92_RESERVED_TO", //506
        (ANTLR_UINT8*) "SQL92_RESERVED_TRUE", //507
        (ANTLR_UINT8*) "SQL92_RESERVED_UNION", //508
        (ANTLR_UINT8*) "SQL92_RESERVED_UNIQUE", //509
        (ANTLR_UINT8*) "SQL92_RESERVED_UPDATE", //510
        (ANTLR_UINT8*) "SQL92_RESERVED_VALUES", //511
        (ANTLR_UINT8*) "SQL92_RESERVED_VIEW", //512
        (ANTLR_UINT8*) "SQL92_RESERVED_WHEN", //513
        (ANTLR_UINT8*) "SQL92_RESERVED_WHERE", //514
        (ANTLR_UINT8*) "SQL92_RESERVED_WITH", //515
        (ANTLR_UINT8*) "SQLDATA_VK", //516
        (ANTLR_UINT8*) "SQL_ISO_RESERVED_OFFSET", //517
        (ANTLR_UINT8*) "STANDALONE_VK", //518
        (ANTLR_UINT8*) "STANDARD_FUNCTION", //519
        (ANTLR_UINT8*) "STARTUP_VK", //520
        (ANTLR_UINT8*) "STATIC_RETURNING", //521
        (ANTLR_UINT8*) "STATIC_VK", //522
        (ANTLR_UINT8*) "STATISTICS_VK", //523
        (ANTLR_UINT8*) "STRING_VK", //524
        (ANTLR_UINT8*) "SUBMULTISET_VK", //525
        (ANTLR_UINT8*) "SUBPARTITION_VK", //526
        (ANTLR_UINT8*) "SUBQUERY", //527
        (ANTLR_UINT8*) "SUSPEND_VK", //528
        (ANTLR_UINT8*) "TABLEVIEW_NAME", //529
        (ANTLR_UINT8*) "TABLE_ELEMENT", //530
        (ANTLR_UINT8*) "TABLE_EXPRESSION", //531
        (ANTLR_UINT8*) "TABLE_REF", //532
        (ANTLR_UINT8*) "TABLE_REF_ELEMENT", //533
        (ANTLR_UINT8*) "TABLE_VAR_NAME", //534
        (ANTLR_UINT8*) "TIES_VK", //535
        (ANTLR_UINT8*) "TILDE_OPERATOR_PART", //536
        (ANTLR_UINT8*) "TIMESTAMP_LTZ_UNCONSTRAINED_VK", //537
        (ANTLR_UINT8*) "TIMESTAMP_TZ_UNCONSTRAINED_VK", //538
        (ANTLR_UINT8*) "TIMESTAMP_UNCONSTRAINED_VK", //539
        (ANTLR_UINT8*) "TIMESTAMP_VK", //540
        (ANTLR_UINT8*) "TIMEZONE_ABBR_VK", //541
        (ANTLR_UINT8*) "TIMEZONE_HOUR_VK", //542
        (ANTLR_UINT8*) "TIMEZONE_MINUTE_VK", //543
        (ANTLR_UINT8*) "TIMEZONE_REGION_VK", //544
        (ANTLR_UINT8*) "TIME_VK", //545
        (ANTLR_UINT8*) "TRAILING_VK", //546
        (ANTLR_UINT8*) "TRANSLATE_VK", //547
        (ANTLR_UINT8*) "TREAT_VK", //548
        (ANTLR_UINT8*) "TRIGGER_NAME", //549
        (ANTLR_UINT8*) "TRIM_VK", //550
        (ANTLR_UINT8*) "TRUNCATE_VK", //551
        (ANTLR_UINT8*) "TYPE_NAME", //552
        (ANTLR_UINT8*) "TYPE_VK", //553
        (ANTLR_UINT8*) "T_BINDVAR_NAME", //554
        (ANTLR_UINT8*) "T_COLUMN_ALIAS", //555
        (ANTLR_UINT8*) "T_COLUMN_LIST", //556
        (ANTLR_UINT8*) "T_COLUMN_NAME", //557
        (ANTLR_UINT8*) "T_COND_AND", //558
        (ANTLR_UINT8*) "T_COND_AND_SEQ", //559
        (ANTLR_UINT8*) "T_COND_BETWEEN", //560
        (ANTLR_UINT8*) "T_COND_COMPARISON", //561
        (ANTLR_UINT8*) "T_COND_EQUALS_PATH", //562
        (ANTLR_UINT8*) "T_COND_EXISTS", //563
        (ANTLR_UINT8*) "T_COND_GROUP_COMPARISON", //564
        (ANTLR_UINT8*) "T_COND_IN", //565
        (ANTLR_UINT8*) "T_COND_IS", //566
        (ANTLR_UINT8*) "T_COND_IS_ANY", //567
        (ANTLR_UINT8*) "T_COND_IS_A_SET", //568
        (ANTLR_UINT8*) "T_COND_IS_EMPTY", //569
        (ANTLR_UINT8*) "T_COND_IS_OF_TYPE", //570
        (ANTLR_UINT8*) "T_COND_IS_PRESENT", //571
        (ANTLR_UINT8*) "T_COND_LIKE", //572
        (ANTLR_UINT8*) "T_COND_MEMEBER", //573
        (ANTLR_UINT8*) "T_COND_NOT", //574
        (ANTLR_UINT8*) "T_COND_OR", //575
        (ANTLR_UINT8*) "T_COND_OR_SEQ", //576
        (ANTLR_UINT8*) "T_COND_PAREN", //577
        (ANTLR_UINT8*) "T_COND_REGEXP_LIKE", //578
        (ANTLR_UINT8*) "T_COND_SUBMULTISET", //579
        (ANTLR_UINT8*) "T_COND_UNDER_PATH", //580
        (ANTLR_UINT8*) "T_DBLINK_NAME", //581
        (ANTLR_UINT8*) "T_DECL", //582
        (ANTLR_UINT8*) "T_FOR_UPDATE_CLAUSE", //583
        (ANTLR_UINT8*) "T_FROM", //584
        (ANTLR_UINT8*) "T_FUNCTION_NAME", //585
        (ANTLR_UINT8*) "T_GROUP_BY", //586
        (ANTLR_UINT8*) "T_HIERARCHICAL", //587
        (ANTLR_UINT8*) "T_IDENTIFIER", //588
        (ANTLR_UINT8*) "T_JOINING_CLAUSE", //589
        (ANTLR_UINT8*) "T_MODEL", //590
        (ANTLR_UINT8*) "T_OPERATOR_BINARY", //591
        (ANTLR_UINT8*) "T_OPERATOR_PART", //592
        (ANTLR_UINT8*) "T_OPERATOR_UNARY", //593
        (ANTLR_UINT8*) "T_ORDER_BY_CLAUSE", //594
        (ANTLR_UINT8*) "T_PACKAGE_NAME", //595
        (ANTLR_UINT8*) "T_RESERVED", //596
        (ANTLR_UINT8*) "T_SCHEMA_NAME", //597
        (ANTLR_UINT8*) "T_SELECT", //598
        (ANTLR_UINT8*) "T_SELECT_COLUMN", //599
        (ANTLR_UINT8*) "T_SUBQUERY", //600
        (ANTLR_UINT8*) "T_TABLE_ALIAS", //601
        (ANTLR_UINT8*) "T_TABLE_CAST", //602
        (ANTLR_UINT8*) "T_TABLE_NAME", //603
        (ANTLR_UINT8*) "T_TABLE_REF", //604
        (ANTLR_UINT8*) "T_UNION", //605
        (ANTLR_UINT8*) "T_UNKNOWN", //606
        (ANTLR_UINT8*) "T_USE", //607
        (ANTLR_UINT8*) "T_WHERE", //608
        (ANTLR_UINT8*) "T_WITH", //609
        (ANTLR_UINT8*) "UNARY_OPERATOR", //610
        (ANTLR_UINT8*) "UNBOUNDED_VK", //611
        (ANTLR_UINT8*) "UNDERSCORE", //612
        (ANTLR_UINT8*) "UNDER_VK", //613
        (ANTLR_UINT8*) "UNLIMITED_VK", //614
        (ANTLR_UINT8*) "UNPIVOT_IN_ELEMENT", //615
        (ANTLR_UINT8*) "UNPIVOT_VK", //616
        (ANTLR_UINT8*) "UNSIGNED_INTEGER", //617
        (ANTLR_UINT8*) "UNTIL_VK", //618
        (ANTLR_UINT8*) "UPDATED_VK", //619
        (ANTLR_UINT8*) "UPSERT_VK", //620
        (ANTLR_UINT8*) "UROWID_VK", //621
        (ANTLR_UINT8*) "VALIDATE_VK", //622
        (ANTLR_UINT8*) "VALUE_VK", //623
        (ANTLR_UINT8*) "VARCHAR2_VK", //624
        (ANTLR_UINT8*) "VARCHAR_VK", //625
        (ANTLR_UINT8*) "VARIABLE_NAME", //626
        (ANTLR_UINT8*) "VECTOR_EXPR", //627
        (ANTLR_UINT8*) "VERSIONS_VK", //628
        (ANTLR_UINT8*) "VERSION_VK", //629
        (ANTLR_UINT8*) "VERTICAL_BAR", //630
        (ANTLR_UINT8*) "WAIT_VK", //631
        (ANTLR_UINT8*) "WELLFORMED_VK", //632
        (ANTLR_UINT8*) "WITHIN_VK", //633
        (ANTLR_UINT8*) "WORK_VK", //634
        (ANTLR_UINT8*) "WRITE_VK", //635
        (ANTLR_UINT8*) "XMLAGG_VK", //636
        (ANTLR_UINT8*) "XMLATTRIBUTES_VK", //637
        (ANTLR_UINT8*) "XMLCAST_VK", //638
        (ANTLR_UINT8*) "XMLCOLATTVAL_VK", //639
        (ANTLR_UINT8*) "XMLELEMENT_VK", //640
        (ANTLR_UINT8*) "XMLEXISTS_VK", //641
        (ANTLR_UINT8*) "XMLFOREST_VK", //642
        (ANTLR_UINT8*) "XMLNAMESPACES_VK", //643
        (ANTLR_UINT8*) "XMLPARSE_VK", //644
        (ANTLR_UINT8*) "XMLPI_VK", //645
        (ANTLR_UINT8*) "XMLQUERY_VK", //646
        (ANTLR_UINT8*) "XMLROOT_VK", //647
        (ANTLR_UINT8*) "XMLSERIALIZE_VK", //648
        (ANTLR_UINT8*) "XMLTABLE_VK", //649
        (ANTLR_UINT8*) "XML_ALIAS", //650
        (ANTLR_UINT8*) "XML_COLUMN", //651
        (ANTLR_UINT8*) "XML_COLUMN_NAME", //652
        (ANTLR_UINT8*) "XML_ELEMENT", //653
        (ANTLR_UINT8*) "XML_VK", //654
        (ANTLR_UINT8*) "YEAR_VK", //655
        (ANTLR_UINT8*) "YES_VK", //656
        (ANTLR_UINT8*) "YMINTERVAL_UNCONSTRAINED_VK", //657
        (ANTLR_UINT8*) "ZV", //658
        (ANTLR_UINT8*) "CONJUNCTION", //669
        (ANTLR_UINT8*) "DISJUNCTION", //671
       };


//typedef CommonTreeAdaptor adaptor;
//TreeAdaptor adaptor = new CommonTreeAdaptor();

//void setTreeAdaptor(TreeAdaptor adaptor)
//{
//	this.adaptor = adaptor;
//	<grammar.directDelegates:{g|<g:delegateName()>.setTreeAdaptor(this.adaptor);}>
//}
//TreeAdaptor getTreeAdaptor()
//{
//	return adaptor;
//}
/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "OracleDML.g";

/** \brief Return the name of the grammar file that generated this code.
 */
const char* OracleDML::getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new OracleDML parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
OracleDML::OracleDML( StreamType* instream)
    :ImplTraits::BaseParserType(ANTLR_SIZE_HINT, instream, NULL)

{
	// See if we can create a new parser with the standard constructor
	//
	this->init(instream);
}

/** \brief Create a new OracleDML parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
OracleDML::OracleDML( StreamType* instream, RecognizerSharedStateType* state)
    :ImplTraits::BaseParserType(ANTLR_SIZE_HINT, instream, state)

{
	this->init(instream );
}

void OracleDML::init(StreamType* instream)
{
	/* Allocate TreeAdaptorType 
	 */
	this->get_psrstate()->set_treeAdaptor( new TreeAdaptorType() );
	// Initialize the lexers/parsers that we are going to delegate some
	// functions to.
	//
	m_gOracleDMLKeys = new OracleDML_OracleDMLKeys(instream, this->get_psrstate(), this);
	m_gOracleDMLCommons = new OracleDML_OracleDMLCommons(instream, this->get_psrstate(), this);
	/* Install the token table
	*/
	this->get_psrstate()->set_tokenNames( OracleDMLTokenNames );

}

void
OracleDML::reset()
{
    this->get_rec()->reset();
}

/** Free the parser resources
 */
OracleDML::~OracleDML()
{
	// Free the parsers that we delegated to functions to.
	// NULL the state so we only free it once.
	//
	m_gOracleDMLKeys->set_psrstate( NULL );
	         delete m_gOracleDMLKeys;
	m_gOracleDMLCommons->set_psrstate( NULL );
	         delete m_gOracleDMLCommons;
	/* Deallocate TreeAdaptorType 
	 */
	delete this->get_psrstate()->get_treeAdaptor();
}

/** Return token names used by this parser
 *
 * The returned pointer is used as an index into the token names table (using the token
 * number as the index).
 *
 * \return Pointer to first char * in the table.
 */
ANTLR_UINT8**	OracleDML::getTokenNames()
{
        return OracleDMLTokenNames;
}


/* Declare the bitsets
 */
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_seq_of_statements_in_compilation_unit670_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000001000000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x4020001000080000), ANTLR_UINT64_LIT(0x0000000000000008) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_seq_of_statements_in_compilation_unit670( FOLLOW_seq_of_statements_in_compilation_unit670_bits, 9 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_EOF_TOKEN_in_compilation_unit673_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_EOF_TOKEN_in_compilation_unit673( FOLLOW_EOF_TOKEN_in_compilation_unit673_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_select_statement_in_seq_of_statements700_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000010000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_select_statement_in_seq_of_statements700( FOLLOW_select_statement_in_seq_of_statements700_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_update_statement_in_seq_of_statements711_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000010000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_update_statement_in_seq_of_statements711( FOLLOW_update_statement_in_seq_of_statements711_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_delete_statement_in_seq_of_statements722_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000010000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_delete_statement_in_seq_of_statements722( FOLLOW_delete_statement_in_seq_of_statements722_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_insert_statement_in_seq_of_statements733_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000010000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_insert_statement_in_seq_of_statements733( FOLLOW_insert_statement_in_seq_of_statements733_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_lock_table_statement_in_seq_of_statements744_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000010000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_lock_table_statement_in_seq_of_statements744( FOLLOW_lock_table_statement_in_seq_of_statements744_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_merge_statement_in_seq_of_statements755_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000010000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_merge_statement_in_seq_of_statements755( FOLLOW_merge_statement_in_seq_of_statements755_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_explain_statement_in_seq_of_statements766_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000010000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_explain_statement_in_seq_of_statements766( FOLLOW_explain_statement_in_seq_of_statements766_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_set_in_seq_of_statements778_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_set_in_seq_of_statements778( FOLLOW_set_in_seq_of_statements778_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_explain_key_in_explain_statement809_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_explain_key_in_explain_statement809( FOLLOW_explain_key_in_explain_statement809_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_plan_key_in_explain_statement811_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x0000004020000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_plan_key_in_explain_statement811( FOLLOW_plan_key_in_explain_statement811_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_set_key_in_explain_statement823_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_set_key_in_explain_statement823( FOLLOW_set_key_in_explain_statement823_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_statement_id_key_in_explain_statement825_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_statement_id_key_in_explain_statement825( FOLLOW_statement_id_key_in_explain_statement825_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_EQUALS_OP_in_explain_statement827_bits[]	= { ANTLR_UINT64_LIT(0x0180000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000040) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_EQUALS_OP_in_explain_statement827( FOLLOW_EQUALS_OP_in_explain_statement827_bits, 5 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_quoted_string_in_explain_statement829_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000004020000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_quoted_string_in_explain_statement829( FOLLOW_quoted_string_in_explain_statement829_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_into_key_in_explain_statement843_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_into_key_in_explain_statement843( FOLLOW_into_key_in_explain_statement843_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_tableview_name_in_explain_statement845_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000020000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_tableview_name_in_explain_statement845( FOLLOW_tableview_name_in_explain_statement845_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_for_key_in_explain_statement858_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x4020001000080000), ANTLR_UINT64_LIT(0x0000000000000008) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_for_key_in_explain_statement858( FOLLOW_for_key_in_explain_statement858_bits, 9 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_select_statement_in_explain_statement871_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_select_statement_in_explain_statement871( FOLLOW_select_statement_in_explain_statement871_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_update_statement_in_explain_statement884_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_update_statement_in_explain_statement884( FOLLOW_update_statement_in_explain_statement884_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_delete_statement_in_explain_statement897_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_delete_statement_in_explain_statement897( FOLLOW_delete_statement_in_explain_statement897_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_insert_statement_in_explain_statement910_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_insert_statement_in_explain_statement910( FOLLOW_insert_statement_in_explain_statement910_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_merge_statement_in_explain_statement923_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_merge_statement_in_explain_statement923( FOLLOW_merge_statement_in_explain_statement923_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_subquery_factoring_clause_in_select_statement984_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0020000000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_subquery_factoring_clause_in_select_statement984( FOLLOW_subquery_factoring_clause_in_select_statement984_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_subquery_in_select_statement995_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000800020000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_subquery_in_select_statement995( FOLLOW_subquery_in_select_statement995_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_for_update_clause_in_select_statement1006_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000800020000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_for_update_clause_in_select_statement1006( FOLLOW_for_update_clause_in_select_statement1006_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_order_by_clause_in_select_statement1018_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000800020000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_order_by_clause_in_select_statement1018( FOLLOW_order_by_clause_in_select_statement1018_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_with_key_in_subquery_factoring_clause1069_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_with_key_in_subquery_factoring_clause1069( FOLLOW_with_key_in_subquery_factoring_clause1069_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_factoring_element_in_subquery_factoring_clause1072_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000010) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_factoring_element_in_subquery_factoring_clause1072( FOLLOW_factoring_element_in_subquery_factoring_clause1072_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_subquery_factoring_clause1075_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_COMMA_in_subquery_factoring_clause1075( FOLLOW_COMMA_in_subquery_factoring_clause1075_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_factoring_element_in_subquery_factoring_clause1078_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000010) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_factoring_element_in_subquery_factoring_clause1078( FOLLOW_factoring_element_in_subquery_factoring_clause1078_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_query_name_in_factoring_element1100_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000020) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_query_name_in_factoring_element1100( FOLLOW_query_name_in_factoring_element1100_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_factoring_element1103_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_factoring_element1103( FOLLOW_LEFT_PAREN_in_factoring_element1103_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_column_name_in_factoring_element1105_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_column_name_in_factoring_element1105( FOLLOW_column_name_in_factoring_element1105_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_factoring_element1108_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_COMMA_in_factoring_element1108( FOLLOW_COMMA_in_factoring_element1108_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_column_name_in_factoring_element1110_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_column_name_in_factoring_element1110( FOLLOW_column_name_in_factoring_element1110_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_factoring_element1114_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000020) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_factoring_element1114( FOLLOW_RIGHT_PAREN_in_factoring_element1114_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_as_key_in_factoring_element1118_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_as_key_in_factoring_element1118( FOLLOW_as_key_in_factoring_element1118_bits, 4 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_factoring_element1120_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0020000000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_factoring_element1120( FOLLOW_LEFT_PAREN_in_factoring_element1120_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_subquery_in_factoring_element1122_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000), ANTLR_UINT64_LIT(0x0000800000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_subquery_in_factoring_element1122( FOLLOW_subquery_in_factoring_element1122_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_order_by_clause_in_factoring_element1124_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_order_by_clause_in_factoring_element1124( FOLLOW_order_by_clause_in_factoring_element1124_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_factoring_element1127_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_factoring_element1127( FOLLOW_RIGHT_PAREN_in_factoring_element1127_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_search_clause_in_factoring_element1138_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_search_clause_in_factoring_element1138( FOLLOW_search_clause_in_factoring_element1138_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_cycle_clause_in_factoring_element1150_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_cycle_clause_in_factoring_element1150( FOLLOW_cycle_clause_in_factoring_element1150_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_search_key_in_search_clause1198_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_search_key_in_search_clause1198( FOLLOW_search_key_in_search_clause1198_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_depth_key_in_search_clause1202_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_depth_key_in_search_clause1202( FOLLOW_depth_key_in_search_clause1202_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_breadth_key_in_search_clause1206_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_breadth_key_in_search_clause1206( FOLLOW_breadth_key_in_search_clause1206_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_first_key_in_search_clause1210_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000200) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_first_key_in_search_clause1210( FOLLOW_first_key_in_search_clause1210_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_by_key_in_search_clause1212_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_by_key_in_search_clause1212( FOLLOW_by_key_in_search_clause1212_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_column_name_in_search_clause1227_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x0000000000100040) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_column_name_in_search_clause1227( FOLLOW_column_name_in_search_clause1227_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_asc_key_in_search_clause1229_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x0000000000100000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_asc_key_in_search_clause1229( FOLLOW_asc_key_in_search_clause1229_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_desc_key_in_search_clause1233_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_desc_key_in_search_clause1233( FOLLOW_desc_key_in_search_clause1233_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_nulls_key_in_search_clause1238_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_nulls_key_in_search_clause1238( FOLLOW_nulls_key_in_search_clause1238_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_first_key_in_search_clause1240_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_first_key_in_search_clause1240( FOLLOW_first_key_in_search_clause1240_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_nulls_key_in_search_clause1245_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_nulls_key_in_search_clause1245( FOLLOW_nulls_key_in_search_clause1245_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_last_key_in_search_clause1247_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_last_key_in_search_clause1247( FOLLOW_last_key_in_search_clause1247_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_search_clause1265_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_COMMA_in_search_clause1265( FOLLOW_COMMA_in_search_clause1265_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_column_name_in_search_clause1267_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x0000000000100040) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_column_name_in_search_clause1267( FOLLOW_column_name_in_search_clause1267_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_asc_key_in_search_clause1269_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x0000000000100000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_asc_key_in_search_clause1269( FOLLOW_asc_key_in_search_clause1269_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_desc_key_in_search_clause1273_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_desc_key_in_search_clause1273( FOLLOW_desc_key_in_search_clause1273_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_nulls_key_in_search_clause1278_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_nulls_key_in_search_clause1278( FOLLOW_nulls_key_in_search_clause1278_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_first_key_in_search_clause1280_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_first_key_in_search_clause1280( FOLLOW_first_key_in_search_clause1280_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_nulls_key_in_search_clause1285_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_nulls_key_in_search_clause1285( FOLLOW_nulls_key_in_search_clause1285_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_last_key_in_search_clause1287_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_last_key_in_search_clause1287( FOLLOW_last_key_in_search_clause1287_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_set_key_in_search_clause1307_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_set_key_in_search_clause1307( FOLLOW_set_key_in_search_clause1307_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_column_name_in_search_clause1309_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_column_name_in_search_clause1309( FOLLOW_column_name_in_search_clause1309_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_cycle_key_in_cycle_clause1329_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_cycle_key_in_cycle_clause1329( FOLLOW_cycle_key_in_cycle_clause1329_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_column_name_in_cycle_clause1331_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_column_name_in_cycle_clause1331( FOLLOW_column_name_in_cycle_clause1331_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_cycle_clause1335_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_COMMA_in_cycle_clause1335( FOLLOW_COMMA_in_cycle_clause1335_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_column_name_in_cycle_clause1337_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_column_name_in_cycle_clause1337( FOLLOW_column_name_in_cycle_clause1337_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_set_key_in_cycle_clause1341_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_set_key_in_cycle_clause1341( FOLLOW_set_key_in_cycle_clause1341_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_column_name_in_cycle_clause1343_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0400000000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_column_name_in_cycle_clause1343( FOLLOW_column_name_in_cycle_clause1343_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_to_key_in_cycle_clause1345_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_to_key_in_cycle_clause1345( FOLLOW_to_key_in_cycle_clause1345_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_expression_in_cycle_clause1347_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000040000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_expression_in_cycle_clause1347( FOLLOW_expression_in_cycle_clause1347_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_default_key_in_cycle_clause1349_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_default_key_in_cycle_clause1349( FOLLOW_default_key_in_cycle_clause1349_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_expression_in_cycle_clause1351_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_expression_in_cycle_clause1351( FOLLOW_expression_in_cycle_clause1351_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_subquery_basic_elements_in_subquery1371_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000002000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x1000002000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_subquery_basic_elements_in_subquery1371( FOLLOW_subquery_basic_elements_in_subquery1371_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_subquery_operation_part_in_subquery1373_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000002000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x1000002000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_subquery_operation_part_in_subquery1373( FOLLOW_subquery_operation_part_in_subquery1373_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_union_key_in_subquery_operation_part1414_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0020000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_union_key_in_subquery_operation_part1414( FOLLOW_union_key_in_subquery_operation_part1414_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_all_key_in_subquery_operation_part1417_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0020000000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_all_key_in_subquery_operation_part1417( FOLLOW_all_key_in_subquery_operation_part1417_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_intersect_key_in_subquery_operation_part1420_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0020000000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_intersect_key_in_subquery_operation_part1420( FOLLOW_intersect_key_in_subquery_operation_part1420_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_minus_key_in_subquery_operation_part1423_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0020000000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_minus_key_in_subquery_operation_part1423( FOLLOW_minus_key_in_subquery_operation_part1423_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_subquery_basic_elements_in_subquery_operation_part1427_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_subquery_basic_elements_in_subquery_operation_part1427( FOLLOW_subquery_basic_elements_in_subquery_operation_part1427_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_query_block_in_subquery_basic_elements1447_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_query_block_in_subquery_basic_elements1447( FOLLOW_query_block_in_subquery_basic_elements1447_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_subquery_basic_elements1458_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0020000000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_subquery_basic_elements1458( FOLLOW_LEFT_PAREN_in_subquery_basic_elements1458_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_subquery_in_subquery_basic_elements1461_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_subquery_in_subquery_basic_elements1461( FOLLOW_subquery_in_subquery_basic_elements1461_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_subquery_basic_elements1463_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_subquery_basic_elements1463( FOLLOW_RIGHT_PAREN_in_subquery_basic_elements1463_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_select_key_in_query_block1482_bits[]	= { ANTLR_UINT64_LIT(0x0180000400082000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x280206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_select_key_in_query_block1482( FOLLOW_select_key_in_query_block1482_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_selected_list_in_query_block1492_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x0000004040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_selected_list_in_query_block1492( FOLLOW_selected_list_in_query_block1492_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_into_clause_in_query_block1502_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_into_clause_in_query_block1502( FOLLOW_into_clause_in_query_block1502_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_from_clause_in_query_block1513_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000080000800), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000600001000), ANTLR_UINT64_LIT(0x0000000000000004) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_from_clause_in_query_block1513( FOLLOW_from_clause_in_query_block1513_bits, 9 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_where_clause_in_query_block1524_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000080000800), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000600001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_where_clause_in_query_block1524( FOLLOW_where_clause_in_query_block1524_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_hierarchical_query_clause_in_query_block1536_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000800), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000600000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_hierarchical_query_clause_in_query_block1536( FOLLOW_hierarchical_query_clause_in_query_block1536_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_group_by_clause_in_query_block1548_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000800) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_group_by_clause_in_query_block1548( FOLLOW_group_by_clause_in_query_block1548_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_model_clause_in_query_block1559_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_model_clause_in_query_block1559( FOLLOW_model_clause_in_query_block1559_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_distinct_key_in_selected_list1637_bits[]	= { ANTLR_UINT64_LIT(0x0180000400082000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_distinct_key_in_selected_list1637( FOLLOW_distinct_key_in_selected_list1637_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_unique_key_in_selected_list1639_bits[]	= { ANTLR_UINT64_LIT(0x0180000400082000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_unique_key_in_selected_list1639( FOLLOW_unique_key_in_selected_list1639_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_all_key_in_selected_list1641_bits[]	= { ANTLR_UINT64_LIT(0x0180000400082000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_all_key_in_selected_list1641( FOLLOW_all_key_in_selected_list1641_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_ASTERISK_in_selected_list1656_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_ASTERISK_in_selected_list1656( FOLLOW_ASTERISK_in_selected_list1656_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_selected_element_in_selected_list1670_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000010) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_selected_element_in_selected_list1670( FOLLOW_selected_element_in_selected_list1670_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_selected_element_seq_in_selected_list1672_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000010) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_selected_element_seq_in_selected_list1672( FOLLOW_selected_element_seq_in_selected_list1672_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_select_list_elements_in_selected_element1758_bits[]	= { ANTLR_UINT64_LIT(0x0180000000000002), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x0000000000000020) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_select_list_elements_in_selected_element1758( FOLLOW_select_list_elements_in_selected_element1758_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_column_alias_in_selected_element1760_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_column_alias_in_selected_element1760( FOLLOW_column_alias_in_selected_element1760_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_selected_element_seq1800_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_COMMA_in_selected_element_seq1800( FOLLOW_COMMA_in_selected_element_seq1800_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_select_list_elements_in_selected_element_seq1802_bits[]	= { ANTLR_UINT64_LIT(0x0180000000000002), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x0000000000000020) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_select_list_elements_in_selected_element_seq1802( FOLLOW_select_list_elements_in_selected_element_seq1802_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_column_alias_in_selected_element_seq1804_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_column_alias_in_selected_element_seq1804( FOLLOW_column_alias_in_selected_element_seq1804_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_from_key_in_from_clause1845_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000004), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x0180000000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_from_key_in_from_clause1845( FOLLOW_from_key_in_from_clause1845_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_table_ref_list_in_from_clause1848_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_table_ref_list_in_from_clause1848( FOLLOW_table_ref_list_in_from_clause1848_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_tableview_name_in_select_list_elements1877_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_tableview_name_in_select_list_elements1877( FOLLOW_tableview_name_in_select_list_elements1877_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_select_list_elements1879_bits[]	= { ANTLR_UINT64_LIT(0x0000000000080000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_PERIOD_in_select_list_elements1879( FOLLOW_PERIOD_in_select_list_elements1879_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_ASTERISK_in_select_list_elements1881_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_ASTERISK_in_select_list_elements1881( FOLLOW_ASTERISK_in_select_list_elements1881_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_expression_in_select_list_elements1907_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_expression_in_select_list_elements1907( FOLLOW_expression_in_select_list_elements1907_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_table_ref_in_table_ref_list1935_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000010) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_table_ref_in_table_ref_list1935( FOLLOW_table_ref_in_table_ref_list1935_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_table_ref_list_seq_in_table_ref_list1937_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000010) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_table_ref_list_seq_in_table_ref_list1937( FOLLOW_table_ref_list_seq_in_table_ref_list1937_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_table_ref_list_seq1963_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000004), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x0180000000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_COMMA_in_table_ref_list_seq1963( FOLLOW_COMMA_in_table_ref_list_seq1963_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_table_ref_in_table_ref_list_seq1965_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_table_ref_in_table_ref_list_seq1965( FOLLOW_table_ref_in_table_ref_list_seq1965_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_table_ref_aux_in_table_ref2006_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000006000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_table_ref_aux_in_table_ref2006( FOLLOW_table_ref_aux_in_table_ref2006_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_join_clause_in_table_ref2008_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000006000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_join_clause_in_table_ref2008( FOLLOW_join_clause_in_table_ref2008_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_pivot_clause_in_table_ref2012_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_pivot_clause_in_table_ref2012( FOLLOW_pivot_clause_in_table_ref2012_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_unpivot_clause_in_table_ref2014_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_unpivot_clause_in_table_ref2014( FOLLOW_unpivot_clause_in_table_ref2014_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_table_ref_aux_ver1_in_table_ref_aux2092_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_table_ref_aux_ver1_in_table_ref_aux2092( FOLLOW_table_ref_aux_ver1_in_table_ref_aux2092_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_table_ref_aux_ver2_in_table_ref_aux2109_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_table_ref_aux_ver2_in_table_ref_aux2109( FOLLOW_table_ref_aux_ver2_in_table_ref_aux2109_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_table_ref_aux_ver3_in_table_ref_aux2128_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_table_ref_aux_ver3_in_table_ref_aux2128( FOLLOW_table_ref_aux_ver3_in_table_ref_aux2128_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_table_ref_aux_ver4_in_table_ref_aux2139_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_table_ref_aux_ver4_in_table_ref_aux2139( FOLLOW_table_ref_aux_ver4_in_table_ref_aux2139_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_dml_table_expression_clause_in_table_ref_aux_ver12182_bits[]	= { ANTLR_UINT64_LIT(0x0180000000000002), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000000006000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x0000000000000020) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_dml_table_expression_clause_in_table_ref_aux_ver12182( FOLLOW_dml_table_expression_clause_in_table_ref_aux_ver12182_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_pivot_clause_in_table_ref_aux_ver12193_bits[]	= { ANTLR_UINT64_LIT(0x0180000000000002), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x0000000000000020) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_pivot_clause_in_table_ref_aux_ver12193( FOLLOW_pivot_clause_in_table_ref_aux_ver12193_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_unpivot_clause_in_table_ref_aux_ver12195_bits[]	= { ANTLR_UINT64_LIT(0x0180000000000002), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x0000000000000020) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_unpivot_clause_in_table_ref_aux_ver12195( FOLLOW_unpivot_clause_in_table_ref_aux_ver12195_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_flashback_query_clause_in_table_ref_aux_ver12199_bits[]	= { ANTLR_UINT64_LIT(0x0180000000000002), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x0000000000000020) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_flashback_query_clause_in_table_ref_aux_ver12199( FOLLOW_flashback_query_clause_in_table_ref_aux_ver12199_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_table_alias_in_table_ref_aux_ver12205_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_table_alias_in_table_ref_aux_ver12205( FOLLOW_table_alias_in_table_ref_aux_ver12205_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_table_ref_aux_ver22266_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000004), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x0180000000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_table_ref_aux_ver22266( FOLLOW_LEFT_PAREN_in_table_ref_aux_ver22266_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_table_ref_in_table_ref_aux_ver22268_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000002000000), ANTLR_UINT64_LIT(0x0000000000001000), ANTLR_UINT64_LIT(0x1000002000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_table_ref_in_table_ref_aux_ver22268( FOLLOW_table_ref_in_table_ref_aux_ver22268_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_subquery_operation_part_in_table_ref_aux_ver22270_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000002000000), ANTLR_UINT64_LIT(0x0000000000001000), ANTLR_UINT64_LIT(0x1000002000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_subquery_operation_part_in_table_ref_aux_ver22270( FOLLOW_subquery_operation_part_in_table_ref_aux_ver22270_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_table_ref_aux_ver22273_bits[]	= { ANTLR_UINT64_LIT(0x0180000000000002), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000000006000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x0000000000000020) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_table_ref_aux_ver22273( FOLLOW_RIGHT_PAREN_in_table_ref_aux_ver22273_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_pivot_clause_in_table_ref_aux_ver22284_bits[]	= { ANTLR_UINT64_LIT(0x0180000000000002), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x0000000000000020) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_pivot_clause_in_table_ref_aux_ver22284( FOLLOW_pivot_clause_in_table_ref_aux_ver22284_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_unpivot_clause_in_table_ref_aux_ver22286_bits[]	= { ANTLR_UINT64_LIT(0x0180000000000002), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x0000000000000020) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_unpivot_clause_in_table_ref_aux_ver22286( FOLLOW_unpivot_clause_in_table_ref_aux_ver22286_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_flashback_query_clause_in_table_ref_aux_ver22290_bits[]	= { ANTLR_UINT64_LIT(0x0180000000000002), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x0000000000000020) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_flashback_query_clause_in_table_ref_aux_ver22290( FOLLOW_flashback_query_clause_in_table_ref_aux_ver22290_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_table_alias_in_table_ref_aux_ver22296_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_table_alias_in_table_ref_aux_ver22296( FOLLOW_table_alias_in_table_ref_aux_ver22296_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_only_key_in_table_ref_aux_ver32369_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_only_key_in_table_ref_aux_ver32369( FOLLOW_only_key_in_table_ref_aux_ver32369_bits, 4 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_table_ref_aux_ver32371_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000004), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x0180000000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_table_ref_aux_ver32371( FOLLOW_LEFT_PAREN_in_table_ref_aux_ver32371_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_dml_table_expression_clause_in_table_ref_aux_ver32373_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_dml_table_expression_clause_in_table_ref_aux_ver32373( FOLLOW_dml_table_expression_clause_in_table_ref_aux_ver32373_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_table_ref_aux_ver32375_bits[]	= { ANTLR_UINT64_LIT(0x0180000000000002), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x0000000000000020) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_table_ref_aux_ver32375( FOLLOW_RIGHT_PAREN_in_table_ref_aux_ver32375_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_flashback_query_clause_in_table_ref_aux_ver32385_bits[]	= { ANTLR_UINT64_LIT(0x0180000000000002), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x0000000000000020) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_flashback_query_clause_in_table_ref_aux_ver32385( FOLLOW_flashback_query_clause_in_table_ref_aux_ver32385_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_table_alias_in_table_ref_aux_ver32391_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_table_alias_in_table_ref_aux_ver32391( FOLLOW_table_alias_in_table_ref_aux_ver32391_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_dml_table_expression_clause_in_table_ref_aux_ver42448_bits[]	= { ANTLR_UINT64_LIT(0x0180000000000002), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000000006000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x0000000000000020) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_dml_table_expression_clause_in_table_ref_aux_ver42448( FOLLOW_dml_table_expression_clause_in_table_ref_aux_ver42448_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_pivot_clause_in_table_ref_aux_ver42451_bits[]	= { ANTLR_UINT64_LIT(0x0180000000000002), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x0000000000000020) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_pivot_clause_in_table_ref_aux_ver42451( FOLLOW_pivot_clause_in_table_ref_aux_ver42451_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_unpivot_clause_in_table_ref_aux_ver42453_bits[]	= { ANTLR_UINT64_LIT(0x0180000000000002), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x0000000000000020) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_unpivot_clause_in_table_ref_aux_ver42453( FOLLOW_unpivot_clause_in_table_ref_aux_ver42453_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_flashback_query_clause_in_table_ref_aux_ver42465_bits[]	= { ANTLR_UINT64_LIT(0x0180000000000002), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x0000000000000020) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_flashback_query_clause_in_table_ref_aux_ver42465( FOLLOW_flashback_query_clause_in_table_ref_aux_ver42465_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_table_alias_in_table_ref_aux_ver42471_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_table_alias_in_table_ref_aux_ver42471( FOLLOW_table_alias_in_table_ref_aux_ver42471_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_query_partition_clause_in_join_clause2522_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_query_partition_clause_in_join_clause2522( FOLLOW_query_partition_clause_in_join_clause2522_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_cross_key_in_join_clause2534_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_cross_key_in_join_clause2534( FOLLOW_cross_key_in_join_clause2534_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_natural_key_in_join_clause2536_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_natural_key_in_join_clause2536( FOLLOW_natural_key_in_join_clause2536_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_inner_key_in_join_clause2541_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_inner_key_in_join_clause2541( FOLLOW_inner_key_in_join_clause2541_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_outer_join_type_in_join_clause2543_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_outer_join_type_in_join_clause2543( FOLLOW_outer_join_type_in_join_clause2543_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_join_key_in_join_clause2547_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000004), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x0180000000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_join_key_in_join_clause2547( FOLLOW_join_key_in_join_clause2547_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_table_ref_aux_in_join_clause2557_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x0000100000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_table_ref_aux_in_join_clause2557( FOLLOW_table_ref_aux_in_join_clause2557_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_query_partition_clause_in_join_clause2569_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000100000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_query_partition_clause_in_join_clause2569( FOLLOW_query_partition_clause_in_join_clause2569_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_join_on_part_in_join_clause2581_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000100000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_join_on_part_in_join_clause2581( FOLLOW_join_on_part_in_join_clause2581_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_join_using_part_in_join_clause2592_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000100000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_join_using_part_in_join_clause2592( FOLLOW_join_using_part_in_join_clause2592_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_on_key_in_join_on_part2675_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_on_key_in_join_on_part2675( FOLLOW_on_key_in_join_on_part2675_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_condition_in_join_on_part2677_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_condition_in_join_on_part2677( FOLLOW_condition_in_join_on_part2677_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_using_key_in_join_using_part2718_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_using_key_in_join_using_part2718( FOLLOW_using_key_in_join_using_part2718_bits, 4 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_join_using_part2721_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_join_using_part2721( FOLLOW_LEFT_PAREN_in_join_using_part2721_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_column_name_in_join_using_part2723_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_column_name_in_join_using_part2723( FOLLOW_column_name_in_join_using_part2723_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_join_using_part2726_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_COMMA_in_join_using_part2726( FOLLOW_COMMA_in_join_using_part2726_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_column_name_in_join_using_part2729_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_column_name_in_join_using_part2729( FOLLOW_column_name_in_join_using_part2729_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_join_using_part2733_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_join_using_part2733( FOLLOW_RIGHT_PAREN_in_join_using_part2733_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_full_key_in_outer_join_type2763_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_full_key_in_outer_join_type2763( FOLLOW_full_key_in_outer_join_type2763_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_left_key_in_outer_join_type2774_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_left_key_in_outer_join_type2774( FOLLOW_left_key_in_outer_join_type2774_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_right_key_in_outer_join_type2785_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_right_key_in_outer_join_type2785( FOLLOW_right_key_in_outer_join_type2785_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_outer_key_in_outer_join_type2801_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_outer_key_in_outer_join_type2801( FOLLOW_outer_key_in_outer_join_type2801_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_partition_key_in_query_partition_clause2823_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000200) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_partition_key_in_query_partition_clause2823( FOLLOW_partition_key_in_query_partition_clause2823_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_by_key_in_query_partition_clause2825_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_by_key_in_query_partition_clause2825( FOLLOW_by_key_in_query_partition_clause2825_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_query_partition_clause2848_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0020000000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_query_partition_clause2848( FOLLOW_LEFT_PAREN_in_query_partition_clause2848_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_subquery_in_query_partition_clause2850_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_subquery_in_query_partition_clause2850( FOLLOW_subquery_in_query_partition_clause2850_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_query_partition_clause2852_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_query_partition_clause2852( FOLLOW_RIGHT_PAREN_in_query_partition_clause2852_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_expression_list_in_query_partition_clause2868_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_expression_list_in_query_partition_clause2868( FOLLOW_expression_list_in_query_partition_clause2868_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_expression_in_query_partition_clause2879_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000010) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_expression_in_query_partition_clause2879( FOLLOW_expression_in_query_partition_clause2879_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_query_partition_clause2882_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_COMMA_in_query_partition_clause2882( FOLLOW_COMMA_in_query_partition_clause2882_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_expression_in_query_partition_clause2884_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000010) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_expression_in_query_partition_clause2884( FOLLOW_expression_in_query_partition_clause2884_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_versions_key_in_flashback_query_clause2945_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000100) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_versions_key_in_flashback_query_clause2945( FOLLOW_versions_key_in_flashback_query_clause2945_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_between_key_in_flashback_query_clause2947_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_between_key_in_flashback_query_clause2947( FOLLOW_between_key_in_flashback_query_clause2947_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_scn_key_in_flashback_query_clause2950_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_scn_key_in_flashback_query_clause2950( FOLLOW_scn_key_in_flashback_query_clause2950_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_timestamp_key_in_flashback_query_clause2952_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_timestamp_key_in_flashback_query_clause2952( FOLLOW_timestamp_key_in_flashback_query_clause2952_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_expression_in_flashback_query_clause2955_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_expression_in_flashback_query_clause2955( FOLLOW_expression_in_flashback_query_clause2955_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_as_key_in_flashback_query_clause2985_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000080000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_as_key_in_flashback_query_clause2985( FOLLOW_as_key_in_flashback_query_clause2985_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_of_key_in_flashback_query_clause2987_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_of_key_in_flashback_query_clause2987( FOLLOW_of_key_in_flashback_query_clause2987_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_scn_key_in_flashback_query_clause2990_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_scn_key_in_flashback_query_clause2990( FOLLOW_scn_key_in_flashback_query_clause2990_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_timestamp_key_in_flashback_query_clause2992_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_timestamp_key_in_flashback_query_clause2992( FOLLOW_timestamp_key_in_flashback_query_clause2992_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_snapshot_key_in_flashback_query_clause2994_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_snapshot_key_in_flashback_query_clause2994( FOLLOW_snapshot_key_in_flashback_query_clause2994_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_expression_in_flashback_query_clause2997_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_expression_in_flashback_query_clause2997( FOLLOW_expression_in_flashback_query_clause2997_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_pivot_key_in_pivot_clause3038_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_pivot_key_in_pivot_clause3038( FOLLOW_pivot_key_in_pivot_clause3038_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_xml_key_in_pivot_clause3040_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_xml_key_in_pivot_clause3040( FOLLOW_xml_key_in_pivot_clause3040_bits, 4 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_pivot_clause3051_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_pivot_clause3051( FOLLOW_LEFT_PAREN_in_pivot_clause3051_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_pivot_element_in_pivot_clause3065_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000020000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_pivot_element_in_pivot_clause3065( FOLLOW_pivot_element_in_pivot_clause3065_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_pivot_clause3068_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_COMMA_in_pivot_clause3068( FOLLOW_COMMA_in_pivot_clause3068_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_pivot_element_in_pivot_clause3070_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000020000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_pivot_element_in_pivot_clause3070( FOLLOW_pivot_element_in_pivot_clause3070_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_pivot_for_clause_in_pivot_clause3086_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000800000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_pivot_for_clause_in_pivot_clause3086( FOLLOW_pivot_for_clause_in_pivot_clause3086_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_pivot_in_clause_in_pivot_clause3100_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_pivot_in_clause_in_pivot_clause3100( FOLLOW_pivot_in_clause_in_pivot_clause3100_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_pivot_clause3112_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_pivot_clause3112( FOLLOW_RIGHT_PAREN_in_pivot_clause3112_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_aggregate_function_name_in_pivot_element3160_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_aggregate_function_name_in_pivot_element3160( FOLLOW_aggregate_function_name_in_pivot_element3160_bits, 4 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_pivot_element3162_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_pivot_element3162( FOLLOW_LEFT_PAREN_in_pivot_element3162_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_expression_in_pivot_element3164_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_expression_in_pivot_element3164( FOLLOW_expression_in_pivot_element3164_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_pivot_element3166_bits[]	= { ANTLR_UINT64_LIT(0x0180000000000002), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x0000000000000020) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_pivot_element3166( FOLLOW_RIGHT_PAREN_in_pivot_element3166_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_column_alias_in_pivot_element3168_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_column_alias_in_pivot_element3168( FOLLOW_column_alias_in_pivot_element3168_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_for_key_in_pivot_for_clause3233_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000004), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_for_key_in_pivot_for_clause3233( FOLLOW_for_key_in_pivot_for_clause3233_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_column_name_in_pivot_for_clause3245_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_column_name_in_pivot_for_clause3245( FOLLOW_column_name_in_pivot_for_clause3245_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_pivot_for_clause3256_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_pivot_for_clause3256( FOLLOW_LEFT_PAREN_in_pivot_for_clause3256_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_column_name_in_pivot_for_clause3258_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_column_name_in_pivot_for_clause3258( FOLLOW_column_name_in_pivot_for_clause3258_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_pivot_for_clause3261_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_COMMA_in_pivot_for_clause3261( FOLLOW_COMMA_in_pivot_for_clause3261_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_column_name_in_pivot_for_clause3263_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_column_name_in_pivot_for_clause3263( FOLLOW_column_name_in_pivot_for_clause3263_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_pivot_for_clause3267_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_pivot_for_clause3267( FOLLOW_RIGHT_PAREN_in_pivot_for_clause3267_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_in_key_in_pivot_in_clause3322_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_in_key_in_pivot_in_clause3322( FOLLOW_in_key_in_pivot_in_clause3322_bits, 4 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_pivot_in_clause3332_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x082206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_pivot_in_clause3332( FOLLOW_LEFT_PAREN_in_pivot_in_clause3332_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_subquery_in_pivot_in_clause3356_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_subquery_in_pivot_in_clause3356( FOLLOW_subquery_in_pivot_in_clause3356_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_any_key_in_pivot_in_clause3382_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_any_key_in_pivot_in_clause3382( FOLLOW_any_key_in_pivot_in_clause3382_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_pivot_in_clause3385_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_COMMA_in_pivot_in_clause3385( FOLLOW_COMMA_in_pivot_in_clause3385_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_any_key_in_pivot_in_clause3387_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_any_key_in_pivot_in_clause3387( FOLLOW_any_key_in_pivot_in_clause3387_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_pivot_in_clause_element_in_pivot_in_clause3410_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_pivot_in_clause_element_in_pivot_in_clause3410( FOLLOW_pivot_in_clause_element_in_pivot_in_clause3410_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_pivot_in_clause3413_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_COMMA_in_pivot_in_clause3413( FOLLOW_COMMA_in_pivot_in_clause3413_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_pivot_in_clause_element_in_pivot_in_clause3415_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_pivot_in_clause_element_in_pivot_in_clause3415( FOLLOW_pivot_in_clause_element_in_pivot_in_clause3415_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_pivot_in_clause3441_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_pivot_in_clause3441( FOLLOW_RIGHT_PAREN_in_pivot_in_clause3441_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_pivot_in_clause_elements_in_pivot_in_clause_element3521_bits[]	= { ANTLR_UINT64_LIT(0x0180000000000002), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x0000000000000020) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_pivot_in_clause_elements_in_pivot_in_clause_element3521( FOLLOW_pivot_in_clause_elements_in_pivot_in_clause_element3521_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_column_alias_in_pivot_in_clause_element3523_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_column_alias_in_pivot_in_clause_element3523( FOLLOW_column_alias_in_pivot_in_clause_element3523_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_expression_in_pivot_in_clause_elements3563_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_expression_in_pivot_in_clause_elements3563( FOLLOW_expression_in_pivot_in_clause_elements3563_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_expression_list_in_pivot_in_clause_elements3587_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_expression_list_in_pivot_in_clause_elements3587( FOLLOW_expression_list_in_pivot_in_clause_elements3587_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_unpivot_key_in_unpivot_clause3607_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_unpivot_key_in_unpivot_clause3607( FOLLOW_unpivot_key_in_unpivot_clause3607_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_include_key_in_unpivot_clause3620_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_include_key_in_unpivot_clause3620( FOLLOW_include_key_in_unpivot_clause3620_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_exclude_key_in_unpivot_clause3622_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_exclude_key_in_unpivot_clause3622( FOLLOW_exclude_key_in_unpivot_clause3622_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_nulls_key_in_unpivot_clause3625_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_nulls_key_in_unpivot_clause3625( FOLLOW_nulls_key_in_unpivot_clause3625_bits, 4 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_unpivot_clause3637_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000004), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_unpivot_clause3637( FOLLOW_LEFT_PAREN_in_unpivot_clause3637_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_column_name_in_unpivot_clause3656_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000020000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_column_name_in_unpivot_clause3656( FOLLOW_column_name_in_unpivot_clause3656_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_unpivot_clause3675_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_unpivot_clause3675( FOLLOW_LEFT_PAREN_in_unpivot_clause3675_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_column_name_in_unpivot_clause3677_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_column_name_in_unpivot_clause3677( FOLLOW_column_name_in_unpivot_clause3677_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_unpivot_clause3680_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_COMMA_in_unpivot_clause3680( FOLLOW_COMMA_in_unpivot_clause3680_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_column_name_in_unpivot_clause3682_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_column_name_in_unpivot_clause3682( FOLLOW_column_name_in_unpivot_clause3682_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_unpivot_clause3686_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000020000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_unpivot_clause3686( FOLLOW_RIGHT_PAREN_in_unpivot_clause3686_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_pivot_for_clause_in_unpivot_clause3714_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000800000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_pivot_for_clause_in_unpivot_clause3714( FOLLOW_pivot_for_clause_in_unpivot_clause3714_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_unpivot_in_clause_in_unpivot_clause3728_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_unpivot_in_clause_in_unpivot_clause3728( FOLLOW_unpivot_in_clause_in_unpivot_clause3728_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_unpivot_clause3738_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_unpivot_clause3738( FOLLOW_RIGHT_PAREN_in_unpivot_clause3738_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_in_key_in_unpivot_in_clause3788_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_in_key_in_unpivot_in_clause3788( FOLLOW_in_key_in_unpivot_in_clause3788_bits, 4 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_unpivot_in_clause3798_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000004), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_unpivot_in_clause3798( FOLLOW_LEFT_PAREN_in_unpivot_in_clause3798_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_unpivot_in_elements_in_unpivot_in_clause3812_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_unpivot_in_elements_in_unpivot_in_clause3812( FOLLOW_unpivot_in_elements_in_unpivot_in_clause3812_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_unpivot_in_clause3815_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000004), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_COMMA_in_unpivot_in_clause3815( FOLLOW_COMMA_in_unpivot_in_clause3815_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_unpivot_in_elements_in_unpivot_in_clause3817_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_unpivot_in_elements_in_unpivot_in_clause3817( FOLLOW_unpivot_in_elements_in_unpivot_in_clause3817_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_unpivot_in_clause3829_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_unpivot_in_clause3829( FOLLOW_RIGHT_PAREN_in_unpivot_in_clause3829_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_column_name_in_unpivot_in_elements3874_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000020) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_column_name_in_unpivot_in_elements3874( FOLLOW_column_name_in_unpivot_in_elements3874_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_unpivot_in_elements3889_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_unpivot_in_elements3889( FOLLOW_LEFT_PAREN_in_unpivot_in_elements3889_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_column_name_in_unpivot_in_elements3891_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_column_name_in_unpivot_in_elements3891( FOLLOW_column_name_in_unpivot_in_elements3891_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_unpivot_in_elements3894_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_COMMA_in_unpivot_in_elements3894( FOLLOW_COMMA_in_unpivot_in_elements3894_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_column_name_in_unpivot_in_elements3896_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_column_name_in_unpivot_in_elements3896( FOLLOW_column_name_in_unpivot_in_elements3896_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_unpivot_in_elements3900_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000020) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_unpivot_in_elements3900( FOLLOW_RIGHT_PAREN_in_unpivot_in_elements3900_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_as_key_in_unpivot_in_elements3925_bits[]	= { ANTLR_UINT64_LIT(0x0180000000002000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x0800040008050000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_as_key_in_unpivot_in_elements3925( FOLLOW_as_key_in_unpivot_in_elements3925_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_constant_in_unpivot_in_elements3940_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_constant_in_unpivot_in_elements3940( FOLLOW_constant_in_unpivot_in_elements3940_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_unpivot_in_elements3960_bits[]	= { ANTLR_UINT64_LIT(0x0180000000002000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x0800040008050000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_unpivot_in_elements3960( FOLLOW_LEFT_PAREN_in_unpivot_in_elements3960_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_constant_in_unpivot_in_elements3962_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_constant_in_unpivot_in_elements3962( FOLLOW_constant_in_unpivot_in_elements3962_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_unpivot_in_elements3965_bits[]	= { ANTLR_UINT64_LIT(0x0180000000002000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x0800040008050000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_COMMA_in_unpivot_in_elements3965( FOLLOW_COMMA_in_unpivot_in_elements3965_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_constant_in_unpivot_in_elements3967_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_constant_in_unpivot_in_elements3967( FOLLOW_constant_in_unpivot_in_elements3967_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_unpivot_in_elements3971_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_unpivot_in_elements3971( FOLLOW_RIGHT_PAREN_in_unpivot_in_elements3971_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_connect_key_in_hierarchical_query_clause4033_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000200) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_connect_key_in_hierarchical_query_clause4033( FOLLOW_connect_key_in_hierarchical_query_clause4033_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_by_key_in_hierarchical_query_clause4035_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_by_key_in_hierarchical_query_clause4035( FOLLOW_by_key_in_hierarchical_query_clause4035_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_nocycle_key_in_hierarchical_query_clause4037_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_nocycle_key_in_hierarchical_query_clause4037( FOLLOW_nocycle_key_in_hierarchical_query_clause4037_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_condition_in_hierarchical_query_clause4040_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000080000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_condition_in_hierarchical_query_clause4040( FOLLOW_condition_in_hierarchical_query_clause4040_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_start_part_in_hierarchical_query_clause4042_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_start_part_in_hierarchical_query_clause4042( FOLLOW_start_part_in_hierarchical_query_clause4042_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_start_part_in_hierarchical_query_clause4084_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_start_part_in_hierarchical_query_clause4084( FOLLOW_start_part_in_hierarchical_query_clause4084_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_connect_key_in_hierarchical_query_clause4086_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000200) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_connect_key_in_hierarchical_query_clause4086( FOLLOW_connect_key_in_hierarchical_query_clause4086_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_by_key_in_hierarchical_query_clause4088_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_by_key_in_hierarchical_query_clause4088( FOLLOW_by_key_in_hierarchical_query_clause4088_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_nocycle_key_in_hierarchical_query_clause4090_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_nocycle_key_in_hierarchical_query_clause4090( FOLLOW_nocycle_key_in_hierarchical_query_clause4090_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_condition_in_hierarchical_query_clause4093_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_condition_in_hierarchical_query_clause4093( FOLLOW_condition_in_hierarchical_query_clause4093_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_start_key_in_start_part4143_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000008) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_start_key_in_start_part4143( FOLLOW_start_key_in_start_part4143_bits, 9 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_with_key_in_start_part4145_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_with_key_in_start_part4145( FOLLOW_with_key_in_start_part4145_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_condition_in_start_part4147_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_condition_in_start_part4147( FOLLOW_condition_in_start_part4147_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_group_key_in_group_by_clause4192_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000200) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_group_key_in_group_by_clause4192( FOLLOW_group_key_in_group_by_clause4192_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_by_key_in_group_by_clause4194_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_by_key_in_group_by_clause4194( FOLLOW_by_key_in_group_by_clause4194_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_group_by_clause4200_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_group_by_clause4200( FOLLOW_LEFT_PAREN_in_group_by_clause4200_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_group_by_clause4202_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000400000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_group_by_clause4202( FOLLOW_RIGHT_PAREN_in_group_by_clause4202_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_group_by_elements_in_group_by_clause4209_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000400000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_group_by_elements_in_group_by_clause4209( FOLLOW_group_by_elements_in_group_by_clause4209_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_group_by_clause4219_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_COMMA_in_group_by_clause4219( FOLLOW_COMMA_in_group_by_clause4219_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_group_by_elements_in_group_by_clause4221_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000400000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_group_by_elements_in_group_by_clause4221( FOLLOW_group_by_elements_in_group_by_clause4221_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_having_clause_in_group_by_clause4232_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_having_clause_in_group_by_clause4232( FOLLOW_having_clause_in_group_by_clause4232_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_having_clause_in_group_by_clause4272_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000200000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_having_clause_in_group_by_clause4272( FOLLOW_having_clause_in_group_by_clause4272_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_group_key_in_group_by_clause4277_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000200) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_group_key_in_group_by_clause4277( FOLLOW_group_key_in_group_by_clause4277_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_by_key_in_group_by_clause4279_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_by_key_in_group_by_clause4279( FOLLOW_by_key_in_group_by_clause4279_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_group_by_clause4285_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_group_by_clause4285( FOLLOW_LEFT_PAREN_in_group_by_clause4285_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_group_by_clause4287_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_group_by_clause4287( FOLLOW_RIGHT_PAREN_in_group_by_clause4287_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_group_by_elements_in_group_by_clause4294_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000010) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_group_by_elements_in_group_by_clause4294( FOLLOW_group_by_elements_in_group_by_clause4294_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_group_by_clause4304_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_COMMA_in_group_by_clause4304( FOLLOW_COMMA_in_group_by_clause4304_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_group_by_elements_in_group_by_clause4306_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000010) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_group_by_elements_in_group_by_clause4306( FOLLOW_group_by_elements_in_group_by_clause4306_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_grouping_sets_clause_in_group_by_elements4361_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_grouping_sets_clause_in_group_by_elements4361( FOLLOW_grouping_sets_clause_in_group_by_elements4361_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_rollup_cube_clause_in_group_by_elements4372_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_rollup_cube_clause_in_group_by_elements4372( FOLLOW_rollup_cube_clause_in_group_by_elements4372_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_expression_in_group_by_elements4384_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_expression_in_group_by_elements4384( FOLLOW_expression_in_group_by_elements4384_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_rollup_key_in_rollup_cube_clause4413_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_rollup_key_in_rollup_cube_clause4413( FOLLOW_rollup_key_in_rollup_cube_clause4413_bits, 4 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_cube_key_in_rollup_cube_clause4416_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_cube_key_in_rollup_cube_clause4416( FOLLOW_cube_key_in_rollup_cube_clause4416_bits, 4 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_rollup_cube_clause4420_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_rollup_cube_clause4420( FOLLOW_LEFT_PAREN_in_rollup_cube_clause4420_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_grouping_sets_elements_in_rollup_cube_clause4422_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_grouping_sets_elements_in_rollup_cube_clause4422( FOLLOW_grouping_sets_elements_in_rollup_cube_clause4422_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_rollup_cube_clause4425_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_COMMA_in_rollup_cube_clause4425( FOLLOW_COMMA_in_rollup_cube_clause4425_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_grouping_sets_elements_in_rollup_cube_clause4428_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_grouping_sets_elements_in_rollup_cube_clause4428( FOLLOW_grouping_sets_elements_in_rollup_cube_clause4428_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_rollup_cube_clause4432_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_rollup_cube_clause4432( FOLLOW_RIGHT_PAREN_in_rollup_cube_clause4432_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_grouping_key_in_grouping_sets_clause4453_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_grouping_key_in_grouping_sets_clause4453( FOLLOW_grouping_key_in_grouping_sets_clause4453_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_sets_key_in_grouping_sets_clause4455_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_sets_key_in_grouping_sets_clause4455( FOLLOW_sets_key_in_grouping_sets_clause4455_bits, 4 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_grouping_sets_clause4466_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_grouping_sets_clause4466( FOLLOW_LEFT_PAREN_in_grouping_sets_clause4466_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_grouping_sets_elements_in_grouping_sets_clause4468_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_grouping_sets_elements_in_grouping_sets_clause4468( FOLLOW_grouping_sets_elements_in_grouping_sets_clause4468_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_grouping_sets_clause4471_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_COMMA_in_grouping_sets_clause4471( FOLLOW_COMMA_in_grouping_sets_clause4471_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_grouping_sets_elements_in_grouping_sets_clause4473_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_grouping_sets_elements_in_grouping_sets_clause4473( FOLLOW_grouping_sets_elements_in_grouping_sets_clause4473_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_grouping_sets_clause4477_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_grouping_sets_clause4477( FOLLOW_RIGHT_PAREN_in_grouping_sets_clause4477_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_rollup_cube_clause_in_grouping_sets_elements4525_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_rollup_cube_clause_in_grouping_sets_elements4525( FOLLOW_rollup_cube_clause_in_grouping_sets_elements4525_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_expression_list_in_grouping_sets_elements4541_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_expression_list_in_grouping_sets_elements4541( FOLLOW_expression_list_in_grouping_sets_elements4541_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_expression_in_grouping_sets_elements4552_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_expression_in_grouping_sets_elements4552( FOLLOW_expression_in_grouping_sets_elements4552_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_having_key_in_having_clause4580_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_having_key_in_having_clause4580( FOLLOW_having_key_in_having_clause4580_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_condition_in_having_clause4582_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_condition_in_having_clause4582( FOLLOW_condition_in_having_clause4582_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_model_key_in_model_clause4622_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_model_key_in_model_clause4622( FOLLOW_model_key_in_model_clause4622_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_cell_reference_options_in_model_clause4624_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_cell_reference_options_in_model_clause4624( FOLLOW_cell_reference_options_in_model_clause4624_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_return_rows_clause_in_model_clause4627_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_return_rows_clause_in_model_clause4627( FOLLOW_return_rows_clause_in_model_clause4627_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_reference_model_in_model_clause4630_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_reference_model_in_model_clause4630( FOLLOW_reference_model_in_model_clause4630_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_main_model_in_model_clause4633_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_main_model_in_model_clause4633( FOLLOW_main_model_in_model_clause4633_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_ignore_key_in_cell_reference_options4679_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_ignore_key_in_cell_reference_options4679( FOLLOW_ignore_key_in_cell_reference_options4679_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_keep_key_in_cell_reference_options4682_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_keep_key_in_cell_reference_options4682( FOLLOW_keep_key_in_cell_reference_options4682_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_nav_key_in_cell_reference_options4686_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_nav_key_in_cell_reference_options4686( FOLLOW_nav_key_in_cell_reference_options4686_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_unique_key_in_cell_reference_options4697_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_unique_key_in_cell_reference_options4697( FOLLOW_unique_key_in_cell_reference_options4697_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_dimension_key_in_cell_reference_options4701_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_dimension_key_in_cell_reference_options4701( FOLLOW_dimension_key_in_cell_reference_options4701_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_single_key_in_cell_reference_options4703_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_single_key_in_cell_reference_options4703( FOLLOW_single_key_in_cell_reference_options4703_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_reference_key_in_cell_reference_options4705_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_reference_key_in_cell_reference_options4705( FOLLOW_reference_key_in_cell_reference_options4705_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_return_key_in_return_rows_clause4726_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_return_key_in_return_rows_clause4726( FOLLOW_return_key_in_return_rows_clause4726_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_updated_key_in_return_rows_clause4730_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_updated_key_in_return_rows_clause4730( FOLLOW_updated_key_in_return_rows_clause4730_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_all_key_in_return_rows_clause4732_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_all_key_in_return_rows_clause4732( FOLLOW_all_key_in_return_rows_clause4732_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_rows_key_in_return_rows_clause4735_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_rows_key_in_return_rows_clause4735( FOLLOW_rows_key_in_return_rows_clause4735_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_reference_key_in_reference_model4756_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_reference_key_in_reference_model4756( FOLLOW_reference_key_in_reference_model4756_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_reference_model_name_in_reference_model4759_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000100000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_reference_model_name_in_reference_model4759( FOLLOW_reference_model_name_in_reference_model4759_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_on_key_in_reference_model4761_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_on_key_in_reference_model4761( FOLLOW_on_key_in_reference_model4761_bits, 4 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_reference_model4777_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0020000000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_reference_model4777( FOLLOW_LEFT_PAREN_in_reference_model4777_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_subquery_in_reference_model4779_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_subquery_in_reference_model4779( FOLLOW_subquery_in_reference_model4779_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_reference_model4781_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_reference_model4781( FOLLOW_RIGHT_PAREN_in_reference_model4781_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_model_column_clauses_in_reference_model4783_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_model_column_clauses_in_reference_model4783( FOLLOW_model_column_clauses_in_reference_model4783_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_cell_reference_options_in_reference_model4798_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_cell_reference_options_in_reference_model4798( FOLLOW_cell_reference_options_in_reference_model4798_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_main_key_in_main_model4820_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_main_key_in_main_model4820( FOLLOW_main_key_in_main_model4820_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_main_model_name_in_main_model4822_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_main_model_name_in_main_model4822( FOLLOW_main_model_name_in_main_model4822_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_model_column_clauses_in_main_model4826_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_model_column_clauses_in_main_model4826( FOLLOW_model_column_clauses_in_main_model4826_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_cell_reference_options_in_main_model4828_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_cell_reference_options_in_main_model4828( FOLLOW_cell_reference_options_in_main_model4828_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_model_rules_clause_in_main_model4831_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_model_rules_clause_in_main_model4831( FOLLOW_model_rules_clause_in_main_model4831_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_model_column_partition_part_in_model_column_clauses4875_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_model_column_partition_part_in_model_column_clauses4875( FOLLOW_model_column_partition_part_in_model_column_clauses4875_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_dimension_key_in_model_column_clauses4886_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000200) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_dimension_key_in_model_column_clauses4886( FOLLOW_dimension_key_in_model_column_clauses4886_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_by_key_in_model_column_clauses4888_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_by_key_in_model_column_clauses4888( FOLLOW_by_key_in_model_column_clauses4888_bits, 4 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_model_column_list_in_model_column_clauses4890_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_model_column_list_in_model_column_clauses4890( FOLLOW_model_column_list_in_model_column_clauses4890_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_measures_key_in_model_column_clauses4892_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_measures_key_in_model_column_clauses4892( FOLLOW_measures_key_in_model_column_clauses4892_bits, 4 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_model_column_list_in_model_column_clauses4894_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_model_column_list_in_model_column_clauses4894( FOLLOW_model_column_list_in_model_column_clauses4894_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_partition_key_in_model_column_partition_part4943_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000200) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_partition_key_in_model_column_partition_part4943( FOLLOW_partition_key_in_model_column_partition_part4943_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_by_key_in_model_column_partition_part4946_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_by_key_in_model_column_partition_part4946( FOLLOW_by_key_in_model_column_partition_part4946_bits, 4 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_model_column_list_in_model_column_partition_part4949_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_model_column_list_in_model_column_partition_part4949( FOLLOW_model_column_list_in_model_column_partition_part4949_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_model_column_list4969_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_model_column_list4969( FOLLOW_LEFT_PAREN_in_model_column_list4969_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_model_column_in_model_column_list4971_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_model_column_in_model_column_list4971( FOLLOW_model_column_in_model_column_list4971_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_model_column_list4974_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_COMMA_in_model_column_list4974( FOLLOW_COMMA_in_model_column_list4974_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_model_column_in_model_column_list4976_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_model_column_in_model_column_list4976( FOLLOW_model_column_in_model_column_list4976_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_model_column_list4981_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_model_column_list4981( FOLLOW_RIGHT_PAREN_in_model_column_list4981_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_expression_in_model_column5018_bits[]	= { ANTLR_UINT64_LIT(0x0180000000000002), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x0000000000000020) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_expression_in_model_column5018( FOLLOW_expression_in_model_column5018_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_column_alias_in_model_column5020_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_column_alias_in_model_column5020( FOLLOW_column_alias_in_model_column5020_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_model_rules_part_in_model_rules_clause5064_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_model_rules_part_in_model_rules_clause5064( FOLLOW_model_rules_part_in_model_rules_clause5064_bits, 4 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_model_rules_clause5067_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000001001), ANTLR_UINT64_LIT(0x480204000C250412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_model_rules_clause5067( FOLLOW_LEFT_PAREN_in_model_rules_clause5067_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_model_rules_element_in_model_rules_clause5070_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_model_rules_element_in_model_rules_clause5070( FOLLOW_model_rules_element_in_model_rules_clause5070_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_model_rules_clause5073_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x480204000C250412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_COMMA_in_model_rules_clause5073( FOLLOW_COMMA_in_model_rules_clause5073_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_model_rules_element_in_model_rules_clause5075_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_model_rules_element_in_model_rules_clause5075( FOLLOW_model_rules_element_in_model_rules_clause5075_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_model_rules_clause5081_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_model_rules_clause5081( FOLLOW_RIGHT_PAREN_in_model_rules_clause5081_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_rules_key_in_model_rules_part5121_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x4000000000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_rules_key_in_model_rules_part5121( FOLLOW_rules_key_in_model_rules_part5121_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_update_key_in_model_rules_part5124_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_update_key_in_model_rules_part5124( FOLLOW_update_key_in_model_rules_part5124_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_upsert_key_in_model_rules_part5126_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_upsert_key_in_model_rules_part5126( FOLLOW_upsert_key_in_model_rules_part5126_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_all_key_in_model_rules_part5128_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_all_key_in_model_rules_part5128( FOLLOW_all_key_in_model_rules_part5128_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_automatic_key_in_model_rules_part5135_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000800000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_automatic_key_in_model_rules_part5135( FOLLOW_automatic_key_in_model_rules_part5135_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_sequential_key_in_model_rules_part5137_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000800000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_sequential_key_in_model_rules_part5137( FOLLOW_sequential_key_in_model_rules_part5137_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_order_key_in_model_rules_part5140_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_order_key_in_model_rules_part5140( FOLLOW_order_key_in_model_rules_part5140_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_model_iterate_clause_in_model_rules_part5144_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_model_iterate_clause_in_model_rules_part5144( FOLLOW_model_iterate_clause_in_model_rules_part5144_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_update_key_in_model_rules_element5198_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080204000C250412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_update_key_in_model_rules_element5198( FOLLOW_update_key_in_model_rules_element5198_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_upsert_key_in_model_rules_element5200_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080204000C250412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_upsert_key_in_model_rules_element5200( FOLLOW_upsert_key_in_model_rules_element5200_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_all_key_in_model_rules_element5208_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080204000C250412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_all_key_in_model_rules_element5208( FOLLOW_all_key_in_model_rules_element5208_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_cell_assignment_in_model_rules_element5222_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000800000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_cell_assignment_in_model_rules_element5222( FOLLOW_cell_assignment_in_model_rules_element5222_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_order_by_clause_in_model_rules_element5240_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_order_by_clause_in_model_rules_element5240( FOLLOW_order_by_clause_in_model_rules_element5240_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_EQUALS_OP_in_model_rules_element5255_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_EQUALS_OP_in_model_rules_element5255( FOLLOW_EQUALS_OP_in_model_rules_element5255_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_expression_in_model_rules_element5257_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_expression_in_model_rules_element5257( FOLLOW_expression_in_model_rules_element5257_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_model_expression_in_cell_assignment5316_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_model_expression_in_cell_assignment5316( FOLLOW_model_expression_in_cell_assignment5316_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_iterate_key_in_model_iterate_clause5336_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_iterate_key_in_model_iterate_clause5336( FOLLOW_iterate_key_in_model_iterate_clause5336_bits, 4 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_model_iterate_clause5338_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_model_iterate_clause5338( FOLLOW_LEFT_PAREN_in_model_iterate_clause5338_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_expression_in_model_iterate_clause5340_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_expression_in_model_iterate_clause5340( FOLLOW_expression_in_model_iterate_clause5340_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_model_iterate_clause5342_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_model_iterate_clause5342( FOLLOW_RIGHT_PAREN_in_model_iterate_clause5342_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_until_part_in_model_iterate_clause5344_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_until_part_in_model_iterate_clause5344( FOLLOW_until_part_in_model_iterate_clause5344_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_until_key_in_until_part5387_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_until_key_in_until_part5387( FOLLOW_until_key_in_until_part5387_bits, 4 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_until_part5389_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_until_part5389( FOLLOW_LEFT_PAREN_in_until_part5389_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_condition_in_until_part5391_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_condition_in_until_part5391( FOLLOW_condition_in_until_part5391_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_until_part5393_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_until_part5393( FOLLOW_RIGHT_PAREN_in_until_part5393_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_order_key_in_order_by_clause5433_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x0000000000000200) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_order_key_in_order_by_clause5433( FOLLOW_order_key_in_order_by_clause5433_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_siblings_key_in_order_by_clause5435_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000200) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_siblings_key_in_order_by_clause5435( FOLLOW_siblings_key_in_order_by_clause5435_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_by_key_in_order_by_clause5438_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_by_key_in_order_by_clause5438( FOLLOW_by_key_in_order_by_clause5438_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_order_by_elements_in_order_by_clause5440_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000010000000), ANTLR_UINT64_LIT(0x0000000000000020) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_order_by_elements_in_order_by_clause5440( FOLLOW_order_by_elements_in_order_by_clause5440_bits, 9 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_order_by_clause5443_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_COMMA_in_order_by_clause5443( FOLLOW_COMMA_in_order_by_clause5443_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_order_by_elements_in_order_by_clause5445_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000010000000), ANTLR_UINT64_LIT(0x0000000000000020) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_order_by_elements_in_order_by_clause5445( FOLLOW_order_by_elements_in_order_by_clause5445_bits, 9 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_row_limiting_clause_in_order_by_clause5449_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_row_limiting_clause_in_order_by_clause5449( FOLLOW_row_limiting_clause_in_order_by_clause5449_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_expression_in_order_by_elements5497_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x0000000000100040) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_expression_in_order_by_elements5497( FOLLOW_expression_in_order_by_elements5497_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_asc_key_in_order_by_elements5500_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_asc_key_in_order_by_elements5500( FOLLOW_asc_key_in_order_by_elements5500_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_desc_key_in_order_by_elements5502_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_desc_key_in_order_by_elements5502( FOLLOW_desc_key_in_order_by_elements5502_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_nulls_key_in_order_by_elements5507_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_nulls_key_in_order_by_elements5507( FOLLOW_nulls_key_in_order_by_elements5507_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_first_key_in_order_by_elements5510_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_first_key_in_order_by_elements5510( FOLLOW_first_key_in_order_by_elements5510_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_last_key_in_order_by_elements5512_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_last_key_in_order_by_elements5512( FOLLOW_last_key_in_order_by_elements5512_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_offset_key_in_row_limiting_clause5571_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_offset_key_in_row_limiting_clause5571( FOLLOW_offset_key_in_row_limiting_clause5571_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_expression_in_row_limiting_clause5573_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x0000000010000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_expression_in_row_limiting_clause5573( FOLLOW_expression_in_row_limiting_clause5573_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_row_key_in_row_limiting_clause5577_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000010000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_row_key_in_row_limiting_clause5577( FOLLOW_row_key_in_row_limiting_clause5577_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_rows_key_in_row_limiting_clause5579_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000010000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_rows_key_in_row_limiting_clause5579( FOLLOW_rows_key_in_row_limiting_clause5579_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_fetch_key_in_row_limiting_clause5596_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_fetch_key_in_row_limiting_clause5596( FOLLOW_fetch_key_in_row_limiting_clause5596_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_first_key_in_row_limiting_clause5599_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_first_key_in_row_limiting_clause5599( FOLLOW_first_key_in_row_limiting_clause5599_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_next_key_in_row_limiting_clause5601_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_next_key_in_row_limiting_clause5601( FOLLOW_next_key_in_row_limiting_clause5601_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_expression_in_row_limiting_clause5605_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_expression_in_row_limiting_clause5605( FOLLOW_expression_in_row_limiting_clause5605_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_percent_key_in_row_limiting_clause5607_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_percent_key_in_row_limiting_clause5607( FOLLOW_percent_key_in_row_limiting_clause5607_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_row_key_in_row_limiting_clause5613_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000008) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_row_key_in_row_limiting_clause5613( FOLLOW_row_key_in_row_limiting_clause5613_bits, 9 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_rows_key_in_row_limiting_clause5615_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000008) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_rows_key_in_row_limiting_clause5615( FOLLOW_rows_key_in_row_limiting_clause5615_bits, 9 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_only_key_in_row_limiting_clause5619_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_only_key_in_row_limiting_clause5619( FOLLOW_only_key_in_row_limiting_clause5619_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_with_key_in_row_limiting_clause5621_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_with_key_in_row_limiting_clause5621( FOLLOW_with_key_in_row_limiting_clause5621_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_ties_key_in_row_limiting_clause5623_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_ties_key_in_row_limiting_clause5623( FOLLOW_ties_key_in_row_limiting_clause5623_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_for_key_in_for_update_clause5671_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x4000000000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_for_key_in_for_update_clause5671( FOLLOW_for_key_in_for_update_clause5671_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_update_key_in_for_update_clause5673_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000010000000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x0000080000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_update_key_in_for_update_clause5673( FOLLOW_update_key_in_for_update_clause5673_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_for_update_of_part_in_for_update_clause5675_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000010000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_for_update_of_part_in_for_update_clause5675( FOLLOW_for_update_of_part_in_for_update_clause5675_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_for_update_options_in_for_update_clause5678_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_for_update_options_in_for_update_clause5678( FOLLOW_for_update_options_in_for_update_clause5678_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_of_key_in_for_update_of_part5721_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_of_key_in_for_update_of_part5721( FOLLOW_of_key_in_for_update_of_part5721_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_column_name_in_for_update_of_part5724_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000010) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_column_name_in_for_update_of_part5724( FOLLOW_column_name_in_for_update_of_part5724_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_for_update_of_part5727_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_COMMA_in_for_update_of_part5727( FOLLOW_COMMA_in_for_update_of_part5727_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_column_name_in_for_update_of_part5730_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000010) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_column_name_in_for_update_of_part5730( FOLLOW_column_name_in_for_update_of_part5730_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_skip_key_in_for_update_options5752_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_skip_key_in_for_update_options5752( FOLLOW_skip_key_in_for_update_options5752_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_locked_key_in_for_update_options5754_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_locked_key_in_for_update_options5754( FOLLOW_locked_key_in_for_update_options5754_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_nowait_key_in_for_update_options5766_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_nowait_key_in_for_update_options5766( FOLLOW_nowait_key_in_for_update_options5766_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_wait_key_in_for_update_options5777_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_wait_key_in_for_update_options5777( FOLLOW_wait_key_in_for_update_options5777_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_expression_in_for_update_options5779_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_expression_in_for_update_options5779( FOLLOW_expression_in_for_update_options5779_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_update_key_in_update_statement5813_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000004), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x0180000000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_update_key_in_update_statement5813( FOLLOW_update_key_in_update_statement5813_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_general_table_ref_in_update_statement5816_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_general_table_ref_in_update_statement5816( FOLLOW_general_table_ref_in_update_statement5816_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_update_set_clause_in_update_statement5826_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_update_set_clause_in_update_statement5826( FOLLOW_update_set_clause_in_update_statement5826_bits, 9 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_where_clause_in_update_statement5836_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_where_clause_in_update_statement5836( FOLLOW_where_clause_in_update_statement5836_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_static_returning_clause_in_update_statement5839_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_static_returning_clause_in_update_statement5839( FOLLOW_static_returning_clause_in_update_statement5839_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_error_logging_clause_in_update_statement5842_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_error_logging_clause_in_update_statement5842( FOLLOW_error_logging_clause_in_update_statement5842_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_set_key_in_update_set_clause5872_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000004), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_set_key_in_update_set_clause5872( FOLLOW_set_key_in_update_set_clause5872_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_column_based_update_set_clause_in_update_set_clause5883_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000010) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_column_based_update_set_clause_in_update_set_clause5883( FOLLOW_column_based_update_set_clause_in_update_set_clause5883_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_update_set_clause5886_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000004), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_COMMA_in_update_set_clause5886( FOLLOW_COMMA_in_update_set_clause5886_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_column_based_update_set_clause_in_update_set_clause5888_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000010) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_column_based_update_set_clause_in_update_set_clause5888( FOLLOW_column_based_update_set_clause_in_update_set_clause5888_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_value_key_in_update_set_clause5901_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_value_key_in_update_set_clause5901( FOLLOW_value_key_in_update_set_clause5901_bits, 4 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_update_set_clause5903_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_update_set_clause5903( FOLLOW_LEFT_PAREN_in_update_set_clause5903_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_id_in_update_set_clause5905_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_id_in_update_set_clause5905( FOLLOW_id_in_update_set_clause5905_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_update_set_clause5908_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_update_set_clause5908( FOLLOW_RIGHT_PAREN_in_update_set_clause5908_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_EQUALS_OP_in_update_set_clause5910_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_EQUALS_OP_in_update_set_clause5910( FOLLOW_EQUALS_OP_in_update_set_clause5910_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_expression_in_update_set_clause5912_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_expression_in_update_set_clause5912( FOLLOW_expression_in_update_set_clause5912_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_column_name_in_column_based_update_set_clause5984_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_column_name_in_column_based_update_set_clause5984( FOLLOW_column_name_in_column_based_update_set_clause5984_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_EQUALS_OP_in_column_based_update_set_clause5986_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_EQUALS_OP_in_column_based_update_set_clause5986( FOLLOW_EQUALS_OP_in_column_based_update_set_clause5986_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_expression_in_column_based_update_set_clause5988_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_expression_in_column_based_update_set_clause5988( FOLLOW_expression_in_column_based_update_set_clause5988_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_column_based_update_set_clause6014_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_column_based_update_set_clause6014( FOLLOW_LEFT_PAREN_in_column_based_update_set_clause6014_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_column_name_in_column_based_update_set_clause6016_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_column_name_in_column_based_update_set_clause6016( FOLLOW_column_name_in_column_based_update_set_clause6016_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_column_based_update_set_clause6019_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_COMMA_in_column_based_update_set_clause6019( FOLLOW_COMMA_in_column_based_update_set_clause6019_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_column_name_in_column_based_update_set_clause6021_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_column_name_in_column_based_update_set_clause6021( FOLLOW_column_name_in_column_based_update_set_clause6021_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_column_based_update_set_clause6025_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_column_based_update_set_clause6025( FOLLOW_RIGHT_PAREN_in_column_based_update_set_clause6025_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_EQUALS_OP_in_column_based_update_set_clause6027_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0020000000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_EQUALS_OP_in_column_based_update_set_clause6027( FOLLOW_EQUALS_OP_in_column_based_update_set_clause6027_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_subquery_in_column_based_update_set_clause6029_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_subquery_in_column_based_update_set_clause6029( FOLLOW_subquery_in_column_based_update_set_clause6029_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_delete_key_in_delete_statement6063_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000004), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x0180000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_delete_key_in_delete_statement6063( FOLLOW_delete_key_in_delete_statement6063_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_from_key_in_delete_statement6066_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000004), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x0180000000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_from_key_in_delete_statement6066( FOLLOW_from_key_in_delete_statement6066_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_general_table_ref_in_delete_statement6078_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_general_table_ref_in_delete_statement6078( FOLLOW_general_table_ref_in_delete_statement6078_bits, 9 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_where_clause_in_delete_statement6088_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_where_clause_in_delete_statement6088( FOLLOW_where_clause_in_delete_statement6088_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_static_returning_clause_in_delete_statement6091_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_static_returning_clause_in_delete_statement6091( FOLLOW_static_returning_clause_in_delete_statement6091_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_error_logging_clause_in_delete_statement6094_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_error_logging_clause_in_delete_statement6094( FOLLOW_error_logging_clause_in_delete_statement6094_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_insert_key_in_insert_statement6115_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x0000004000000002), ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_insert_key_in_insert_statement6115( FOLLOW_insert_key_in_insert_statement6115_bits, 9 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_single_table_insert_in_insert_statement6127_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_single_table_insert_in_insert_statement6127( FOLLOW_single_table_insert_in_insert_statement6127_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_multi_table_insert_in_insert_statement6138_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_multi_table_insert_in_insert_statement6138( FOLLOW_multi_table_insert_in_insert_statement6138_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_insert_into_clause_in_single_table_insert6166_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x8020000000000000), ANTLR_UINT64_LIT(0x0000000000000008) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_insert_into_clause_in_single_table_insert6166( FOLLOW_insert_into_clause_in_single_table_insert6166_bits, 9 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_values_clause_in_single_table_insert6177_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_values_clause_in_single_table_insert6177( FOLLOW_values_clause_in_single_table_insert6177_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_static_returning_clause_in_single_table_insert6179_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_static_returning_clause_in_single_table_insert6179( FOLLOW_static_returning_clause_in_single_table_insert6179_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_select_statement_in_single_table_insert6191_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_select_statement_in_single_table_insert6191( FOLLOW_select_statement_in_single_table_insert6191_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_error_logging_clause_in_single_table_insert6207_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_error_logging_clause_in_single_table_insert6207( FOLLOW_error_logging_clause_in_single_table_insert6207_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_all_key_in_multi_table_insert6266_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000004000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_all_key_in_multi_table_insert6266( FOLLOW_all_key_in_multi_table_insert6266_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_multi_table_element_in_multi_table_insert6268_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0020004000000000), ANTLR_UINT64_LIT(0x0000000000000008) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_multi_table_element_in_multi_table_insert6268( FOLLOW_multi_table_element_in_multi_table_insert6268_bits, 9 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_conditional_insert_clause_in_multi_table_insert6280_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0020000000000000), ANTLR_UINT64_LIT(0x0000000000000008) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_conditional_insert_clause_in_multi_table_insert6280( FOLLOW_conditional_insert_clause_in_multi_table_insert6280_bits, 9 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_select_statement_in_multi_table_insert6296_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_select_statement_in_multi_table_insert6296( FOLLOW_select_statement_in_multi_table_insert6296_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_insert_into_clause_in_multi_table_element6338_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x8000000000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_insert_into_clause_in_multi_table_element6338( FOLLOW_insert_into_clause_in_multi_table_element6338_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_values_clause_in_multi_table_element6340_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_values_clause_in_multi_table_element6340( FOLLOW_values_clause_in_multi_table_element6340_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_error_logging_clause_in_multi_table_element6343_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_error_logging_clause_in_multi_table_element6343( FOLLOW_error_logging_clause_in_multi_table_element6343_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_all_key_in_conditional_insert_clause6387_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_all_key_in_conditional_insert_clause6387( FOLLOW_all_key_in_conditional_insert_clause6387_bits, 9 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_first_key_in_conditional_insert_clause6389_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_first_key_in_conditional_insert_clause6389( FOLLOW_first_key_in_conditional_insert_clause6389_bits, 9 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_conditional_insert_when_part_in_conditional_insert_clause6401_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000800000), ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_conditional_insert_when_part_in_conditional_insert_clause6401( FOLLOW_conditional_insert_when_part_in_conditional_insert_clause6401_bits, 9 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_conditional_insert_else_part_in_conditional_insert_clause6404_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_conditional_insert_else_part_in_conditional_insert_clause6404( FOLLOW_conditional_insert_else_part_in_conditional_insert_clause6404_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_when_key_in_conditional_insert_when_part6452_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_when_key_in_conditional_insert_when_part6452( FOLLOW_when_key_in_conditional_insert_when_part6452_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_condition_in_conditional_insert_when_part6454_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0200000000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_condition_in_conditional_insert_when_part6454( FOLLOW_condition_in_conditional_insert_when_part6454_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_then_key_in_conditional_insert_when_part6456_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000004000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_then_key_in_conditional_insert_when_part6456( FOLLOW_then_key_in_conditional_insert_when_part6456_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_multi_table_element_in_conditional_insert_when_part6458_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000004000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_multi_table_element_in_conditional_insert_when_part6458( FOLLOW_multi_table_element_in_conditional_insert_when_part6458_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_else_key_in_conditional_insert_else_part6502_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000004000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_else_key_in_conditional_insert_else_part6502( FOLLOW_else_key_in_conditional_insert_else_part6502_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_multi_table_element_in_conditional_insert_else_part6505_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000004000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_multi_table_element_in_conditional_insert_else_part6505( FOLLOW_multi_table_element_in_conditional_insert_else_part6505_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_into_key_in_insert_into_clause6526_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000004), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x0180000000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_into_key_in_insert_into_clause6526( FOLLOW_into_key_in_insert_into_clause6526_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_general_table_ref_in_insert_into_clause6528_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_general_table_ref_in_insert_into_clause6528( FOLLOW_general_table_ref_in_insert_into_clause6528_bits, 4 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_insert_into_clause6540_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_insert_into_clause6540( FOLLOW_LEFT_PAREN_in_insert_into_clause6540_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_column_name_in_insert_into_clause6542_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_column_name_in_insert_into_clause6542( FOLLOW_column_name_in_insert_into_clause6542_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_insert_into_clause6545_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_COMMA_in_insert_into_clause6545( FOLLOW_COMMA_in_insert_into_clause6545_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_column_name_in_insert_into_clause6547_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_column_name_in_insert_into_clause6547( FOLLOW_column_name_in_insert_into_clause6547_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_insert_into_clause6551_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_insert_into_clause6551( FOLLOW_RIGHT_PAREN_in_insert_into_clause6551_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_values_key_in_values_clause6596_bits[]	= { ANTLR_UINT64_LIT(0x0000000400000000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000004), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_values_key_in_values_clause6596( FOLLOW_values_key_in_values_clause6596_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_expression_list_in_values_clause6600_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_expression_list_in_values_clause6600( FOLLOW_expression_list_in_values_clause6600_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_record_name_in_values_clause6604_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_record_name_in_values_clause6604( FOLLOW_record_name_in_values_clause6604_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_merge_key_in_merge_statement6626_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000004000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_merge_key_in_merge_statement6626( FOLLOW_merge_key_in_merge_statement6626_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_into_key_in_merge_statement6628_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_into_key_in_merge_statement6628( FOLLOW_into_key_in_merge_statement6628_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_tableview_name_in_merge_statement6630_bits[]	= { ANTLR_UINT64_LIT(0x0180000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_tableview_name_in_merge_statement6630( FOLLOW_tableview_name_in_merge_statement6630_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_table_alias_in_merge_statement6632_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000008000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_table_alias_in_merge_statement6632( FOLLOW_table_alias_in_merge_statement6632_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_using_key_in_merge_statement6643_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000004), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_using_key_in_merge_statement6643( FOLLOW_using_key_in_merge_statement6643_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_selected_tableview_in_merge_statement6645_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000100000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_selected_tableview_in_merge_statement6645( FOLLOW_selected_tableview_in_merge_statement6645_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_on_key_in_merge_statement6647_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_on_key_in_merge_statement6647( FOLLOW_on_key_in_merge_statement6647_bits, 4 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_merge_statement6649_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_merge_statement6649( FOLLOW_LEFT_PAREN_in_merge_statement6649_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_condition_in_merge_statement6651_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_condition_in_merge_statement6651( FOLLOW_condition_in_merge_statement6651_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_merge_statement6653_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_merge_statement6653( FOLLOW_RIGHT_PAREN_in_merge_statement6653_bits, 9 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_merge_update_insert_seq_in_merge_statement6685_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_merge_update_insert_seq_in_merge_statement6685( FOLLOW_merge_update_insert_seq_in_merge_statement6685_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_merge_insert_update_seq_in_merge_statement6719_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_merge_insert_update_seq_in_merge_statement6719( FOLLOW_merge_insert_update_seq_in_merge_statement6719_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_error_logging_clause_in_merge_statement6740_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_error_logging_clause_in_merge_statement6740( FOLLOW_error_logging_clause_in_merge_statement6740_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_merge_update_clause_in_merge_update_insert_seq6823_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_merge_update_clause_in_merge_update_insert_seq6823( FOLLOW_merge_update_clause_in_merge_update_insert_seq6823_bits, 9 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_merge_insert_clause_in_merge_update_insert_seq6825_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_merge_insert_clause_in_merge_update_insert_seq6825( FOLLOW_merge_insert_clause_in_merge_update_insert_seq6825_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_merge_insert_clause_in_merge_insert_update_seq6843_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_merge_insert_clause_in_merge_insert_update_seq6843( FOLLOW_merge_insert_clause_in_merge_insert_update_seq6843_bits, 9 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_merge_update_clause_in_merge_insert_update_seq6845_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_merge_update_clause_in_merge_insert_update_seq6845( FOLLOW_merge_update_clause_in_merge_insert_update_seq6845_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_when_key_in_merge_update_clause6866_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_when_key_in_merge_update_clause6866( FOLLOW_when_key_in_merge_update_clause6866_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_matched_key_in_merge_update_clause6868_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0200000000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_matched_key_in_merge_update_clause6868( FOLLOW_matched_key_in_merge_update_clause6868_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_then_key_in_merge_update_clause6870_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x4000000000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_then_key_in_merge_update_clause6870( FOLLOW_then_key_in_merge_update_clause6870_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_update_key_in_merge_update_clause6872_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_update_key_in_merge_update_clause6872( FOLLOW_update_key_in_merge_update_clause6872_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_set_key_in_merge_update_clause6874_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_set_key_in_merge_update_clause6874( FOLLOW_set_key_in_merge_update_clause6874_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_merge_element_in_merge_update_clause6885_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000080000), ANTLR_UINT64_LIT(0x0000000000000004) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_merge_element_in_merge_update_clause6885( FOLLOW_merge_element_in_merge_update_clause6885_bits, 9 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_merge_update_clause6888_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_COMMA_in_merge_update_clause6888( FOLLOW_COMMA_in_merge_update_clause6888_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_merge_element_in_merge_update_clause6890_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000080000), ANTLR_UINT64_LIT(0x0000000000000004) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_merge_element_in_merge_update_clause6890( FOLLOW_merge_element_in_merge_update_clause6890_bits, 9 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_where_clause_in_merge_update_clause6902_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000080000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_where_clause_in_merge_update_clause6902( FOLLOW_where_clause_in_merge_update_clause6902_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_merge_update_delete_part_in_merge_update_clause6905_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_merge_update_delete_part_in_merge_update_clause6905( FOLLOW_merge_update_delete_part_in_merge_update_clause6905_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_column_name_in_merge_element6957_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_column_name_in_merge_element6957( FOLLOW_column_name_in_merge_element6957_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_EQUALS_OP_in_merge_element6959_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_EQUALS_OP_in_merge_element6959( FOLLOW_EQUALS_OP_in_merge_element6959_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_expression_in_merge_element6961_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_expression_in_merge_element6961( FOLLOW_expression_in_merge_element6961_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_delete_key_in_merge_update_delete_part7004_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_delete_key_in_merge_update_delete_part7004( FOLLOW_delete_key_in_merge_update_delete_part7004_bits, 9 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_where_clause_in_merge_update_delete_part7007_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_where_clause_in_merge_update_delete_part7007( FOLLOW_where_clause_in_merge_update_delete_part7007_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_when_key_in_merge_insert_clause7027_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_when_key_in_merge_insert_clause7027( FOLLOW_when_key_in_merge_insert_clause7027_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_not_key_in_merge_insert_clause7029_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_not_key_in_merge_insert_clause7029( FOLLOW_not_key_in_merge_insert_clause7029_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_matched_key_in_merge_insert_clause7031_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0200000000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_matched_key_in_merge_insert_clause7031( FOLLOW_matched_key_in_merge_insert_clause7031_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_then_key_in_merge_insert_clause7033_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000001000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_then_key_in_merge_insert_clause7033( FOLLOW_then_key_in_merge_insert_clause7033_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_insert_key_in_merge_insert_clause7035_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x8000000000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_insert_key_in_merge_insert_clause7035( FOLLOW_insert_key_in_merge_insert_clause7035_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_merge_insert_clause7047_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_merge_insert_clause7047( FOLLOW_LEFT_PAREN_in_merge_insert_clause7047_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_column_name_in_merge_insert_clause7049_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_column_name_in_merge_insert_clause7049( FOLLOW_column_name_in_merge_insert_clause7049_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_merge_insert_clause7052_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_COMMA_in_merge_insert_clause7052( FOLLOW_COMMA_in_merge_insert_clause7052_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_column_name_in_merge_insert_clause7054_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_column_name_in_merge_insert_clause7054( FOLLOW_column_name_in_merge_insert_clause7054_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_merge_insert_clause7058_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x8000000000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_merge_insert_clause7058( FOLLOW_RIGHT_PAREN_in_merge_insert_clause7058_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_values_key_in_merge_insert_clause7070_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_values_key_in_merge_insert_clause7070( FOLLOW_values_key_in_merge_insert_clause7070_bits, 4 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_expression_list_in_merge_insert_clause7072_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_expression_list_in_merge_insert_clause7072( FOLLOW_expression_list_in_merge_insert_clause7072_bits, 9 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_where_clause_in_merge_insert_clause7074_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_where_clause_in_merge_insert_clause7074( FOLLOW_where_clause_in_merge_insert_clause7074_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_tableview_name_in_selected_tableview7135_bits[]	= { ANTLR_UINT64_LIT(0x0180000000000002), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_tableview_name_in_selected_tableview7135( FOLLOW_tableview_name_in_selected_tableview7135_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_selected_tableview7139_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0020000000000000), ANTLR_UINT64_LIT(0x0000000000000008) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_selected_tableview7139( FOLLOW_LEFT_PAREN_in_selected_tableview7139_bits, 9 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_select_statement_in_selected_tableview7141_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_select_statement_in_selected_tableview7141( FOLLOW_select_statement_in_selected_tableview7141_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_selected_tableview7143_bits[]	= { ANTLR_UINT64_LIT(0x0180000000000002), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_selected_tableview7143( FOLLOW_RIGHT_PAREN_in_selected_tableview7143_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_table_alias_in_selected_tableview7146_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_table_alias_in_selected_tableview7146( FOLLOW_table_alias_in_selected_tableview7146_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_lock_key_in_lock_table_statement7192_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0080000000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_lock_key_in_lock_table_statement7192( FOLLOW_lock_key_in_lock_table_statement7192_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_table_key_in_lock_table_statement7194_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_table_key_in_lock_table_statement7194( FOLLOW_table_key_in_lock_table_statement7194_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_lock_table_element_in_lock_table_statement7205_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000800000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_lock_table_element_in_lock_table_statement7205( FOLLOW_lock_table_element_in_lock_table_statement7205_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_lock_table_statement7208_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_COMMA_in_lock_table_statement7208( FOLLOW_COMMA_in_lock_table_statement7208_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_lock_table_element_in_lock_table_statement7210_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000800000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_lock_table_element_in_lock_table_statement7210( FOLLOW_lock_table_element_in_lock_table_statement7210_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_in_key_in_lock_table_statement7223_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040080000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_in_key_in_lock_table_statement7223( FOLLOW_in_key_in_lock_table_statement7223_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_lock_mode_in_lock_table_statement7225_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000004000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_lock_mode_in_lock_table_statement7225( FOLLOW_lock_mode_in_lock_table_statement7225_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_mode_key_in_lock_table_statement7227_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000010000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_mode_key_in_lock_table_statement7227( FOLLOW_mode_key_in_lock_table_statement7227_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_wait_nowait_part_in_lock_table_statement7229_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_wait_nowait_part_in_lock_table_statement7229( FOLLOW_wait_nowait_part_in_lock_table_statement7229_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_wait_key_in_wait_nowait_part7272_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_wait_key_in_wait_nowait_part7272( FOLLOW_wait_key_in_wait_nowait_part7272_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_expression_in_wait_nowait_part7274_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_expression_in_wait_nowait_part7274( FOLLOW_expression_in_wait_nowait_part7274_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_nowait_key_in_wait_nowait_part7297_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_nowait_key_in_wait_nowait_part7297( FOLLOW_nowait_key_in_wait_nowait_part7297_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_tableview_name_in_lock_table_element7319_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_tableview_name_in_lock_table_element7319( FOLLOW_tableview_name_in_lock_table_element7319_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_partition_extension_clause_in_lock_table_element7321_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_partition_extension_clause_in_lock_table_element7321( FOLLOW_partition_extension_clause_in_lock_table_element7321_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_row_key_in_lock_mode7361_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_row_key_in_lock_mode7361( FOLLOW_row_key_in_lock_mode7361_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_share_key_in_lock_mode7363_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_share_key_in_lock_mode7363( FOLLOW_share_key_in_lock_mode7363_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_row_key_in_lock_mode7374_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000080000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_row_key_in_lock_mode7374( FOLLOW_row_key_in_lock_mode7374_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_exclusive_key_in_lock_mode7376_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_exclusive_key_in_lock_mode7376( FOLLOW_exclusive_key_in_lock_mode7376_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_share_key_in_lock_mode7387_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x4000000000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_share_key_in_lock_mode7387( FOLLOW_share_key_in_lock_mode7387_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_update_key_in_lock_mode7389_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_update_key_in_lock_mode7389( FOLLOW_update_key_in_lock_mode7389_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_share_key_in_lock_mode7401_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_share_key_in_lock_mode7401( FOLLOW_share_key_in_lock_mode7401_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_row_key_in_lock_mode7403_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000080000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_row_key_in_lock_mode7403( FOLLOW_row_key_in_lock_mode7403_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_exclusive_key_in_lock_mode7405_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_exclusive_key_in_lock_mode7405( FOLLOW_exclusive_key_in_lock_mode7405_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_exclusive_key_in_lock_mode7416_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_exclusive_key_in_lock_mode7416( FOLLOW_exclusive_key_in_lock_mode7416_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_dml_table_expression_clause_in_general_table_ref7444_bits[]	= { ANTLR_UINT64_LIT(0x0180000000000002), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_dml_table_expression_clause_in_general_table_ref7444( FOLLOW_dml_table_expression_clause_in_general_table_ref7444_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_only_key_in_general_table_ref7459_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_only_key_in_general_table_ref7459( FOLLOW_only_key_in_general_table_ref7459_bits, 4 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_general_table_ref7461_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000004), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x0180000000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_general_table_ref7461( FOLLOW_LEFT_PAREN_in_general_table_ref7461_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_dml_table_expression_clause_in_general_table_ref7463_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_dml_table_expression_clause_in_general_table_ref7463( FOLLOW_dml_table_expression_clause_in_general_table_ref7463_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_general_table_ref7465_bits[]	= { ANTLR_UINT64_LIT(0x0180000000000002), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_general_table_ref7465( FOLLOW_RIGHT_PAREN_in_general_table_ref7465_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_table_alias_in_general_table_ref7480_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_table_alias_in_general_table_ref7480( FOLLOW_table_alias_in_general_table_ref7480_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_returning_key_in_static_returning_clause7524_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_returning_key_in_static_returning_clause7524( FOLLOW_returning_key_in_static_returning_clause7524_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_return_key_in_static_returning_clause7526_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_return_key_in_static_returning_clause7526( FOLLOW_return_key_in_static_returning_clause7526_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_expression_in_static_returning_clause7529_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x0000004000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_expression_in_static_returning_clause7529( FOLLOW_expression_in_static_returning_clause7529_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_static_returning_clause7532_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_COMMA_in_static_returning_clause7532( FOLLOW_COMMA_in_static_returning_clause7532_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_expression_in_static_returning_clause7534_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x0000004000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_expression_in_static_returning_clause7534( FOLLOW_expression_in_static_returning_clause7534_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_into_clause_in_static_returning_clause7547_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_into_clause_in_static_returning_clause7547( FOLLOW_into_clause_in_static_returning_clause7547_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_log_key_in_error_logging_clause7590_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_log_key_in_error_logging_clause7590( FOLLOW_log_key_in_error_logging_clause7590_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_errors_key_in_error_logging_clause7592_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002002), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206400C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_errors_key_in_error_logging_clause7592( FOLLOW_errors_key_in_error_logging_clause7592_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_error_logging_into_part_in_error_logging_clause7603_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002002), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_error_logging_into_part_in_error_logging_clause7603( FOLLOW_error_logging_into_part_in_error_logging_clause7603_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_expression_wrapper_in_error_logging_clause7620_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_expression_wrapper_in_error_logging_clause7620( FOLLOW_expression_wrapper_in_error_logging_clause7620_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_error_logging_reject_part_in_error_logging_clause7632_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_error_logging_reject_part_in_error_logging_clause7632( FOLLOW_error_logging_reject_part_in_error_logging_clause7632_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_into_key_in_error_logging_into_part7676_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_into_key_in_error_logging_into_part7676( FOLLOW_into_key_in_error_logging_into_part7676_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_tableview_name_in_error_logging_into_part7679_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_tableview_name_in_error_logging_into_part7679( FOLLOW_tableview_name_in_error_logging_into_part7679_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_reject_key_in_error_logging_reject_part7699_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_reject_key_in_error_logging_reject_part7699( FOLLOW_reject_key_in_error_logging_reject_part7699_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_limit_key_in_error_logging_reject_part7702_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_limit_key_in_error_logging_reject_part7702( FOLLOW_limit_key_in_error_logging_reject_part7702_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_unlimited_key_in_error_logging_reject_part7710_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_unlimited_key_in_error_logging_reject_part7710( FOLLOW_unlimited_key_in_error_logging_reject_part7710_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_expression_wrapper_in_error_logging_reject_part7712_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_expression_wrapper_in_error_logging_reject_part7712( FOLLOW_expression_wrapper_in_error_logging_reject_part7712_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_table_collection_expression_in_dml_table_expression_clause7733_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_table_collection_expression_in_dml_table_expression_clause7733( FOLLOW_table_collection_expression_in_dml_table_expression_clause7733_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_dml_table_expression_clause7756_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0020000000000000), ANTLR_UINT64_LIT(0x0000000000000008) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_dml_table_expression_clause7756( FOLLOW_LEFT_PAREN_in_dml_table_expression_clause7756_bits, 9 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_select_statement_in_dml_table_expression_clause7758_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000008) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_select_statement_in_dml_table_expression_clause7758( FOLLOW_select_statement_in_dml_table_expression_clause7758_bits, 9 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_subquery_restriction_clause_in_dml_table_expression_clause7760_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_subquery_restriction_clause_in_dml_table_expression_clause7760( FOLLOW_subquery_restriction_clause_in_dml_table_expression_clause7760_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_dml_table_expression_clause7763_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_dml_table_expression_clause7763( FOLLOW_RIGHT_PAREN_in_dml_table_expression_clause7763_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_tableview_name_in_dml_table_expression_clause7805_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_tableview_name_in_dml_table_expression_clause7805( FOLLOW_tableview_name_in_dml_table_expression_clause7805_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_sample_clause_in_dml_table_expression_clause7807_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_sample_clause_in_dml_table_expression_clause7807( FOLLOW_sample_clause_in_dml_table_expression_clause7807_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_table_key_in_table_collection_expression7845_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_table_key_in_table_collection_expression7845( FOLLOW_table_key_in_table_collection_expression7845_bits, 4 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_the_key_in_table_collection_expression7849_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_the_key_in_table_collection_expression7849( FOLLOW_the_key_in_table_collection_expression7849_bits, 4 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_table_collection_expression7877_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0020000000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_table_collection_expression7877( FOLLOW_LEFT_PAREN_in_table_collection_expression7877_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_subquery_in_table_collection_expression7879_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_subquery_in_table_collection_expression7879( FOLLOW_subquery_in_table_collection_expression7879_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_table_collection_expression7881_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_table_collection_expression7881( FOLLOW_RIGHT_PAREN_in_table_collection_expression7881_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_table_collection_expression7894_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_table_collection_expression7894( FOLLOW_LEFT_PAREN_in_table_collection_expression7894_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_expression_in_table_collection_expression7896_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_expression_in_table_collection_expression7896( FOLLOW_expression_in_table_collection_expression7896_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_table_collection_expression7898_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_table_collection_expression7898( FOLLOW_RIGHT_PAREN_in_table_collection_expression7898_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_with_key_in_subquery_restriction_clause7951_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x0000000000000800) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_with_key_in_subquery_restriction_clause7951( FOLLOW_with_key_in_subquery_restriction_clause7951_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_read_key_in_subquery_restriction_clause7962_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_read_key_in_subquery_restriction_clause7962( FOLLOW_read_key_in_subquery_restriction_clause7962_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_only_key_in_subquery_restriction_clause7964_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_only_key_in_subquery_restriction_clause7964( FOLLOW_only_key_in_subquery_restriction_clause7964_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_check_key_in_subquery_restriction_clause7975_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000200000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_check_key_in_subquery_restriction_clause7975( FOLLOW_check_key_in_subquery_restriction_clause7975_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_option_key_in_subquery_restriction_clause7977_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_option_key_in_subquery_restriction_clause7977( FOLLOW_option_key_in_subquery_restriction_clause7977_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_constraint_key_in_subquery_restriction_clause7980_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_constraint_key_in_subquery_restriction_clause7980( FOLLOW_constraint_key_in_subquery_restriction_clause7980_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_constraint_name_in_subquery_restriction_clause7982_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_constraint_name_in_subquery_restriction_clause7982( FOLLOW_constraint_name_in_subquery_restriction_clause7982_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_sample_key_in_sample_clause8033_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_sample_key_in_sample_clause8033( FOLLOW_sample_key_in_sample_clause8033_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_block_key_in_sample_clause8035_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_block_key_in_sample_clause8035( FOLLOW_block_key_in_sample_clause8035_bits, 4 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_sample_clause8047_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_sample_clause8047( FOLLOW_LEFT_PAREN_in_sample_clause8047_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_expression_in_sample_clause8051_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_expression_in_sample_clause8051( FOLLOW_expression_in_sample_clause8051_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_sample_clause8054_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_COMMA_in_sample_clause8054( FOLLOW_COMMA_in_sample_clause8054_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_expression_in_sample_clause8058_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_expression_in_sample_clause8058( FOLLOW_expression_in_sample_clause8058_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_sample_clause8062_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_sample_clause8062( FOLLOW_RIGHT_PAREN_in_sample_clause8062_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_seed_part_in_sample_clause8072_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_seed_part_in_sample_clause8072( FOLLOW_seed_part_in_sample_clause8072_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_seed_key_in_seed_part8128_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_seed_key_in_seed_part8128( FOLLOW_seed_key_in_seed_part8128_bits, 4 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_seed_part8130_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_seed_part8130( FOLLOW_LEFT_PAREN_in_seed_part8130_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_expression_in_seed_part8132_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_expression_in_seed_part8132( FOLLOW_expression_in_seed_part8132_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_seed_part8134_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_seed_part8134( FOLLOW_RIGHT_PAREN_in_seed_part8134_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_cursor_key_in_cursor_expression8181_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_cursor_key_in_cursor_expression8181( FOLLOW_cursor_key_in_cursor_expression8181_bits, 4 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_cursor_expression8183_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0020000000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_cursor_expression8183( FOLLOW_LEFT_PAREN_in_cursor_expression8183_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_subquery_in_cursor_expression8185_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_subquery_in_cursor_expression8185( FOLLOW_subquery_in_cursor_expression8185_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_cursor_expression8187_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_cursor_expression8187( FOLLOW_RIGHT_PAREN_in_cursor_expression8187_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_expression_list8207_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000012), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000001001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_expression_list8207( FOLLOW_LEFT_PAREN_in_expression_list8207_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_expression_in_expression_list8209_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_expression_in_expression_list8209( FOLLOW_expression_in_expression_list8209_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_expression_list8213_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_COMMA_in_expression_list8213( FOLLOW_COMMA_in_expression_list8213_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_expression_in_expression_list8215_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_expression_in_expression_list8215( FOLLOW_expression_in_expression_list8215_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_expression_list8219_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_expression_list8219( FOLLOW_RIGHT_PAREN_in_expression_list8219_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_expression_in_condition8264_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_expression_in_condition8264( FOLLOW_expression_in_condition8264_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_expression_in_condition_wrapper8284_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_expression_in_condition_wrapper8284( FOLLOW_expression_in_condition_wrapper8284_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_or_key_in_logical_or_expression_seq8318_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C250412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_or_key_in_logical_or_expression_seq8318( FOLLOW_or_key_in_logical_or_expression_seq8318_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_logical_and_expression_in_logical_or_expression_seq8321_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_logical_and_expression_in_logical_or_expression_seq8321( FOLLOW_logical_and_expression_in_logical_or_expression_seq8321_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_cursor_expression_in_expression8364_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_cursor_expression_in_expression8364( FOLLOW_cursor_expression_in_expression8364_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_logical_and_expression_in_expression8379_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000400000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_logical_and_expression_in_expression8379( FOLLOW_logical_and_expression_in_expression8379_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_logical_or_expression_seq_in_expression8383_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000400000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_logical_or_expression_seq_in_expression8383( FOLLOW_logical_or_expression_seq_in_expression8383_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_expression_in_expression_wrapper8441_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_expression_in_expression_wrapper8441( FOLLOW_expression_in_expression_wrapper8441_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_and_key_in_logical_and_expression_seq8478_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C250412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_and_key_in_logical_and_expression_seq8478( FOLLOW_and_key_in_logical_and_expression_seq8478_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_negated_expression_in_logical_and_expression_seq8481_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_negated_expression_in_logical_and_expression_seq8481( FOLLOW_negated_expression_in_logical_and_expression_seq8481_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_negated_expression_in_logical_and_expression8510_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000008) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_negated_expression_in_logical_and_expression8510( FOLLOW_negated_expression_in_logical_and_expression8510_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_logical_and_expression_seq_in_logical_and_expression8513_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000008) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_logical_and_expression_seq_in_logical_and_expression8513( FOLLOW_logical_and_expression_seq_in_logical_and_expression8513_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_not_key_in_negated_expression8573_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C250412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_not_key_in_negated_expression8573( FOLLOW_not_key_in_negated_expression8573_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_negated_expression_in_negated_expression8576_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_negated_expression_in_negated_expression8576( FOLLOW_negated_expression_in_negated_expression8576_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_equality_expression_in_negated_expression8587_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_equality_expression_in_negated_expression8587( FOLLOW_equality_expression_in_negated_expression8587_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_multiset_comparsion_in_equality_expression8616_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000008000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_multiset_comparsion_in_equality_expression8616( FOLLOW_multiset_comparsion_in_equality_expression8616_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_is_key_in_equality_expression8632_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x00000E0000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_is_key_in_equality_expression8632( FOLLOW_is_key_in_equality_expression8632_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_not_key_in_equality_expression8635_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x00000C0000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_not_key_in_equality_expression8635( FOLLOW_not_key_in_equality_expression8635_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_null_key_in_equality_expression8654_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_null_key_in_equality_expression8654( FOLLOW_null_key_in_equality_expression8654_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_nan_key_in_equality_expression8721_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_nan_key_in_equality_expression8721( FOLLOW_nan_key_in_equality_expression8721_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_present_key_in_equality_expression8788_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_present_key_in_equality_expression8788( FOLLOW_present_key_in_equality_expression8788_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_infinite_key_in_equality_expression8855_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_infinite_key_in_equality_expression8855( FOLLOW_infinite_key_in_equality_expression8855_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_a_key_in_equality_expression8922_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_a_key_in_equality_expression8922( FOLLOW_a_key_in_equality_expression8922_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_set_key_in_equality_expression8924_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_set_key_in_equality_expression8924( FOLLOW_set_key_in_equality_expression8924_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_empty_key_in_equality_expression8991_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_empty_key_in_equality_expression8991( FOLLOW_empty_key_in_equality_expression8991_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_of_key_in_equality_expression9058_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_of_key_in_equality_expression9058( FOLLOW_of_key_in_equality_expression9058_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_type_key_in_equality_expression9060_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_type_key_in_equality_expression9060( FOLLOW_type_key_in_equality_expression9060_bits, 4 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_equality_expression9063_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x0000000000010000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_equality_expression9063( FOLLOW_LEFT_PAREN_in_equality_expression9063_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_only_key_in_equality_expression9065_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x0000000000010000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_only_key_in_equality_expression9065( FOLLOW_only_key_in_equality_expression9065_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_type_spec_in_equality_expression9068_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_type_spec_in_equality_expression9068( FOLLOW_type_spec_in_equality_expression9068_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_equality_expression9071_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x0000000000010000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_COMMA_in_equality_expression9071( FOLLOW_COMMA_in_equality_expression9071_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_type_spec_in_equality_expression9073_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_type_spec_in_equality_expression9073( FOLLOW_type_spec_in_equality_expression9073_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_equality_expression9077_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_equality_expression9077( FOLLOW_RIGHT_PAREN_in_equality_expression9077_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_relational_expression_in_multiset_comparsion9174_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_relational_expression_in_multiset_comparsion9174( FOLLOW_relational_expression_in_multiset_comparsion9174_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_multiset_type_in_multiset_comparsion9190_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x08020C000C250412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_multiset_type_in_multiset_comparsion9190( FOLLOW_multiset_type_in_multiset_comparsion9190_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_of_key_in_multiset_comparsion9192_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080204000C250412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_of_key_in_multiset_comparsion9192( FOLLOW_of_key_in_multiset_comparsion9192_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_concatenation_in_multiset_comparsion9195_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_concatenation_in_multiset_comparsion9195( FOLLOW_concatenation_in_multiset_comparsion9195_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_member_key_in_multiset_type9240_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_member_key_in_multiset_type9240( FOLLOW_member_key_in_multiset_type9240_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_submultiset_key_in_multiset_type9251_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_submultiset_key_in_multiset_type9251( FOLLOW_submultiset_key_in_multiset_type9251_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_compound_expression_in_relational_expression9271_bits[]	= { ANTLR_UINT64_LIT(0x0001000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000003000000410), ANTLR_UINT64_LIT(0x0000000300000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_compound_expression_in_relational_expression9271( FOLLOW_compound_expression_in_relational_expression9271_bits, 5 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_EQUALS_OP_in_relational_expression9281_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080204000C250412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_EQUALS_OP_in_relational_expression9281( FOLLOW_EQUALS_OP_in_relational_expression9281_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_not_equal_op_in_relational_expression9286_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080204000C250412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_not_equal_op_in_relational_expression9286( FOLLOW_not_equal_op_in_relational_expression9286_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LESS_THAN_OP_in_relational_expression9291_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080204000C250412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LESS_THAN_OP_in_relational_expression9291( FOLLOW_LESS_THAN_OP_in_relational_expression9291_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_GREATER_THAN_OP_in_relational_expression9296_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080204000C250412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_GREATER_THAN_OP_in_relational_expression9296( FOLLOW_GREATER_THAN_OP_in_relational_expression9296_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_less_than_or_equals_op_in_relational_expression9301_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080204000C250412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_less_than_or_equals_op_in_relational_expression9301( FOLLOW_less_than_or_equals_op_in_relational_expression9301_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_greater_than_or_equals_op_in_relational_expression9306_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080204000C250412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_greater_than_or_equals_op_in_relational_expression9306( FOLLOW_greater_than_or_equals_op_in_relational_expression9306_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_compound_expression_in_relational_expression9311_bits[]	= { ANTLR_UINT64_LIT(0x0001000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000003000000410), ANTLR_UINT64_LIT(0x0000000300000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_compound_expression_in_relational_expression9311( FOLLOW_compound_expression_in_relational_expression9311_bits, 5 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_concatenation_in_compound_expression9342_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x0000030800000100) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_concatenation_in_compound_expression9342( FOLLOW_concatenation_in_compound_expression9342_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_not_key_in_compound_expression9359_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x0000010800000100) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_not_key_in_compound_expression9359( FOLLOW_not_key_in_compound_expression9359_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_in_key_in_compound_expression9379_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x0800040008050000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_in_key_in_compound_expression9379( FOLLOW_in_key_in_compound_expression9379_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_in_elements_in_compound_expression9381_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_in_elements_in_compound_expression9381( FOLLOW_in_elements_in_compound_expression9381_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_between_key_in_compound_expression9452_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080204000C250412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_between_key_in_compound_expression9452( FOLLOW_between_key_in_compound_expression9452_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_between_elements_in_compound_expression9454_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_between_elements_in_compound_expression9454( FOLLOW_between_elements_in_compound_expression9454_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_like_type_in_compound_expression9525_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080204000C250412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_like_type_in_compound_expression9525( FOLLOW_like_type_in_compound_expression9525_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_concatenation_in_compound_expression9527_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_concatenation_in_compound_expression9527( FOLLOW_concatenation_in_compound_expression9527_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_like_escape_part_in_compound_expression9529_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_like_escape_part_in_compound_expression9529( FOLLOW_like_escape_part_in_compound_expression9529_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_like_key_in_like_type9638_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_like_key_in_like_type9638( FOLLOW_like_key_in_like_type9638_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_likec_key_in_like_type9649_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_likec_key_in_like_type9649( FOLLOW_likec_key_in_like_type9649_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_like2_key_in_like_type9660_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_like2_key_in_like_type9660( FOLLOW_like2_key_in_like_type9660_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_like4_key_in_like_type9671_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_like4_key_in_like_type9671( FOLLOW_like4_key_in_like_type9671_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_escape_key_in_like_escape_part9691_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080204000C250412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_escape_key_in_like_escape_part9691( FOLLOW_escape_key_in_like_escape_part9691_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_concatenation_in_like_escape_part9693_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_concatenation_in_like_escape_part9693( FOLLOW_concatenation_in_like_escape_part9693_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_in_elements9751_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0020000000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_in_elements9751( FOLLOW_LEFT_PAREN_in_in_elements9751_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_subquery_in_in_elements9753_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_subquery_in_in_elements9753( FOLLOW_subquery_in_in_elements9753_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_in_elements9755_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_in_elements9755( FOLLOW_RIGHT_PAREN_in_in_elements9755_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_in_elements9786_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080204000C250412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_in_elements9786( FOLLOW_LEFT_PAREN_in_in_elements9786_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_in_elements9788_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_in_elements9788( FOLLOW_concatenation_wrapper_in_in_elements9788_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_in_elements9791_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080204000C250412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_COMMA_in_in_elements9791( FOLLOW_COMMA_in_in_elements9791_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_in_elements9793_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_in_elements9793( FOLLOW_concatenation_wrapper_in_in_elements9793_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_in_elements9797_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_in_elements9797( FOLLOW_RIGHT_PAREN_in_in_elements9797_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_constant_in_in_elements9829_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_constant_in_in_elements9829( FOLLOW_constant_in_in_elements9829_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_bind_variable_in_in_elements9857_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_bind_variable_in_in_elements9857( FOLLOW_bind_variable_in_in_elements9857_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_general_element_in_in_elements9885_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_general_element_in_in_elements9885( FOLLOW_general_element_in_in_elements9885_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_concatenation_in_between_elements9924_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000008) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_concatenation_in_between_elements9924( FOLLOW_concatenation_in_between_elements9924_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_and_key_in_between_elements9926_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080204000C250412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_and_key_in_between_elements9926( FOLLOW_and_key_in_between_elements9926_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_concatenation_in_between_elements9930_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_concatenation_in_between_elements9930( FOLLOW_concatenation_in_between_elements9930_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_additive_expression_in_concatenation9983_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000001000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0040000000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_additive_expression_in_concatenation9983( FOLLOW_additive_expression_in_concatenation9983_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_concatenation_seq_in_concatenation9986_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000001000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0040000000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_concatenation_seq_in_concatenation9986( FOLLOW_concatenation_seq_in_concatenation9986_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_concatenation_op_in_concatenation_seq10045_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080204000C250412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_concatenation_op_in_concatenation_seq10045( FOLLOW_concatenation_op_in_concatenation_seq10045_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_additive_expression_in_concatenation_seq10048_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_additive_expression_in_concatenation_seq10048( FOLLOW_additive_expression_in_concatenation_seq10048_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_concatenation_in_concatenation_wrapper10068_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_concatenation_in_concatenation_wrapper10068( FOLLOW_concatenation_in_concatenation_wrapper10068_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_multiply_expression_in_additive_expression10104_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0200000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000800000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_multiply_expression_in_additive_expression10104( FOLLOW_multiply_expression_in_additive_expression10104_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_PLUS_SIGN_in_additive_expression10110_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080204000C250412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_PLUS_SIGN_in_additive_expression10110( FOLLOW_PLUS_SIGN_in_additive_expression10110_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_MINUS_SIGN_in_additive_expression10115_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080204000C250412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_MINUS_SIGN_in_additive_expression10115( FOLLOW_MINUS_SIGN_in_additive_expression10115_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_multiply_expression_in_additive_expression10120_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0200000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000800000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_multiply_expression_in_additive_expression10120( FOLLOW_multiply_expression_in_additive_expression10120_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_datetime_expression_in_multiply_expression10142_bits[]	= { ANTLR_UINT64_LIT(0x0000000000080002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_datetime_expression_in_multiply_expression10142( FOLLOW_datetime_expression_in_multiply_expression10142_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_ASTERISK_in_multiply_expression10148_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080204000C250412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_ASTERISK_in_multiply_expression10148( FOLLOW_ASTERISK_in_multiply_expression10148_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_SOLIDUS_in_multiply_expression10153_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080204000C250412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_SOLIDUS_in_multiply_expression10153( FOLLOW_SOLIDUS_in_multiply_expression10153_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_datetime_expression_in_multiply_expression10158_bits[]	= { ANTLR_UINT64_LIT(0x0000000000080002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_datetime_expression_in_multiply_expression10158( FOLLOW_datetime_expression_in_multiply_expression10158_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_model_expression_in_datetime_expression10181_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_model_expression_in_datetime_expression10181( FOLLOW_model_expression_in_datetime_expression10181_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_at_key_in_datetime_expression10197_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_at_key_in_datetime_expression10197( FOLLOW_at_key_in_datetime_expression10197_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_local_key_in_datetime_expression10200_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_local_key_in_datetime_expression10200( FOLLOW_local_key_in_datetime_expression10200_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_time_key_in_datetime_expression10202_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_time_key_in_datetime_expression10202( FOLLOW_time_key_in_datetime_expression10202_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_zone_key_in_datetime_expression10204_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080204000C250412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_zone_key_in_datetime_expression10204( FOLLOW_zone_key_in_datetime_expression10204_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_datetime_expression10206_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_datetime_expression10206( FOLLOW_concatenation_wrapper_in_datetime_expression10206_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_interval_expression_in_datetime_expression10256_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_interval_expression_in_datetime_expression10256( FOLLOW_interval_expression_in_datetime_expression10256_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_day_key_in_interval_expression10306_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0400000000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_day_key_in_interval_expression10306( FOLLOW_day_key_in_interval_expression10306_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_interval_expression10310_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080204000C250412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_interval_expression10310( FOLLOW_LEFT_PAREN_in_interval_expression10310_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_interval_expression10314_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_interval_expression10314( FOLLOW_concatenation_wrapper_in_interval_expression10314_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_interval_expression10316_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0400000000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_interval_expression10316( FOLLOW_RIGHT_PAREN_in_interval_expression10316_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_to_key_in_interval_expression10320_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_to_key_in_interval_expression10320( FOLLOW_to_key_in_interval_expression10320_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_second_key_in_interval_expression10322_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_second_key_in_interval_expression10322( FOLLOW_second_key_in_interval_expression10322_bits, 4 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_interval_expression10325_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080204000C250412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_interval_expression10325( FOLLOW_LEFT_PAREN_in_interval_expression10325_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_interval_expression10329_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_interval_expression10329( FOLLOW_concatenation_wrapper_in_interval_expression10329_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_interval_expression10331_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_interval_expression10331( FOLLOW_RIGHT_PAREN_in_interval_expression10331_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_year_key_in_interval_expression10370_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0400000000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_year_key_in_interval_expression10370( FOLLOW_year_key_in_interval_expression10370_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_interval_expression10373_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080204000C250412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_interval_expression10373( FOLLOW_LEFT_PAREN_in_interval_expression10373_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_interval_expression10375_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_interval_expression10375( FOLLOW_concatenation_wrapper_in_interval_expression10375_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_interval_expression10377_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0400000000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_interval_expression10377( FOLLOW_RIGHT_PAREN_in_interval_expression10377_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_to_key_in_interval_expression10381_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_to_key_in_interval_expression10381( FOLLOW_to_key_in_interval_expression10381_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_month_key_in_interval_expression10383_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_month_key_in_interval_expression10383( FOLLOW_month_key_in_interval_expression10383_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_multiset_expression_in_model_expression10424_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000020000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_multiset_expression_in_model_expression10424( FOLLOW_multiset_expression_in_model_expression10424_bits, 4 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_BRACKET_in_model_expression10440_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206002C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_BRACKET_in_model_expression10440( FOLLOW_LEFT_BRACKET_in_model_expression10440_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_model_expression_element_in_model_expression10442_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000800) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_model_expression_element_in_model_expression10442( FOLLOW_model_expression_element_in_model_expression10442_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_RIGHT_BRACKET_in_model_expression10444_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_RIGHT_BRACKET_in_model_expression10444( FOLLOW_RIGHT_BRACKET_in_model_expression10444_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_any_key_in_model_expression_element10496_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000010) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_any_key_in_model_expression_element10496( FOLLOW_any_key_in_model_expression_element10496_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_condition_wrapper_in_model_expression_element10498_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000010) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_condition_wrapper_in_model_expression_element10498( FOLLOW_condition_wrapper_in_model_expression_element10498_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_model_expression_element10502_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_COMMA_in_model_expression_element10502( FOLLOW_COMMA_in_model_expression_element10502_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_any_key_in_model_expression_element10511_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000010) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_any_key_in_model_expression_element10511( FOLLOW_any_key_in_model_expression_element10511_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_condition_wrapper_in_model_expression_element10513_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000010) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_condition_wrapper_in_model_expression_element10513( FOLLOW_condition_wrapper_in_model_expression_element10513_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_single_column_for_loop_in_model_expression_element10527_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000010) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_single_column_for_loop_in_model_expression_element10527( FOLLOW_single_column_for_loop_in_model_expression_element10527_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_model_expression_element10530_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000020000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_COMMA_in_model_expression_element10530( FOLLOW_COMMA_in_model_expression_element10530_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_single_column_for_loop_in_model_expression_element10533_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000010) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_single_column_for_loop_in_model_expression_element10533( FOLLOW_single_column_for_loop_in_model_expression_element10533_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_multi_column_for_loop_in_model_expression_element10546_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_multi_column_for_loop_in_model_expression_element10546( FOLLOW_multi_column_for_loop_in_model_expression_element10546_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_for_key_in_single_column_for_loop10574_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_for_key_in_single_column_for_loop10574( FOLLOW_for_key_in_single_column_for_loop10574_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_column_name_in_single_column_for_loop10576_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000010840000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_column_name_in_single_column_for_loop10576( FOLLOW_column_name_in_single_column_for_loop10576_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_in_key_in_single_column_for_loop10588_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_in_key_in_single_column_for_loop10588( FOLLOW_in_key_in_single_column_for_loop10588_bits, 4 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_expression_list_in_single_column_for_loop10590_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_expression_list_in_single_column_for_loop10590( FOLLOW_expression_list_in_single_column_for_loop10590_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_for_like_part_in_single_column_for_loop10603_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_for_like_part_in_single_column_for_loop10603( FOLLOW_for_like_part_in_single_column_for_loop10603_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_from_key_in_single_column_for_loop10606_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_from_key_in_single_column_for_loop10606( FOLLOW_from_key_in_single_column_for_loop10606_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_expression_in_single_column_for_loop10610_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0400000000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_expression_in_single_column_for_loop10610( FOLLOW_expression_in_single_column_for_loop10610_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_to_key_in_single_column_for_loop10624_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_to_key_in_single_column_for_loop10624( FOLLOW_to_key_in_single_column_for_loop10624_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_expression_in_single_column_for_loop10628_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_expression_in_single_column_for_loop10628( FOLLOW_expression_in_single_column_for_loop10628_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_for_increment_decrement_type_in_single_column_for_loop10630_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_for_increment_decrement_type_in_single_column_for_loop10630( FOLLOW_for_increment_decrement_type_in_single_column_for_loop10630_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_expression_in_single_column_for_loop10634_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_expression_in_single_column_for_loop10634( FOLLOW_expression_in_single_column_for_loop10634_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_like_key_in_for_like_part10743_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_like_key_in_for_like_part10743( FOLLOW_like_key_in_for_like_part10743_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_expression_in_for_like_part10745_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_expression_in_for_like_part10745( FOLLOW_expression_in_for_like_part10745_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_increment_key_in_for_increment_decrement_type10785_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_increment_key_in_for_increment_decrement_type10785( FOLLOW_increment_key_in_for_increment_decrement_type10785_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_decrement_key_in_for_increment_decrement_type10796_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_decrement_key_in_for_increment_decrement_type10796( FOLLOW_decrement_key_in_for_increment_decrement_type10796_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_for_key_in_multi_column_for_loop10816_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_for_key_in_multi_column_for_loop10816( FOLLOW_for_key_in_multi_column_for_loop10816_bits, 4 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_multi_column_for_loop10818_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_multi_column_for_loop10818( FOLLOW_LEFT_PAREN_in_multi_column_for_loop10818_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_column_name_in_multi_column_for_loop10820_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_column_name_in_multi_column_for_loop10820( FOLLOW_column_name_in_multi_column_for_loop10820_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_multi_column_for_loop10823_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_COMMA_in_multi_column_for_loop10823( FOLLOW_COMMA_in_multi_column_for_loop10823_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_column_name_in_multi_column_for_loop10825_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_column_name_in_multi_column_for_loop10825( FOLLOW_column_name_in_multi_column_for_loop10825_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_multi_column_for_loop10829_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000800000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_multi_column_for_loop10829( FOLLOW_RIGHT_PAREN_in_multi_column_for_loop10829_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_in_key_in_multi_column_for_loop10831_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_in_key_in_multi_column_for_loop10831( FOLLOW_in_key_in_multi_column_for_loop10831_bits, 4 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_multi_column_for_loop10841_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0020000000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_multi_column_for_loop10841( FOLLOW_LEFT_PAREN_in_multi_column_for_loop10841_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_subquery_in_multi_column_for_loop10865_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_subquery_in_multi_column_for_loop10865( FOLLOW_subquery_in_multi_column_for_loop10865_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_multi_column_for_loop10889_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_multi_column_for_loop10889( FOLLOW_LEFT_PAREN_in_multi_column_for_loop10889_bits, 4 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_expression_list_in_multi_column_for_loop10891_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_expression_list_in_multi_column_for_loop10891( FOLLOW_expression_list_in_multi_column_for_loop10891_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_multi_column_for_loop10894_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_COMMA_in_multi_column_for_loop10894( FOLLOW_COMMA_in_multi_column_for_loop10894_bits, 4 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_expression_list_in_multi_column_for_loop10896_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_expression_list_in_multi_column_for_loop10896( FOLLOW_expression_list_in_multi_column_for_loop10896_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_multi_column_for_loop10900_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_multi_column_for_loop10900( FOLLOW_RIGHT_PAREN_in_multi_column_for_loop10900_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_multi_column_for_loop10924_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_multi_column_for_loop10924( FOLLOW_RIGHT_PAREN_in_multi_column_for_loop10924_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_unary_expression_in_multiset_expression10972_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_unary_expression_in_multiset_expression10972( FOLLOW_unary_expression_in_multiset_expression10972_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_multiset_op_in_multiset_expression10985_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080204000C250412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_multiset_op_in_multiset_expression10985( FOLLOW_multiset_op_in_multiset_expression10985_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_unary_expression_in_multiset_expression10988_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_unary_expression_in_multiset_expression10988( FOLLOW_unary_expression_in_multiset_expression10988_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_MINUS_SIGN_in_unary_expression11020_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080204000C250412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_MINUS_SIGN_in_unary_expression11020( FOLLOW_MINUS_SIGN_in_unary_expression11020_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_unary_expression_in_unary_expression11022_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_unary_expression_in_unary_expression11022( FOLLOW_unary_expression_in_unary_expression11022_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_PLUS_SIGN_in_unary_expression11042_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080204000C250412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_PLUS_SIGN_in_unary_expression11042( FOLLOW_PLUS_SIGN_in_unary_expression11042_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_unary_expression_in_unary_expression11044_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_unary_expression_in_unary_expression11044( FOLLOW_unary_expression_in_unary_expression11044_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_prior_key_in_unary_expression11064_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080204000C250412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_prior_key_in_unary_expression11064( FOLLOW_prior_key_in_unary_expression11064_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_unary_expression_in_unary_expression11067_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_unary_expression_in_unary_expression11067( FOLLOW_unary_expression_in_unary_expression11067_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_connect_by_root_key_in_unary_expression11078_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080204000C250412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_connect_by_root_key_in_unary_expression11078( FOLLOW_connect_by_root_key_in_unary_expression11078_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_unary_expression_in_unary_expression11081_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_unary_expression_in_unary_expression11081( FOLLOW_unary_expression_in_unary_expression11081_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_new_key_in_unary_expression11095_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080204000C250412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_new_key_in_unary_expression11095( FOLLOW_new_key_in_unary_expression11095_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_unary_expression_in_unary_expression11098_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_unary_expression_in_unary_expression11098( FOLLOW_unary_expression_in_unary_expression11098_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_distinct_key_in_unary_expression11109_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080204000C250412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_distinct_key_in_unary_expression11109( FOLLOW_distinct_key_in_unary_expression11109_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_unary_expression_in_unary_expression11112_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_unary_expression_in_unary_expression11112( FOLLOW_unary_expression_in_unary_expression11112_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_all_key_in_unary_expression11123_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080204000C250412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_all_key_in_unary_expression11123( FOLLOW_all_key_in_unary_expression11123_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_unary_expression_in_unary_expression11126_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_unary_expression_in_unary_expression11126( FOLLOW_unary_expression_in_unary_expression11126_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_case_statement_in_unary_expression11139_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_case_statement_in_unary_expression11139( FOLLOW_case_statement_in_unary_expression11139_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_quantified_expression_in_unary_expression11151_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_quantified_expression_in_unary_expression11151( FOLLOW_quantified_expression_in_unary_expression11151_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_standard_function_in_unary_expression11162_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_standard_function_in_unary_expression11162( FOLLOW_standard_function_in_unary_expression11162_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_atom_in_unary_expression11181_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_atom_in_unary_expression11181( FOLLOW_atom_in_unary_expression11181_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_searched_case_statement_in_case_statement11228_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_searched_case_statement_in_case_statement11228( FOLLOW_searched_case_statement_in_case_statement11228_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_simple_case_statement_in_case_statement11239_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_simple_case_statement_in_case_statement11239( FOLLOW_simple_case_statement_in_case_statement11239_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_label_name_in_simple_case_statement11263_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_label_name_in_simple_case_statement11263( FOLLOW_label_name_in_simple_case_statement11263_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_case_key_in_simple_case_statement11269_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x0800040008050000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_case_key_in_simple_case_statement11269( FOLLOW_case_key_in_simple_case_statement11269_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_atom_in_simple_case_statement11271_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_atom_in_simple_case_statement11271( FOLLOW_atom_in_simple_case_statement11271_bits, 9 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_simple_case_when_part_in_simple_case_statement11281_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000001800000), ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_simple_case_when_part_in_simple_case_statement11281( FOLLOW_simple_case_when_part_in_simple_case_statement11281_bits, 9 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_case_else_part_in_simple_case_statement11293_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000001000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_case_else_part_in_simple_case_statement11293( FOLLOW_case_else_part_in_simple_case_statement11293_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_end_key_in_simple_case_statement11304_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_end_key_in_simple_case_statement11304( FOLLOW_end_key_in_simple_case_statement11304_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_case_key_in_simple_case_statement11309_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_case_key_in_simple_case_statement11309( FOLLOW_case_key_in_simple_case_statement11309_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_label_name_in_simple_case_statement11311_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_label_name_in_simple_case_statement11311( FOLLOW_label_name_in_simple_case_statement11311_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_when_key_in_simple_case_when_part11368_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_when_key_in_simple_case_when_part11368( FOLLOW_when_key_in_simple_case_when_part11368_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_expression_wrapper_in_simple_case_when_part11373_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0200000000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_expression_wrapper_in_simple_case_when_part11373( FOLLOW_expression_wrapper_in_simple_case_when_part11373_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_then_key_in_simple_case_when_part11375_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000801000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x482206100C2D8412), ANTLR_UINT64_LIT(0x0000000000000008), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_then_key_in_simple_case_when_part11375( FOLLOW_then_key_in_simple_case_when_part11375_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_seq_of_statements_in_simple_case_when_part11381_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_seq_of_statements_in_simple_case_when_part11381( FOLLOW_seq_of_statements_in_simple_case_when_part11381_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_expression_wrapper_in_simple_case_when_part11387_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_expression_wrapper_in_simple_case_when_part11387( FOLLOW_expression_wrapper_in_simple_case_when_part11387_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_label_name_in_searched_case_statement11410_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_label_name_in_searched_case_statement11410( FOLLOW_label_name_in_searched_case_statement11410_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_case_key_in_searched_case_statement11416_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_case_key_in_searched_case_statement11416( FOLLOW_case_key_in_searched_case_statement11416_bits, 9 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_searched_case_when_part_in_searched_case_statement11426_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000001800000), ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_searched_case_when_part_in_searched_case_statement11426( FOLLOW_searched_case_when_part_in_searched_case_statement11426_bits, 9 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_case_else_part_in_searched_case_statement11437_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000001000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_case_else_part_in_searched_case_statement11437( FOLLOW_case_else_part_in_searched_case_statement11437_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_end_key_in_searched_case_statement11448_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_end_key_in_searched_case_statement11448( FOLLOW_end_key_in_searched_case_statement11448_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_case_key_in_searched_case_statement11453_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_case_key_in_searched_case_statement11453( FOLLOW_case_key_in_searched_case_statement11453_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_label_name_in_searched_case_statement11455_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_label_name_in_searched_case_statement11455( FOLLOW_label_name_in_searched_case_statement11455_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_when_key_in_searched_case_when_part11506_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_when_key_in_searched_case_when_part11506( FOLLOW_when_key_in_searched_case_when_part11506_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_condition_wrapper_in_searched_case_when_part11509_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0200000000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_condition_wrapper_in_searched_case_when_part11509( FOLLOW_condition_wrapper_in_searched_case_when_part11509_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_then_key_in_searched_case_when_part11511_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000801000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x482206100C2D8412), ANTLR_UINT64_LIT(0x0000000000000008), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_then_key_in_searched_case_when_part11511( FOLLOW_then_key_in_searched_case_when_part11511_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_seq_of_statements_in_searched_case_when_part11517_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_seq_of_statements_in_searched_case_when_part11517( FOLLOW_seq_of_statements_in_searched_case_when_part11517_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_expression_wrapper_in_searched_case_when_part11521_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_expression_wrapper_in_searched_case_when_part11521( FOLLOW_expression_wrapper_in_searched_case_when_part11521_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_else_key_in_case_else_part11542_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000801000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x482206100C2D8412), ANTLR_UINT64_LIT(0x0000000000000008), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_else_key_in_case_else_part11542( FOLLOW_else_key_in_case_else_part11542_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_seq_of_statements_in_case_else_part11548_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_seq_of_statements_in_case_else_part11548( FOLLOW_seq_of_statements_in_case_else_part11548_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_expression_wrapper_in_case_else_part11552_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_expression_wrapper_in_case_else_part11552( FOLLOW_expression_wrapper_in_case_else_part11552_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_table_element_in_atom11599_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_table_element_in_atom11599( FOLLOW_table_element_in_atom11599_bits, 4 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_outer_join_sign_in_atom11601_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_outer_join_sign_in_atom11601( FOLLOW_outer_join_sign_in_atom11601_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_bind_variable_in_atom11612_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_bind_variable_in_atom11612( FOLLOW_bind_variable_in_atom11612_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_constant_in_atom11623_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_constant_in_atom11623( FOLLOW_constant_in_atom11623_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_general_element_in_atom11634_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_general_element_in_atom11634( FOLLOW_general_element_in_atom11634_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_atom11645_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x082206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_atom11645( FOLLOW_LEFT_PAREN_in_atom11645_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_subquery_in_atom11682_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_subquery_in_atom11682( FOLLOW_subquery_in_atom11682_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_atom11684_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000002000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x1000002000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_atom11684( FOLLOW_RIGHT_PAREN_in_atom11684_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_subquery_operation_part_in_atom11686_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000002000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x1000002000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_subquery_operation_part_in_atom11686( FOLLOW_subquery_operation_part_in_atom11686_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_expression_or_vector_in_atom11707_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_expression_or_vector_in_atom11707( FOLLOW_expression_or_vector_in_atom11707_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_atom11709_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_atom11709( FOLLOW_RIGHT_PAREN_in_atom11709_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_expression_in_expression_or_vector11810_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000010) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_expression_in_expression_or_vector11810( FOLLOW_expression_in_expression_or_vector11810_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_vector_expr_in_expression_or_vector11813_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_vector_expr_in_expression_or_vector11813( FOLLOW_vector_expr_in_expression_or_vector11813_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_vector_expr11873_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_COMMA_in_vector_expr11873( FOLLOW_COMMA_in_vector_expr11873_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_expression_in_vector_expr11875_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000010) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_expression_in_vector_expr11875( FOLLOW_expression_in_vector_expr11875_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_vector_expr11878_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_COMMA_in_vector_expr11878( FOLLOW_COMMA_in_vector_expr11878_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_expression_in_vector_expr11880_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000010) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_expression_in_vector_expr11880( FOLLOW_expression_in_vector_expr11880_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_some_key_in_quantified_expression11929_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_some_key_in_quantified_expression11929( FOLLOW_some_key_in_quantified_expression11929_bits, 4 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_exists_key_in_quantified_expression11933_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_exists_key_in_quantified_expression11933( FOLLOW_exists_key_in_quantified_expression11933_bits, 4 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_all_key_in_quantified_expression11937_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_all_key_in_quantified_expression11937( FOLLOW_all_key_in_quantified_expression11937_bits, 4 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_any_key_in_quantified_expression11941_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_any_key_in_quantified_expression11941( FOLLOW_any_key_in_quantified_expression11941_bits, 4 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_quantified_expression11968_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0020000000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_quantified_expression11968( FOLLOW_LEFT_PAREN_in_quantified_expression11968_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_subquery_in_quantified_expression11970_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_subquery_in_quantified_expression11970( FOLLOW_subquery_in_quantified_expression11970_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_quantified_expression11972_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_quantified_expression11972( FOLLOW_RIGHT_PAREN_in_quantified_expression11972_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_quantified_expression11989_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_quantified_expression11989( FOLLOW_LEFT_PAREN_in_quantified_expression11989_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_expression_wrapper_in_quantified_expression11991_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_expression_wrapper_in_quantified_expression11991( FOLLOW_expression_wrapper_in_quantified_expression11991_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_quantified_expression11993_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_quantified_expression11993( FOLLOW_RIGHT_PAREN_in_quantified_expression11993_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_stantard_function_enabling_over_in_standard_function12129_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_stantard_function_enabling_over_in_standard_function12129( FOLLOW_stantard_function_enabling_over_in_standard_function12129_bits, 4 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_function_argument_analytic_in_standard_function12132_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_function_argument_analytic_in_standard_function12132( FOLLOW_function_argument_analytic_in_standard_function12132_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_over_clause_in_standard_function12134_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_over_clause_in_standard_function12134( FOLLOW_over_clause_in_standard_function12134_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_stantard_function_enabling_using_in_standard_function12146_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_stantard_function_enabling_using_in_standard_function12146( FOLLOW_stantard_function_enabling_using_in_standard_function12146_bits, 4 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_function_argument_modeling_in_standard_function12149_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000008000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_function_argument_modeling_in_standard_function12149( FOLLOW_function_argument_modeling_in_standard_function12149_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_using_clause_in_standard_function12151_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_using_clause_in_standard_function12151( FOLLOW_using_clause_in_standard_function12151_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_count_key_in_standard_function12163_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_count_key_in_standard_function12163( FOLLOW_count_key_in_standard_function12163_bits, 4 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_standard_function12178_bits[]	= { ANTLR_UINT64_LIT(0x0180000400082000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x280204000C250412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_standard_function12178( FOLLOW_LEFT_PAREN_in_standard_function12178_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_ASTERISK_in_standard_function12198_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_ASTERISK_in_standard_function12198( FOLLOW_ASTERISK_in_standard_function12198_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_distinct_key_in_standard_function12203_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080204000C250412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_distinct_key_in_standard_function12203( FOLLOW_distinct_key_in_standard_function12203_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_unique_key_in_standard_function12205_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080204000C250412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_unique_key_in_standard_function12205( FOLLOW_unique_key_in_standard_function12205_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_all_key_in_standard_function12207_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080204000C250412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_all_key_in_standard_function12207( FOLLOW_all_key_in_standard_function12207_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_standard_function12211_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_standard_function12211( FOLLOW_concatenation_wrapper_in_standard_function12211_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_standard_function12227_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_standard_function12227( FOLLOW_RIGHT_PAREN_in_standard_function12227_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_over_clause_in_standard_function12229_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_over_clause_in_standard_function12229( FOLLOW_over_clause_in_standard_function12229_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_cast_key_in_standard_function12242_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_cast_key_in_standard_function12242( FOLLOW_cast_key_in_standard_function12242_bits, 4 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_xmlcast_key_in_standard_function12245_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_xmlcast_key_in_standard_function12245( FOLLOW_xmlcast_key_in_standard_function12245_bits, 4 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_standard_function12262_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800001300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080204000C250412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_standard_function12262( FOLLOW_LEFT_PAREN_in_standard_function12262_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_multiset_key_in_standard_function12294_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_multiset_key_in_standard_function12294( FOLLOW_multiset_key_in_standard_function12294_bits, 4 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_standard_function12297_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0020000000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_standard_function12297( FOLLOW_LEFT_PAREN_in_standard_function12297_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_subquery_in_standard_function12299_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000), ANTLR_UINT64_LIT(0x0000800000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_subquery_in_standard_function12299( FOLLOW_subquery_in_standard_function12299_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_order_by_clause_in_standard_function12301_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_order_by_clause_in_standard_function12301( FOLLOW_order_by_clause_in_standard_function12301_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_standard_function12304_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000), ANTLR_UINT64_LIT(0x0000000000000020) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_standard_function12304( FOLLOW_RIGHT_PAREN_in_standard_function12304_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_as_key_in_standard_function12322_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x0000000000010000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_as_key_in_standard_function12322( FOLLOW_as_key_in_standard_function12322_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_type_spec_in_standard_function12325_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_type_spec_in_standard_function12325( FOLLOW_type_spec_in_standard_function12325_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_standard_function12343_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000020) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_standard_function12343( FOLLOW_concatenation_wrapper_in_standard_function12343_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_as_key_in_standard_function12345_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x0000000000010000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_as_key_in_standard_function12345( FOLLOW_as_key_in_standard_function12345_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_type_spec_in_standard_function12348_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_type_spec_in_standard_function12348( FOLLOW_type_spec_in_standard_function12348_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_standard_function12376_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_standard_function12376( FOLLOW_RIGHT_PAREN_in_standard_function12376_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_chr_key_in_standard_function12387_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_chr_key_in_standard_function12387( FOLLOW_chr_key_in_standard_function12387_bits, 4 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_standard_function12402_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080204000C250412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_standard_function12402( FOLLOW_LEFT_PAREN_in_standard_function12402_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_standard_function12421_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000008000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_standard_function12421( FOLLOW_concatenation_wrapper_in_standard_function12421_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_using_key_in_standard_function12423_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_using_key_in_standard_function12423( FOLLOW_using_key_in_standard_function12423_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_nchar_cs_key_in_standard_function12426_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_nchar_cs_key_in_standard_function12426( FOLLOW_nchar_cs_key_in_standard_function12426_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_standard_function12441_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_standard_function12441( FOLLOW_RIGHT_PAREN_in_standard_function12441_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_collect_key_in_standard_function12452_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_collect_key_in_standard_function12452( FOLLOW_collect_key_in_standard_function12452_bits, 4 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_standard_function12467_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x280204000C250412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_standard_function12467( FOLLOW_LEFT_PAREN_in_standard_function12467_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_distinct_key_in_standard_function12487_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080204000C250412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_distinct_key_in_standard_function12487( FOLLOW_distinct_key_in_standard_function12487_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_unique_key_in_standard_function12489_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080204000C250412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_unique_key_in_standard_function12489( FOLLOW_unique_key_in_standard_function12489_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_standard_function12493_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000), ANTLR_UINT64_LIT(0x0000800000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_standard_function12493( FOLLOW_concatenation_wrapper_in_standard_function12493_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_collect_order_by_part_in_standard_function12495_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_collect_order_by_part_in_standard_function12495( FOLLOW_collect_order_by_part_in_standard_function12495_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_standard_function12510_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_standard_function12510( FOLLOW_RIGHT_PAREN_in_standard_function12510_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_stantard_function_enabling_within_or_over_in_standard_function12521_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_stantard_function_enabling_within_or_over_in_standard_function12521( FOLLOW_stantard_function_enabling_within_or_over_in_standard_function12521_bits, 4 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_function_argument_in_standard_function12537_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_function_argument_in_standard_function12537( FOLLOW_function_argument_in_standard_function12537_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_within_or_over_part_in_standard_function12539_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_within_or_over_part_in_standard_function12539( FOLLOW_within_or_over_part_in_standard_function12539_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_decompose_key_in_standard_function12551_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_decompose_key_in_standard_function12551( FOLLOW_decompose_key_in_standard_function12551_bits, 4 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_standard_function12566_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080204000C250412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_standard_function12566( FOLLOW_LEFT_PAREN_in_standard_function12566_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_standard_function12585_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_standard_function12585( FOLLOW_concatenation_wrapper_in_standard_function12585_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_canonical_key_in_standard_function12588_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_canonical_key_in_standard_function12588( FOLLOW_canonical_key_in_standard_function12588_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_compatibility_key_in_standard_function12590_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_compatibility_key_in_standard_function12590( FOLLOW_compatibility_key_in_standard_function12590_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_standard_function12607_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_standard_function12607( FOLLOW_RIGHT_PAREN_in_standard_function12607_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_extract_key_in_standard_function12618_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_extract_key_in_standard_function12618( FOLLOW_extract_key_in_standard_function12618_bits, 4 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_standard_function12633_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_standard_function12633( FOLLOW_LEFT_PAREN_in_standard_function12633_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_standard_function12651_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_standard_function12651( FOLLOW_REGULAR_ID_in_standard_function12651_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_from_key_in_standard_function12653_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080204000C250412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_from_key_in_standard_function12653( FOLLOW_from_key_in_standard_function12653_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_standard_function12656_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_standard_function12656( FOLLOW_concatenation_wrapper_in_standard_function12656_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_standard_function12671_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_standard_function12671( FOLLOW_RIGHT_PAREN_in_standard_function12671_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_first_value_key_in_standard_function12683_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_first_value_key_in_standard_function12683( FOLLOW_first_value_key_in_standard_function12683_bits, 4 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_last_value_key_in_standard_function12686_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_last_value_key_in_standard_function12686( FOLLOW_last_value_key_in_standard_function12686_bits, 4 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_function_argument_analytic_in_standard_function12690_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_function_argument_analytic_in_standard_function12690( FOLLOW_function_argument_analytic_in_standard_function12690_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_respect_or_ignore_nulls_in_standard_function12705_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_respect_or_ignore_nulls_in_standard_function12705( FOLLOW_respect_or_ignore_nulls_in_standard_function12705_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_over_clause_in_standard_function12708_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_over_clause_in_standard_function12708( FOLLOW_over_clause_in_standard_function12708_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_stantard_function_pedictions_in_standard_function12719_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_stantard_function_pedictions_in_standard_function12719( FOLLOW_stantard_function_pedictions_in_standard_function12719_bits, 4 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_standard_function12734_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_standard_function12734( FOLLOW_LEFT_PAREN_in_standard_function12734_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_expression_wrapper_in_standard_function12752_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_expression_wrapper_in_standard_function12752( FOLLOW_expression_wrapper_in_standard_function12752_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_standard_function12755_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_COMMA_in_standard_function12755( FOLLOW_COMMA_in_standard_function12755_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_expression_wrapper_in_standard_function12757_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_expression_wrapper_in_standard_function12757( FOLLOW_expression_wrapper_in_standard_function12757_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_cost_matrix_clause_in_standard_function12761_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_cost_matrix_clause_in_standard_function12761( FOLLOW_cost_matrix_clause_in_standard_function12761_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_using_clause_in_standard_function12764_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_using_clause_in_standard_function12764( FOLLOW_using_clause_in_standard_function12764_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_standard_function12780_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_standard_function12780( FOLLOW_RIGHT_PAREN_in_standard_function12780_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_translate_key_in_standard_function12791_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_translate_key_in_standard_function12791( FOLLOW_translate_key_in_standard_function12791_bits, 4 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_standard_function12806_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_standard_function12806( FOLLOW_LEFT_PAREN_in_standard_function12806_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_expression_wrapper_in_standard_function12825_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_expression_wrapper_in_standard_function12825( FOLLOW_expression_wrapper_in_standard_function12825_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_using_key_in_standard_function12828_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_using_key_in_standard_function12828( FOLLOW_using_key_in_standard_function12828_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_char_cs_key_in_standard_function12832_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_char_cs_key_in_standard_function12832( FOLLOW_char_cs_key_in_standard_function12832_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_nchar_cs_key_in_standard_function12834_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_nchar_cs_key_in_standard_function12834( FOLLOW_nchar_cs_key_in_standard_function12834_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_standard_function12861_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_COMMA_in_standard_function12861( FOLLOW_COMMA_in_standard_function12861_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_expression_wrapper_in_standard_function12863_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_expression_wrapper_in_standard_function12863( FOLLOW_expression_wrapper_in_standard_function12863_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_standard_function12880_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_standard_function12880( FOLLOW_RIGHT_PAREN_in_standard_function12880_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_treat_key_in_standard_function12891_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_treat_key_in_standard_function12891( FOLLOW_treat_key_in_standard_function12891_bits, 4 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_standard_function12906_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_standard_function12906( FOLLOW_LEFT_PAREN_in_standard_function12906_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_expression_wrapper_in_standard_function12924_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000020) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_expression_wrapper_in_standard_function12924( FOLLOW_expression_wrapper_in_standard_function12924_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_as_key_in_standard_function12926_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x0000000000010000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_as_key_in_standard_function12926( FOLLOW_as_key_in_standard_function12926_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_ref_key_in_standard_function12929_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x0000000000010000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_ref_key_in_standard_function12929( FOLLOW_ref_key_in_standard_function12929_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_type_spec_in_standard_function12932_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_type_spec_in_standard_function12932( FOLLOW_type_spec_in_standard_function12932_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_standard_function12947_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_standard_function12947( FOLLOW_RIGHT_PAREN_in_standard_function12947_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_trim_key_in_standard_function12958_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_trim_key_in_standard_function12958( FOLLOW_trim_key_in_standard_function12958_bits, 4 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_standard_function12973_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080204004C250412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_standard_function12973( FOLLOW_LEFT_PAREN_in_standard_function12973_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_leading_key_in_standard_function12993_bits[]	= { ANTLR_UINT64_LIT(0x0180000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_leading_key_in_standard_function12993( FOLLOW_leading_key_in_standard_function12993_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_trailing_key_in_standard_function12995_bits[]	= { ANTLR_UINT64_LIT(0x0180000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_trailing_key_in_standard_function12995( FOLLOW_trailing_key_in_standard_function12995_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_both_key_in_standard_function12997_bits[]	= { ANTLR_UINT64_LIT(0x0180000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_both_key_in_standard_function12997( FOLLOW_both_key_in_standard_function12997_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_quoted_string_in_standard_function13001_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_quoted_string_in_standard_function13001( FOLLOW_quoted_string_in_standard_function13001_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_from_key_in_standard_function13004_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080204000C250412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_from_key_in_standard_function13004( FOLLOW_from_key_in_standard_function13004_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_standard_function13024_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_standard_function13024( FOLLOW_concatenation_wrapper_in_standard_function13024_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_standard_function13038_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_standard_function13038( FOLLOW_RIGHT_PAREN_in_standard_function13038_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_xmlagg_key_in_standard_function13049_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_xmlagg_key_in_standard_function13049( FOLLOW_xmlagg_key_in_standard_function13049_bits, 4 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_standard_function13064_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_standard_function13064( FOLLOW_LEFT_PAREN_in_standard_function13064_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_expression_wrapper_in_standard_function13083_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000), ANTLR_UINT64_LIT(0x0000800000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_expression_wrapper_in_standard_function13083( FOLLOW_expression_wrapper_in_standard_function13083_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_order_by_clause_in_standard_function13085_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_order_by_clause_in_standard_function13085( FOLLOW_order_by_clause_in_standard_function13085_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_standard_function13101_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_standard_function13101( FOLLOW_RIGHT_PAREN_in_standard_function13101_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_standard_function13116_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_PERIOD_in_standard_function13116( FOLLOW_PERIOD_in_standard_function13116_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_general_element_part_in_standard_function13118_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_general_element_part_in_standard_function13118( FOLLOW_general_element_part_in_standard_function13118_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_xmlcolattval_key_in_standard_function13132_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_xmlcolattval_key_in_standard_function13132( FOLLOW_xmlcolattval_key_in_standard_function13132_bits, 4 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_xmlforest_key_in_standard_function13135_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_xmlforest_key_in_standard_function13135( FOLLOW_xmlforest_key_in_standard_function13135_bits, 4 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_standard_function13152_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_standard_function13152( FOLLOW_LEFT_PAREN_in_standard_function13152_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_xml_multiuse_expression_element_in_standard_function13170_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_xml_multiuse_expression_element_in_standard_function13170( FOLLOW_xml_multiuse_expression_element_in_standard_function13170_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_standard_function13173_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_COMMA_in_standard_function13173( FOLLOW_COMMA_in_standard_function13173_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_xml_multiuse_expression_element_in_standard_function13176_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_xml_multiuse_expression_element_in_standard_function13176( FOLLOW_xml_multiuse_expression_element_in_standard_function13176_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_standard_function13192_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_standard_function13192( FOLLOW_RIGHT_PAREN_in_standard_function13192_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_standard_function13207_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_PERIOD_in_standard_function13207( FOLLOW_PERIOD_in_standard_function13207_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_general_element_part_in_standard_function13209_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_general_element_part_in_standard_function13209( FOLLOW_general_element_part_in_standard_function13209_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_xmlelement_key_in_standard_function13222_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_xmlelement_key_in_standard_function13222( FOLLOW_xmlelement_key_in_standard_function13222_bits, 4 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_standard_function13237_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_standard_function13237( FOLLOW_LEFT_PAREN_in_standard_function13237_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_entityescaping_key_in_standard_function13256_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_entityescaping_key_in_standard_function13256( FOLLOW_entityescaping_key_in_standard_function13256_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_noentityescaping_key_in_standard_function13258_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_noentityescaping_key_in_standard_function13258( FOLLOW_noentityescaping_key_in_standard_function13258_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_name_key_in_standard_function13279_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_name_key_in_standard_function13279( FOLLOW_name_key_in_standard_function13279_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_evalname_key_in_standard_function13281_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_evalname_key_in_standard_function13281( FOLLOW_evalname_key_in_standard_function13281_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_expression_wrapper_in_standard_function13285_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_expression_wrapper_in_standard_function13285( FOLLOW_expression_wrapper_in_standard_function13285_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_standard_function13306_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_COMMA_in_standard_function13306( FOLLOW_COMMA_in_standard_function13306_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_xml_attributes_clause_in_standard_function13309_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_xml_attributes_clause_in_standard_function13309( FOLLOW_xml_attributes_clause_in_standard_function13309_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_standard_function13330_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_COMMA_in_standard_function13330( FOLLOW_COMMA_in_standard_function13330_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_expression_wrapper_in_standard_function13333_bits[]	= { ANTLR_UINT64_LIT(0x0180000000000000), ANTLR_UINT64_LIT(0x0002000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001001), ANTLR_UINT64_LIT(0x0000000000000020) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_expression_wrapper_in_standard_function13333( FOLLOW_expression_wrapper_in_standard_function13333_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_column_alias_in_standard_function13335_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_column_alias_in_standard_function13335( FOLLOW_column_alias_in_standard_function13335_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_standard_function13352_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_standard_function13352( FOLLOW_RIGHT_PAREN_in_standard_function13352_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_standard_function13367_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_PERIOD_in_standard_function13367( FOLLOW_PERIOD_in_standard_function13367_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_general_element_part_in_standard_function13369_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_general_element_part_in_standard_function13369( FOLLOW_general_element_part_in_standard_function13369_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_xmlexists_key_in_standard_function13382_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_xmlexists_key_in_standard_function13382( FOLLOW_xmlexists_key_in_standard_function13382_bits, 4 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_standard_function13397_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_standard_function13397( FOLLOW_LEFT_PAREN_in_standard_function13397_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_expression_wrapper_in_standard_function13415_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_expression_wrapper_in_standard_function13415( FOLLOW_expression_wrapper_in_standard_function13415_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_xml_passing_clause_in_standard_function13433_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_xml_passing_clause_in_standard_function13433( FOLLOW_xml_passing_clause_in_standard_function13433_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_standard_function13448_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_standard_function13448( FOLLOW_RIGHT_PAREN_in_standard_function13448_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_xmlparse_key_in_standard_function13459_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_xmlparse_key_in_standard_function13459( FOLLOW_xmlparse_key_in_standard_function13459_bits, 4 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_standard_function13474_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_standard_function13474( FOLLOW_LEFT_PAREN_in_standard_function13474_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_document_key_in_standard_function13494_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080204000C250412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_document_key_in_standard_function13494( FOLLOW_document_key_in_standard_function13494_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_content_key_in_standard_function13496_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080204000C250412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_content_key_in_standard_function13496( FOLLOW_content_key_in_standard_function13496_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_standard_function13499_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_standard_function13499( FOLLOW_concatenation_wrapper_in_standard_function13499_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_wellformed_key_in_standard_function13501_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_wellformed_key_in_standard_function13501( FOLLOW_wellformed_key_in_standard_function13501_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_standard_function13516_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_standard_function13516( FOLLOW_RIGHT_PAREN_in_standard_function13516_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_standard_function13531_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_PERIOD_in_standard_function13531( FOLLOW_PERIOD_in_standard_function13531_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_general_element_part_in_standard_function13533_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_general_element_part_in_standard_function13533( FOLLOW_general_element_part_in_standard_function13533_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_xmlpi_key_in_standard_function13546_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_xmlpi_key_in_standard_function13546( FOLLOW_xmlpi_key_in_standard_function13546_bits, 4 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_standard_function13561_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_standard_function13561( FOLLOW_LEFT_PAREN_in_standard_function13561_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_name_key_in_standard_function13585_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_name_key_in_standard_function13585( FOLLOW_name_key_in_standard_function13585_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_id_in_standard_function13587_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_id_in_standard_function13587( FOLLOW_id_in_standard_function13587_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_evalname_key_in_standard_function13611_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080204000C250412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_evalname_key_in_standard_function13611( FOLLOW_evalname_key_in_standard_function13611_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_standard_function13613_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_standard_function13613( FOLLOW_concatenation_wrapper_in_standard_function13613_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_standard_function13650_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080204000C250412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_COMMA_in_standard_function13650( FOLLOW_COMMA_in_standard_function13650_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_standard_function13653_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_standard_function13653( FOLLOW_concatenation_wrapper_in_standard_function13653_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_standard_function13669_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_standard_function13669( FOLLOW_RIGHT_PAREN_in_standard_function13669_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_standard_function13684_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_PERIOD_in_standard_function13684( FOLLOW_PERIOD_in_standard_function13684_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_general_element_part_in_standard_function13686_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_general_element_part_in_standard_function13686( FOLLOW_general_element_part_in_standard_function13686_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_xmlquery_key_in_standard_function13699_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_xmlquery_key_in_standard_function13699( FOLLOW_xmlquery_key_in_standard_function13699_bits, 4 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_standard_function13714_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080204000C250412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_standard_function13714( FOLLOW_LEFT_PAREN_in_standard_function13714_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_standard_function13733_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_standard_function13733( FOLLOW_concatenation_wrapper_in_standard_function13733_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_xml_passing_clause_in_standard_function13735_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_xml_passing_clause_in_standard_function13735( FOLLOW_xml_passing_clause_in_standard_function13735_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_returning_key_in_standard_function13754_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_returning_key_in_standard_function13754( FOLLOW_returning_key_in_standard_function13754_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_content_key_in_standard_function13757_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000), ANTLR_UINT64_LIT(0x0000040000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_content_key_in_standard_function13757( FOLLOW_content_key_in_standard_function13757_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_null_key_in_standard_function13761_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000100000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_null_key_in_standard_function13761( FOLLOW_null_key_in_standard_function13761_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_on_key_in_standard_function13763_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_on_key_in_standard_function13763( FOLLOW_on_key_in_standard_function13763_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_empty_key_in_standard_function13766_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_empty_key_in_standard_function13766( FOLLOW_empty_key_in_standard_function13766_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_standard_function13783_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_standard_function13783( FOLLOW_RIGHT_PAREN_in_standard_function13783_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_standard_function13798_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_PERIOD_in_standard_function13798( FOLLOW_PERIOD_in_standard_function13798_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_general_element_part_in_standard_function13800_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_general_element_part_in_standard_function13800( FOLLOW_general_element_part_in_standard_function13800_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_xmlroot_key_in_standard_function13813_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_xmlroot_key_in_standard_function13813( FOLLOW_xmlroot_key_in_standard_function13813_bits, 4 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_standard_function13828_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080204000C250412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_standard_function13828( FOLLOW_LEFT_PAREN_in_standard_function13828_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_standard_function13846_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_standard_function13846( FOLLOW_concatenation_wrapper_in_standard_function13846_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_xmlroot_param_version_part_in_standard_function13868_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_xmlroot_param_version_part_in_standard_function13868( FOLLOW_xmlroot_param_version_part_in_standard_function13868_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_standard_function13891_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_COMMA_in_standard_function13891( FOLLOW_COMMA_in_standard_function13891_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_xmlroot_param_standalone_part_in_standard_function13894_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_xmlroot_param_standalone_part_in_standard_function13894( FOLLOW_xmlroot_param_standalone_part_in_standard_function13894_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_standard_function13910_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_standard_function13910( FOLLOW_RIGHT_PAREN_in_standard_function13910_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_standard_function13925_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_PERIOD_in_standard_function13925( FOLLOW_PERIOD_in_standard_function13925_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_general_element_part_in_standard_function13927_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_general_element_part_in_standard_function13927( FOLLOW_general_element_part_in_standard_function13927_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_xmlserialize_key_in_standard_function13940_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_xmlserialize_key_in_standard_function13940( FOLLOW_xmlserialize_key_in_standard_function13940_bits, 4 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_standard_function13955_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_standard_function13955( FOLLOW_LEFT_PAREN_in_standard_function13955_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_document_key_in_standard_function13974_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080204000C250412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_document_key_in_standard_function13974( FOLLOW_document_key_in_standard_function13974_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_content_key_in_standard_function13976_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080204000C250412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_content_key_in_standard_function13976( FOLLOW_content_key_in_standard_function13976_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_standard_function13995_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001001), ANTLR_UINT64_LIT(0x0000000000000020) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_standard_function13995( FOLLOW_concatenation_wrapper_in_standard_function13995_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_as_key_in_standard_function13998_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x0000000000010000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_as_key_in_standard_function13998( FOLLOW_as_key_in_standard_function13998_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_type_spec_in_standard_function14001_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_type_spec_in_standard_function14001( FOLLOW_type_spec_in_standard_function14001_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_xmlserialize_param_enconding_part_in_standard_function14021_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_xmlserialize_param_enconding_part_in_standard_function14021( FOLLOW_xmlserialize_param_enconding_part_in_standard_function14021_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_xmlserialize_param_version_part_in_standard_function14040_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_xmlserialize_param_version_part_in_standard_function14040( FOLLOW_xmlserialize_param_version_part_in_standard_function14040_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_xmlserialize_param_ident_part_in_standard_function14059_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_xmlserialize_param_ident_part_in_standard_function14059( FOLLOW_xmlserialize_param_ident_part_in_standard_function14059_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_hide_key_in_standard_function14080_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_hide_key_in_standard_function14080( FOLLOW_hide_key_in_standard_function14080_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_show_key_in_standard_function14082_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_show_key_in_standard_function14082( FOLLOW_show_key_in_standard_function14082_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_defaults_key_in_standard_function14085_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_defaults_key_in_standard_function14085( FOLLOW_defaults_key_in_standard_function14085_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_standard_function14101_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_standard_function14101( FOLLOW_RIGHT_PAREN_in_standard_function14101_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_standard_function14116_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_PERIOD_in_standard_function14116( FOLLOW_PERIOD_in_standard_function14116_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_general_element_part_in_standard_function14118_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_general_element_part_in_standard_function14118( FOLLOW_general_element_part_in_standard_function14118_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_xmltable_key_in_standard_function14131_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_xmltable_key_in_standard_function14131( FOLLOW_xmltable_key_in_standard_function14131_bits, 4 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_standard_function14146_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080204000C250412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_standard_function14146( FOLLOW_LEFT_PAREN_in_standard_function14146_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_xml_namespaces_clause_in_standard_function14164_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080204000C250412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_xml_namespaces_clause_in_standard_function14164( FOLLOW_xml_namespaces_clause_in_standard_function14164_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_standard_function14183_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_standard_function14183( FOLLOW_concatenation_wrapper_in_standard_function14183_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_xml_passing_clause_in_standard_function14201_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_xml_passing_clause_in_standard_function14201( FOLLOW_xml_passing_clause_in_standard_function14201_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_columns_key_in_standard_function14221_bits[]	= { ANTLR_UINT64_LIT(0x0180000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_columns_key_in_standard_function14221( FOLLOW_columns_key_in_standard_function14221_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_xml_table_column_in_standard_function14224_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_xml_table_column_in_standard_function14224( FOLLOW_xml_table_column_in_standard_function14224_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_standard_function14227_bits[]	= { ANTLR_UINT64_LIT(0x0180000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_COMMA_in_standard_function14227( FOLLOW_COMMA_in_standard_function14227_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_xml_table_column_in_standard_function14230_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_xml_table_column_in_standard_function14230( FOLLOW_xml_table_column_in_standard_function14230_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_standard_function14247_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_standard_function14247( FOLLOW_RIGHT_PAREN_in_standard_function14247_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_standard_function14262_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_PERIOD_in_standard_function14262( FOLLOW_PERIOD_in_standard_function14262_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_general_element_part_in_standard_function14264_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_general_element_part_in_standard_function14264( FOLLOW_general_element_part_in_standard_function14264_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_stantard_function_enabling_over14289_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_stantard_function_enabling_over14289( FOLLOW_REGULAR_ID_in_stantard_function_enabling_over14289_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_stantard_function_enabling_using14317_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_stantard_function_enabling_using14317( FOLLOW_REGULAR_ID_in_stantard_function_enabling_using14317_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_stantard_function_enabling_within_or_over14345_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_stantard_function_enabling_within_or_over14345( FOLLOW_REGULAR_ID_in_stantard_function_enabling_within_or_over14345_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_stantard_function_pedictions14373_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_stantard_function_pedictions14373( FOLLOW_REGULAR_ID_in_stantard_function_pedictions14373_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_over_key_in_over_clause14398_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_over_key_in_over_clause14398( FOLLOW_over_key_in_over_clause14398_bits, 4 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_over_clause14409_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001001), ANTLR_UINT64_LIT(0x0000800000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_over_clause14409( FOLLOW_LEFT_PAREN_in_over_clause14409_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_query_partition_clause_in_over_clause14423_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000), ANTLR_UINT64_LIT(0x0000800000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_query_partition_clause_in_over_clause14423( FOLLOW_query_partition_clause_in_over_clause14423_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_order_by_clause_in_over_clause14439_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_order_by_clause_in_over_clause14439( FOLLOW_order_by_clause_in_over_clause14439_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_windowing_clause_in_over_clause14441_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_windowing_clause_in_over_clause14441( FOLLOW_windowing_clause_in_over_clause14441_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_over_clause14454_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_over_clause14454( FOLLOW_RIGHT_PAREN_in_over_clause14454_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_windowing_type_in_windowing_clause14482_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080204000C254512), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_windowing_type_in_windowing_clause14482( FOLLOW_windowing_type_in_windowing_clause14482_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_between_key_in_windowing_clause14493_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080204000C254412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_between_key_in_windowing_clause14493( FOLLOW_between_key_in_windowing_clause14493_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_windowing_elements_in_windowing_clause14495_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000008) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_windowing_elements_in_windowing_clause14495( FOLLOW_windowing_elements_in_windowing_clause14495_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_and_key_in_windowing_clause14497_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080204000C254412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_and_key_in_windowing_clause14497( FOLLOW_and_key_in_windowing_clause14497_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_windowing_elements_in_windowing_clause14499_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_windowing_elements_in_windowing_clause14499( FOLLOW_windowing_elements_in_windowing_clause14499_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_windowing_elements_in_windowing_clause14512_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_windowing_elements_in_windowing_clause14512( FOLLOW_windowing_elements_in_windowing_clause14512_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_rows_key_in_windowing_type14571_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_rows_key_in_windowing_type14571( FOLLOW_rows_key_in_windowing_type14571_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_range_key_in_windowing_type14582_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_range_key_in_windowing_type14582( FOLLOW_range_key_in_windowing_type14582_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_unbounded_key_in_windowing_elements14602_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_unbounded_key_in_windowing_elements14602( FOLLOW_unbounded_key_in_windowing_elements14602_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_preceding_key_in_windowing_elements14605_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_preceding_key_in_windowing_elements14605( FOLLOW_preceding_key_in_windowing_elements14605_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_current_key_in_windowing_elements14616_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_current_key_in_windowing_elements14616( FOLLOW_current_key_in_windowing_elements14616_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_row_key_in_windowing_elements14619_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_row_key_in_windowing_elements14619( FOLLOW_row_key_in_windowing_elements14619_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_windowing_elements14630_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_windowing_elements14630( FOLLOW_concatenation_wrapper_in_windowing_elements14630_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_preceding_key_in_windowing_elements14633_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_preceding_key_in_windowing_elements14633( FOLLOW_preceding_key_in_windowing_elements14633_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_following_key_in_windowing_elements14636_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_following_key_in_windowing_elements14636( FOLLOW_following_key_in_windowing_elements14636_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_using_key_in_using_clause14658_bits[]	= { ANTLR_UINT64_LIT(0x0180000400082000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206080C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_using_key_in_using_clause14658( FOLLOW_using_key_in_using_clause14658_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_ASTERISK_in_using_clause14670_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_ASTERISK_in_using_clause14670( FOLLOW_ASTERISK_in_using_clause14670_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_using_element_in_using_clause14681_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000010) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_using_element_in_using_clause14681( FOLLOW_using_element_in_using_clause14681_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_using_clause14684_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206080C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_COMMA_in_using_clause14684( FOLLOW_COMMA_in_using_clause14684_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_using_element_in_using_clause14687_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000010) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_using_element_in_using_clause14687( FOLLOW_using_element_in_using_clause14687_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_in_key_in_using_element14716_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_in_key_in_using_element14716( FOLLOW_in_key_in_using_element14716_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_out_key_in_using_element14718_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_out_key_in_using_element14718( FOLLOW_out_key_in_using_element14718_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_out_key_in_using_element14721_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_out_key_in_using_element14721( FOLLOW_out_key_in_using_element14721_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_select_list_elements_in_using_element14725_bits[]	= { ANTLR_UINT64_LIT(0x0180000000000002), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x0000000000000020) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_select_list_elements_in_using_element14725( FOLLOW_select_list_elements_in_using_element14725_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_column_alias_in_using_element14727_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_column_alias_in_using_element14727( FOLLOW_column_alias_in_using_element14727_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_order_key_in_collect_order_by_part14773_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000200) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_order_key_in_collect_order_by_part14773( FOLLOW_order_key_in_collect_order_by_part14773_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_by_key_in_collect_order_by_part14776_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080204000C250412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_by_key_in_collect_order_by_part14776( FOLLOW_by_key_in_collect_order_by_part14776_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_collect_order_by_part14779_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_collect_order_by_part14779( FOLLOW_concatenation_wrapper_in_collect_order_by_part14779_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_within_key_in_within_or_over_part14799_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000200000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_within_key_in_within_or_over_part14799( FOLLOW_within_key_in_within_or_over_part14799_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_group_key_in_within_or_over_part14802_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_group_key_in_within_or_over_part14802( FOLLOW_group_key_in_within_or_over_part14802_bits, 4 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_within_or_over_part14805_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000800000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_within_or_over_part14805( FOLLOW_LEFT_PAREN_in_within_or_over_part14805_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_order_by_clause_in_within_or_over_part14807_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_order_by_clause_in_within_or_over_part14807( FOLLOW_order_by_clause_in_within_or_over_part14807_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_within_or_over_part14809_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_within_or_over_part14809( FOLLOW_RIGHT_PAREN_in_within_or_over_part14809_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_over_clause_in_within_or_over_part14820_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_over_clause_in_within_or_over_part14820( FOLLOW_over_clause_in_within_or_over_part14820_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_cost_key_in_cost_matrix_clause14840_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000800) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_cost_key_in_cost_matrix_clause14840( FOLLOW_cost_key_in_cost_matrix_clause14840_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_model_key_in_cost_matrix_clause14852_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_model_key_in_cost_matrix_clause14852( FOLLOW_model_key_in_cost_matrix_clause14852_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_auto_key_in_cost_matrix_clause14854_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_auto_key_in_cost_matrix_clause14854( FOLLOW_auto_key_in_cost_matrix_clause14854_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_cost_matrix_clause14866_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_cost_matrix_clause14866( FOLLOW_LEFT_PAREN_in_cost_matrix_clause14866_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_cost_class_name_in_cost_matrix_clause14868_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_cost_class_name_in_cost_matrix_clause14868( FOLLOW_cost_class_name_in_cost_matrix_clause14868_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_cost_matrix_clause14871_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_COMMA_in_cost_matrix_clause14871( FOLLOW_COMMA_in_cost_matrix_clause14871_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_cost_class_name_in_cost_matrix_clause14874_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_cost_class_name_in_cost_matrix_clause14874( FOLLOW_cost_class_name_in_cost_matrix_clause14874_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_cost_matrix_clause14878_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x8000000000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_cost_matrix_clause14878( FOLLOW_RIGHT_PAREN_in_cost_matrix_clause14878_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_values_key_in_cost_matrix_clause14880_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_values_key_in_cost_matrix_clause14880( FOLLOW_values_key_in_cost_matrix_clause14880_bits, 4 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_expression_list_in_cost_matrix_clause14896_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_expression_list_in_cost_matrix_clause14896( FOLLOW_expression_list_in_cost_matrix_clause14896_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_passing_key_in_xml_passing_clause14922_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258612), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_passing_key_in_xml_passing_clause14922( FOLLOW_passing_key_in_xml_passing_clause14922_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_by_key_in_xml_passing_clause14926_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_by_key_in_xml_passing_clause14926( FOLLOW_by_key_in_xml_passing_clause14926_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_value_key_in_xml_passing_clause14929_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_value_key_in_xml_passing_clause14929( FOLLOW_value_key_in_xml_passing_clause14929_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_expression_wrapper_in_xml_passing_clause14945_bits[]	= { ANTLR_UINT64_LIT(0x0180000000000000), ANTLR_UINT64_LIT(0x0002000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x0000000000000020) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_expression_wrapper_in_xml_passing_clause14945( FOLLOW_expression_wrapper_in_xml_passing_clause14945_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_column_alias_in_xml_passing_clause14947_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_column_alias_in_xml_passing_clause14947( FOLLOW_column_alias_in_xml_passing_clause14947_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_xml_passing_clause14951_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_COMMA_in_xml_passing_clause14951( FOLLOW_COMMA_in_xml_passing_clause14951_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_expression_wrapper_in_xml_passing_clause14954_bits[]	= { ANTLR_UINT64_LIT(0x0180000000000002), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x0000000000000020) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_expression_wrapper_in_xml_passing_clause14954( FOLLOW_expression_wrapper_in_xml_passing_clause14954_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_column_alias_in_xml_passing_clause14956_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_column_alias_in_xml_passing_clause14956( FOLLOW_column_alias_in_xml_passing_clause14956_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_xmlattributes_key_in_xml_attributes_clause14978_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_xmlattributes_key_in_xml_attributes_clause14978( FOLLOW_xmlattributes_key_in_xml_attributes_clause14978_bits, 4 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_xml_attributes_clause14989_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_xml_attributes_clause14989( FOLLOW_LEFT_PAREN_in_xml_attributes_clause14989_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_entityescaping_key_in_xml_attributes_clause15004_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_entityescaping_key_in_xml_attributes_clause15004( FOLLOW_entityescaping_key_in_xml_attributes_clause15004_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_noentityescaping_key_in_xml_attributes_clause15006_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_noentityescaping_key_in_xml_attributes_clause15006( FOLLOW_noentityescaping_key_in_xml_attributes_clause15006_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_schemacheck_key_in_xml_attributes_clause15023_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_schemacheck_key_in_xml_attributes_clause15023( FOLLOW_schemacheck_key_in_xml_attributes_clause15023_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_noschemacheck_key_in_xml_attributes_clause15025_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_noschemacheck_key_in_xml_attributes_clause15025( FOLLOW_noschemacheck_key_in_xml_attributes_clause15025_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_xml_multiuse_expression_element_in_xml_attributes_clause15041_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_xml_multiuse_expression_element_in_xml_attributes_clause15041( FOLLOW_xml_multiuse_expression_element_in_xml_attributes_clause15041_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_xml_attributes_clause15044_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_COMMA_in_xml_attributes_clause15044( FOLLOW_COMMA_in_xml_attributes_clause15044_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_xml_multiuse_expression_element_in_xml_attributes_clause15047_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_xml_multiuse_expression_element_in_xml_attributes_clause15047( FOLLOW_xml_multiuse_expression_element_in_xml_attributes_clause15047_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_xml_attributes_clause15059_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_xml_attributes_clause15059( FOLLOW_RIGHT_PAREN_in_xml_attributes_clause15059_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_xmlnamespaces_key_in_xml_namespaces_clause15079_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_xmlnamespaces_key_in_xml_namespaces_clause15079( FOLLOW_xmlnamespaces_key_in_xml_namespaces_clause15079_bits, 4 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_xml_namespaces_clause15090_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000012), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000001001), ANTLR_UINT64_LIT(0x080204000C250412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_xml_namespaces_clause15090( FOLLOW_LEFT_PAREN_in_xml_namespaces_clause15090_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_xml_namespaces_clause15105_bits[]	= { ANTLR_UINT64_LIT(0x0180000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x0000000000000020) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_xml_namespaces_clause15105( FOLLOW_concatenation_wrapper_in_xml_namespaces_clause15105_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_column_alias_in_xml_namespaces_clause15107_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000), ANTLR_UINT64_LIT(0x0000000000040000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_column_alias_in_xml_namespaces_clause15107( FOLLOW_column_alias_in_xml_namespaces_clause15107_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_xml_namespaces_clause15128_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080204000C250412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_COMMA_in_xml_namespaces_clause15128( FOLLOW_COMMA_in_xml_namespaces_clause15128_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_xml_namespaces_clause15131_bits[]	= { ANTLR_UINT64_LIT(0x0180000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x0000000000000020) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_xml_namespaces_clause15131( FOLLOW_concatenation_wrapper_in_xml_namespaces_clause15131_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_column_alias_in_xml_namespaces_clause15133_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000), ANTLR_UINT64_LIT(0x0000000000040000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_column_alias_in_xml_namespaces_clause15133( FOLLOW_column_alias_in_xml_namespaces_clause15133_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_xml_general_default_part_in_xml_namespaces_clause15155_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_xml_general_default_part_in_xml_namespaces_clause15155( FOLLOW_xml_general_default_part_in_xml_namespaces_clause15155_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_xml_namespaces_clause15167_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_xml_namespaces_clause15167( FOLLOW_RIGHT_PAREN_in_xml_namespaces_clause15167_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_xml_column_name_in_xml_table_column15187_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x0000000020010000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_xml_column_name_in_xml_table_column15187( FOLLOW_xml_column_name_in_xml_table_column15187_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_for_key_in_xml_table_column15198_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_for_key_in_xml_table_column15198( FOLLOW_for_key_in_xml_table_column15198_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_ordinality_key_in_xml_table_column15200_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_ordinality_key_in_xml_table_column15200( FOLLOW_ordinality_key_in_xml_table_column15200_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_type_spec_in_xml_table_column15211_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x0000000000040000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_type_spec_in_xml_table_column15211( FOLLOW_type_spec_in_xml_table_column15211_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_path_key_in_xml_table_column15214_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080204000C250412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_path_key_in_xml_table_column15214( FOLLOW_path_key_in_xml_table_column15214_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_xml_table_column15216_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000040000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_xml_table_column15216( FOLLOW_concatenation_wrapper_in_xml_table_column15216_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_xml_general_default_part_in_xml_table_column15226_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_xml_general_default_part_in_xml_table_column15226( FOLLOW_xml_general_default_part_in_xml_table_column15226_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_default_key_in_xml_general_default_part15282_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080204000C250412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_default_key_in_xml_general_default_part15282( FOLLOW_default_key_in_xml_general_default_part15282_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_xml_general_default_part15285_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_xml_general_default_part15285( FOLLOW_concatenation_wrapper_in_xml_general_default_part15285_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_expression_in_xml_multiuse_expression_element15313_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000020) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_expression_in_xml_multiuse_expression_element15313( FOLLOW_expression_in_xml_multiuse_expression_element15313_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_as_key_in_xml_multiuse_expression_element15316_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_as_key_in_xml_multiuse_expression_element15316( FOLLOW_as_key_in_xml_multiuse_expression_element15316_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_xml_multiuse_expression_element15319_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_id_expression_in_xml_multiuse_expression_element15319( FOLLOW_id_expression_in_xml_multiuse_expression_element15319_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_evalname_key_in_xml_multiuse_expression_element15324_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080204000C250412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_evalname_key_in_xml_multiuse_expression_element15324( FOLLOW_evalname_key_in_xml_multiuse_expression_element15324_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_concatenation_in_xml_multiuse_expression_element15326_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_concatenation_in_xml_multiuse_expression_element15326( FOLLOW_concatenation_in_xml_multiuse_expression_element15326_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_version_key_in_xmlroot_param_version_part15437_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_version_key_in_xmlroot_param_version_part15437( FOLLOW_version_key_in_xmlroot_param_version_part15437_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_no_key_in_xmlroot_param_version_part15441_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_no_key_in_xmlroot_param_version_part15441( FOLLOW_no_key_in_xmlroot_param_version_part15441_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_value_key_in_xmlroot_param_version_part15443_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_value_key_in_xmlroot_param_version_part15443( FOLLOW_value_key_in_xmlroot_param_version_part15443_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_expression_wrapper_in_xmlroot_param_version_part15445_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_expression_wrapper_in_xmlroot_param_version_part15445( FOLLOW_expression_wrapper_in_xmlroot_param_version_part15445_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_standalone_key_in_xmlroot_param_standalone_part15466_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_standalone_key_in_xmlroot_param_standalone_part15466( FOLLOW_standalone_key_in_xmlroot_param_standalone_part15466_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_yes_key_in_xmlroot_param_standalone_part15470_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_yes_key_in_xmlroot_param_standalone_part15470( FOLLOW_yes_key_in_xmlroot_param_standalone_part15470_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_no_key_in_xmlroot_param_standalone_part15472_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_no_key_in_xmlroot_param_standalone_part15472( FOLLOW_no_key_in_xmlroot_param_standalone_part15472_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_value_key_in_xmlroot_param_standalone_part15474_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_value_key_in_xmlroot_param_standalone_part15474( FOLLOW_value_key_in_xmlroot_param_standalone_part15474_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_encoding_key_in_xmlserialize_param_enconding_part15496_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080204000C250412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_encoding_key_in_xmlserialize_param_enconding_part15496( FOLLOW_encoding_key_in_xmlserialize_param_enconding_part15496_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_xmlserialize_param_enconding_part15499_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_xmlserialize_param_enconding_part15499( FOLLOW_concatenation_wrapper_in_xmlserialize_param_enconding_part15499_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_version_key_in_xmlserialize_param_version_part15519_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080204000C250412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_version_key_in_xmlserialize_param_version_part15519( FOLLOW_version_key_in_xmlserialize_param_version_part15519_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_xmlserialize_param_version_part15522_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_xmlserialize_param_version_part15522( FOLLOW_concatenation_wrapper_in_xmlserialize_param_version_part15522_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_no_key_in_xmlserialize_param_ident_part15542_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_no_key_in_xmlserialize_param_ident_part15542( FOLLOW_no_key_in_xmlserialize_param_ident_part15542_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_indent_key_in_xmlserialize_param_ident_part15544_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_indent_key_in_xmlserialize_param_ident_part15544( FOLLOW_indent_key_in_xmlserialize_param_ident_part15544_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_indent_key_in_xmlserialize_param_ident_part15555_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0040000000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_indent_key_in_xmlserialize_param_ident_part15555( FOLLOW_indent_key_in_xmlserialize_param_ident_part15555_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_size_key_in_xmlserialize_param_ident_part15559_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_size_key_in_xmlserialize_param_ident_part15559( FOLLOW_size_key_in_xmlserialize_param_ident_part15559_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_EQUALS_OP_in_xmlserialize_param_ident_part15562_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080204000C250412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_EQUALS_OP_in_xmlserialize_param_ident_part15562( FOLLOW_EQUALS_OP_in_xmlserialize_param_ident_part15562_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_xmlserialize_param_ident_part15565_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_xmlserialize_param_ident_part15565( FOLLOW_concatenation_wrapper_in_xmlserialize_param_ident_part15565_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_order_key_in_synpred1_OracleDML1009_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x0000000000000200) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_order_key_in_synpred1_OracleDML1009( FOLLOW_order_key_in_synpred1_OracleDML1009_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_siblings_key_in_synpred1_OracleDML1011_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000200) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_siblings_key_in_synpred1_OracleDML1011( FOLLOW_siblings_key_in_synpred1_OracleDML1011_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_by_key_in_synpred1_OracleDML1014_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_by_key_in_synpred1_OracleDML1014( FOLLOW_by_key_in_synpred1_OracleDML1014_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_distinct_key_in_synpred2_OracleDML1628_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_distinct_key_in_synpred2_OracleDML1628( FOLLOW_distinct_key_in_synpred2_OracleDML1628_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_unique_key_in_synpred2_OracleDML1630_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_unique_key_in_synpred2_OracleDML1630( FOLLOW_unique_key_in_synpred2_OracleDML1630_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_all_key_in_synpred2_OracleDML1632_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_all_key_in_synpred2_OracleDML1632( FOLLOW_all_key_in_synpred2_OracleDML1632_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_tableview_name_in_synpred3_OracleDML1869_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000004) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_tableview_name_in_synpred3_OracleDML1869( FOLLOW_tableview_name_in_synpred3_OracleDML1869_bits, 6 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_synpred3_OracleDML1871_bits[]	= { ANTLR_UINT64_LIT(0x0000000000080000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_PERIOD_in_synpred3_OracleDML1871( FOLLOW_PERIOD_in_synpred3_OracleDML1871_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_ASTERISK_in_synpred3_OracleDML1873_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_ASTERISK_in_synpred3_OracleDML1873( FOLLOW_ASTERISK_in_synpred3_OracleDML1873_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_synpred4_OracleDML2081_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0020000000000000), ANTLR_UINT64_LIT(0x0000000000000008) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_synpred4_OracleDML2081( FOLLOW_LEFT_PAREN_in_synpred4_OracleDML2081_bits, 9 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_select_key_in_synpred4_OracleDML2084_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_select_key_in_synpred4_OracleDML2084( FOLLOW_select_key_in_synpred4_OracleDML2084_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_with_key_in_synpred4_OracleDML2086_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_with_key_in_synpred4_OracleDML2086( FOLLOW_with_key_in_synpred4_OracleDML2086_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_synpred5_OracleDML2104_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_synpred5_OracleDML2104( FOLLOW_LEFT_PAREN_in_synpred5_OracleDML2104_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_only_key_in_synpred6_OracleDML2121_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_only_key_in_synpred6_OracleDML2121( FOLLOW_only_key_in_synpred6_OracleDML2121_bits, 4 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_synpred6_OracleDML2123_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_synpred6_OracleDML2123( FOLLOW_LEFT_PAREN_in_synpred6_OracleDML2123_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_synpred10_OracleDML2837_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0020000000000000), ANTLR_UINT64_LIT(0x0000000000000008) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_synpred10_OracleDML2837( FOLLOW_LEFT_PAREN_in_synpred10_OracleDML2837_bits, 9 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_select_key_in_synpred10_OracleDML2840_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_select_key_in_synpred10_OracleDML2840( FOLLOW_select_key_in_synpred10_OracleDML2840_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_with_key_in_synpred10_OracleDML2842_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_with_key_in_synpred10_OracleDML2842( FOLLOW_with_key_in_synpred10_OracleDML2842_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_synpred11_OracleDML2864_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_synpred11_OracleDML2864( FOLLOW_LEFT_PAREN_in_synpred11_OracleDML2864_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_select_key_in_synpred12_OracleDML3352_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_select_key_in_synpred12_OracleDML3352( FOLLOW_select_key_in_synpred12_OracleDML3352_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_any_key_in_synpred13_OracleDML3378_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_any_key_in_synpred13_OracleDML3378( FOLLOW_any_key_in_synpred13_OracleDML3378_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_synpred14_OracleDML3583_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_synpred14_OracleDML3583( FOLLOW_LEFT_PAREN_in_synpred14_OracleDML3583_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_synpred15_OracleDML3956_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_synpred15_OracleDML3956( FOLLOW_LEFT_PAREN_in_synpred15_OracleDML3956_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_group_key_in_synpred16_OracleDML4187_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_group_key_in_synpred16_OracleDML4187( FOLLOW_group_key_in_synpred16_OracleDML4187_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_synpred17_OracleDML4213_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_COMMA_in_synpred17_OracleDML4213( FOLLOW_COMMA_in_synpred17_OracleDML4213_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_group_by_elements_in_synpred17_OracleDML4215_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_group_by_elements_in_synpred17_OracleDML4215( FOLLOW_group_by_elements_in_synpred17_OracleDML4215_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_having_key_in_synpred18_OracleDML4267_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_having_key_in_synpred18_OracleDML4267( FOLLOW_having_key_in_synpred18_OracleDML4267_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_synpred19_OracleDML4298_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080206000C258412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_COMMA_in_synpred19_OracleDML4298( FOLLOW_COMMA_in_synpred19_OracleDML4298_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_group_by_elements_in_synpred19_OracleDML4300_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_group_by_elements_in_synpred19_OracleDML4300( FOLLOW_group_by_elements_in_synpred19_OracleDML4300_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_rollup_key_in_synpred20_OracleDML4519_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_rollup_key_in_synpred20_OracleDML4519( FOLLOW_rollup_key_in_synpred20_OracleDML4519_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_cube_key_in_synpred20_OracleDML4521_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_cube_key_in_synpred20_OracleDML4521( FOLLOW_cube_key_in_synpred20_OracleDML4521_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_synpred21_OracleDML4537_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_synpred21_OracleDML4537( FOLLOW_LEFT_PAREN_in_synpred21_OracleDML4537_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_all_key_in_synpred22_OracleDML5204_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_all_key_in_synpred22_OracleDML5204( FOLLOW_all_key_in_synpred22_OracleDML5204_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_when_key_in_synpred23_OracleDML6678_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_when_key_in_synpred23_OracleDML6678( FOLLOW_when_key_in_synpred23_OracleDML6678_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_matched_key_in_synpred23_OracleDML6680_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_matched_key_in_synpred23_OracleDML6680( FOLLOW_matched_key_in_synpred23_OracleDML6680_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_when_key_in_synpred24_OracleDML6710_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_when_key_in_synpred24_OracleDML6710( FOLLOW_when_key_in_synpred24_OracleDML6710_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_not_key_in_synpred24_OracleDML6712_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_not_key_in_synpred24_OracleDML6712( FOLLOW_not_key_in_synpred24_OracleDML6712_bits, 7 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_matched_key_in_synpred24_OracleDML6714_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_matched_key_in_synpred24_OracleDML6714( FOLLOW_matched_key_in_synpred24_OracleDML6714_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_synpred25_OracleDML7616_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_synpred25_OracleDML7616( FOLLOW_LEFT_PAREN_in_synpred25_OracleDML7616_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_unlimited_key_in_synpred26_OracleDML7707_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_unlimited_key_in_synpred26_OracleDML7707( FOLLOW_unlimited_key_in_synpred26_OracleDML7707_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_synpred27_OracleDML7864_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0020000000000000), ANTLR_UINT64_LIT(0x0000000000000008) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_synpred27_OracleDML7864( FOLLOW_LEFT_PAREN_in_synpred27_OracleDML7864_bits, 9 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_select_key_in_synpred27_OracleDML7867_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_select_key_in_synpred27_OracleDML7867( FOLLOW_select_key_in_synpred27_OracleDML7867_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_with_key_in_synpred27_OracleDML7871_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_with_key_in_synpred27_OracleDML7871( FOLLOW_with_key_in_synpred27_OracleDML7871_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_cursor_key_in_synpred28_OracleDML8351_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_cursor_key_in_synpred28_OracleDML8351( FOLLOW_cursor_key_in_synpred28_OracleDML8351_bits, 4 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_synpred28_OracleDML8353_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0020000000000000), ANTLR_UINT64_LIT(0x0000000000000008) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_synpred28_OracleDML8353( FOLLOW_LEFT_PAREN_in_synpred28_OracleDML8353_bits, 9 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_select_key_in_synpred28_OracleDML8356_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_select_key_in_synpred28_OracleDML8356( FOLLOW_select_key_in_synpred28_OracleDML8356_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_with_key_in_synpred28_OracleDML8358_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_with_key_in_synpred28_OracleDML8358( FOLLOW_with_key_in_synpred28_OracleDML8358_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_synpred29_OracleDML9738_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0020000000000000), ANTLR_UINT64_LIT(0x0000000000000008) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_synpred29_OracleDML9738( FOLLOW_LEFT_PAREN_in_synpred29_OracleDML9738_bits, 9 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_select_key_in_synpred29_OracleDML9742_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_select_key_in_synpred29_OracleDML9742( FOLLOW_select_key_in_synpred29_OracleDML9742_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_with_key_in_synpred29_OracleDML9744_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_with_key_in_synpred29_OracleDML9744( FOLLOW_with_key_in_synpred29_OracleDML9744_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_interval_expression_in_synpred30_OracleDML10252_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_interval_expression_in_synpred30_OracleDML10252( FOLLOW_interval_expression_in_synpred30_OracleDML10252_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_any_key_in_synpred31_OracleDML10492_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_any_key_in_synpred31_OracleDML10492( FOLLOW_any_key_in_synpred31_OracleDML10492_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_any_key_in_synpred32_OracleDML10507_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_any_key_in_synpred32_OracleDML10507( FOLLOW_any_key_in_synpred32_OracleDML10507_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_select_key_in_synpred33_OracleDML10861_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_select_key_in_synpred33_OracleDML10861( FOLLOW_select_key_in_synpred33_OracleDML10861_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_synpred34_OracleDML10885_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_synpred34_OracleDML10885( FOLLOW_LEFT_PAREN_in_synpred34_OracleDML10885_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_new_key_in_synpred39_OracleDML11095_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080204000C250412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_new_key_in_synpred39_OracleDML11095( FOLLOW_new_key_in_synpred39_OracleDML11095_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_unary_expression_in_synpred39_OracleDML11098_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_unary_expression_in_synpred39_OracleDML11098( FOLLOW_unary_expression_in_synpred39_OracleDML11098_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_all_key_in_synpred41_OracleDML11123_bits[]	= { ANTLR_UINT64_LIT(0x0180000400002000), ANTLR_UINT64_LIT(0x0002000000000002), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0200000040000004), ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800000300), ANTLR_UINT64_LIT(0x0000000000000001), ANTLR_UINT64_LIT(0x080204000C250412), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_all_key_in_synpred41_OracleDML11123( FOLLOW_all_key_in_synpred41_OracleDML11123_bits, 10 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_unary_expression_in_synpred41_OracleDML11126_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_unary_expression_in_synpred41_OracleDML11126( FOLLOW_unary_expression_in_synpred41_OracleDML11126_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_case_statement_in_synpred42_OracleDML11139_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_case_statement_in_synpred42_OracleDML11139( FOLLOW_case_statement_in_synpred42_OracleDML11139_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_quantified_expression_in_synpred43_OracleDML11151_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_quantified_expression_in_synpred43_OracleDML11151( FOLLOW_quantified_expression_in_synpred43_OracleDML11151_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_standard_function_in_synpred44_OracleDML11162_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_standard_function_in_synpred44_OracleDML11162( FOLLOW_standard_function_in_synpred44_OracleDML11162_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_label_name_in_synpred45_OracleDML11219_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_label_name_in_synpred45_OracleDML11219( FOLLOW_label_name_in_synpred45_OracleDML11219_bits, 8 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_case_key_in_synpred45_OracleDML11222_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_case_key_in_synpred45_OracleDML11222( FOLLOW_case_key_in_synpred45_OracleDML11222_bits, 9 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_when_key_in_synpred45_OracleDML11224_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_when_key_in_synpred45_OracleDML11224( FOLLOW_when_key_in_synpred45_OracleDML11224_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_table_element_in_synpred46_OracleDML11592_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_table_element_in_synpred46_OracleDML11592( FOLLOW_table_element_in_synpred46_OracleDML11592_bits, 4 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_outer_join_sign_in_synpred46_OracleDML11594_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_outer_join_sign_in_synpred46_OracleDML11594( FOLLOW_outer_join_sign_in_synpred46_OracleDML11594_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_constant_in_synpred48_OracleDML11623_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_constant_in_synpred48_OracleDML11623( FOLLOW_constant_in_synpred48_OracleDML11623_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_general_element_in_synpred49_OracleDML11634_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_general_element_in_synpred49_OracleDML11634( FOLLOW_general_element_in_synpred49_OracleDML11634_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_select_key_in_synpred50_OracleDML11674_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_select_key_in_synpred50_OracleDML11674( FOLLOW_select_key_in_synpred50_OracleDML11674_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_with_key_in_synpred50_OracleDML11678_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_with_key_in_synpred50_OracleDML11678( FOLLOW_with_key_in_synpred50_OracleDML11678_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_synpred51_OracleDML11957_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0020000000000000), ANTLR_UINT64_LIT(0x0000000000000008) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_synpred51_OracleDML11957( FOLLOW_LEFT_PAREN_in_synpred51_OracleDML11957_bits, 9 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_select_key_in_synpred51_OracleDML11960_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_select_key_in_synpred51_OracleDML11960( FOLLOW_select_key_in_synpred51_OracleDML11960_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_with_key_in_synpred51_OracleDML11962_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_with_key_in_synpred51_OracleDML11962( FOLLOW_with_key_in_synpred51_OracleDML11962_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_multiset_key_in_synpred52_OracleDML12279_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_multiset_key_in_synpred52_OracleDML12279( FOLLOW_multiset_key_in_synpred52_OracleDML12279_bits, 4 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_synpred52_OracleDML12281_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0020000000000000), ANTLR_UINT64_LIT(0x0000000000000008) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_synpred52_OracleDML12281( FOLLOW_LEFT_PAREN_in_synpred52_OracleDML12281_bits, 9 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_select_key_in_synpred52_OracleDML12285_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_select_key_in_synpred52_OracleDML12285( FOLLOW_select_key_in_synpred52_OracleDML12285_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_with_key_in_synpred52_OracleDML12287_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_with_key_in_synpred52_OracleDML12287( FOLLOW_with_key_in_synpred52_OracleDML12287_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_default_key_in_synpred53_OracleDML15151_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_default_key_in_synpred53_OracleDML15151( FOLLOW_default_key_in_synpred53_OracleDML15151_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: OracleDML  */
static	ANTLR_BITWORD FOLLOW_default_key_in_synpred54_OracleDML15222_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  OracleDMLImplTraits::BitsetListType FOLLOW_default_key_in_synpred54_OracleDML15222( FOLLOW_default_key_in_synpred54_OracleDML15222_bits, 1 );



/* =========================================================================
 * DFA tables for the parser
 */
/** Static dfa state tables for Cyclic dfa:
 *    174:70: ( nulls_key last_key )?
 */
static const ANTLR_INT32 dfa18_eot[54] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa18_eof[54] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa18_min[54] =
    {
	68, 113, -1, 68, -1, 113, 113, 113, 68, 68, 113, 68, 68, 113, 113, -1, 
	113, 113, 113, 113, 113, 113, 113, 68, 68, 113, 68, 68, 113, 68, 68, 113, 
	113, 113, 113, 113, 113, 113, 113, 113, 113, 68, 68, 113, 68, 68, 113, 
	113, 113, 113, 113, 113, 68, 68
    };
static const ANTLR_INT32 dfa18_max[54] =
    {
	384, 384, -1, 501, -1, 384, 384, 384, 468, 468, 384, 501, 501, 384, 384, 
	-1, 384, 384, 384, 384, 384, 384, 384, 501, 501, 384, 506, 506, 384, 453, 
	453, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 501, 501, 384, 506, 
	506, 384, 384, 384, 384, 384, 384, 506, 506
    };
static const ANTLR_INT32 dfa18_accept[54] =
    {
	-1, -1, 2, -1, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa18_special[54] =
    {
	48, 34, -1, 8, -1, 12, 17, 18, 10, 1, 40, 7, 4, 47, 44, -1, 43, 36, 15, 
	35, 46, 26, 30, 32, 25, 41, 37, 49, 0, 3, 6, 29, 39, 27, 14, 23, 45, 38, 
	16, 9, 5, 24, 33, 31, 20, 50, 21, 28, 13, 22, 42, 2, 11, 19
    };

/** Used when there is no transition table entry for a particular state */
static const ANTLR_INT32* dfa18_T_empty	 =   NULL;

static const ANTLR_INT32 dfa18_T0[] =
    {
	40, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 39
    };

static const ANTLR_INT32 dfa18_T1[] =
    {
	15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 15, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, 4, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 15
    };

static const ANTLR_INT32 dfa18_T2[] =
    {
	30, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 46, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 29
    };

static const ANTLR_INT32 dfa18_T3[] =
    {
	4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 15, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, 15
    };

static const ANTLR_INT32 dfa18_T4[] =
    {
	20, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 15, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 18, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 19, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 15
    };

static const ANTLR_INT32 dfa18_T5[] =
    {
	5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 4
    };

static const ANTLR_INT32 dfa18_T6[] =
    {
	15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 49, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 15, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, 4
    };

static const ANTLR_INT32 dfa18_T7[] =
    {
	9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 7, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 8
    };

static const ANTLR_INT32 dfa18_T8[] =
    {
	27, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 43, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 26
    };

static const ANTLR_INT32 dfa18_T9[] =
    {
	12, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 22, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 11
    };

static const ANTLR_INT32 dfa18_T10[] =
    {
	24, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 23
    };

static const ANTLR_INT32 dfa18_T11[] =
    {
	45, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 44
    };

static const ANTLR_INT32 dfa18_T12[] =
    {
	12, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 10, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 11
    };

static const ANTLR_INT32 dfa18_T13[] =
    {
	14, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 13
    };

static const ANTLR_INT32 dfa18_T14[] =
    {
	51, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 50
    };

static const ANTLR_INT32 dfa18_T15[] =
    {
	53, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 52
    };

static const ANTLR_INT32 dfa18_T16[] =
    {
	42, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 41
    };

static const ANTLR_INT32 dfa18_T17[] =
    {
	20, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 15, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 35, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 19, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 15
    };

static const ANTLR_INT32 dfa18_T18[] =
    {
	32, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 31
    };

static const ANTLR_INT32 dfa18_T19[] =
    {
	9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 21, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 8
    };

static const ANTLR_INT32 dfa18_T20[] =
    {
	34, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 33
    };

static const ANTLR_INT32 dfa18_T21[] =
    {
	48, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 47
    };

static const ANTLR_INT32 dfa18_T22[] =
    {
	4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 4, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 3
    };

static const ANTLR_INT32 dfa18_T23[] =
    {
	27, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 25, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 26
    };

static const ANTLR_INT32 dfa18_T24[] =
    {
	15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 38, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 15, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, 4
    };

static const ANTLR_INT32 dfa18_T25[] =
    {
	17, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 16
    };

static const ANTLR_INT32 dfa18_T26[] =
    {
	37, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 36
    };

static const ANTLR_INT32 dfa18_T27[] =
    {
	30, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 28, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 29
    };

static const ANTLR_INT32 dfa18_T28[] =
    {
	2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1
    };


/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR_INT32 * const dfa18_transitions[] =
{
    dfa18_T28, dfa18_T22, NULL, dfa18_T5, NULL, dfa18_T7, dfa18_T12, dfa18_T13, 
    dfa18_T1, dfa18_T1, dfa18_T25, dfa18_T4, dfa18_T4, dfa18_T19, dfa18_T19, 
    NULL, dfa18_T9, dfa18_T9, dfa18_T10, dfa18_T23, dfa18_T27, dfa18_T18, 
    dfa18_T20, dfa18_T17, dfa18_T17, dfa18_T26, dfa18_T24, dfa18_T24, dfa18_T0, 
    dfa18_T3, dfa18_T3, dfa18_T19, dfa18_T19, dfa18_T9, dfa18_T9, dfa18_T16, 
    dfa18_T8, dfa18_T8, dfa18_T11, dfa18_T2, dfa18_T2, dfa18_T17, dfa18_T17, 
    dfa18_T21, dfa18_T6, dfa18_T6, dfa18_T14, dfa18_T8, dfa18_T8, dfa18_T15, 
    dfa18_T2, dfa18_T2, dfa18_T6, dfa18_T6
};


/* Declare tracking structure for Cyclic DFA 18
 */
class OracleDMLCyclicDFA18 : public CyclicDFA< OracleDMLImplTraits, OracleDML >, public OracleDMLTokens
{
public:
	typedef CyclicDFA< OracleDMLImplTraits, OracleDML >  BaseType;
	typedef BaseType::ContextType CtxType;

private:
	//to maintain C-Target compatibility, we need to make some of ctx functions look like member funcs
	CtxType*	m_ctx; 
	

public:
	OracleDMLCyclicDFA18( ANTLR_INT32	decisionNumber
					, const ANTLR_UCHAR*	description
					, const ANTLR_INT32* const	eot
					, const ANTLR_INT32* const	eof
					, const ANTLR_INT32* const	min
					, const ANTLR_INT32* const	max
					, const ANTLR_INT32* const	accept
					, const ANTLR_INT32* const	special
					, const ANTLR_INT32* const *const	transition)
					:BaseType( decisionNumber, description, eot, eof, min, max, accept,
								special, transition )
	{
		m_ctx = NULL;
		
	}

    ANTLR_UINT32 LA(ANTLR_INT32 i)
    {
        return m_ctx->LA(i);
    }

    const CtxType::CommonTokenType*  LT(ANTLR_INT32 k)
    {
        return m_ctx->LT(k);
    }
    template<typename PredType>
    bool msynpred( PredType pred )
    {
        return m_ctx->msynpred(pred);
    }

	ANTLR_INT32  specialStateTransition(CtxType * ctx, RecognizerType* recognizer, IntStreamType* is, ANTLR_INT32 s)
	{
	    ANTLR_INT32    _s;

	    m_ctx = ctx;
	    _s	    = s;
	    switch  (s)
	    {
	    	    case 0:

	    		{
	    		    ANTLR_UINT32 LA18_28;

	    		    ANTLR_MARKER index18_28;


	    		    LA18_28 = ctx->LA(1);

	    		     
	    		        index18_28 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA18_28 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 39;
	    		    }

	    		    else if ( (LA18_28 == DELIMITED_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 40;
	    		    }

	    			 
	    				ctx->seek(index18_28);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 1:

	    		{
	    		    ANTLR_UINT32 LA18_9;

	    		    ANTLR_MARKER index18_9;


	    		    LA18_9 = ctx->LA(1);

	    		     
	    		        index18_9 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA18_9 == COMMA || LA18_9 == PERIOD || LA18_9 == REGULAR_ID || LA18_9 == SQL92_RESERVED_ASC || LA18_9 == SQL92_RESERVED_DESC) && ((toUpper(LT(1)->getText()) == "NULLS")) )
	    		    {
	    		        s = 15;
	    		    }

	    		    else if ( (LA18_9 == LEFT_PAREN || LA18_9 == SQL92_RESERVED_AS) && ((toUpper(LT(1)->getText()) == "SET")) )
	    		    {
	    		        s = 4;
	    		    }

	    			 
	    				ctx->seek(index18_9);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 2:

	    		{
	    		    ANTLR_UINT32 LA18_51;

	    		    ANTLR_MARKER index18_51;


	    		    LA18_51 = ctx->LA(1);

	    		     
	    		        index18_51 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA18_51 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 29;
	    		    }

	    		    else if ( (LA18_51 == DELIMITED_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 30;
	    		    }

	    		    else if ( (LA18_51 == PERIOD) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 46;
	    		    }

	    			 
	    				ctx->seek(index18_51);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 3:

	    		{
	    		    ANTLR_UINT32 LA18_29;

	    		    ANTLR_MARKER index18_29;


	    		    LA18_29 = ctx->LA(1);

	    		     
	    		        index18_29 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA18_29 == LEFT_PAREN || LA18_29 == SQL92_RESERVED_AS) && ((toUpper(LT(1)->getText()) == "NULLS")) )
	    		    {
	    		        s = 15;
	    		    }

	    		    else if ( (LA18_29 == COMMA || LA18_29 == PERIOD || LA18_29 == REGULAR_ID) && ((toUpper(LT(1)->getText()) == "SET")) )
	    		    {
	    		        s = 4;
	    		    }

	    			 
	    				ctx->seek(index18_29);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 4:

	    		{
	    		    ANTLR_UINT32 LA18_12;

	    		    ANTLR_MARKER index18_12;


	    		    LA18_12 = ctx->LA(1);

	    		     
	    		        index18_12 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA18_12 == PERIOD) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 18;
	    		    }

	    		    else if ( (LA18_12 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 19;
	    		    }

	    		    else if ( (LA18_12 == COMMA) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 20;
	    		    }

	    		    else if ( (LA18_12 == LEFT_PAREN || LA18_12 == SQL92_RESERVED_SELECT) && ((toUpper(LT(1)->getText()) == "NULLS")) )
	    		    {
	    		        s = 15;
	    		    }

	    			 
	    				ctx->seek(index18_12);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 5:

	    		{
	    		    ANTLR_UINT32 LA18_40;

	    		    ANTLR_MARKER index18_40;


	    		    LA18_40 = ctx->LA(1);

	    		     
	    		        index18_40 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA18_40 == PERIOD) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 46;
	    		    }

	    		    else if ( (LA18_40 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 29;
	    		    }

	    		    else if ( (LA18_40 == DELIMITED_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 30;
	    		    }

	    			 
	    				ctx->seek(index18_40);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 6:

	    		{
	    		    ANTLR_UINT32 LA18_30;

	    		    ANTLR_MARKER index18_30;


	    		    LA18_30 = ctx->LA(1);

	    		     
	    		        index18_30 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA18_30 == LEFT_PAREN || LA18_30 == SQL92_RESERVED_AS) && ((toUpper(LT(1)->getText()) == "NULLS")) )
	    		    {
	    		        s = 15;
	    		    }

	    		    else if ( (LA18_30 == COMMA || LA18_30 == PERIOD || LA18_30 == REGULAR_ID) && ((toUpper(LT(1)->getText()) == "SET")) )
	    		    {
	    		        s = 4;
	    		    }

	    			 
	    				ctx->seek(index18_30);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 7:

	    		{
	    		    ANTLR_UINT32 LA18_11;

	    		    ANTLR_MARKER index18_11;


	    		    LA18_11 = ctx->LA(1);

	    		     
	    		        index18_11 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA18_11 == PERIOD) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 18;
	    		    }

	    		    else if ( (LA18_11 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 19;
	    		    }

	    		    else if ( (LA18_11 == COMMA) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 20;
	    		    }

	    		    else if ( (LA18_11 == LEFT_PAREN || LA18_11 == SQL92_RESERVED_SELECT) && ((toUpper(LT(1)->getText()) == "NULLS")) )
	    		    {
	    		        s = 15;
	    		    }

	    			 
	    				ctx->seek(index18_11);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 8:

	    		{
	    		    ANTLR_UINT32 LA18_3;

	    		    ANTLR_MARKER index18_3;


	    		    LA18_3 = ctx->LA(1);

	    		     
	    		        index18_3 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA18_3 == COMMA) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 5;
	    		    }

	    		    else if ( (LA18_3 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 6;
	    		    }

	    		    else if ( (LA18_3 == LEFT_PAREN || LA18_3 == PERIOD || LA18_3 == SQL92_RESERVED_SELECT) && ((toUpper(LT(1)->getText()) == "SET")) )
	    		    {
	    		        s = 4;
	    		    }

	    			 
	    				ctx->seek(index18_3);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 9:

	    		{
	    		    ANTLR_UINT32 LA18_39;

	    		    ANTLR_MARKER index18_39;


	    		    LA18_39 = ctx->LA(1);

	    		     
	    		        index18_39 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA18_39 == PERIOD) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 46;
	    		    }

	    		    else if ( (LA18_39 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 29;
	    		    }

	    		    else if ( (LA18_39 == DELIMITED_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 30;
	    		    }

	    			 
	    				ctx->seek(index18_39);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 10:

	    		{
	    		    ANTLR_UINT32 LA18_8;

	    		    ANTLR_MARKER index18_8;


	    		    LA18_8 = ctx->LA(1);

	    		     
	    		        index18_8 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA18_8 == COMMA || LA18_8 == PERIOD || LA18_8 == REGULAR_ID || LA18_8 == SQL92_RESERVED_ASC || LA18_8 == SQL92_RESERVED_DESC) && ((toUpper(LT(1)->getText()) == "NULLS")) )
	    		    {
	    		        s = 15;
	    		    }

	    		    else if ( (LA18_8 == LEFT_PAREN || LA18_8 == SQL92_RESERVED_AS) && ((toUpper(LT(1)->getText()) == "SET")) )
	    		    {
	    		        s = 4;
	    		    }

	    			 
	    				ctx->seek(index18_8);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 11:

	    		{
	    		    ANTLR_UINT32 LA18_52;

	    		    ANTLR_MARKER index18_52;


	    		    LA18_52 = ctx->LA(1);

	    		     
	    		        index18_52 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA18_52 == COMMA || LA18_52 == REGULAR_ID) && ((toUpper(LT(1)->getText()) == "NULLS")) )
	    		    {
	    		        s = 15;
	    		    }

	    		    else if ( (LA18_52 == PERIOD) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 49;
	    		    }

	    		    else if ( (LA18_52 == SQL92_RESERVED_TO) && ((toUpper(LT(1)->getText()) == "SET")) )
	    		    {
	    		        s = 4;
	    		    }

	    			 
	    				ctx->seek(index18_52);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 12:

	    		{
	    		    ANTLR_UINT32 LA18_5;

	    		    ANTLR_MARKER index18_5;


	    		    LA18_5 = ctx->LA(1);

	    		     
	    		        index18_5 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA18_5 == INTRODUCER) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 7;
	    		    }

	    		    else if ( (LA18_5 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 8;
	    		    }

	    		    else if ( (LA18_5 == DELIMITED_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 9;
	    		    }

	    			 
	    				ctx->seek(index18_5);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 13:

	    		{
	    		    ANTLR_UINT32 LA18_48;

	    		    ANTLR_MARKER index18_48;


	    		    LA18_48 = ctx->LA(1);

	    		     
	    		        index18_48 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA18_48 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 26;
	    		    }

	    		    else if ( (LA18_48 == DELIMITED_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 27;
	    		    }

	    		    else if ( (LA18_48 == PERIOD) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 43;
	    		    }

	    			 
	    				ctx->seek(index18_48);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 14:

	    		{
	    		    ANTLR_UINT32 LA18_34;

	    		    ANTLR_MARKER index18_34;


	    		    LA18_34 = ctx->LA(1);

	    		     
	    		        index18_34 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA18_34 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 11;
	    		    }

	    		    else if ( (LA18_34 == DELIMITED_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 12;
	    		    }

	    		    else if ( (LA18_34 == PERIOD) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 22;
	    		    }

	    			 
	    				ctx->seek(index18_34);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 15:

	    		{
	    		    ANTLR_UINT32 LA18_18;

	    		    ANTLR_MARKER index18_18;


	    		    LA18_18 = ctx->LA(1);

	    		     
	    		        index18_18 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA18_18 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 23;
	    		    }

	    		    else if ( (LA18_18 == DELIMITED_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 24;
	    		    }

	    			 
	    				ctx->seek(index18_18);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 16:

	    		{
	    		    ANTLR_UINT32 LA18_38;

	    		    ANTLR_MARKER index18_38;


	    		    LA18_38 = ctx->LA(1);

	    		     
	    		        index18_38 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA18_38 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 44;
	    		    }

	    		    else if ( (LA18_38 == DELIMITED_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 45;
	    		    }

	    			 
	    				ctx->seek(index18_38);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 17:

	    		{
	    		    ANTLR_UINT32 LA18_6;

	    		    ANTLR_MARKER index18_6;


	    		    LA18_6 = ctx->LA(1);

	    		     
	    		        index18_6 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA18_6 == INTRODUCER) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 10;
	    		    }

	    		    else if ( (LA18_6 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 11;
	    		    }

	    		    else if ( (LA18_6 == DELIMITED_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 12;
	    		    }

	    			 
	    				ctx->seek(index18_6);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 18:

	    		{
	    		    ANTLR_UINT32 LA18_7;

	    		    ANTLR_MARKER index18_7;


	    		    LA18_7 = ctx->LA(1);

	    		     
	    		        index18_7 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA18_7 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 13;
	    		    }

	    		    else if ( (LA18_7 == DELIMITED_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 14;
	    		    }

	    			 
	    				ctx->seek(index18_7);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 19:

	    		{
	    		    ANTLR_UINT32 LA18_53;

	    		    ANTLR_MARKER index18_53;


	    		    LA18_53 = ctx->LA(1);

	    		     
	    		        index18_53 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA18_53 == COMMA || LA18_53 == REGULAR_ID) && ((toUpper(LT(1)->getText()) == "NULLS")) )
	    		    {
	    		        s = 15;
	    		    }

	    		    else if ( (LA18_53 == PERIOD) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 49;
	    		    }

	    		    else if ( (LA18_53 == SQL92_RESERVED_TO) && ((toUpper(LT(1)->getText()) == "SET")) )
	    		    {
	    		        s = 4;
	    		    }

	    			 
	    				ctx->seek(index18_53);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 20:

	    		{
	    		    ANTLR_UINT32 LA18_44;

	    		    ANTLR_MARKER index18_44;


	    		    LA18_44 = ctx->LA(1);

	    		     
	    		        index18_44 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA18_44 == PERIOD) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 49;
	    		    }

	    		    else if ( (LA18_44 == COMMA || LA18_44 == REGULAR_ID) && ((toUpper(LT(1)->getText()) == "NULLS")) )
	    		    {
	    		        s = 15;
	    		    }

	    		    else if ( (LA18_44 == SQL92_RESERVED_TO) && ((toUpper(LT(1)->getText()) == "SET")) )
	    		    {
	    		        s = 4;
	    		    }

	    			 
	    				ctx->seek(index18_44);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 21:

	    		{
	    		    ANTLR_UINT32 LA18_46;

	    		    ANTLR_MARKER index18_46;


	    		    LA18_46 = ctx->LA(1);

	    		     
	    		        index18_46 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA18_46 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 50;
	    		    }

	    		    else if ( (LA18_46 == DELIMITED_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 51;
	    		    }

	    			 
	    				ctx->seek(index18_46);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 22:

	    		{
	    		    ANTLR_UINT32 LA18_49;

	    		    ANTLR_MARKER index18_49;


	    		    LA18_49 = ctx->LA(1);

	    		     
	    		        index18_49 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA18_49 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 52;
	    		    }

	    		    else if ( (LA18_49 == DELIMITED_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 53;
	    		    }

	    			 
	    				ctx->seek(index18_49);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 23:

	    		{
	    		    ANTLR_UINT32 LA18_35;

	    		    ANTLR_MARKER index18_35;


	    		    LA18_35 = ctx->LA(1);

	    		     
	    		        index18_35 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA18_35 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 41;
	    		    }

	    		    else if ( (LA18_35 == DELIMITED_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 42;
	    		    }

	    			 
	    				ctx->seek(index18_35);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 24:

	    		{
	    		    ANTLR_UINT32 LA18_41;

	    		    ANTLR_MARKER index18_41;


	    		    LA18_41 = ctx->LA(1);

	    		     
	    		        index18_41 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA18_41 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 19;
	    		    }

	    		    else if ( (LA18_41 == COMMA) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 20;
	    		    }

	    		    else if ( (LA18_41 == LEFT_PAREN || LA18_41 == SQL92_RESERVED_SELECT) && ((toUpper(LT(1)->getText()) == "NULLS")) )
	    		    {
	    		        s = 15;
	    		    }

	    		    else if ( (LA18_41 == PERIOD) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 35;
	    		    }

	    			 
	    				ctx->seek(index18_41);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 25:

	    		{
	    		    ANTLR_UINT32 LA18_24;

	    		    ANTLR_MARKER index18_24;


	    		    LA18_24 = ctx->LA(1);

	    		     
	    		        index18_24 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA18_24 == PERIOD) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 35;
	    		    }

	    		    else if ( (LA18_24 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 19;
	    		    }

	    		    else if ( (LA18_24 == COMMA) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 20;
	    		    }

	    		    else if ( (LA18_24 == LEFT_PAREN || LA18_24 == SQL92_RESERVED_SELECT) && ((toUpper(LT(1)->getText()) == "NULLS")) )
	    		    {
	    		        s = 15;
	    		    }

	    			 
	    				ctx->seek(index18_24);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 26:

	    		{
	    		    ANTLR_UINT32 LA18_21;

	    		    ANTLR_MARKER index18_21;


	    		    LA18_21 = ctx->LA(1);

	    		     
	    		        index18_21 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA18_21 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 31;
	    		    }

	    		    else if ( (LA18_21 == DELIMITED_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 32;
	    		    }

	    			 
	    				ctx->seek(index18_21);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 27:

	    		{
	    		    ANTLR_UINT32 LA18_33;

	    		    ANTLR_MARKER index18_33;


	    		    LA18_33 = ctx->LA(1);

	    		     
	    		        index18_33 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA18_33 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 11;
	    		    }

	    		    else if ( (LA18_33 == DELIMITED_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 12;
	    		    }

	    		    else if ( (LA18_33 == PERIOD) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 22;
	    		    }

	    			 
	    				ctx->seek(index18_33);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 28:

	    		{
	    		    ANTLR_UINT32 LA18_47;

	    		    ANTLR_MARKER index18_47;


	    		    LA18_47 = ctx->LA(1);

	    		     
	    		        index18_47 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA18_47 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 26;
	    		    }

	    		    else if ( (LA18_47 == DELIMITED_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 27;
	    		    }

	    		    else if ( (LA18_47 == PERIOD) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 43;
	    		    }

	    			 
	    				ctx->seek(index18_47);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 29:

	    		{
	    		    ANTLR_UINT32 LA18_31;

	    		    ANTLR_MARKER index18_31;


	    		    LA18_31 = ctx->LA(1);

	    		     
	    		        index18_31 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA18_31 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 8;
	    		    }

	    		    else if ( (LA18_31 == DELIMITED_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 9;
	    		    }

	    		    else if ( (LA18_31 == PERIOD) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 21;
	    		    }

	    			 
	    				ctx->seek(index18_31);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 30:

	    		{
	    		    ANTLR_UINT32 LA18_22;

	    		    ANTLR_MARKER index18_22;


	    		    LA18_22 = ctx->LA(1);

	    		     
	    		        index18_22 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA18_22 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 33;
	    		    }

	    		    else if ( (LA18_22 == DELIMITED_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 34;
	    		    }

	    			 
	    				ctx->seek(index18_22);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 31:

	    		{
	    		    ANTLR_UINT32 LA18_43;

	    		    ANTLR_MARKER index18_43;


	    		    LA18_43 = ctx->LA(1);

	    		     
	    		        index18_43 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA18_43 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 47;
	    		    }

	    		    else if ( (LA18_43 == DELIMITED_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 48;
	    		    }

	    			 
	    				ctx->seek(index18_43);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 32:

	    		{
	    		    ANTLR_UINT32 LA18_23;

	    		    ANTLR_MARKER index18_23;


	    		    LA18_23 = ctx->LA(1);

	    		     
	    		        index18_23 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA18_23 == PERIOD) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 35;
	    		    }

	    		    else if ( (LA18_23 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 19;
	    		    }

	    		    else if ( (LA18_23 == COMMA) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 20;
	    		    }

	    		    else if ( (LA18_23 == LEFT_PAREN || LA18_23 == SQL92_RESERVED_SELECT) && ((toUpper(LT(1)->getText()) == "NULLS")) )
	    		    {
	    		        s = 15;
	    		    }

	    			 
	    				ctx->seek(index18_23);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 33:

	    		{
	    		    ANTLR_UINT32 LA18_42;

	    		    ANTLR_MARKER index18_42;


	    		    LA18_42 = ctx->LA(1);

	    		     
	    		        index18_42 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA18_42 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 19;
	    		    }

	    		    else if ( (LA18_42 == COMMA) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 20;
	    		    }

	    		    else if ( (LA18_42 == LEFT_PAREN || LA18_42 == SQL92_RESERVED_SELECT) && ((toUpper(LT(1)->getText()) == "NULLS")) )
	    		    {
	    		        s = 15;
	    		    }

	    		    else if ( (LA18_42 == PERIOD) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 35;
	    		    }

	    			 
	    				ctx->seek(index18_42);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 34:

	    		{
	    		    ANTLR_UINT32 LA18_1;

	    		    ANTLR_MARKER index18_1;


	    		    LA18_1 = ctx->LA(1);

	    		     
	    		        index18_1 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA18_1 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 3;
	    		    }

	    		    else if ( (LA18_1 == DELIMITED_ID || LA18_1 == INTRODUCER) && ((toUpper(LT(1)->getText()) == "SET")) )
	    		    {
	    		        s = 4;
	    		    }

	    			 
	    				ctx->seek(index18_1);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 35:

	    		{
	    		    ANTLR_UINT32 LA18_19;

	    		    ANTLR_MARKER index18_19;


	    		    LA18_19 = ctx->LA(1);

	    		     
	    		        index18_19 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA18_19 == INTRODUCER) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 25;
	    		    }

	    		    else if ( (LA18_19 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 26;
	    		    }

	    		    else if ( (LA18_19 == DELIMITED_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 27;
	    		    }

	    			 
	    				ctx->seek(index18_19);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 36:

	    		{
	    		    ANTLR_UINT32 LA18_17;

	    		    ANTLR_MARKER index18_17;


	    		    LA18_17 = ctx->LA(1);

	    		     
	    		        index18_17 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA18_17 == PERIOD) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 22;
	    		    }

	    		    else if ( (LA18_17 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 11;
	    		    }

	    		    else if ( (LA18_17 == DELIMITED_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 12;
	    		    }

	    			 
	    				ctx->seek(index18_17);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 37:

	    		{
	    		    ANTLR_UINT32 LA18_26;

	    		    ANTLR_MARKER index18_26;


	    		    LA18_26 = ctx->LA(1);

	    		     
	    		        index18_26 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA18_26 == PERIOD) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 38;
	    		    }

	    		    else if ( (LA18_26 == COMMA || LA18_26 == REGULAR_ID) && ((toUpper(LT(1)->getText()) == "NULLS")) )
	    		    {
	    		        s = 15;
	    		    }

	    		    else if ( (LA18_26 == SQL92_RESERVED_TO) && ((toUpper(LT(1)->getText()) == "SET")) )
	    		    {
	    		        s = 4;
	    		    }

	    			 
	    				ctx->seek(index18_26);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 38:

	    		{
	    		    ANTLR_UINT32 LA18_37;

	    		    ANTLR_MARKER index18_37;


	    		    LA18_37 = ctx->LA(1);

	    		     
	    		        index18_37 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA18_37 == PERIOD) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 43;
	    		    }

	    		    else if ( (LA18_37 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 26;
	    		    }

	    		    else if ( (LA18_37 == DELIMITED_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 27;
	    		    }

	    			 
	    				ctx->seek(index18_37);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 39:

	    		{
	    		    ANTLR_UINT32 LA18_32;

	    		    ANTLR_MARKER index18_32;


	    		    LA18_32 = ctx->LA(1);

	    		     
	    		        index18_32 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA18_32 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 8;
	    		    }

	    		    else if ( (LA18_32 == DELIMITED_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 9;
	    		    }

	    		    else if ( (LA18_32 == PERIOD) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 21;
	    		    }

	    			 
	    				ctx->seek(index18_32);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 40:

	    		{
	    		    ANTLR_UINT32 LA18_10;

	    		    ANTLR_MARKER index18_10;


	    		    LA18_10 = ctx->LA(1);

	    		     
	    		        index18_10 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA18_10 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 16;
	    		    }

	    		    else if ( (LA18_10 == DELIMITED_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 17;
	    		    }

	    			 
	    				ctx->seek(index18_10);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 41:

	    		{
	    		    ANTLR_UINT32 LA18_25;

	    		    ANTLR_MARKER index18_25;


	    		    LA18_25 = ctx->LA(1);

	    		     
	    		        index18_25 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA18_25 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 36;
	    		    }

	    		    else if ( (LA18_25 == DELIMITED_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 37;
	    		    }

	    			 
	    				ctx->seek(index18_25);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 42:

	    		{
	    		    ANTLR_UINT32 LA18_50;

	    		    ANTLR_MARKER index18_50;


	    		    LA18_50 = ctx->LA(1);

	    		     
	    		        index18_50 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA18_50 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 29;
	    		    }

	    		    else if ( (LA18_50 == DELIMITED_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 30;
	    		    }

	    		    else if ( (LA18_50 == PERIOD) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 46;
	    		    }

	    			 
	    				ctx->seek(index18_50);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 43:

	    		{
	    		    ANTLR_UINT32 LA18_16;

	    		    ANTLR_MARKER index18_16;


	    		    LA18_16 = ctx->LA(1);

	    		     
	    		        index18_16 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA18_16 == PERIOD) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 22;
	    		    }

	    		    else if ( (LA18_16 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 11;
	    		    }

	    		    else if ( (LA18_16 == DELIMITED_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 12;
	    		    }

	    			 
	    				ctx->seek(index18_16);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 44:

	    		{
	    		    ANTLR_UINT32 LA18_14;

	    		    ANTLR_MARKER index18_14;


	    		    LA18_14 = ctx->LA(1);

	    		     
	    		        index18_14 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA18_14 == PERIOD) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 21;
	    		    }

	    		    else if ( (LA18_14 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 8;
	    		    }

	    		    else if ( (LA18_14 == DELIMITED_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 9;
	    		    }

	    			 
	    				ctx->seek(index18_14);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 45:

	    		{
	    		    ANTLR_UINT32 LA18_36;

	    		    ANTLR_MARKER index18_36;


	    		    LA18_36 = ctx->LA(1);

	    		     
	    		        index18_36 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA18_36 == PERIOD) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 43;
	    		    }

	    		    else if ( (LA18_36 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 26;
	    		    }

	    		    else if ( (LA18_36 == DELIMITED_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 27;
	    		    }

	    			 
	    				ctx->seek(index18_36);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 46:

	    		{
	    		    ANTLR_UINT32 LA18_20;

	    		    ANTLR_MARKER index18_20;


	    		    LA18_20 = ctx->LA(1);

	    		     
	    		        index18_20 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA18_20 == INTRODUCER) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 28;
	    		    }

	    		    else if ( (LA18_20 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 29;
	    		    }

	    		    else if ( (LA18_20 == DELIMITED_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 30;
	    		    }

	    			 
	    				ctx->seek(index18_20);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 47:

	    		{
	    		    ANTLR_UINT32 LA18_13;

	    		    ANTLR_MARKER index18_13;


	    		    LA18_13 = ctx->LA(1);

	    		     
	    		        index18_13 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA18_13 == PERIOD) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 21;
	    		    }

	    		    else if ( (LA18_13 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 8;
	    		    }

	    		    else if ( (LA18_13 == DELIMITED_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 9;
	    		    }

	    			 
	    				ctx->seek(index18_13);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 48:

	    		{
	    		    ANTLR_UINT32 LA18_0;

	    		    ANTLR_MARKER index18_0;


	    		    LA18_0 = ctx->LA(1);

	    		     
	    		        index18_0 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA18_0 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 1;
	    		    }

	    		    else if ( (LA18_0 == COMMA)  )
	    		    {
	    		        s = 2;
	    		    }

	    			 
	    				ctx->seek(index18_0);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 49:

	    		{
	    		    ANTLR_UINT32 LA18_27;

	    		    ANTLR_MARKER index18_27;


	    		    LA18_27 = ctx->LA(1);

	    		     
	    		        index18_27 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA18_27 == PERIOD) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 38;
	    		    }

	    		    else if ( (LA18_27 == COMMA || LA18_27 == REGULAR_ID) && ((toUpper(LT(1)->getText()) == "NULLS")) )
	    		    {
	    		        s = 15;
	    		    }

	    		    else if ( (LA18_27 == SQL92_RESERVED_TO) && ((toUpper(LT(1)->getText()) == "SET")) )
	    		    {
	    		        s = 4;
	    		    }

	    			 
	    				ctx->seek(index18_27);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 50:

	    		{
	    		    ANTLR_UINT32 LA18_45;

	    		    ANTLR_MARKER index18_45;


	    		    LA18_45 = ctx->LA(1);

	    		     
	    		        index18_45 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA18_45 == PERIOD) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 49;
	    		    }

	    		    else if ( (LA18_45 == COMMA || LA18_45 == REGULAR_ID) && ((toUpper(LT(1)->getText()) == "NULLS")) )
	    		    {
	    		        s = 15;
	    		    }

	    		    else if ( (LA18_45 == SQL92_RESERVED_TO) && ((toUpper(LT(1)->getText()) == "SET")) )
	    		    {
	    		        s = 4;
	    		    }

	    			 
	    				ctx->seek(index18_45);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;
	    }
	    if ( ctx->get_backtracking() > 0)
	    {
		 ctx->set_failedflag( true );
		return	-1;
	    }
	    ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( recognizer, "174:70: ( nulls_key last_key )?" );
	    ex->set_decisionNum( 18 );
	    ex->set_state(_s);
	    return -1;
	}
};

static OracleDMLCyclicDFA18  cdfa18(
	    18,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const ANTLR_UCHAR*)"174:70: ( nulls_key last_key )?",
	    dfa18_eot,	    /* EOT table			    */
	    dfa18_eof,	    /* EOF table			    */
	    dfa18_min,	    /* Minimum tokens for each state    */
	    dfa18_max,	    /* Maximum tokens for each state    */
	    dfa18_accept,	/* Accept table			    */
	    dfa18_special,	/* Special transition states	    */
	    dfa18_transitions	/* Table of transition tables	    */

	);


/* End of Cyclic DFA 18
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    175:77: ( nulls_key last_key )?
 */
static const ANTLR_INT32 dfa22_eot[54] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa22_eof[54] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa22_min[54] =
    {
	68, 113, -1, 68, -1, 113, 113, 113, 68, 68, 113, 68, 68, 113, 113, 113, 
	113, 113, -1, 113, 113, 113, 68, 68, 113, 68, 68, 113, 68, 68, 113, 113, 
	113, 113, 113, 113, 113, 113, 113, 113, 113, 68, 68, 113, 68, 68, 113, 
	113, 113, 113, 113, 113, 68, 68
    };
static const ANTLR_INT32 dfa22_max[54] =
    {
	384, 384, -1, 501, -1, 384, 384, 384, 501, 501, 384, 468, 468, 384, 384, 
	384, 384, 384, -1, 384, 384, 384, 501, 501, 384, 506, 506, 384, 453, 453, 
	384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 501, 501, 384, 506, 
	506, 384, 384, 384, 384, 384, 384, 506, 506
    };
static const ANTLR_INT32 dfa22_accept[54] =
    {
	-1, -1, 2, -1, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa22_special[54] =
    {
	20, 12, -1, 23, -1, 17, 11, 41, 7, 4, 18, 9, 1, 45, 37, 15, 36, 48, -1, 
	47, 44, 32, 34, 27, 42, 38, 49, 0, 3, 6, 28, 29, 14, 25, 46, 39, 16, 8, 
	5, 31, 40, 26, 35, 33, 21, 50, 22, 30, 13, 24, 43, 2, 10, 19
    };

/** Used when there is no transition table entry for a particular state */
static const ANTLR_INT32* dfa22_T_empty	 =   NULL;

static const ANTLR_INT32 dfa22_T0[] =
    {
	38, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 37
    };

static const ANTLR_INT32 dfa22_T1[] =
    {
	18, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 18, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 18, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, 4, 18, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 18
    };

static const ANTLR_INT32 dfa22_T2[] =
    {
	29, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 46, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 28
    };

static const ANTLR_INT32 dfa22_T3[] =
    {
	4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 18, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, 18
    };

static const ANTLR_INT32 dfa22_T4[] =
    {
	17, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 18, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 16, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 18
    };

static const ANTLR_INT32 dfa22_T5[] =
    {
	18, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 49, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 18, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, 4
    };

static const ANTLR_INT32 dfa22_T6[] =
    {
	12, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 10, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 11
    };

static const ANTLR_INT32 dfa22_T7[] =
    {
	4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 4, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 3
    };

static const ANTLR_INT32 dfa22_T8[] =
    {
	26, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 43, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 25
    };

static const ANTLR_INT32 dfa22_T9[] =
    {
	9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 21, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 8
    };

static const ANTLR_INT32 dfa22_T10[] =
    {
	23, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 22
    };

static const ANTLR_INT32 dfa22_T11[] =
    {
	45, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 44
    };

static const ANTLR_INT32 dfa22_T12[] =
    {
	9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 7, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 8
    };

static const ANTLR_INT32 dfa22_T13[] =
    {
	20, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 19
    };

static const ANTLR_INT32 dfa22_T14[] =
    {
	2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1
    };

static const ANTLR_INT32 dfa22_T15[] =
    {
	51, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 50
    };

static const ANTLR_INT32 dfa22_T16[] =
    {
	6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 4
    };

static const ANTLR_INT32 dfa22_T17[] =
    {
	53, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 52
    };

static const ANTLR_INT32 dfa22_T18[] =
    {
	42, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 41
    };

static const ANTLR_INT32 dfa22_T19[] =
    {
	17, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 18, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 33, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 16, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 18
    };

static const ANTLR_INT32 dfa22_T20[] =
    {
	40, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 39
    };

static const ANTLR_INT32 dfa22_T21[] =
    {
	12, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 30, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 11
    };

static const ANTLR_INT32 dfa22_T22[] =
    {
	32, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 31
    };

static const ANTLR_INT32 dfa22_T23[] =
    {
	48, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 47
    };

static const ANTLR_INT32 dfa22_T24[] =
    {
	26, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 24, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 25
    };

static const ANTLR_INT32 dfa22_T25[] =
    {
	18, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 36, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 18, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, 4
    };

static const ANTLR_INT32 dfa22_T26[] =
    {
	14, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 13
    };

static const ANTLR_INT32 dfa22_T27[] =
    {
	35, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 34
    };

static const ANTLR_INT32 dfa22_T28[] =
    {
	29, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 27, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 28
    };


/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR_INT32 * const dfa22_transitions[] =
{
    dfa22_T14, dfa22_T7, NULL, dfa22_T16, NULL, dfa22_T12, dfa22_T6, dfa22_T26, 
    dfa22_T4, dfa22_T4, dfa22_T13, dfa22_T1, dfa22_T1, dfa22_T9, dfa22_T9, 
    dfa22_T10, dfa22_T24, dfa22_T28, NULL, dfa22_T21, dfa22_T21, dfa22_T22, 
    dfa22_T19, dfa22_T19, dfa22_T27, dfa22_T25, dfa22_T25, dfa22_T0, dfa22_T3, 
    dfa22_T3, dfa22_T20, dfa22_T9, dfa22_T9, dfa22_T18, dfa22_T8, dfa22_T8, 
    dfa22_T11, dfa22_T2, dfa22_T2, dfa22_T21, dfa22_T21, dfa22_T19, dfa22_T19, 
    dfa22_T23, dfa22_T5, dfa22_T5, dfa22_T15, dfa22_T8, dfa22_T8, dfa22_T17, 
    dfa22_T2, dfa22_T2, dfa22_T5, dfa22_T5
};


/* Declare tracking structure for Cyclic DFA 22
 */
class OracleDMLCyclicDFA22 : public CyclicDFA< OracleDMLImplTraits, OracleDML >, public OracleDMLTokens
{
public:
	typedef CyclicDFA< OracleDMLImplTraits, OracleDML >  BaseType;
	typedef BaseType::ContextType CtxType;

private:
	//to maintain C-Target compatibility, we need to make some of ctx functions look like member funcs
	CtxType*	m_ctx; 
	

public:
	OracleDMLCyclicDFA22( ANTLR_INT32	decisionNumber
					, const ANTLR_UCHAR*	description
					, const ANTLR_INT32* const	eot
					, const ANTLR_INT32* const	eof
					, const ANTLR_INT32* const	min
					, const ANTLR_INT32* const	max
					, const ANTLR_INT32* const	accept
					, const ANTLR_INT32* const	special
					, const ANTLR_INT32* const *const	transition)
					:BaseType( decisionNumber, description, eot, eof, min, max, accept,
								special, transition )
	{
		m_ctx = NULL;
		
	}

    ANTLR_UINT32 LA(ANTLR_INT32 i)
    {
        return m_ctx->LA(i);
    }

    const CtxType::CommonTokenType*  LT(ANTLR_INT32 k)
    {
        return m_ctx->LT(k);
    }
    template<typename PredType>
    bool msynpred( PredType pred )
    {
        return m_ctx->msynpred(pred);
    }

	ANTLR_INT32  specialStateTransition(CtxType * ctx, RecognizerType* recognizer, IntStreamType* is, ANTLR_INT32 s)
	{
	    ANTLR_INT32    _s;

	    m_ctx = ctx;
	    _s	    = s;
	    switch  (s)
	    {
	    	    case 0:

	    		{
	    		    ANTLR_UINT32 LA22_27;

	    		    ANTLR_MARKER index22_27;


	    		    LA22_27 = ctx->LA(1);

	    		     
	    		        index22_27 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA22_27 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 37;
	    		    }

	    		    else if ( (LA22_27 == DELIMITED_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 38;
	    		    }

	    			 
	    				ctx->seek(index22_27);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 1:

	    		{
	    		    ANTLR_UINT32 LA22_12;

	    		    ANTLR_MARKER index22_12;


	    		    LA22_12 = ctx->LA(1);

	    		     
	    		        index22_12 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA22_12 == COMMA || LA22_12 == PERIOD || LA22_12 == REGULAR_ID || LA22_12 == SQL92_RESERVED_ASC || LA22_12 == SQL92_RESERVED_DESC) && ((toUpper(LT(1)->getText()) == "NULLS")) )
	    		    {
	    		        s = 18;
	    		    }

	    		    else if ( (LA22_12 == LEFT_PAREN || LA22_12 == SQL92_RESERVED_AS) && ((toUpper(LT(1)->getText()) == "SET")) )
	    		    {
	    		        s = 4;
	    		    }

	    			 
	    				ctx->seek(index22_12);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 2:

	    		{
	    		    ANTLR_UINT32 LA22_51;

	    		    ANTLR_MARKER index22_51;


	    		    LA22_51 = ctx->LA(1);

	    		     
	    		        index22_51 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA22_51 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 28;
	    		    }

	    		    else if ( (LA22_51 == DELIMITED_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 29;
	    		    }

	    		    else if ( (LA22_51 == PERIOD) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 46;
	    		    }

	    			 
	    				ctx->seek(index22_51);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 3:

	    		{
	    		    ANTLR_UINT32 LA22_28;

	    		    ANTLR_MARKER index22_28;


	    		    LA22_28 = ctx->LA(1);

	    		     
	    		        index22_28 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA22_28 == LEFT_PAREN || LA22_28 == SQL92_RESERVED_AS) && ((toUpper(LT(1)->getText()) == "NULLS")) )
	    		    {
	    		        s = 18;
	    		    }

	    		    else if ( (LA22_28 == COMMA || LA22_28 == PERIOD || LA22_28 == REGULAR_ID) && ((toUpper(LT(1)->getText()) == "SET")) )
	    		    {
	    		        s = 4;
	    		    }

	    			 
	    				ctx->seek(index22_28);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 4:

	    		{
	    		    ANTLR_UINT32 LA22_9;

	    		    ANTLR_MARKER index22_9;


	    		    LA22_9 = ctx->LA(1);

	    		     
	    		        index22_9 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA22_9 == PERIOD) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 15;
	    		    }

	    		    else if ( (LA22_9 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 16;
	    		    }

	    		    else if ( (LA22_9 == COMMA) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 17;
	    		    }

	    		    else if ( (LA22_9 == LEFT_PAREN || LA22_9 == SQL92_RESERVED_SELECT) && ((toUpper(LT(1)->getText()) == "NULLS")) )
	    		    {
	    		        s = 18;
	    		    }

	    			 
	    				ctx->seek(index22_9);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 5:

	    		{
	    		    ANTLR_UINT32 LA22_38;

	    		    ANTLR_MARKER index22_38;


	    		    LA22_38 = ctx->LA(1);

	    		     
	    		        index22_38 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA22_38 == PERIOD) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 46;
	    		    }

	    		    else if ( (LA22_38 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 28;
	    		    }

	    		    else if ( (LA22_38 == DELIMITED_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 29;
	    		    }

	    			 
	    				ctx->seek(index22_38);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 6:

	    		{
	    		    ANTLR_UINT32 LA22_29;

	    		    ANTLR_MARKER index22_29;


	    		    LA22_29 = ctx->LA(1);

	    		     
	    		        index22_29 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA22_29 == LEFT_PAREN || LA22_29 == SQL92_RESERVED_AS) && ((toUpper(LT(1)->getText()) == "NULLS")) )
	    		    {
	    		        s = 18;
	    		    }

	    		    else if ( (LA22_29 == COMMA || LA22_29 == PERIOD || LA22_29 == REGULAR_ID) && ((toUpper(LT(1)->getText()) == "SET")) )
	    		    {
	    		        s = 4;
	    		    }

	    			 
	    				ctx->seek(index22_29);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 7:

	    		{
	    		    ANTLR_UINT32 LA22_8;

	    		    ANTLR_MARKER index22_8;


	    		    LA22_8 = ctx->LA(1);

	    		     
	    		        index22_8 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA22_8 == PERIOD) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 15;
	    		    }

	    		    else if ( (LA22_8 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 16;
	    		    }

	    		    else if ( (LA22_8 == COMMA) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 17;
	    		    }

	    		    else if ( (LA22_8 == LEFT_PAREN || LA22_8 == SQL92_RESERVED_SELECT) && ((toUpper(LT(1)->getText()) == "NULLS")) )
	    		    {
	    		        s = 18;
	    		    }

	    			 
	    				ctx->seek(index22_8);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 8:

	    		{
	    		    ANTLR_UINT32 LA22_37;

	    		    ANTLR_MARKER index22_37;


	    		    LA22_37 = ctx->LA(1);

	    		     
	    		        index22_37 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA22_37 == PERIOD) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 46;
	    		    }

	    		    else if ( (LA22_37 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 28;
	    		    }

	    		    else if ( (LA22_37 == DELIMITED_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 29;
	    		    }

	    			 
	    				ctx->seek(index22_37);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 9:

	    		{
	    		    ANTLR_UINT32 LA22_11;

	    		    ANTLR_MARKER index22_11;


	    		    LA22_11 = ctx->LA(1);

	    		     
	    		        index22_11 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA22_11 == COMMA || LA22_11 == PERIOD || LA22_11 == REGULAR_ID || LA22_11 == SQL92_RESERVED_ASC || LA22_11 == SQL92_RESERVED_DESC) && ((toUpper(LT(1)->getText()) == "NULLS")) )
	    		    {
	    		        s = 18;
	    		    }

	    		    else if ( (LA22_11 == LEFT_PAREN || LA22_11 == SQL92_RESERVED_AS) && ((toUpper(LT(1)->getText()) == "SET")) )
	    		    {
	    		        s = 4;
	    		    }

	    			 
	    				ctx->seek(index22_11);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 10:

	    		{
	    		    ANTLR_UINT32 LA22_52;

	    		    ANTLR_MARKER index22_52;


	    		    LA22_52 = ctx->LA(1);

	    		     
	    		        index22_52 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA22_52 == COMMA || LA22_52 == REGULAR_ID) && ((toUpper(LT(1)->getText()) == "NULLS")) )
	    		    {
	    		        s = 18;
	    		    }

	    		    else if ( (LA22_52 == PERIOD) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 49;
	    		    }

	    		    else if ( (LA22_52 == SQL92_RESERVED_TO) && ((toUpper(LT(1)->getText()) == "SET")) )
	    		    {
	    		        s = 4;
	    		    }

	    			 
	    				ctx->seek(index22_52);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 11:

	    		{
	    		    ANTLR_UINT32 LA22_6;

	    		    ANTLR_MARKER index22_6;


	    		    LA22_6 = ctx->LA(1);

	    		     
	    		        index22_6 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA22_6 == INTRODUCER) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 10;
	    		    }

	    		    else if ( (LA22_6 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 11;
	    		    }

	    		    else if ( (LA22_6 == DELIMITED_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 12;
	    		    }

	    			 
	    				ctx->seek(index22_6);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 12:

	    		{
	    		    ANTLR_UINT32 LA22_1;

	    		    ANTLR_MARKER index22_1;


	    		    LA22_1 = ctx->LA(1);

	    		     
	    		        index22_1 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA22_1 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 3;
	    		    }

	    		    else if ( (LA22_1 == DELIMITED_ID || LA22_1 == INTRODUCER) && ((toUpper(LT(1)->getText()) == "SET")) )
	    		    {
	    		        s = 4;
	    		    }

	    			 
	    				ctx->seek(index22_1);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 13:

	    		{
	    		    ANTLR_UINT32 LA22_48;

	    		    ANTLR_MARKER index22_48;


	    		    LA22_48 = ctx->LA(1);

	    		     
	    		        index22_48 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA22_48 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 25;
	    		    }

	    		    else if ( (LA22_48 == DELIMITED_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 26;
	    		    }

	    		    else if ( (LA22_48 == PERIOD) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 43;
	    		    }

	    			 
	    				ctx->seek(index22_48);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 14:

	    		{
	    		    ANTLR_UINT32 LA22_32;

	    		    ANTLR_MARKER index22_32;


	    		    LA22_32 = ctx->LA(1);

	    		     
	    		        index22_32 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA22_32 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 8;
	    		    }

	    		    else if ( (LA22_32 == DELIMITED_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 9;
	    		    }

	    		    else if ( (LA22_32 == PERIOD) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 21;
	    		    }

	    			 
	    				ctx->seek(index22_32);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 15:

	    		{
	    		    ANTLR_UINT32 LA22_15;

	    		    ANTLR_MARKER index22_15;


	    		    LA22_15 = ctx->LA(1);

	    		     
	    		        index22_15 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA22_15 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 22;
	    		    }

	    		    else if ( (LA22_15 == DELIMITED_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 23;
	    		    }

	    			 
	    				ctx->seek(index22_15);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 16:

	    		{
	    		    ANTLR_UINT32 LA22_36;

	    		    ANTLR_MARKER index22_36;


	    		    LA22_36 = ctx->LA(1);

	    		     
	    		        index22_36 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA22_36 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 44;
	    		    }

	    		    else if ( (LA22_36 == DELIMITED_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 45;
	    		    }

	    			 
	    				ctx->seek(index22_36);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 17:

	    		{
	    		    ANTLR_UINT32 LA22_5;

	    		    ANTLR_MARKER index22_5;


	    		    LA22_5 = ctx->LA(1);

	    		     
	    		        index22_5 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA22_5 == INTRODUCER) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 7;
	    		    }

	    		    else if ( (LA22_5 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 8;
	    		    }

	    		    else if ( (LA22_5 == DELIMITED_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 9;
	    		    }

	    			 
	    				ctx->seek(index22_5);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 18:

	    		{
	    		    ANTLR_UINT32 LA22_10;

	    		    ANTLR_MARKER index22_10;


	    		    LA22_10 = ctx->LA(1);

	    		     
	    		        index22_10 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA22_10 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 19;
	    		    }

	    		    else if ( (LA22_10 == DELIMITED_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 20;
	    		    }

	    			 
	    				ctx->seek(index22_10);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 19:

	    		{
	    		    ANTLR_UINT32 LA22_53;

	    		    ANTLR_MARKER index22_53;


	    		    LA22_53 = ctx->LA(1);

	    		     
	    		        index22_53 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA22_53 == COMMA || LA22_53 == REGULAR_ID) && ((toUpper(LT(1)->getText()) == "NULLS")) )
	    		    {
	    		        s = 18;
	    		    }

	    		    else if ( (LA22_53 == PERIOD) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 49;
	    		    }

	    		    else if ( (LA22_53 == SQL92_RESERVED_TO) && ((toUpper(LT(1)->getText()) == "SET")) )
	    		    {
	    		        s = 4;
	    		    }

	    			 
	    				ctx->seek(index22_53);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 20:

	    		{
	    		    ANTLR_UINT32 LA22_0;

	    		    ANTLR_MARKER index22_0;


	    		    LA22_0 = ctx->LA(1);

	    		     
	    		        index22_0 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA22_0 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 1;
	    		    }

	    		    else if ( (LA22_0 == COMMA)  )
	    		    {
	    		        s = 2;
	    		    }

	    			 
	    				ctx->seek(index22_0);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 21:

	    		{
	    		    ANTLR_UINT32 LA22_44;

	    		    ANTLR_MARKER index22_44;


	    		    LA22_44 = ctx->LA(1);

	    		     
	    		        index22_44 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA22_44 == PERIOD) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 49;
	    		    }

	    		    else if ( (LA22_44 == COMMA || LA22_44 == REGULAR_ID) && ((toUpper(LT(1)->getText()) == "NULLS")) )
	    		    {
	    		        s = 18;
	    		    }

	    		    else if ( (LA22_44 == SQL92_RESERVED_TO) && ((toUpper(LT(1)->getText()) == "SET")) )
	    		    {
	    		        s = 4;
	    		    }

	    			 
	    				ctx->seek(index22_44);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 22:

	    		{
	    		    ANTLR_UINT32 LA22_46;

	    		    ANTLR_MARKER index22_46;


	    		    LA22_46 = ctx->LA(1);

	    		     
	    		        index22_46 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA22_46 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 50;
	    		    }

	    		    else if ( (LA22_46 == DELIMITED_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 51;
	    		    }

	    			 
	    				ctx->seek(index22_46);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 23:

	    		{
	    		    ANTLR_UINT32 LA22_3;

	    		    ANTLR_MARKER index22_3;


	    		    LA22_3 = ctx->LA(1);

	    		     
	    		        index22_3 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA22_3 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 5;
	    		    }

	    		    else if ( (LA22_3 == COMMA) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 6;
	    		    }

	    		    else if ( (LA22_3 == LEFT_PAREN || LA22_3 == PERIOD || LA22_3 == SQL92_RESERVED_SELECT) && ((toUpper(LT(1)->getText()) == "SET")) )
	    		    {
	    		        s = 4;
	    		    }

	    			 
	    				ctx->seek(index22_3);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 24:

	    		{
	    		    ANTLR_UINT32 LA22_49;

	    		    ANTLR_MARKER index22_49;


	    		    LA22_49 = ctx->LA(1);

	    		     
	    		        index22_49 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA22_49 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 52;
	    		    }

	    		    else if ( (LA22_49 == DELIMITED_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 53;
	    		    }

	    			 
	    				ctx->seek(index22_49);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 25:

	    		{
	    		    ANTLR_UINT32 LA22_33;

	    		    ANTLR_MARKER index22_33;


	    		    LA22_33 = ctx->LA(1);

	    		     
	    		        index22_33 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA22_33 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 41;
	    		    }

	    		    else if ( (LA22_33 == DELIMITED_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 42;
	    		    }

	    			 
	    				ctx->seek(index22_33);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 26:

	    		{
	    		    ANTLR_UINT32 LA22_41;

	    		    ANTLR_MARKER index22_41;


	    		    LA22_41 = ctx->LA(1);

	    		     
	    		        index22_41 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA22_41 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 16;
	    		    }

	    		    else if ( (LA22_41 == COMMA) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 17;
	    		    }

	    		    else if ( (LA22_41 == LEFT_PAREN || LA22_41 == SQL92_RESERVED_SELECT) && ((toUpper(LT(1)->getText()) == "NULLS")) )
	    		    {
	    		        s = 18;
	    		    }

	    		    else if ( (LA22_41 == PERIOD) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 33;
	    		    }

	    			 
	    				ctx->seek(index22_41);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 27:

	    		{
	    		    ANTLR_UINT32 LA22_23;

	    		    ANTLR_MARKER index22_23;


	    		    LA22_23 = ctx->LA(1);

	    		     
	    		        index22_23 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA22_23 == PERIOD) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 33;
	    		    }

	    		    else if ( (LA22_23 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 16;
	    		    }

	    		    else if ( (LA22_23 == COMMA) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 17;
	    		    }

	    		    else if ( (LA22_23 == LEFT_PAREN || LA22_23 == SQL92_RESERVED_SELECT) && ((toUpper(LT(1)->getText()) == "NULLS")) )
	    		    {
	    		        s = 18;
	    		    }

	    			 
	    				ctx->seek(index22_23);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 28:

	    		{
	    		    ANTLR_UINT32 LA22_30;

	    		    ANTLR_MARKER index22_30;


	    		    LA22_30 = ctx->LA(1);

	    		     
	    		        index22_30 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA22_30 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 39;
	    		    }

	    		    else if ( (LA22_30 == DELIMITED_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 40;
	    		    }

	    			 
	    				ctx->seek(index22_30);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 29:

	    		{
	    		    ANTLR_UINT32 LA22_31;

	    		    ANTLR_MARKER index22_31;


	    		    LA22_31 = ctx->LA(1);

	    		     
	    		        index22_31 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA22_31 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 8;
	    		    }

	    		    else if ( (LA22_31 == DELIMITED_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 9;
	    		    }

	    		    else if ( (LA22_31 == PERIOD) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 21;
	    		    }

	    			 
	    				ctx->seek(index22_31);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 30:

	    		{
	    		    ANTLR_UINT32 LA22_47;

	    		    ANTLR_MARKER index22_47;


	    		    LA22_47 = ctx->LA(1);

	    		     
	    		        index22_47 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA22_47 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 25;
	    		    }

	    		    else if ( (LA22_47 == DELIMITED_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 26;
	    		    }

	    		    else if ( (LA22_47 == PERIOD) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 43;
	    		    }

	    			 
	    				ctx->seek(index22_47);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 31:

	    		{
	    		    ANTLR_UINT32 LA22_39;

	    		    ANTLR_MARKER index22_39;


	    		    LA22_39 = ctx->LA(1);

	    		     
	    		        index22_39 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA22_39 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 11;
	    		    }

	    		    else if ( (LA22_39 == DELIMITED_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 12;
	    		    }

	    		    else if ( (LA22_39 == PERIOD) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 30;
	    		    }

	    			 
	    				ctx->seek(index22_39);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 32:

	    		{
	    		    ANTLR_UINT32 LA22_21;

	    		    ANTLR_MARKER index22_21;


	    		    LA22_21 = ctx->LA(1);

	    		     
	    		        index22_21 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA22_21 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 31;
	    		    }

	    		    else if ( (LA22_21 == DELIMITED_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 32;
	    		    }

	    			 
	    				ctx->seek(index22_21);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 33:

	    		{
	    		    ANTLR_UINT32 LA22_43;

	    		    ANTLR_MARKER index22_43;


	    		    LA22_43 = ctx->LA(1);

	    		     
	    		        index22_43 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA22_43 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 47;
	    		    }

	    		    else if ( (LA22_43 == DELIMITED_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 48;
	    		    }

	    			 
	    				ctx->seek(index22_43);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 34:

	    		{
	    		    ANTLR_UINT32 LA22_22;

	    		    ANTLR_MARKER index22_22;


	    		    LA22_22 = ctx->LA(1);

	    		     
	    		        index22_22 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA22_22 == PERIOD) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 33;
	    		    }

	    		    else if ( (LA22_22 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 16;
	    		    }

	    		    else if ( (LA22_22 == COMMA) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 17;
	    		    }

	    		    else if ( (LA22_22 == LEFT_PAREN || LA22_22 == SQL92_RESERVED_SELECT) && ((toUpper(LT(1)->getText()) == "NULLS")) )
	    		    {
	    		        s = 18;
	    		    }

	    			 
	    				ctx->seek(index22_22);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 35:

	    		{
	    		    ANTLR_UINT32 LA22_42;

	    		    ANTLR_MARKER index22_42;


	    		    LA22_42 = ctx->LA(1);

	    		     
	    		        index22_42 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA22_42 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 16;
	    		    }

	    		    else if ( (LA22_42 == COMMA) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 17;
	    		    }

	    		    else if ( (LA22_42 == LEFT_PAREN || LA22_42 == SQL92_RESERVED_SELECT) && ((toUpper(LT(1)->getText()) == "NULLS")) )
	    		    {
	    		        s = 18;
	    		    }

	    		    else if ( (LA22_42 == PERIOD) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 33;
	    		    }

	    			 
	    				ctx->seek(index22_42);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 36:

	    		{
	    		    ANTLR_UINT32 LA22_16;

	    		    ANTLR_MARKER index22_16;


	    		    LA22_16 = ctx->LA(1);

	    		     
	    		        index22_16 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA22_16 == INTRODUCER) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 24;
	    		    }

	    		    else if ( (LA22_16 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 25;
	    		    }

	    		    else if ( (LA22_16 == DELIMITED_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 26;
	    		    }

	    			 
	    				ctx->seek(index22_16);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 37:

	    		{
	    		    ANTLR_UINT32 LA22_14;

	    		    ANTLR_MARKER index22_14;


	    		    LA22_14 = ctx->LA(1);

	    		     
	    		        index22_14 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA22_14 == PERIOD) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 21;
	    		    }

	    		    else if ( (LA22_14 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 8;
	    		    }

	    		    else if ( (LA22_14 == DELIMITED_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 9;
	    		    }

	    			 
	    				ctx->seek(index22_14);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 38:

	    		{
	    		    ANTLR_UINT32 LA22_25;

	    		    ANTLR_MARKER index22_25;


	    		    LA22_25 = ctx->LA(1);

	    		     
	    		        index22_25 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA22_25 == PERIOD) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 36;
	    		    }

	    		    else if ( (LA22_25 == COMMA || LA22_25 == REGULAR_ID) && ((toUpper(LT(1)->getText()) == "NULLS")) )
	    		    {
	    		        s = 18;
	    		    }

	    		    else if ( (LA22_25 == SQL92_RESERVED_TO) && ((toUpper(LT(1)->getText()) == "SET")) )
	    		    {
	    		        s = 4;
	    		    }

	    			 
	    				ctx->seek(index22_25);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 39:

	    		{
	    		    ANTLR_UINT32 LA22_35;

	    		    ANTLR_MARKER index22_35;


	    		    LA22_35 = ctx->LA(1);

	    		     
	    		        index22_35 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA22_35 == PERIOD) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 43;
	    		    }

	    		    else if ( (LA22_35 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 25;
	    		    }

	    		    else if ( (LA22_35 == DELIMITED_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 26;
	    		    }

	    			 
	    				ctx->seek(index22_35);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 40:

	    		{
	    		    ANTLR_UINT32 LA22_40;

	    		    ANTLR_MARKER index22_40;


	    		    LA22_40 = ctx->LA(1);

	    		     
	    		        index22_40 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA22_40 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 11;
	    		    }

	    		    else if ( (LA22_40 == DELIMITED_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 12;
	    		    }

	    		    else if ( (LA22_40 == PERIOD) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 30;
	    		    }

	    			 
	    				ctx->seek(index22_40);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 41:

	    		{
	    		    ANTLR_UINT32 LA22_7;

	    		    ANTLR_MARKER index22_7;


	    		    LA22_7 = ctx->LA(1);

	    		     
	    		        index22_7 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA22_7 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 13;
	    		    }

	    		    else if ( (LA22_7 == DELIMITED_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 14;
	    		    }

	    			 
	    				ctx->seek(index22_7);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 42:

	    		{
	    		    ANTLR_UINT32 LA22_24;

	    		    ANTLR_MARKER index22_24;


	    		    LA22_24 = ctx->LA(1);

	    		     
	    		        index22_24 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA22_24 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 34;
	    		    }

	    		    else if ( (LA22_24 == DELIMITED_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 35;
	    		    }

	    			 
	    				ctx->seek(index22_24);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 43:

	    		{
	    		    ANTLR_UINT32 LA22_50;

	    		    ANTLR_MARKER index22_50;


	    		    LA22_50 = ctx->LA(1);

	    		     
	    		        index22_50 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA22_50 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 28;
	    		    }

	    		    else if ( (LA22_50 == DELIMITED_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 29;
	    		    }

	    		    else if ( (LA22_50 == PERIOD) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 46;
	    		    }

	    			 
	    				ctx->seek(index22_50);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 44:

	    		{
	    		    ANTLR_UINT32 LA22_20;

	    		    ANTLR_MARKER index22_20;


	    		    LA22_20 = ctx->LA(1);

	    		     
	    		        index22_20 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA22_20 == PERIOD) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 30;
	    		    }

	    		    else if ( (LA22_20 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 11;
	    		    }

	    		    else if ( (LA22_20 == DELIMITED_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 12;
	    		    }

	    			 
	    				ctx->seek(index22_20);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 45:

	    		{
	    		    ANTLR_UINT32 LA22_13;

	    		    ANTLR_MARKER index22_13;


	    		    LA22_13 = ctx->LA(1);

	    		     
	    		        index22_13 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA22_13 == PERIOD) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 21;
	    		    }

	    		    else if ( (LA22_13 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 8;
	    		    }

	    		    else if ( (LA22_13 == DELIMITED_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 9;
	    		    }

	    			 
	    				ctx->seek(index22_13);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 46:

	    		{
	    		    ANTLR_UINT32 LA22_34;

	    		    ANTLR_MARKER index22_34;


	    		    LA22_34 = ctx->LA(1);

	    		     
	    		        index22_34 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA22_34 == PERIOD) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 43;
	    		    }

	    		    else if ( (LA22_34 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 25;
	    		    }

	    		    else if ( (LA22_34 == DELIMITED_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 26;
	    		    }

	    			 
	    				ctx->seek(index22_34);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 47:

	    		{
	    		    ANTLR_UINT32 LA22_19;

	    		    ANTLR_MARKER index22_19;


	    		    LA22_19 = ctx->LA(1);

	    		     
	    		        index22_19 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA22_19 == PERIOD) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 30;
	    		    }

	    		    else if ( (LA22_19 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 11;
	    		    }

	    		    else if ( (LA22_19 == DELIMITED_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 12;
	    		    }

	    			 
	    				ctx->seek(index22_19);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 48:

	    		{
	    		    ANTLR_UINT32 LA22_17;

	    		    ANTLR_MARKER index22_17;


	    		    LA22_17 = ctx->LA(1);

	    		     
	    		        index22_17 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA22_17 == INTRODUCER) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 27;
	    		    }

	    		    else if ( (LA22_17 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 28;
	    		    }

	    		    else if ( (LA22_17 == DELIMITED_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 29;
	    		    }

	    			 
	    				ctx->seek(index22_17);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 49:

	    		{
	    		    ANTLR_UINT32 LA22_26;

	    		    ANTLR_MARKER index22_26;


	    		    LA22_26 = ctx->LA(1);

	    		     
	    		        index22_26 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA22_26 == PERIOD) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 36;
	    		    }

	    		    else if ( (LA22_26 == COMMA || LA22_26 == REGULAR_ID) && ((toUpper(LT(1)->getText()) == "NULLS")) )
	    		    {
	    		        s = 18;
	    		    }

	    		    else if ( (LA22_26 == SQL92_RESERVED_TO) && ((toUpper(LT(1)->getText()) == "SET")) )
	    		    {
	    		        s = 4;
	    		    }

	    			 
	    				ctx->seek(index22_26);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 50:

	    		{
	    		    ANTLR_UINT32 LA22_45;

	    		    ANTLR_MARKER index22_45;


	    		    LA22_45 = ctx->LA(1);

	    		     
	    		        index22_45 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA22_45 == PERIOD) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))) )
	    		    {
	    		        s = 49;
	    		    }

	    		    else if ( (LA22_45 == COMMA || LA22_45 == REGULAR_ID) && ((toUpper(LT(1)->getText()) == "NULLS")) )
	    		    {
	    		        s = 18;
	    		    }

	    		    else if ( (LA22_45 == SQL92_RESERVED_TO) && ((toUpper(LT(1)->getText()) == "SET")) )
	    		    {
	    		        s = 4;
	    		    }

	    			 
	    				ctx->seek(index22_45);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;
	    }
	    if ( ctx->get_backtracking() > 0)
	    {
		 ctx->set_failedflag( true );
		return	-1;
	    }
	    ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( recognizer, "175:77: ( nulls_key last_key )?" );
	    ex->set_decisionNum( 22 );
	    ex->set_state(_s);
	    return -1;
	}
};

static OracleDMLCyclicDFA22  cdfa22(
	    22,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const ANTLR_UCHAR*)"175:77: ( nulls_key last_key )?",
	    dfa22_eot,	    /* EOT table			    */
	    dfa22_eof,	    /* EOF table			    */
	    dfa22_min,	    /* Minimum tokens for each state    */
	    dfa22_max,	    /* Maximum tokens for each state    */
	    dfa22_accept,	/* Accept table			    */
	    dfa22_special,	/* Special transition states	    */
	    dfa22_transitions	/* Table of transition tables	    */

	);


/* End of Cyclic DFA 22
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    ()* loopback of 488:64: ( reference_model )*
 */
static const ANTLR_INT32 dfa108_eot[13] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa108_eof[13] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa108_min[13] =
    {
	384, 113, 113, 384, 384, -1, 113, 113, -1, -1, 113, 113, 113
    };
static const ANTLR_INT32 dfa108_max[13] =
    {
	384, 457, 384, 492, 492, -1, 384, 384, -1, -1, 384, 384, 384
    };
static const ANTLR_INT32 dfa108_accept[13] =
    {
	-1, -1, -1, -1, -1, 2, -1, -1, 2, 1, -1, -1, -1
    };
static const ANTLR_INT32 dfa108_special[13] =
    {
	8, 2, 7, 4, 0, -1, 6, 3, -1, -1, 5, 1, 9
    };

/** Used when there is no transition table entry for a particular state */
static const ANTLR_INT32* dfa108_T_empty	 =   NULL;

static const ANTLR_INT32 dfa108_T0[] =
    {
	8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	9
    };

static const ANTLR_INT32 dfa108_T1[] =
    {
	4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 3
    };

static const ANTLR_INT32 dfa108_T2[] =
    {
	4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 2, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 5
    };

static const ANTLR_INT32 dfa108_T3[] =
    {
	12, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 11
    };

static const ANTLR_INT32 dfa108_T4[] =
    {
	7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 6
    };

static const ANTLR_INT32 dfa108_T5[] =
    {
	1
    };


/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR_INT32 * const dfa108_transitions[] =
{
    dfa108_T5, dfa108_T2, dfa108_T4, dfa108_T0, dfa108_T0, NULL, dfa108_T1, 
    dfa108_T1, NULL, NULL, dfa108_T3, dfa108_T1, dfa108_T1
};


/* Declare tracking structure for Cyclic DFA 108
 */
class OracleDMLCyclicDFA108 : public CyclicDFA< OracleDMLImplTraits, OracleDML >, public OracleDMLTokens
{
public:
	typedef CyclicDFA< OracleDMLImplTraits, OracleDML >  BaseType;
	typedef BaseType::ContextType CtxType;

private:
	//to maintain C-Target compatibility, we need to make some of ctx functions look like member funcs
	CtxType*	m_ctx; 
	

public:
	OracleDMLCyclicDFA108( ANTLR_INT32	decisionNumber
					, const ANTLR_UCHAR*	description
					, const ANTLR_INT32* const	eot
					, const ANTLR_INT32* const	eof
					, const ANTLR_INT32* const	min
					, const ANTLR_INT32* const	max
					, const ANTLR_INT32* const	accept
					, const ANTLR_INT32* const	special
					, const ANTLR_INT32* const *const	transition)
					:BaseType( decisionNumber, description, eot, eof, min, max, accept,
								special, transition )
	{
		m_ctx = NULL;
		
	}

    ANTLR_UINT32 LA(ANTLR_INT32 i)
    {
        return m_ctx->LA(i);
    }

    const CtxType::CommonTokenType*  LT(ANTLR_INT32 k)
    {
        return m_ctx->LT(k);
    }
    template<typename PredType>
    bool msynpred( PredType pred )
    {
        return m_ctx->msynpred(pred);
    }

	ANTLR_INT32  specialStateTransition(CtxType * ctx, RecognizerType* recognizer, IntStreamType* is, ANTLR_INT32 s)
	{
	    ANTLR_INT32    _s;

	    m_ctx = ctx;
	    _s	    = s;
	    switch  (s)
	    {
	    	    case 0:

	    		{
	    		    ANTLR_UINT32 LA108_4;

	    		    ANTLR_MARKER index108_4;


	    		    LA108_4 = ctx->LA(1);

	    		     
	    		        index108_4 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA108_4 == REGULAR_ID) && ((toUpper(LT(1)->getText()) == "MAIN")) )
	    		    {
	    		        s = 8;
	    		    }

	    		    else if ( (LA108_4 == SQL92_RESERVED_ON) && ((toUpper(LT(1)->getText()) == "REFERENCE")) )
	    		    {
	    		        s = 9;
	    		    }

	    			 
	    				ctx->seek(index108_4);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 1:

	    		{
	    		    ANTLR_UINT32 LA108_11;

	    		    ANTLR_MARKER index108_11;


	    		    LA108_11 = ctx->LA(1);

	    		     
	    		        index108_11 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA108_11 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "MAIN"))||((toUpper(LT(1)->getText()) == "REFERENCE")))) )
	    		    {
	    		        s = 3;
	    		    }

	    		    else if ( (LA108_11 == DELIMITED_ID) && ((((toUpper(LT(1)->getText()) == "MAIN"))||((toUpper(LT(1)->getText()) == "REFERENCE")))) )
	    		    {
	    		        s = 4;
	    		    }

	    		    else if ( (LA108_11 == PERIOD) && ((((toUpper(LT(1)->getText()) == "MAIN"))||((toUpper(LT(1)->getText()) == "REFERENCE")))) )
	    		    {
	    		        s = 10;
	    		    }

	    			 
	    				ctx->seek(index108_11);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 2:

	    		{
	    		    ANTLR_UINT32 LA108_1;

	    		    ANTLR_MARKER index108_1;


	    		    LA108_1 = ctx->LA(1);

	    		     
	    		        index108_1 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA108_1 == INTRODUCER) && ((((toUpper(LT(1)->getText()) == "MAIN"))||((toUpper(LT(1)->getText()) == "REFERENCE")))) )
	    		    {
	    		        s = 2;
	    		    }

	    		    else if ( (LA108_1 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "MAIN"))||((toUpper(LT(1)->getText()) == "REFERENCE")))) )
	    		    {
	    		        s = 3;
	    		    }

	    		    else if ( (LA108_1 == DELIMITED_ID) && ((((toUpper(LT(1)->getText()) == "MAIN"))||((toUpper(LT(1)->getText()) == "REFERENCE")))) )
	    		    {
	    		        s = 4;
	    		    }

	    		    else if ( (LA108_1 == SQL92_RESERVED_BY) && ((((toUpper(LT(1)->getText()) == "DIMENSION"))||((toUpper(LT(1)->getText()) == "PARTITION")))) )
	    		    {
	    		        s = 5;
	    		    }

	    			 
	    				ctx->seek(index108_1);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 3:

	    		{
	    		    ANTLR_UINT32 LA108_7;

	    		    ANTLR_MARKER index108_7;


	    		    LA108_7 = ctx->LA(1);

	    		     
	    		        index108_7 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA108_7 == PERIOD) && ((((toUpper(LT(1)->getText()) == "MAIN"))||((toUpper(LT(1)->getText()) == "REFERENCE")))) )
	    		    {
	    		        s = 10;
	    		    }

	    		    else if ( (LA108_7 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "MAIN"))||((toUpper(LT(1)->getText()) == "REFERENCE")))) )
	    		    {
	    		        s = 3;
	    		    }

	    		    else if ( (LA108_7 == DELIMITED_ID) && ((((toUpper(LT(1)->getText()) == "MAIN"))||((toUpper(LT(1)->getText()) == "REFERENCE")))) )
	    		    {
	    		        s = 4;
	    		    }

	    			 
	    				ctx->seek(index108_7);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 4:

	    		{
	    		    ANTLR_UINT32 LA108_3;

	    		    ANTLR_MARKER index108_3;


	    		    LA108_3 = ctx->LA(1);

	    		     
	    		        index108_3 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA108_3 == REGULAR_ID) && ((toUpper(LT(1)->getText()) == "MAIN")) )
	    		    {
	    		        s = 8;
	    		    }

	    		    else if ( (LA108_3 == SQL92_RESERVED_ON) && ((toUpper(LT(1)->getText()) == "REFERENCE")) )
	    		    {
	    		        s = 9;
	    		    }

	    			 
	    				ctx->seek(index108_3);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 5:

	    		{
	    		    ANTLR_UINT32 LA108_10;

	    		    ANTLR_MARKER index108_10;


	    		    LA108_10 = ctx->LA(1);

	    		     
	    		        index108_10 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA108_10 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "MAIN"))||((toUpper(LT(1)->getText()) == "REFERENCE")))) )
	    		    {
	    		        s = 11;
	    		    }

	    		    else if ( (LA108_10 == DELIMITED_ID) && ((((toUpper(LT(1)->getText()) == "MAIN"))||((toUpper(LT(1)->getText()) == "REFERENCE")))) )
	    		    {
	    		        s = 12;
	    		    }

	    			 
	    				ctx->seek(index108_10);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 6:

	    		{
	    		    ANTLR_UINT32 LA108_6;

	    		    ANTLR_MARKER index108_6;


	    		    LA108_6 = ctx->LA(1);

	    		     
	    		        index108_6 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA108_6 == PERIOD) && ((((toUpper(LT(1)->getText()) == "MAIN"))||((toUpper(LT(1)->getText()) == "REFERENCE")))) )
	    		    {
	    		        s = 10;
	    		    }

	    		    else if ( (LA108_6 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "MAIN"))||((toUpper(LT(1)->getText()) == "REFERENCE")))) )
	    		    {
	    		        s = 3;
	    		    }

	    		    else if ( (LA108_6 == DELIMITED_ID) && ((((toUpper(LT(1)->getText()) == "MAIN"))||((toUpper(LT(1)->getText()) == "REFERENCE")))) )
	    		    {
	    		        s = 4;
	    		    }

	    			 
	    				ctx->seek(index108_6);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 7:

	    		{
	    		    ANTLR_UINT32 LA108_2;

	    		    ANTLR_MARKER index108_2;


	    		    LA108_2 = ctx->LA(1);

	    		     
	    		        index108_2 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA108_2 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "MAIN"))||((toUpper(LT(1)->getText()) == "REFERENCE")))) )
	    		    {
	    		        s = 6;
	    		    }

	    		    else if ( (LA108_2 == DELIMITED_ID) && ((((toUpper(LT(1)->getText()) == "MAIN"))||((toUpper(LT(1)->getText()) == "REFERENCE")))) )
	    		    {
	    		        s = 7;
	    		    }

	    			 
	    				ctx->seek(index108_2);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 8:

	    		{
	    		    ANTLR_UINT32 LA108_0;

	    		    ANTLR_MARKER index108_0;


	    		    LA108_0 = ctx->LA(1);

	    		     
	    		        index108_0 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA108_0 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "DIMENSION"))||((toUpper(LT(1)->getText()) == "PARTITION"))||((toUpper(LT(1)->getText()) == "MAIN"))||((toUpper(LT(1)->getText()) == "REFERENCE")))) )
	    		    {
	    		        s = 1;
	    		    }

	    			 
	    				ctx->seek(index108_0);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 9:

	    		{
	    		    ANTLR_UINT32 LA108_12;

	    		    ANTLR_MARKER index108_12;


	    		    LA108_12 = ctx->LA(1);

	    		     
	    		        index108_12 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA108_12 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "MAIN"))||((toUpper(LT(1)->getText()) == "REFERENCE")))) )
	    		    {
	    		        s = 3;
	    		    }

	    		    else if ( (LA108_12 == DELIMITED_ID) && ((((toUpper(LT(1)->getText()) == "MAIN"))||((toUpper(LT(1)->getText()) == "REFERENCE")))) )
	    		    {
	    		        s = 4;
	    		    }

	    		    else if ( (LA108_12 == PERIOD) && ((((toUpper(LT(1)->getText()) == "MAIN"))||((toUpper(LT(1)->getText()) == "REFERENCE")))) )
	    		    {
	    		        s = 10;
	    		    }

	    			 
	    				ctx->seek(index108_12);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;
	    }
	    if ( ctx->get_backtracking() > 0)
	    {
		 ctx->set_failedflag( true );
		return	-1;
	    }
	    ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( recognizer, "()* loopback of 488:64: ( reference_model )*" );
	    ex->set_decisionNum( 108 );
	    ex->set_state(_s);
	    return -1;
	}
};

static OracleDMLCyclicDFA108  cdfa108(
	    108,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const ANTLR_UCHAR*)"()* loopback of 488:64: ( reference_model )*",
	    dfa108_eot,	    /* EOT table			    */
	    dfa108_eof,	    /* EOF table			    */
	    dfa108_min,	    /* Minimum tokens for each state    */
	    dfa108_max,	    /* Maximum tokens for each state    */
	    dfa108_accept,	/* Accept table			    */
	    dfa108_special,	/* Special transition states	    */
	    dfa108_transitions	/* Table of transition tables	    */

	);


/* End of Cyclic DFA 108
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    782:9: ( error_logging_into_part )?
 */
static const ANTLR_INT32 dfa199_eot[12] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa199_eof[12] =
    {
	2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa199_min[12] =
    {
	13, 113, -1, 113, -1, -1, 113, 113, 113, -1, 113, 113
    };
static const ANTLR_INT32 dfa199_max[12] =
    {
	617, 504, -1, 384, -1, -1, 384, 384, 384, -1, 384, 384
    };
static const ANTLR_INT32 dfa199_accept[12] =
    {
	-1, -1, 2, -1, 1, 1, -1, -1, -1, 1, -1, -1
    };
static const ANTLR_INT32 dfa199_special[12] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
static const ANTLR_INT32* dfa199_T_empty	 =   NULL;

static const ANTLR_INT32 dfa199_T0[] =
    {
	11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 10
    };

static const ANTLR_INT32 dfa199_T1[] =
    {
	5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 3, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 2
    };

static const ANTLR_INT32 dfa199_T2[] =
    {
	5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 9
    };

static const ANTLR_INT32 dfa199_T3[] =
    {
	2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, 2, 2, -1, -1, -1, -1, -1, -1, -1, -1, 2, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 2, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, 2, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 2, -1, -1, 2, -1, -1, -1, -1, -1, 2, -1, -1, -1, -1, 2, 2, -1, 2, -1, 
	-1, 2, -1, 2, -1, -1, 2, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 
	-1, -1, 2, 2, -1, -1, -1, -1, -1, -1, 2, -1, -1, -1, 2, -1, -1, -1, -1, 
	-1, 2, -1, -1, -1, -1, -1, 2, -1, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 2
    };

static const ANTLR_INT32 dfa199_T4[] =
    {
	7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 6
    };


/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR_INT32 * const dfa199_transitions[] =
{
    dfa199_T3, dfa199_T1, NULL, dfa199_T4, NULL, NULL, dfa199_T2, dfa199_T2, 
    dfa199_T0, NULL, dfa199_T2, dfa199_T2
};


/* Declare tracking structure for Cyclic DFA 199
 */
class OracleDMLCyclicDFA199 : public CyclicDFA< OracleDMLImplTraits, OracleDML >, public OracleDMLTokens
{
public:
	typedef CyclicDFA< OracleDMLImplTraits, OracleDML >  BaseType;
	typedef BaseType::ContextType CtxType;

private:
	

public:
	OracleDMLCyclicDFA199( ANTLR_INT32	decisionNumber
					, const ANTLR_UCHAR*	description
					, const ANTLR_INT32* const	eot
					, const ANTLR_INT32* const	eof
					, const ANTLR_INT32* const	min
					, const ANTLR_INT32* const	max
					, const ANTLR_INT32* const	accept
					, const ANTLR_INT32* const	special
					, const ANTLR_INT32* const *const	transition)
					:BaseType( decisionNumber, description, eot, eof, min, max, accept,
								special, transition )
	{
		
	}

};

static OracleDMLCyclicDFA199  cdfa199(
	    199,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const ANTLR_UCHAR*)"782:9: ( error_logging_into_part )?",
	    dfa199_eot,	    /* EOT table			    */
	    dfa199_eof,	    /* EOF table			    */
	    dfa199_min,	    /* Minimum tokens for each state    */
	    dfa199_max,	    /* Maximum tokens for each state    */
	    dfa199_accept,	/* Accept table			    */
	    dfa199_special,	/* Special transition states	    */
	    dfa199_transitions	/* Table of transition tables	    */

	);


/* End of Cyclic DFA 199
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    1124:1: atom options {backtrack=true; } : ( ( table_element outer_join_sign )=> table_element outer_join_sign | bind_variable | constant | general_element | LEFT_PAREN ( ( select_key | with_key )=> subquery RIGHT_PAREN ( subquery_operation_part )* | expression_or_vector RIGHT_PAREN ) -> { mode == 1 }? ^( NESTED_SUBQUERY LEFT_PAREN subquery RIGHT_PAREN ( subquery_operation_part )* ) -> ^( NESTED_EXPR LEFT_PAREN expression_or_vector RIGHT_PAREN ) );
 */
static const ANTLR_INT32 dfa278_eot[27] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa278_eof[27] =
    {
	-1, -1, -1, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 11, 11, 
	-1, -1, -1, -1, -1, -1, -1, 11, 11
    };
static const ANTLR_INT32 dfa278_min[27] =
    {
	13, 113, 222, 19, -1, -1, -1, 113, 113, -1, -1, -1, 113, 13, 113, 19, 19, 
	19, 13, 113, 113, 13, 113, -1, 13, 19, 19
    };
static const ANTLR_INT32 dfa278_max[27] =
    {
	617, 384, 322, 630, -1, -1, -1, 384, 384, -1, -1, -1, 384, 617, 384, 630, 
	630, 630, 617, 384, 384, 617, 384, -1, 617, 630, 630
    };
static const ANTLR_INT32 dfa278_accept[27] =
    {
	-1, -1, -1, -1, 2, 3, 5, -1, -1, 1, 1, 4, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 1, -1, -1, -1
    };
static const ANTLR_INT32 dfa278_special[27] =
    {
	-1, -1, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	2, -1, -1, -1, -1, -1, 0, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
static const ANTLR_INT32* dfa278_T_empty	 =   NULL;

static const ANTLR_INT32 dfa278_T0[] =
    {
	17, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 11, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 16
    };

static const ANTLR_INT32 dfa278_T1[] =
    {
	3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 14, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 15
    };

static const ANTLR_INT32 dfa278_T2[] =
    {
	11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, 11, 11, -1, -1, -1, -1, -1, -1, -1, -1, 11, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 11, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 23, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 11, -1, -1, 11, -1, -1, -1, -1, -1, 11, -1, -1, -1, -1, 
	-1, 11, -1, 11, -1, -1, 11, -1, -1, -1, -1, 11, 11, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 11, -1, -1, -1, -1, -1, -1, 11, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11
    };

static const ANTLR_INT32 dfa278_T3[] =
    {
	10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9
    };

static const ANTLR_INT32 dfa278_T4[] =
    {
	8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 7
    };

static const ANTLR_INT32 dfa278_T5[] =
    {
	5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, 5, 5, -1, -1, -1, -1, -1, -1, -1, -1, 4, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 3, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	5, -1, 5, -1, -1, -1, -1, -1, -1, -1, -1, 5, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 5
    };

static const ANTLR_INT32 dfa278_T6[] =
    {
	11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, -1, -1, -1, -1, -1, -1, 
	11, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, -1, -1, -1, -1, 
	-1, -1, -1, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 11, -1, -1, -1, -1, -1, 11, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 11, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 11, 21, -1, 11, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 11, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 22, -1, -1, 
	-1, -1, -1, -1, -1, -1, 11, 11, 11, 11, 11, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 11, -1, -1, -1, -1, -1, 11, -1, -1, -1, 11, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 11, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 11, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, -1, -1, -1, -1, -1, 
	11, -1, 11, 11, -1, 11, -1, -1, -1, 11, -1, -1, -1, -1, -1, 11, 11, 11, 
	-1, -1, 11, 11, -1, -1, -1, 11, 11, 11, -1, -1, 11, 11, 11, -1, 11, 11, 
	11, 11, 11, -1, -1, 11, -1, 11, 11, -1, -1, -1, -1, -1, 11, -1, -1, -1, 
	11, 11, -1, 11, -1, -1, -1, -1, 11, 11, 11, -1, 11, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11
    };

static const ANTLR_INT32 dfa278_T7[] =
    {
	11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, 11, 11, -1, -1, -1, -1, -1, -1, -1, -1, 11, -1, 
	-1, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 11, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	24, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 11, -1, -1, 11, -1, -1, -1, -1, -1, 11, -1, -1, -1, -1, 
	11, 11, -1, 11, -1, -1, 11, -1, -1, -1, -1, 11, 11, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 11, 11, -1, -1, -1, -1, -1, -1, 11, -1, 
	-1, -1, 11, -1, -1, -1, -1, -1, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11
    };

static const ANTLR_INT32 dfa278_T8[] =
    {
	20, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 19
    };

static const ANTLR_INT32 dfa278_T9[] =
    {
	11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, -1, -1, -1, -1, -1, -1, 
	11, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, -1, -1, -1, -1, 
	-1, -1, -1, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 11, -1, -1, -1, -1, -1, 11, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 11, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 11, 13, -1, 11, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 11, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 12, -1, -1, 
	-1, -1, -1, -1, -1, -1, 11, 11, 11, 11, 11, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 11, -1, -1, -1, -1, -1, 11, -1, -1, -1, 11, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 11, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 11, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, -1, -1, -1, -1, -1, 
	11, -1, 11, 11, -1, 11, -1, -1, -1, 11, -1, -1, -1, -1, -1, 11, 11, 11, 
	-1, -1, 11, 11, -1, -1, -1, 11, 11, 11, -1, -1, 11, 11, 11, -1, 11, 11, 
	11, 11, 11, -1, -1, 11, -1, 11, 11, -1, -1, -1, -1, -1, 11, -1, -1, -1, 
	11, 11, -1, 11, -1, -1, -1, -1, 11, 11, 11, -1, 11, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11
    };

static const ANTLR_INT32 dfa278_T10[] =
    {
	11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, 11, 11, -1, -1, -1, -1, -1, -1, -1, -1, 11, -1, 
	-1, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 11, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	18, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 11, -1, -1, 11, -1, -1, -1, -1, -1, 11, -1, -1, -1, -1, 
	11, 11, -1, 11, -1, -1, 11, -1, -1, -1, -1, 11, 11, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 11, 11, -1, -1, -1, -1, -1, -1, 11, -1, 
	-1, -1, 11, -1, -1, -1, -1, -1, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11
    };

static const ANTLR_INT32 dfa278_T11[] =
    {
	26, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 11, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 25
    };


/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR_INT32 * const dfa278_transitions[] =
{
    dfa278_T5, dfa278_T4, dfa278_T3, dfa278_T9, NULL, NULL, NULL, dfa278_T1, 
    dfa278_T1, NULL, NULL, NULL, dfa278_T0, dfa278_T10, dfa278_T8, dfa278_T9, 
    dfa278_T6, dfa278_T6, dfa278_T2, dfa278_T1, dfa278_T1, dfa278_T7, dfa278_T11, 
    NULL, dfa278_T2, dfa278_T6, dfa278_T6
};


/* Declare tracking structure for Cyclic DFA 278
 */
class OracleDMLCyclicDFA278 : public CyclicDFA< OracleDMLImplTraits, OracleDML >, public OracleDMLTokens
{
public:
	typedef CyclicDFA< OracleDMLImplTraits, OracleDML >  BaseType;
	typedef BaseType::ContextType CtxType;

private:
	//to maintain C-Target compatibility, we need to make some of ctx functions look like member funcs
	CtxType*	m_ctx; 
	

public:
	OracleDMLCyclicDFA278( ANTLR_INT32	decisionNumber
					, const ANTLR_UCHAR*	description
					, const ANTLR_INT32* const	eot
					, const ANTLR_INT32* const	eof
					, const ANTLR_INT32* const	min
					, const ANTLR_INT32* const	max
					, const ANTLR_INT32* const	accept
					, const ANTLR_INT32* const	special
					, const ANTLR_INT32* const *const	transition)
					:BaseType( decisionNumber, description, eot, eof, min, max, accept,
								special, transition )
	{
		m_ctx = NULL;
		
	}

    ANTLR_UINT32 LA(ANTLR_INT32 i)
    {
        return m_ctx->LA(i);
    }

    const CtxType::CommonTokenType*  LT(ANTLR_INT32 k)
    {
        return m_ctx->LT(k);
    }
    template<typename PredType>
    bool msynpred( PredType pred )
    {
        return m_ctx->msynpred(pred);
    }

	ANTLR_INT32  specialStateTransition(CtxType * ctx, RecognizerType* recognizer, IntStreamType* is, ANTLR_INT32 s)
	{
	    ANTLR_INT32    _s;

	    m_ctx = ctx;
	    _s	    = s;
	    switch  (s)
	    {
	    	    case 0:

	    		{
	    		    ANTLR_UINT32 LA278_24;

	    		    ANTLR_MARKER index278_24;


	    		    LA278_24 = ctx->LA(1);

	    		     
	    		        index278_24 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA278_24 == RIGHT_PAREN) && (this->msynpred( antlr3::ClassForwarder<synpred46_OracleDML>() )) )
	    		    {
	    		        s = 23;
	    		    }

	    		    else if ( (LA278_24 == APPROXIMATE_NUM_LIT || LA278_24 == BINDVAR || ((LA278_24 >= CHAR_STRING) && (LA278_24 <= CHAR_STRING_PERL)) || LA278_24 == COLON || LA278_24 == DELIMITED_ID || LA278_24 == EXACT_NUM_LIT || LA278_24 == INTRODUCER || LA278_24 == LEFT_PAREN || LA278_24 == MINUS_SIGN || LA278_24 == NATIONAL_CHAR_STRING_LIT || ((LA278_24 >= PLSQL_NON_RESERVED_CAST) && (LA278_24 <= PLSQL_NON_RESERVED_CONNECT_BY_ROOT)) || LA278_24 == PLUS_SIGN || LA278_24 == REGULAR_ID || LA278_24 == SQL92_RESERVED_ALL || LA278_24 == SQL92_RESERVED_ANY || LA278_24 == SQL92_RESERVED_CASE || LA278_24 == SQL92_RESERVED_DATE || LA278_24 == SQL92_RESERVED_DEFAULT || LA278_24 == SQL92_RESERVED_DISTINCT || ((LA278_24 >= SQL92_RESERVED_EXISTS) && (LA278_24 <= SQL92_RESERVED_FALSE)) || LA278_24 == SQL92_RESERVED_NULL || LA278_24 == SQL92_RESERVED_PRIOR || LA278_24 == SQL92_RESERVED_TRUE || LA278_24 == UNSIGNED_INTEGER)  )
	    		    {
	    		        s = 11;
	    		    }

	    			 
	    				ctx->seek(index278_24);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 1:

	    		{
	    		    ANTLR_UINT32 LA278_2;

	    		    ANTLR_MARKER index278_2;


	    		    LA278_2 = ctx->LA(1);

	    		     
	    		        index278_2 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA278_2 == PERIOD) && (this->msynpred( antlr3::ClassForwarder<synpred46_OracleDML>() )) )
	    		    {
	    		        s = 9;
	    		    }

	    		    else if ( (LA278_2 == LEFT_PAREN) && (this->msynpred( antlr3::ClassForwarder<synpred46_OracleDML>() )) )
	    		    {
	    		        s = 10;
	    		    }

	    		    else if ( (( ((((toUpper(LT(1)->getText()) == "INTERVAL"))||((toUpper(LT(1)->getText()) == "MINVALUE"))||((toUpper(LT(1)->getText()) == "SESSIONTIMEZONE"))||((toUpper(LT(1)->getText()) == "TIMESTAMP"))||((toUpper(LT(1)->getText()) == "MAXVALUE"))||((toUpper(LT(1)->getText()) == "DBTIMEZONE")))) && (this->msynpred( antlr3::ClassForwarder<synpred48_OracleDML>() )) ))  )
	    		    {
	    		        s = 5;
	    		    }

	    		    else if ( (this->msynpred( antlr3::ClassForwarder<synpred49_OracleDML>() ))  )
	    		    {
	    		        s = 11;
	    		    }

	    			 
	    				ctx->seek(index278_2);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 2:

	    		{
	    		    ANTLR_UINT32 LA278_18;

	    		    ANTLR_MARKER index278_18;


	    		    LA278_18 = ctx->LA(1);

	    		     
	    		        index278_18 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA278_18 == RIGHT_PAREN) && (this->msynpred( antlr3::ClassForwarder<synpred46_OracleDML>() )) )
	    		    {
	    		        s = 23;
	    		    }

	    		    else if ( (LA278_18 == APPROXIMATE_NUM_LIT || LA278_18 == BINDVAR || ((LA278_18 >= CHAR_STRING) && (LA278_18 <= CHAR_STRING_PERL)) || LA278_18 == COLON || LA278_18 == DELIMITED_ID || LA278_18 == EXACT_NUM_LIT || LA278_18 == INTRODUCER || LA278_18 == LEFT_PAREN || LA278_18 == MINUS_SIGN || LA278_18 == NATIONAL_CHAR_STRING_LIT || ((LA278_18 >= PLSQL_NON_RESERVED_CAST) && (LA278_18 <= PLSQL_NON_RESERVED_CONNECT_BY_ROOT)) || LA278_18 == PLUS_SIGN || LA278_18 == REGULAR_ID || LA278_18 == SQL92_RESERVED_ALL || LA278_18 == SQL92_RESERVED_ANY || LA278_18 == SQL92_RESERVED_CASE || LA278_18 == SQL92_RESERVED_DATE || LA278_18 == SQL92_RESERVED_DEFAULT || LA278_18 == SQL92_RESERVED_DISTINCT || ((LA278_18 >= SQL92_RESERVED_EXISTS) && (LA278_18 <= SQL92_RESERVED_FALSE)) || LA278_18 == SQL92_RESERVED_NULL || LA278_18 == SQL92_RESERVED_PRIOR || LA278_18 == SQL92_RESERVED_TRUE || LA278_18 == UNSIGNED_INTEGER)  )
	    		    {
	    		        s = 11;
	    		    }

	    			 
	    				ctx->seek(index278_18);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;
	    }
	    if ( ctx->get_backtracking() > 0)
	    {
		 ctx->set_failedflag( true );
		return	-1;
	    }
	    ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( recognizer, "1124:1: atom options {backtrack=true; } : ( ( table_element outer_join_sign )=> table_element outer_join_sign | bind_variable | constant | general_element | LEFT_PAREN ( ( select_key | with_key )=> subquery RIGHT_PAREN ( subquery_operation_part )* | expression_or_vector RIGHT_PAREN ) -> { mode == 1 }? ^( NESTED_SUBQUERY LEFT_PAREN subquery RIGHT_PAREN ( subquery_operation_part )* ) -> ^( NESTED_EXPR LEFT_PAREN expression_or_vector RIGHT_PAREN ) );" );
	    ex->set_decisionNum( 278 );
	    ex->set_state(_s);
	    return -1;
	}
};

static OracleDMLCyclicDFA278  cdfa278(
	    278,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const ANTLR_UCHAR*)"1124:1: atom options {backtrack=true; } : ( ( table_element outer_join_sign )=> table_element outer_join_sign | bind_variable | constant | general_element | LEFT_PAREN ( ( select_key | with_key )=> subquery RIGHT_PAREN ( subquery_operation_part )* | expression_or_vector RIGHT_PAREN ) -> { mode == 1 }? ^( NESTED_SUBQUERY LEFT_PAREN subquery RIGHT_PAREN ( subquery_operation_part )* ) -> ^( NESTED_EXPR LEFT_PAREN expression_or_vector RIGHT_PAREN ) );",
	    dfa278_eot,	    /* EOT table			    */
	    dfa278_eof,	    /* EOF table			    */
	    dfa278_min,	    /* Minimum tokens for each state    */
	    dfa278_max,	    /* Maximum tokens for each state    */
	    dfa278_accept,	/* Accept table			    */
	    dfa278_special,	/* Special transition states	    */
	    dfa278_transitions	/* Table of transition tables	    */

	);


/* End of Cyclic DFA 278
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    1247:17: ( name_key id[T_UNKNOWN,T_USE] | evalname_key concatenation_wrapper )
 */
static const ANTLR_INT32 dfa323_eot[14] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa323_eof[14] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa323_min[14] =
    {
	384, 13, 113, 0, 0, -1, 113, 113, -1, 113, 0, 0, 113, 113
    };
static const ANTLR_INT32 dfa323_max[14] =
    {
	384, 617, 384, 0, 0, -1, 384, 384, -1, 384, 0, 0, 384, 384
    };
static const ANTLR_INT32 dfa323_accept[14] =
    {
	-1, -1, -1, -1, -1, 2, -1, -1, 1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa323_special[14] =
    {
	11, 4, 0, 6, 1, -1, 8, 10, -1, 2, 7, 9, 3, 5
    };

/** Used when there is no transition table entry for a particular state */
static const ANTLR_INT32* dfa323_T_empty	 =   NULL;

static const ANTLR_INT32 dfa323_T0[] =
    {
	7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 6
    };

static const ANTLR_INT32 dfa323_T1[] =
    {
	-1
    };

static const ANTLR_INT32 dfa323_T2[] =
    {
	13, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 12
    };

static const ANTLR_INT32 dfa323_T3[] =
    {
	11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 10
    };

static const ANTLR_INT32 dfa323_T4[] =
    {
	5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, 5, 5, -1, -1, -1, -1, -1, -1, -1, -1, 5, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 4, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, 5, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 5, -1, -1, 5, -1, -1, -1, -1, -1, 5, -1, -1, -1, -1, -1, 5, -1, 5, 
	-1, -1, 5, -1, -1, -1, -1, 5, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 5, -1, -1, -1, -1, -1, -1, 5, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 5
    };

static const ANTLR_INT32 dfa323_T5[] =
    {
	1
    };


/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR_INT32 * const dfa323_transitions[] =
{
    dfa323_T5, dfa323_T4, dfa323_T0, dfa323_T1, dfa323_T1, NULL, dfa323_T3, 
    dfa323_T3, NULL, dfa323_T2, dfa323_T1, dfa323_T1, dfa323_T3, dfa323_T3
};


/* Declare tracking structure for Cyclic DFA 323
 */
class OracleDMLCyclicDFA323 : public CyclicDFA< OracleDMLImplTraits, OracleDML >, public OracleDMLTokens
{
public:
	typedef CyclicDFA< OracleDMLImplTraits, OracleDML >  BaseType;
	typedef BaseType::ContextType CtxType;

private:
	//to maintain C-Target compatibility, we need to make some of ctx functions look like member funcs
	CtxType*	m_ctx; 
	

public:
	OracleDMLCyclicDFA323( ANTLR_INT32	decisionNumber
					, const ANTLR_UCHAR*	description
					, const ANTLR_INT32* const	eot
					, const ANTLR_INT32* const	eof
					, const ANTLR_INT32* const	min
					, const ANTLR_INT32* const	max
					, const ANTLR_INT32* const	accept
					, const ANTLR_INT32* const	special
					, const ANTLR_INT32* const *const	transition)
					:BaseType( decisionNumber, description, eot, eof, min, max, accept,
								special, transition )
	{
		m_ctx = NULL;
		
	}

    ANTLR_UINT32 LA(ANTLR_INT32 i)
    {
        return m_ctx->LA(i);
    }

    const CtxType::CommonTokenType*  LT(ANTLR_INT32 k)
    {
        return m_ctx->LT(k);
    }
    template<typename PredType>
    bool msynpred( PredType pred )
    {
        return m_ctx->msynpred(pred);
    }

	ANTLR_INT32  specialStateTransition(CtxType * ctx, RecognizerType* recognizer, IntStreamType* is, ANTLR_INT32 s)
	{
	    ANTLR_INT32    _s;

	    m_ctx = ctx;
	    _s	    = s;
	    switch  (s)
	    {
	    	    case 0:

	    		{
	    		    ANTLR_UINT32 LA323_2;

	    		    ANTLR_MARKER index323_2;


	    		    LA323_2 = ctx->LA(1);

	    		     
	    		        index323_2 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA323_2 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "EVALNAME"))||((toUpper(LT(1)->getText()) == "NAME")))) )
	    		    {
	    		        s = 6;
	    		    }

	    		    else if ( (LA323_2 == DELIMITED_ID) && ((((toUpper(LT(1)->getText()) == "EVALNAME"))||((toUpper(LT(1)->getText()) == "NAME")))) )
	    		    {
	    		        s = 7;
	    		    }

	    			 
	    				ctx->seek(index323_2);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 1:

	    		{
	    		    ANTLR_UINT32 LA323_4;

	    		    ANTLR_MARKER index323_4;


	    		    LA323_4 = ctx->LA(1);

	    		     
	    		        index323_4 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((toUpper(LT(1)->getText()) == "NAME"))  )
	    		    {
	    		        s = 8;
	    		    }

	    		    else if ( ((toUpper(LT(1)->getText()) == "EVALNAME"))  )
	    		    {
	    		        s = 5;
	    		    }

	    			 
	    				ctx->seek(index323_4);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 2:

	    		{
	    		    ANTLR_UINT32 LA323_9;

	    		    ANTLR_MARKER index323_9;


	    		    LA323_9 = ctx->LA(1);

	    		     
	    		        index323_9 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA323_9 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "EVALNAME"))||((toUpper(LT(1)->getText()) == "NAME")))) )
	    		    {
	    		        s = 12;
	    		    }

	    		    else if ( (LA323_9 == DELIMITED_ID) && ((((toUpper(LT(1)->getText()) == "EVALNAME"))||((toUpper(LT(1)->getText()) == "NAME")))) )
	    		    {
	    		        s = 13;
	    		    }

	    			 
	    				ctx->seek(index323_9);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 3:

	    		{
	    		    ANTLR_UINT32 LA323_12;

	    		    ANTLR_MARKER index323_12;


	    		    LA323_12 = ctx->LA(1);

	    		     
	    		        index323_12 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA323_12 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "EVALNAME"))||((toUpper(LT(1)->getText()) == "NAME")))) )
	    		    {
	    		        s = 10;
	    		    }

	    		    else if ( (LA323_12 == DELIMITED_ID) && ((((toUpper(LT(1)->getText()) == "EVALNAME"))||((toUpper(LT(1)->getText()) == "NAME")))) )
	    		    {
	    		        s = 11;
	    		    }

	    		    else if ( (LA323_12 == PERIOD) && ((((toUpper(LT(1)->getText()) == "EVALNAME"))||((toUpper(LT(1)->getText()) == "NAME")))) )
	    		    {
	    		        s = 9;
	    		    }

	    			 
	    				ctx->seek(index323_12);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 4:

	    		{
	    		    ANTLR_UINT32 LA323_1;

	    		    ANTLR_MARKER index323_1;


	    		    LA323_1 = ctx->LA(1);

	    		     
	    		        index323_1 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA323_1 == INTRODUCER) && ((((toUpper(LT(1)->getText()) == "EVALNAME"))||((toUpper(LT(1)->getText()) == "NAME")))) )
	    		    {
	    		        s = 2;
	    		    }

	    		    else if ( (LA323_1 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "EVALNAME"))||((toUpper(LT(1)->getText()) == "NAME")))) )
	    		    {
	    		        s = 3;
	    		    }

	    		    else if ( (LA323_1 == DELIMITED_ID) && ((((toUpper(LT(1)->getText()) == "EVALNAME"))||((toUpper(LT(1)->getText()) == "NAME")))) )
	    		    {
	    		        s = 4;
	    		    }

	    		    else if ( (LA323_1 == APPROXIMATE_NUM_LIT || LA323_1 == BINDVAR || ((LA323_1 >= CHAR_STRING) && (LA323_1 <= CHAR_STRING_PERL)) || LA323_1 == COLON || LA323_1 == EXACT_NUM_LIT || LA323_1 == LEFT_PAREN || LA323_1 == MINUS_SIGN || LA323_1 == NATIONAL_CHAR_STRING_LIT || ((LA323_1 >= PLSQL_NON_RESERVED_CAST) && (LA323_1 <= PLSQL_NON_RESERVED_CONNECT_BY_ROOT)) || LA323_1 == PLUS_SIGN || LA323_1 == SQL92_RESERVED_ALL || LA323_1 == SQL92_RESERVED_ANY || LA323_1 == SQL92_RESERVED_CASE || LA323_1 == SQL92_RESERVED_DATE || LA323_1 == SQL92_RESERVED_DEFAULT || LA323_1 == SQL92_RESERVED_DISTINCT || ((LA323_1 >= SQL92_RESERVED_EXISTS) && (LA323_1 <= SQL92_RESERVED_FALSE)) || LA323_1 == SQL92_RESERVED_NULL || LA323_1 == SQL92_RESERVED_PRIOR || LA323_1 == SQL92_RESERVED_TRUE || LA323_1 == UNSIGNED_INTEGER) && ((toUpper(LT(1)->getText()) == "EVALNAME")) )
	    		    {
	    		        s = 5;
	    		    }

	    			 
	    				ctx->seek(index323_1);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 5:

	    		{
	    		    ANTLR_UINT32 LA323_13;

	    		    ANTLR_MARKER index323_13;


	    		    LA323_13 = ctx->LA(1);

	    		     
	    		        index323_13 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA323_13 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "EVALNAME"))||((toUpper(LT(1)->getText()) == "NAME")))) )
	    		    {
	    		        s = 10;
	    		    }

	    		    else if ( (LA323_13 == DELIMITED_ID) && ((((toUpper(LT(1)->getText()) == "EVALNAME"))||((toUpper(LT(1)->getText()) == "NAME")))) )
	    		    {
	    		        s = 11;
	    		    }

	    		    else if ( (LA323_13 == PERIOD) && ((((toUpper(LT(1)->getText()) == "EVALNAME"))||((toUpper(LT(1)->getText()) == "NAME")))) )
	    		    {
	    		        s = 9;
	    		    }

	    			 
	    				ctx->seek(index323_13);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 6:

	    		{
	    		    ANTLR_UINT32 LA323_3;

	    		    ANTLR_MARKER index323_3;


	    		    LA323_3 = ctx->LA(1);

	    		     
	    		        index323_3 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((toUpper(LT(1)->getText()) == "NAME"))  )
	    		    {
	    		        s = 8;
	    		    }

	    		    else if ( ((toUpper(LT(1)->getText()) == "EVALNAME"))  )
	    		    {
	    		        s = 5;
	    		    }

	    			 
	    				ctx->seek(index323_3);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 7:

	    		{
	    		    ANTLR_UINT32 LA323_10;

	    		    ANTLR_MARKER index323_10;


	    		    LA323_10 = ctx->LA(1);

	    		     
	    		        index323_10 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((toUpper(LT(1)->getText()) == "NAME"))  )
	    		    {
	    		        s = 8;
	    		    }

	    		    else if ( ((toUpper(LT(1)->getText()) == "EVALNAME"))  )
	    		    {
	    		        s = 5;
	    		    }

	    			 
	    				ctx->seek(index323_10);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 8:

	    		{
	    		    ANTLR_UINT32 LA323_6;

	    		    ANTLR_MARKER index323_6;


	    		    LA323_6 = ctx->LA(1);

	    		     
	    		        index323_6 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA323_6 == PERIOD) && ((((toUpper(LT(1)->getText()) == "EVALNAME"))||((toUpper(LT(1)->getText()) == "NAME")))) )
	    		    {
	    		        s = 9;
	    		    }

	    		    else if ( (LA323_6 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "EVALNAME"))||((toUpper(LT(1)->getText()) == "NAME")))) )
	    		    {
	    		        s = 10;
	    		    }

	    		    else if ( (LA323_6 == DELIMITED_ID) && ((((toUpper(LT(1)->getText()) == "EVALNAME"))||((toUpper(LT(1)->getText()) == "NAME")))) )
	    		    {
	    		        s = 11;
	    		    }

	    			 
	    				ctx->seek(index323_6);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 9:

	    		{
	    		    ANTLR_UINT32 LA323_11;

	    		    ANTLR_MARKER index323_11;


	    		    LA323_11 = ctx->LA(1);

	    		     
	    		        index323_11 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((toUpper(LT(1)->getText()) == "NAME"))  )
	    		    {
	    		        s = 8;
	    		    }

	    		    else if ( ((toUpper(LT(1)->getText()) == "EVALNAME"))  )
	    		    {
	    		        s = 5;
	    		    }

	    			 
	    				ctx->seek(index323_11);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 10:

	    		{
	    		    ANTLR_UINT32 LA323_7;

	    		    ANTLR_MARKER index323_7;


	    		    LA323_7 = ctx->LA(1);

	    		     
	    		        index323_7 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA323_7 == PERIOD) && ((((toUpper(LT(1)->getText()) == "EVALNAME"))||((toUpper(LT(1)->getText()) == "NAME")))) )
	    		    {
	    		        s = 9;
	    		    }

	    		    else if ( (LA323_7 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "EVALNAME"))||((toUpper(LT(1)->getText()) == "NAME")))) )
	    		    {
	    		        s = 10;
	    		    }

	    		    else if ( (LA323_7 == DELIMITED_ID) && ((((toUpper(LT(1)->getText()) == "EVALNAME"))||((toUpper(LT(1)->getText()) == "NAME")))) )
	    		    {
	    		        s = 11;
	    		    }

	    			 
	    				ctx->seek(index323_7);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 11:

	    		{
	    		    ANTLR_UINT32 LA323_0;

	    		    ANTLR_MARKER index323_0;


	    		    LA323_0 = ctx->LA(1);

	    		     
	    		        index323_0 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA323_0 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "EVALNAME"))||((toUpper(LT(1)->getText()) == "NAME")))) )
	    		    {
	    		        s = 1;
	    		    }

	    			 
	    				ctx->seek(index323_0);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;
	    }
	    if ( ctx->get_backtracking() > 0)
	    {
		 ctx->set_failedflag( true );
		return	-1;
	    }
	    ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( recognizer, "1247:17: ( name_key id[T_UNKNOWN,T_USE] | evalname_key concatenation_wrapper )" );
	    ex->set_decisionNum( 323 );
	    ex->set_state(_s);
	    return -1;
	}
};

static OracleDMLCyclicDFA323  cdfa323(
	    323,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const ANTLR_UCHAR*)"1247:17: ( name_key id[T_UNKNOWN,T_USE] | evalname_key concatenation_wrapper )",
	    dfa323_eot,	    /* EOT table			    */
	    dfa323_eof,	    /* EOF table			    */
	    dfa323_min,	    /* Minimum tokens for each state    */
	    dfa323_max,	    /* Maximum tokens for each state    */
	    dfa323_accept,	/* Accept table			    */
	    dfa323_special,	/* Special transition states	    */
	    dfa323_transitions	/* Table of transition tables	    */

	);


/* End of Cyclic DFA 323
 * ---------------------
 */ 
/* =========================================================================
 * End of DFA tables for the parser
 */

/* ==============================================
 * Parsing rules
 */
/**
 * $ANTLR start compilation_unit
 * OracleDML.g:121:1: compilation_unit : ( seq_of_statements )* EOF ;
 */
OracleDML::compilation_unit_return
OracleDML::compilation_unit()
{
    OracleDML::compilation_unit_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* EOF2 = NULL;
    OracleDML::seq_of_statements_return seq_of_statements1;
    ImplTraits::TreeTypePtr::pointer seq_of_statements1_last = NULL;
    ImplTraits::TreeTypePtr EOF2_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:122:5: ( ( seq_of_statements )* EOF )
        // OracleDML.g:122:11: ( seq_of_statements )* EOF
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            // OracleDML.g:122:11: ( seq_of_statements )*

            for (;;)
            {
                ANTLR_UINT32 alt1=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    ANTLR_UINT32 LA1_0 = this->LA(1);
                    if ( (LA1_0 == LEFT_PAREN || LA1_0 == PLSQL_RESERVED_LOCK || LA1_0 == SQL92_RESERVED_DELETE || LA1_0 == SQL92_RESERVED_INSERT || LA1_0 == SQL92_RESERVED_SELECT || LA1_0 == SQL92_RESERVED_UPDATE || LA1_0 == SQL92_RESERVED_WITH))
                    {
                        alt1=1;
                    }
                    else if ( (LA1_0 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "EXPLAIN"))||((toUpper(LT(1)->getText()) == "MERGE")))))
                    {
                        alt1=1;
                    }

                }
                switch (alt1)
                {
            	case 1:
            	    // OracleDML.g:122:11: seq_of_statements
            	    {
            	        this->followPush(FOLLOW_seq_of_statements_in_compilation_unit670);
            	        seq_of_statements1=seq_of_statements();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecompilation_unitEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, seq_of_statements1.tree);


            	    }
            	    break;

            	default:
            	    goto loop1;	/* break out of the loop */
            	    break;
                }
            }
            loop1: ; /* Jump out to here if this rule does not match */


            EOF2 =  this->matchToken(EOF_TOKEN, &FOLLOW_EOF_TOKEN_in_compilation_unit673);
            if  (this->hasException())
            {
                goto rulecompilation_unitEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            EOF2_tree = std::move(get_psrstate()->get_treeAdaptor()->create(EOF2));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, EOF2_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulecompilation_unitEx; /* Prevent compiler warnings */
    rulecompilation_unitEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end compilation_unit */

/**
 * $ANTLR start seq_of_statements
 * OracleDML.g:126:1: seq_of_statements : ( select_statement | update_statement | delete_statement | insert_statement | lock_table_statement | merge_statement | explain_statement ) ( SEMICOLON | EOF ) ;
 */
OracleDML::seq_of_statements_return
OracleDML::seq_of_statements()
{
    OracleDML::seq_of_statements_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* set10 = NULL;
    OracleDML::select_statement_return select_statement3;
    ImplTraits::TreeTypePtr::pointer select_statement3_last = NULL;
    OracleDML::update_statement_return update_statement4;
    ImplTraits::TreeTypePtr::pointer update_statement4_last = NULL;
    OracleDML::delete_statement_return delete_statement5;
    ImplTraits::TreeTypePtr::pointer delete_statement5_last = NULL;
    OracleDML::insert_statement_return insert_statement6;
    ImplTraits::TreeTypePtr::pointer insert_statement6_last = NULL;
    OracleDML::lock_table_statement_return lock_table_statement7;
    ImplTraits::TreeTypePtr::pointer lock_table_statement7_last = NULL;
    OracleDML::merge_statement_return merge_statement8;
    ImplTraits::TreeTypePtr::pointer merge_statement8_last = NULL;
    OracleDML::explain_statement_return explain_statement9;
    ImplTraits::TreeTypePtr::pointer explain_statement9_last = NULL;
    ImplTraits::TreeTypePtr set10_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:127:5: ( ( select_statement | update_statement | delete_statement | insert_statement | lock_table_statement | merge_statement | explain_statement ) ( SEMICOLON | EOF ) )
        // OracleDML.g:128:5: ( select_statement | update_statement | delete_statement | insert_statement | lock_table_statement | merge_statement | explain_statement ) ( SEMICOLON | EOF )
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            // OracleDML.g:128:5: ( select_statement | update_statement | delete_statement | insert_statement | lock_table_statement | merge_statement | explain_statement )
            {
                ANTLR_UINT32 alt2=7;
                {
                    ANTLR_UINT32 LA2_0 = this->LA(1);
                    if ( (LA2_0 == LEFT_PAREN || LA2_0 == SQL92_RESERVED_SELECT || LA2_0 == SQL92_RESERVED_WITH))
                    {
                        alt2=1;
                    }
                    else if ( (LA2_0 == SQL92_RESERVED_UPDATE))
                    {
                        alt2=2;
                    }
                    else if ( (LA2_0 == SQL92_RESERVED_DELETE))
                    {
                        alt2=3;
                    }
                    else if ( (LA2_0 == SQL92_RESERVED_INSERT))
                    {
                        alt2=4;
                    }
                    else if ( (LA2_0 == PLSQL_RESERVED_LOCK))
                    {
                        alt2=5;
                    }
                    else if ( (LA2_0 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "EXPLAIN"))||((toUpper(LT(1)->getText()) == "MERGE")))))
                    {
                        {
                            ANTLR_UINT32 LA2_6 = this->LA(2);
                            if ( (LA2_6 == SQL92_RESERVED_INTO) && ((toUpper(LT(1)->getText()) == "MERGE")))
                            {
                                alt2=6;
                            }
                            else if ( (LA2_6 == REGULAR_ID) && ((toUpper(LT(1)->getText()) == "EXPLAIN")))
                            {
                                alt2=7;
                            }
                            else
                            {
                                if (this->get_backtracking()>0)
                                {
                                    this->set_failedflag( true );
                                    return retval;
                                }


                                ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                ex->set_decisionNum( 2 );
                                ex->set_state( 6 );


                                goto ruleseq_of_statementsEx;

                            }
                        }
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return retval;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 2 );
                        ex->set_state( 0 );


                        goto ruleseq_of_statementsEx;

                    }
                }
                switch (alt2)
                {
            	case 1:
            	    // OracleDML.g:128:10: select_statement
            	    {
            	        this->followPush(FOLLOW_select_statement_in_seq_of_statements700);
            	        select_statement3=select_statement();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleseq_of_statementsEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, select_statement3.tree);


            	    }
            	    break;
            	case 2:
            	    // OracleDML.g:129:10: update_statement
            	    {
            	        this->followPush(FOLLOW_update_statement_in_seq_of_statements711);
            	        update_statement4=update_statement();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleseq_of_statementsEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, update_statement4.tree);


            	    }
            	    break;
            	case 3:
            	    // OracleDML.g:130:10: delete_statement
            	    {
            	        this->followPush(FOLLOW_delete_statement_in_seq_of_statements722);
            	        delete_statement5=delete_statement();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleseq_of_statementsEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, delete_statement5.tree);


            	    }
            	    break;
            	case 4:
            	    // OracleDML.g:131:10: insert_statement
            	    {
            	        this->followPush(FOLLOW_insert_statement_in_seq_of_statements733);
            	        insert_statement6=insert_statement();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleseq_of_statementsEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, insert_statement6.tree);


            	    }
            	    break;
            	case 5:
            	    // OracleDML.g:132:10: lock_table_statement
            	    {
            	        this->followPush(FOLLOW_lock_table_statement_in_seq_of_statements744);
            	        lock_table_statement7=lock_table_statement();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleseq_of_statementsEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, lock_table_statement7.tree);


            	    }
            	    break;
            	case 6:
            	    // OracleDML.g:133:10: merge_statement
            	    {
            	        this->followPush(FOLLOW_merge_statement_in_seq_of_statements755);
            	        merge_statement8=merge_statement();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleseq_of_statementsEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, merge_statement8.tree);


            	    }
            	    break;
            	case 7:
            	    // OracleDML.g:134:10: explain_statement
            	    {
            	        this->followPush(FOLLOW_explain_statement_in_seq_of_statements766);
            	        explain_statement9=explain_statement();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleseq_of_statementsEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, explain_statement9.tree);


            	    }
            	    break;

                }
            }

            set10=(ImplTraits::CommonTokenType const*) this->LT(1);

            if ( this->LA(1) == EOF_TOKEN || this->LA(1) == SEMICOLON )
            {
                this->consume();
                if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(set10));
                this->set_perror_recovery(false);
                 this->set_failedflag(false); 

            }
            else
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                new ANTLR_Exception< OracleDMLImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );
                this->get_exception()->set_expectingSet(NULL);

                goto ruleseq_of_statementsEx;
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleseq_of_statementsEx; /* Prevent compiler warnings */
    ruleseq_of_statementsEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end seq_of_statements */

/**
 * $ANTLR start explain_statement
 * OracleDML.g:139:1: explain_statement : explain_key plan_key ( set_key statement_id_key EQUALS_OP quoted_string )? ( into_key tableview_name )? for_key ( select_statement | update_statement | delete_statement | insert_statement | merge_statement ) -> ^( EXPLAIN_STATEMENT ( select_statement )? ( update_statement )? ( delete_statement )? ( insert_statement )? ( merge_statement )? ) ;
 */
OracleDML::explain_statement_return
OracleDML::explain_statement()
{
    OracleDML::explain_statement_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* EQUALS_OP15 = NULL;
    OracleDML_OracleDMLKeys::explain_key_return explain_key11;
    ImplTraits::TreeTypePtr::pointer explain_key11_last = NULL;
    OracleDML_OracleDMLKeys::plan_key_return plan_key12;
    ImplTraits::TreeTypePtr::pointer plan_key12_last = NULL;
    OracleDML_OracleDMLKeys::set_key_return set_key13;
    ImplTraits::TreeTypePtr::pointer set_key13_last = NULL;
    OracleDML_OracleDMLKeys::statement_id_key_return statement_id_key14;
    ImplTraits::TreeTypePtr::pointer statement_id_key14_last = NULL;
    OracleDML_OracleDMLCommons::quoted_string_return quoted_string16;
    ImplTraits::TreeTypePtr::pointer quoted_string16_last = NULL;
    OracleDML_OracleDMLKeys::into_key_return into_key17;
    ImplTraits::TreeTypePtr::pointer into_key17_last = NULL;
    OracleDML_OracleDMLCommons::tableview_name_return tableview_name18;
    ImplTraits::TreeTypePtr::pointer tableview_name18_last = NULL;
    OracleDML_OracleDMLKeys::for_key_return for_key19;
    ImplTraits::TreeTypePtr::pointer for_key19_last = NULL;
    OracleDML::select_statement_return select_statement20;
    ImplTraits::TreeTypePtr::pointer select_statement20_last = NULL;
    OracleDML::update_statement_return update_statement21;
    ImplTraits::TreeTypePtr::pointer update_statement21_last = NULL;
    OracleDML::delete_statement_return delete_statement22;
    ImplTraits::TreeTypePtr::pointer delete_statement22_last = NULL;
    OracleDML::insert_statement_return insert_statement23;
    ImplTraits::TreeTypePtr::pointer insert_statement23_last = NULL;
    OracleDML::merge_statement_return merge_statement24;
    ImplTraits::TreeTypePtr::pointer merge_statement24_last = NULL;
    ImplTraits::TreeTypePtr EQUALS_OP15_tree;
    RewriteRuleTokenStream<ImplTraits> stream_EQUALS_OP(get_psrstate()->get_treeAdaptor(), "token EQUALS_OP");
    RewriteRuleSubtreeStream<ImplTraits> stream_delete_statement(get_psrstate()->get_treeAdaptor(), "rule delete_statement");
    RewriteRuleSubtreeStream<ImplTraits> stream_quoted_string(get_psrstate()->get_treeAdaptor(), "rule quoted_string");
    RewriteRuleSubtreeStream<ImplTraits> stream_plan_key(get_psrstate()->get_treeAdaptor(), "rule plan_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_into_key(get_psrstate()->get_treeAdaptor(), "rule into_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_statement_id_key(get_psrstate()->get_treeAdaptor(), "rule statement_id_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_explain_key(get_psrstate()->get_treeAdaptor(), "rule explain_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_merge_statement(get_psrstate()->get_treeAdaptor(), "rule merge_statement");
    RewriteRuleSubtreeStream<ImplTraits> stream_update_statement(get_psrstate()->get_treeAdaptor(), "rule update_statement");
    RewriteRuleSubtreeStream<ImplTraits> stream_select_statement(get_psrstate()->get_treeAdaptor(), "rule select_statement");
    RewriteRuleSubtreeStream<ImplTraits> stream_set_key(get_psrstate()->get_treeAdaptor(), "rule set_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_insert_statement(get_psrstate()->get_treeAdaptor(), "rule insert_statement");
    RewriteRuleSubtreeStream<ImplTraits> stream_tableview_name(get_psrstate()->get_treeAdaptor(), "rule tableview_name");
    RewriteRuleSubtreeStream<ImplTraits> stream_for_key(get_psrstate()->get_treeAdaptor(), "rule for_key");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:140:5: ( explain_key plan_key ( set_key statement_id_key EQUALS_OP quoted_string )? ( into_key tableview_name )? for_key ( select_statement | update_statement | delete_statement | insert_statement | merge_statement ) -> ^( EXPLAIN_STATEMENT ( select_statement )? ( update_statement )? ( delete_statement )? ( insert_statement )? ( merge_statement )? ) )
        // OracleDML.g:140:10: explain_key plan_key ( set_key statement_id_key EQUALS_OP quoted_string )? ( into_key tableview_name )? for_key ( select_statement | update_statement | delete_statement | insert_statement | merge_statement )
        {
            this->followPush(FOLLOW_explain_key_in_explain_statement809);
            explain_key11=explain_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleexplain_statementEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                explain_key11_last = explain_key11.tree.get();
                stream_explain_key.add(explain_key11.tree);
            }

            this->followPush(FOLLOW_plan_key_in_explain_statement811);
            plan_key12=plan_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleexplain_statementEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                plan_key12_last = plan_key12.tree.get();
                stream_plan_key.add(plan_key12.tree);
            }

            // OracleDML.g:141:10: ( set_key statement_id_key EQUALS_OP quoted_string )?
            {
                ANTLR_UINT32 alt3=2;
                {
                    ANTLR_UINT32 LA3_0 = this->LA(1);
                    if ( (LA3_0 == REGULAR_ID) && ((toUpper(LT(1)->getText()) == "SET")))
                    {
                        alt3=1;
                    }
                }
                switch (alt3)
                {
            	case 1:
            	    // OracleDML.g:141:11: set_key statement_id_key EQUALS_OP quoted_string
            	    {
            	        this->followPush(FOLLOW_set_key_in_explain_statement823);
            	        set_key13=set_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleexplain_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            set_key13_last = set_key13.tree.get();
            	            stream_set_key.add(set_key13.tree);
            	        }

            	        this->followPush(FOLLOW_statement_id_key_in_explain_statement825);
            	        statement_id_key14=statement_id_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleexplain_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            statement_id_key14_last = statement_id_key14.tree.get();
            	            stream_statement_id_key.add(statement_id_key14.tree);
            	        }

            	        EQUALS_OP15 =  this->matchToken(EQUALS_OP, &FOLLOW_EQUALS_OP_in_explain_statement827);
            	        if  (this->hasException())
            	        {
            	            goto ruleexplain_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( this->get_backtracking()==0 ) stream_EQUALS_OP.add(EQUALS_OP15);


            	        this->followPush(FOLLOW_quoted_string_in_explain_statement829);
            	        quoted_string16=quoted_string();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleexplain_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            quoted_string16_last = quoted_string16.tree.get();
            	            stream_quoted_string.add(quoted_string16.tree);
            	        }

            	    }
            	    break;

                }
            }

            // OracleDML.g:142:10: ( into_key tableview_name )?
            {
                ANTLR_UINT32 alt4=2;
                switch ( this->LA(1) )
                {
                    case SQL92_RESERVED_INTO:
                    	{
                    		alt4=1;
                    	}
                        break;
                }

                switch (alt4)
                {
            	case 1:
            	    // OracleDML.g:142:11: into_key tableview_name
            	    {
            	        this->followPush(FOLLOW_into_key_in_explain_statement843);
            	        into_key17=into_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleexplain_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            into_key17_last = into_key17.tree.get();
            	            stream_into_key.add(into_key17.tree);
            	        }

            	        this->followPush(FOLLOW_tableview_name_in_explain_statement845);
            	        tableview_name18=tableview_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleexplain_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            tableview_name18_last = tableview_name18.tree.get();
            	            stream_tableview_name.add(tableview_name18.tree);
            	        }

            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_for_key_in_explain_statement858);
            for_key19=for_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleexplain_statementEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                for_key19_last = for_key19.tree.get();
                stream_for_key.add(for_key19.tree);
            }

            // OracleDML.g:144:10: ( select_statement | update_statement | delete_statement | insert_statement | merge_statement )
            {
                ANTLR_UINT32 alt5=5;
                {
                    ANTLR_UINT32 LA5_0 = this->LA(1);
                    if ( (LA5_0 == LEFT_PAREN || LA5_0 == SQL92_RESERVED_SELECT || LA5_0 == SQL92_RESERVED_WITH))
                    {
                        alt5=1;
                    }
                    else if ( (LA5_0 == SQL92_RESERVED_UPDATE))
                    {
                        alt5=2;
                    }
                    else if ( (LA5_0 == SQL92_RESERVED_DELETE))
                    {
                        alt5=3;
                    }
                    else if ( (LA5_0 == SQL92_RESERVED_INSERT))
                    {
                        alt5=4;
                    }
                    else if ( (LA5_0 == REGULAR_ID) && ((toUpper(LT(1)->getText()) == "MERGE")))
                    {
                        alt5=5;
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return retval;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 5 );
                        ex->set_state( 0 );


                        goto ruleexplain_statementEx;

                    }
                }
                switch (alt5)
                {
            	case 1:
            	    // OracleDML.g:144:12: select_statement
            	    {
            	        this->followPush(FOLLOW_select_statement_in_explain_statement871);
            	        select_statement20=select_statement();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleexplain_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            select_statement20_last = select_statement20.tree.get();
            	            stream_select_statement.add(select_statement20.tree);
            	        }

            	    }
            	    break;
            	case 2:
            	    // OracleDML.g:145:12: update_statement
            	    {
            	        this->followPush(FOLLOW_update_statement_in_explain_statement884);
            	        update_statement21=update_statement();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleexplain_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            update_statement21_last = update_statement21.tree.get();
            	            stream_update_statement.add(update_statement21.tree);
            	        }

            	    }
            	    break;
            	case 3:
            	    // OracleDML.g:146:12: delete_statement
            	    {
            	        this->followPush(FOLLOW_delete_statement_in_explain_statement897);
            	        delete_statement22=delete_statement();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleexplain_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            delete_statement22_last = delete_statement22.tree.get();
            	            stream_delete_statement.add(delete_statement22.tree);
            	        }

            	    }
            	    break;
            	case 4:
            	    // OracleDML.g:147:12: insert_statement
            	    {
            	        this->followPush(FOLLOW_insert_statement_in_explain_statement910);
            	        insert_statement23=insert_statement();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleexplain_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            insert_statement23_last = insert_statement23.tree.get();
            	            stream_insert_statement.add(insert_statement23.tree);
            	        }

            	    }
            	    break;
            	case 5:
            	    // OracleDML.g:148:12: merge_statement
            	    {
            	        this->followPush(FOLLOW_merge_statement_in_explain_statement923);
            	        merge_statement24=merge_statement();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleexplain_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            merge_statement24_last = merge_statement24.tree.get();
            	            stream_merge_statement.add(merge_statement24.tree);
            	        }

            	    }
            	    break;

                }
            }

            // AST REWRITE
            // elements: delete_statement, insert_statement, update_statement, merge_statement, select_statement
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 150:10: -> ^( EXPLAIN_STATEMENT ( select_statement )? ( update_statement )? ( delete_statement )? ( insert_statement )? ( merge_statement )? )
            {
            	// OracleDML.g:150:13: ^( EXPLAIN_STATEMENT ( select_statement )? ( update_statement )? ( delete_statement )? ( insert_statement )? ( merge_statement )? )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(EXPLAIN_STATEMENT, "EXPLAIN_STATEMENT"), root_1);
            	// OracleDML.g:150:33: ( select_statement )?
            	if ( stream_select_statement.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_select_statement.nextTree());
            	}
            	stream_select_statement.reset();

            	// OracleDML.g:150:51: ( update_statement )?
            	if ( stream_update_statement.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_update_statement.nextTree());
            	}
            	stream_update_statement.reset();

            	// OracleDML.g:150:69: ( delete_statement )?
            	if ( stream_delete_statement.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_delete_statement.nextTree());
            	}
            	stream_delete_statement.reset();

            	// OracleDML.g:150:87: ( insert_statement )?
            	if ( stream_insert_statement.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_insert_statement.nextTree());
            	}
            	stream_insert_statement.reset();

            	// OracleDML.g:150:105: ( merge_statement )?
            	if ( stream_merge_statement.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_merge_statement.nextTree());
            	}
            	stream_merge_statement.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleexplain_statementEx; /* Prevent compiler warnings */
    ruleexplain_statementEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end explain_statement */

/**
 * $ANTLR start select_statement
 * OracleDML.g:153:1: select_statement : ( subquery_factoring_clause )? subquery ( for_update_clause | ( order_key ( siblings_key )? by_key )=> order_by_clause )* -> ^( SELECT_STATEMENT[(ToraType)T_SELECT] ( subquery_factoring_clause )? subquery ( for_update_clause )* ( order_by_clause )* ) ;
 */
OracleDML::select_statement_return
OracleDML::select_statement()
{
    OracleDML::select_statement_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML::subquery_factoring_clause_return subquery_factoring_clause25;
    ImplTraits::TreeTypePtr::pointer subquery_factoring_clause25_last = NULL;
    OracleDML::subquery_return subquery26;
    ImplTraits::TreeTypePtr::pointer subquery26_last = NULL;
    OracleDML::for_update_clause_return for_update_clause27;
    ImplTraits::TreeTypePtr::pointer for_update_clause27_last = NULL;
    OracleDML::order_by_clause_return order_by_clause28;
    ImplTraits::TreeTypePtr::pointer order_by_clause28_last = NULL;
    RewriteRuleSubtreeStream<ImplTraits> stream_subquery_factoring_clause(get_psrstate()->get_treeAdaptor(), "rule subquery_factoring_clause");
    RewriteRuleSubtreeStream<ImplTraits> stream_order_by_clause(get_psrstate()->get_treeAdaptor(), "rule order_by_clause");
    RewriteRuleSubtreeStream<ImplTraits> stream_for_update_clause(get_psrstate()->get_treeAdaptor(), "rule for_update_clause");
    RewriteRuleSubtreeStream<ImplTraits> stream_subquery(get_psrstate()->get_treeAdaptor(), "rule subquery");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:154:5: ( ( subquery_factoring_clause )? subquery ( for_update_clause | ( order_key ( siblings_key )? by_key )=> order_by_clause )* -> ^( SELECT_STATEMENT[(ToraType)T_SELECT] ( subquery_factoring_clause )? subquery ( for_update_clause )* ( order_by_clause )* ) )
        // OracleDML.g:154:10: ( subquery_factoring_clause )? subquery ( for_update_clause | ( order_key ( siblings_key )? by_key )=> order_by_clause )*
        {
            // OracleDML.g:154:10: ( subquery_factoring_clause )?
            {
                ANTLR_UINT32 alt6=2;
                switch ( this->LA(1) )
                {
                    case SQL92_RESERVED_WITH:
                    	{
                    		alt6=1;
                    	}
                        break;
                }

                switch (alt6)
                {
            	case 1:
            	    // OracleDML.g:154:10: subquery_factoring_clause
            	    {
            	        this->followPush(FOLLOW_subquery_factoring_clause_in_select_statement984);
            	        subquery_factoring_clause25=subquery_factoring_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleselect_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            subquery_factoring_clause25_last = subquery_factoring_clause25.tree.get();
            	            stream_subquery_factoring_clause.add(subquery_factoring_clause25.tree);
            	        }

            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_subquery_in_select_statement995);
            subquery26=subquery();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleselect_statementEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                subquery26_last = subquery26.tree.get();
                stream_subquery.add(subquery26.tree);
            }

            // OracleDML.g:156:9: ( for_update_clause | ( order_key ( siblings_key )? by_key )=> order_by_clause )*

            for (;;)
            {
                ANTLR_UINT32 alt7=3;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    ANTLR_UINT32 LA7_0 = this->LA(1);
                    if ( (LA7_0 == SQL92_RESERVED_FOR))
                    {
                        alt7=1;
                    }
                    else if ( (LA7_0 == SQL92_RESERVED_ORDER) && (this->msynpred( antlr3::ClassForwarder<synpred1_OracleDML>() )))
                    {
                        alt7=2;
                    }

                }
                switch (alt7)
                {
            	case 1:
            	    // OracleDML.g:156:10: for_update_clause
            	    {
            	        this->followPush(FOLLOW_for_update_clause_in_select_statement1006);
            	        for_update_clause27=for_update_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleselect_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            for_update_clause27_last = for_update_clause27.tree.get();
            	            stream_for_update_clause.add(for_update_clause27.tree);
            	        }

            	    }
            	    break;
            	case 2:
            	    // OracleDML.g:156:28: ( order_key ( siblings_key )? by_key )=> order_by_clause
            	    {
            	        this->followPush(FOLLOW_order_by_clause_in_select_statement1018);
            	        order_by_clause28=order_by_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleselect_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            order_by_clause28_last = order_by_clause28.tree.get();
            	            stream_order_by_clause.add(order_by_clause28.tree);
            	        }

            	    }
            	    break;

            	default:
            	    goto loop7;	/* break out of the loop */
            	    break;
                }
            }
            loop7: ; /* Jump out to here if this rule does not match */


            // AST REWRITE
            // elements: order_by_clause, subquery, for_update_clause, subquery_factoring_clause
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 157:9: -> ^( SELECT_STATEMENT[(ToraType)T_SELECT] ( subquery_factoring_clause )? subquery ( for_update_clause )* ( order_by_clause )* )
            {
            	// OracleDML.g:157:12: ^( SELECT_STATEMENT[(ToraType)T_SELECT] ( subquery_factoring_clause )? subquery ( for_update_clause )* ( order_by_clause )* )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(SELECT_STATEMENT, (ToraType)T_SELECT), root_1);
            	// OracleDML.g:157:51: ( subquery_factoring_clause )?
            	if ( stream_subquery_factoring_clause.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_subquery_factoring_clause.nextTree());
            	}
            	stream_subquery_factoring_clause.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_subquery.nextTree());
            	// OracleDML.g:157:87: ( for_update_clause )*
            	while ( stream_for_update_clause.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_for_update_clause.nextTree());
            	}
            	stream_for_update_clause.reset();

            	// OracleDML.g:157:106: ( order_by_clause )*
            	while ( stream_order_by_clause.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_order_by_clause.nextTree());
            	}
            	stream_order_by_clause.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleselect_statementEx; /* Prevent compiler warnings */
    ruleselect_statementEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end select_statement */

/**
 * $ANTLR start subquery_factoring_clause
 * OracleDML.g:161:1: subquery_factoring_clause : with_key ^ factoring_element ( COMMA ! factoring_element )* ;
 */
OracleDML::subquery_factoring_clause_return
OracleDML::subquery_factoring_clause()
{
    OracleDML::subquery_factoring_clause_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* COMMA31 = NULL;
    OracleDML_OracleDMLKeys::with_key_return with_key29;
    ImplTraits::TreeTypePtr::pointer with_key29_last = NULL;
    OracleDML::factoring_element_return factoring_element30;
    ImplTraits::TreeTypePtr::pointer factoring_element30_last = NULL;
    OracleDML::factoring_element_return factoring_element32;
    ImplTraits::TreeTypePtr::pointer factoring_element32_last = NULL;
    ImplTraits::TreeTypePtr COMMA31_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:162:5: ( with_key ^ factoring_element ( COMMA ! factoring_element )* )
        // OracleDML.g:162:10: with_key ^ factoring_element ( COMMA ! factoring_element )*
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            this->followPush(FOLLOW_with_key_in_subquery_factoring_clause1069);
            with_key29=with_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesubquery_factoring_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(with_key29.tree, root_0);

            this->followPush(FOLLOW_factoring_element_in_subquery_factoring_clause1072);
            factoring_element30=factoring_element();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesubquery_factoring_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, factoring_element30.tree);


            // OracleDML.g:162:38: ( COMMA ! factoring_element )*

            for (;;)
            {
                ANTLR_UINT32 alt8=2;
                switch ( this->LA(1) )
                {
                case COMMA:
                	{
                		alt8=1;
                	}
                    break;

                }

                switch (alt8)
                {
            	case 1:
            	    // OracleDML.g:162:39: COMMA ! factoring_element
            	    {
            	        COMMA31 =  this->matchToken(COMMA, &FOLLOW_COMMA_in_subquery_factoring_clause1075);
            	        if  (this->hasException())
            	        {
            	            goto rulesubquery_factoring_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }


            	        this->followPush(FOLLOW_factoring_element_in_subquery_factoring_clause1078);
            	        factoring_element32=factoring_element();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesubquery_factoring_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, factoring_element32.tree);


            	    }
            	    break;

            	default:
            	    goto loop8;	/* break out of the loop */
            	    break;
                }
            }
            loop8: ; /* Jump out to here if this rule does not match */


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulesubquery_factoring_clauseEx; /* Prevent compiler warnings */
    rulesubquery_factoring_clauseEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end subquery_factoring_clause */

/**
 * $ANTLR start factoring_element
 * OracleDML.g:165:1: factoring_element : query_name ( LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN )? as_key LEFT_PAREN subquery ( order_by_clause )? RIGHT_PAREN ( search_clause )? ( cycle_clause )? -> ^( FACTORING query_name ( column_name )* subquery ( search_clause )? ( cycle_clause )? ) ;
 */
OracleDML::factoring_element_return
OracleDML::factoring_element()
{
    OracleDML::factoring_element_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* LEFT_PAREN34 = NULL;
    ImplTraits::CommonTokenType const* COMMA36 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN38 = NULL;
    ImplTraits::CommonTokenType const* LEFT_PAREN40 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN43 = NULL;
    OracleDML_OracleDMLCommons::query_name_return query_name33;
    ImplTraits::TreeTypePtr::pointer query_name33_last = NULL;
    OracleDML_OracleDMLCommons::column_name_return column_name35;
    ImplTraits::TreeTypePtr::pointer column_name35_last = NULL;
    OracleDML_OracleDMLCommons::column_name_return column_name37;
    ImplTraits::TreeTypePtr::pointer column_name37_last = NULL;
    OracleDML_OracleDMLKeys::as_key_return as_key39;
    ImplTraits::TreeTypePtr::pointer as_key39_last = NULL;
    OracleDML::subquery_return subquery41;
    ImplTraits::TreeTypePtr::pointer subquery41_last = NULL;
    OracleDML::order_by_clause_return order_by_clause42;
    ImplTraits::TreeTypePtr::pointer order_by_clause42_last = NULL;
    OracleDML::search_clause_return search_clause44;
    ImplTraits::TreeTypePtr::pointer search_clause44_last = NULL;
    OracleDML::cycle_clause_return cycle_clause45;
    ImplTraits::TreeTypePtr::pointer cycle_clause45_last = NULL;
    ImplTraits::TreeTypePtr LEFT_PAREN34_tree;
    ImplTraits::TreeTypePtr COMMA36_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN38_tree;
    ImplTraits::TreeTypePtr LEFT_PAREN40_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN43_tree;
    RewriteRuleTokenStream<ImplTraits> stream_LEFT_PAREN(get_psrstate()->get_treeAdaptor(), "token LEFT_PAREN");
    RewriteRuleTokenStream<ImplTraits> stream_RIGHT_PAREN(get_psrstate()->get_treeAdaptor(), "token RIGHT_PAREN");
    RewriteRuleTokenStream<ImplTraits> stream_COMMA(get_psrstate()->get_treeAdaptor(), "token COMMA");
    RewriteRuleSubtreeStream<ImplTraits> stream_order_by_clause(get_psrstate()->get_treeAdaptor(), "rule order_by_clause");
    RewriteRuleSubtreeStream<ImplTraits> stream_cycle_clause(get_psrstate()->get_treeAdaptor(), "rule cycle_clause");
    RewriteRuleSubtreeStream<ImplTraits> stream_search_clause(get_psrstate()->get_treeAdaptor(), "rule search_clause");
    RewriteRuleSubtreeStream<ImplTraits> stream_as_key(get_psrstate()->get_treeAdaptor(), "rule as_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_column_name(get_psrstate()->get_treeAdaptor(), "rule column_name");
    RewriteRuleSubtreeStream<ImplTraits> stream_query_name(get_psrstate()->get_treeAdaptor(), "rule query_name");
    RewriteRuleSubtreeStream<ImplTraits> stream_subquery(get_psrstate()->get_treeAdaptor(), "rule subquery");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:166:5: ( query_name ( LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN )? as_key LEFT_PAREN subquery ( order_by_clause )? RIGHT_PAREN ( search_clause )? ( cycle_clause )? -> ^( FACTORING query_name ( column_name )* subquery ( search_clause )? ( cycle_clause )? ) )
        // OracleDML.g:166:10: query_name ( LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN )? as_key LEFT_PAREN subquery ( order_by_clause )? RIGHT_PAREN ( search_clause )? ( cycle_clause )?
        {
            this->followPush(FOLLOW_query_name_in_factoring_element1100);
            query_name33=query_name();

            this->followPop();
            if  (this->hasException())
            {
                goto rulefactoring_elementEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                query_name33_last = query_name33.tree.get();
                stream_query_name.add(query_name33.tree);
            }

            // OracleDML.g:166:21: ( LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN )?
            {
                ANTLR_UINT32 alt10=2;
                switch ( this->LA(1) )
                {
                    case LEFT_PAREN:
                    	{
                    		alt10=1;
                    	}
                        break;
                }

                switch (alt10)
                {
            	case 1:
            	    // OracleDML.g:166:22: LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN
            	    {
            	        LEFT_PAREN34 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_factoring_element1103);
            	        if  (this->hasException())
            	        {
            	            goto rulefactoring_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( this->get_backtracking()==0 ) stream_LEFT_PAREN.add(LEFT_PAREN34);


            	        this->followPush(FOLLOW_column_name_in_factoring_element1105);
            	        column_name35=column_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulefactoring_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            column_name35_last = column_name35.tree.get();
            	            stream_column_name.add(column_name35.tree);
            	        }

            	        // OracleDML.g:166:45: ( COMMA column_name )*

            	        for (;;)
            	        {
            	            ANTLR_UINT32 alt9=2;
            	            switch ( this->LA(1) )
            	            {
            	            case COMMA:
            	            	{
            	            		alt9=1;
            	            	}
            	                break;

            	            }

            	            switch (alt9)
            	            {
            	        	case 1:
            	        	    // OracleDML.g:166:46: COMMA column_name
            	        	    {
            	        	        COMMA36 =  this->matchToken(COMMA, &FOLLOW_COMMA_in_factoring_element1108);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulefactoring_elementEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }
            	        	         
            	        	        if ( this->get_backtracking()==0 ) stream_COMMA.add(COMMA36);


            	        	        this->followPush(FOLLOW_column_name_in_factoring_element1110);
            	        	        column_name37=column_name();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulefactoring_elementEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) 
            	        	        {
            	        	            column_name37_last = column_name37.tree.get();
            	        	            stream_column_name.add(column_name37.tree);
            	        	        }

            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop9;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop9: ; /* Jump out to here if this rule does not match */


            	        RIGHT_PAREN38 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_factoring_element1114);
            	        if  (this->hasException())
            	        {
            	            goto rulefactoring_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( this->get_backtracking()==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN38);


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_as_key_in_factoring_element1118);
            as_key39=as_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulefactoring_elementEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                as_key39_last = as_key39.tree.get();
                stream_as_key.add(as_key39.tree);
            }

            LEFT_PAREN40 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_factoring_element1120);
            if  (this->hasException())
            {
                goto rulefactoring_elementEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_LEFT_PAREN.add(LEFT_PAREN40);


            this->followPush(FOLLOW_subquery_in_factoring_element1122);
            subquery41=subquery();

            this->followPop();
            if  (this->hasException())
            {
                goto rulefactoring_elementEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                subquery41_last = subquery41.tree.get();
                stream_subquery.add(subquery41.tree);
            }

            // OracleDML.g:166:107: ( order_by_clause )?
            {
                ANTLR_UINT32 alt11=2;
                switch ( this->LA(1) )
                {
                    case SQL92_RESERVED_ORDER:
                    	{
                    		alt11=1;
                    	}
                        break;
                }

                switch (alt11)
                {
            	case 1:
            	    // OracleDML.g:166:107: order_by_clause
            	    {
            	        this->followPush(FOLLOW_order_by_clause_in_factoring_element1124);
            	        order_by_clause42=order_by_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulefactoring_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            order_by_clause42_last = order_by_clause42.tree.get();
            	            stream_order_by_clause.add(order_by_clause42.tree);
            	        }

            	    }
            	    break;

                }
            }

            RIGHT_PAREN43 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_factoring_element1127);
            if  (this->hasException())
            {
                goto rulefactoring_elementEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN43);


            // OracleDML.g:167:10: ( search_clause )?
            {
                ANTLR_UINT32 alt12=2;
                switch ( this->LA(1) )
                {
                    case REGULAR_ID:
                    	{
                    		switch ( this->LA(2) )
                    		{
                    		    case REGULAR_ID:
                    		    	{
                    		    		switch ( this->LA(3) )
                    		    		{
                    		    		    case REGULAR_ID:
                    		    		    	{
                    		    		    		switch ( this->LA(4) )
                    		    		    		{
                    		    		    		    case SQL92_RESERVED_BY:
                    		    		    		    	{
                    		    		    		    		alt12=1;
                    		    		    		    	}
                    		    		    		        break;
                    		    		    		}

                    		    		    	}
                    		    		        break;
                    		    		}

                    		    	}
                    		        break;
                    		}

                    	}
                        break;
                }

                switch (alt12)
                {
            	case 1:
            	    // OracleDML.g:167:10: search_clause
            	    {
            	        this->followPush(FOLLOW_search_clause_in_factoring_element1138);
            	        search_clause44=search_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulefactoring_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            search_clause44_last = search_clause44.tree.get();
            	            stream_search_clause.add(search_clause44.tree);
            	        }

            	    }
            	    break;

                }
            }

            // OracleDML.g:168:10: ( cycle_clause )?
            {
                ANTLR_UINT32 alt13=2;
                switch ( this->LA(1) )
                {
                    case REGULAR_ID:
                    	{
                    		alt13=1;
                    	}
                        break;
                }

                switch (alt13)
                {
            	case 1:
            	    // OracleDML.g:168:10: cycle_clause
            	    {
            	        this->followPush(FOLLOW_cycle_clause_in_factoring_element1150);
            	        cycle_clause45=cycle_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulefactoring_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            cycle_clause45_last = cycle_clause45.tree.get();
            	            stream_cycle_clause.add(cycle_clause45.tree);
            	        }

            	    }
            	    break;

                }
            }

            // AST REWRITE
            // elements: query_name, cycle_clause, subquery, search_clause, column_name
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 169:9: -> ^( FACTORING query_name ( column_name )* subquery ( search_clause )? ( cycle_clause )? )
            {
            	// OracleDML.g:169:12: ^( FACTORING query_name ( column_name )* subquery ( search_clause )? ( cycle_clause )? )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(FACTORING, "FACTORING"), root_1);
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_query_name.nextTree());
            	// OracleDML.g:169:35: ( column_name )*
            	while ( stream_column_name.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_column_name.nextTree());
            	}
            	stream_column_name.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_subquery.nextTree());
            	// OracleDML.g:169:57: ( search_clause )?
            	if ( stream_search_clause.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_search_clause.nextTree());
            	}
            	stream_search_clause.reset();

            	// OracleDML.g:169:72: ( cycle_clause )?
            	if ( stream_cycle_clause.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_cycle_clause.nextTree());
            	}
            	stream_cycle_clause.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulefactoring_elementEx; /* Prevent compiler warnings */
    rulefactoring_elementEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end factoring_element */

/**
 * $ANTLR start search_clause
 * OracleDML.g:172:1: search_clause : search_key ( depth_key | breadth_key ) first_key by_key column_name ( asc_key )? ( desc_key )? ( nulls_key first_key )? ( nulls_key last_key )? ( COMMA column_name ( asc_key )? ( desc_key )? ( nulls_key first_key )? ( nulls_key last_key )? )* set_key column_name ;
 */
OracleDML::search_clause_return
OracleDML::search_clause()
{
    OracleDML::search_clause_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* COMMA58 = NULL;
    OracleDML_OracleDMLKeys::search_key_return search_key46;
    ImplTraits::TreeTypePtr::pointer search_key46_last = NULL;
    OracleDML_OracleDMLKeys::depth_key_return depth_key47;
    ImplTraits::TreeTypePtr::pointer depth_key47_last = NULL;
    OracleDML_OracleDMLKeys::breadth_key_return breadth_key48;
    ImplTraits::TreeTypePtr::pointer breadth_key48_last = NULL;
    OracleDML_OracleDMLKeys::first_key_return first_key49;
    ImplTraits::TreeTypePtr::pointer first_key49_last = NULL;
    OracleDML_OracleDMLKeys::by_key_return by_key50;
    ImplTraits::TreeTypePtr::pointer by_key50_last = NULL;
    OracleDML_OracleDMLCommons::column_name_return column_name51;
    ImplTraits::TreeTypePtr::pointer column_name51_last = NULL;
    OracleDML_OracleDMLKeys::asc_key_return asc_key52;
    ImplTraits::TreeTypePtr::pointer asc_key52_last = NULL;
    OracleDML_OracleDMLKeys::desc_key_return desc_key53;
    ImplTraits::TreeTypePtr::pointer desc_key53_last = NULL;
    OracleDML_OracleDMLKeys::nulls_key_return nulls_key54;
    ImplTraits::TreeTypePtr::pointer nulls_key54_last = NULL;
    OracleDML_OracleDMLKeys::first_key_return first_key55;
    ImplTraits::TreeTypePtr::pointer first_key55_last = NULL;
    OracleDML_OracleDMLKeys::nulls_key_return nulls_key56;
    ImplTraits::TreeTypePtr::pointer nulls_key56_last = NULL;
    OracleDML_OracleDMLKeys::last_key_return last_key57;
    ImplTraits::TreeTypePtr::pointer last_key57_last = NULL;
    OracleDML_OracleDMLCommons::column_name_return column_name59;
    ImplTraits::TreeTypePtr::pointer column_name59_last = NULL;
    OracleDML_OracleDMLKeys::asc_key_return asc_key60;
    ImplTraits::TreeTypePtr::pointer asc_key60_last = NULL;
    OracleDML_OracleDMLKeys::desc_key_return desc_key61;
    ImplTraits::TreeTypePtr::pointer desc_key61_last = NULL;
    OracleDML_OracleDMLKeys::nulls_key_return nulls_key62;
    ImplTraits::TreeTypePtr::pointer nulls_key62_last = NULL;
    OracleDML_OracleDMLKeys::first_key_return first_key63;
    ImplTraits::TreeTypePtr::pointer first_key63_last = NULL;
    OracleDML_OracleDMLKeys::nulls_key_return nulls_key64;
    ImplTraits::TreeTypePtr::pointer nulls_key64_last = NULL;
    OracleDML_OracleDMLKeys::last_key_return last_key65;
    ImplTraits::TreeTypePtr::pointer last_key65_last = NULL;
    OracleDML_OracleDMLKeys::set_key_return set_key66;
    ImplTraits::TreeTypePtr::pointer set_key66_last = NULL;
    OracleDML_OracleDMLCommons::column_name_return column_name67;
    ImplTraits::TreeTypePtr::pointer column_name67_last = NULL;
    ImplTraits::TreeTypePtr COMMA58_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:173:5: ( search_key ( depth_key | breadth_key ) first_key by_key column_name ( asc_key )? ( desc_key )? ( nulls_key first_key )? ( nulls_key last_key )? ( COMMA column_name ( asc_key )? ( desc_key )? ( nulls_key first_key )? ( nulls_key last_key )? )* set_key column_name )
        // OracleDML.g:173:10: search_key ( depth_key | breadth_key ) first_key by_key column_name ( asc_key )? ( desc_key )? ( nulls_key first_key )? ( nulls_key last_key )? ( COMMA column_name ( asc_key )? ( desc_key )? ( nulls_key first_key )? ( nulls_key last_key )? )* set_key column_name
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            this->followPush(FOLLOW_search_key_in_search_clause1198);
            search_key46=search_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesearch_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, search_key46.tree);


            // OracleDML.g:173:21: ( depth_key | breadth_key )
            {
                ANTLR_UINT32 alt14=2;
                switch ( this->LA(1) )
                {
                case REGULAR_ID:
                	{
                		{
                		    ANTLR_UINT32 LA14_1 = this->LA(2);
                		    if ( ((toUpper(LT(1)->getText()) == "DEPTH")))
                		    {
                		        alt14=1;
                		    }
                		    else if ( ((toUpper(LT(1)->getText()) == "BREADTH")))
                		    {
                		        alt14=2;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return retval;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 14 );
                		        ex->set_state( 1 );


                		        goto rulesearch_clauseEx;

                		    }
                		}
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return retval;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 14 );
                    ex->set_state( 0 );


                    goto rulesearch_clauseEx;

                }

                switch (alt14)
                {
            	case 1:
            	    // OracleDML.g:173:23: depth_key
            	    {
            	        this->followPush(FOLLOW_depth_key_in_search_clause1202);
            	        depth_key47=depth_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesearch_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, depth_key47.tree);


            	    }
            	    break;
            	case 2:
            	    // OracleDML.g:173:35: breadth_key
            	    {
            	        this->followPush(FOLLOW_breadth_key_in_search_clause1206);
            	        breadth_key48=breadth_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesearch_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, breadth_key48.tree);


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_first_key_in_search_clause1210);
            first_key49=first_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesearch_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, first_key49.tree);


            this->followPush(FOLLOW_by_key_in_search_clause1212);
            by_key50=by_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesearch_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, by_key50.tree);


            this->followPush(FOLLOW_column_name_in_search_clause1227);
            column_name51=column_name();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesearch_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, column_name51.tree);


            // OracleDML.g:174:26: ( asc_key )?
            {
                ANTLR_UINT32 alt15=2;
                switch ( this->LA(1) )
                {
                    case SQL92_RESERVED_ASC:
                    	{
                    		alt15=1;
                    	}
                        break;
                }

                switch (alt15)
                {
            	case 1:
            	    // OracleDML.g:174:26: asc_key
            	    {
            	        this->followPush(FOLLOW_asc_key_in_search_clause1229);
            	        asc_key52=asc_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesearch_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, asc_key52.tree);


            	    }
            	    break;

                }
            }

            // OracleDML.g:174:36: ( desc_key )?
            {
                ANTLR_UINT32 alt16=2;
                switch ( this->LA(1) )
                {
                    case SQL92_RESERVED_DESC:
                    	{
                    		alt16=1;
                    	}
                        break;
                }

                switch (alt16)
                {
            	case 1:
            	    // OracleDML.g:174:36: desc_key
            	    {
            	        this->followPush(FOLLOW_desc_key_in_search_clause1233);
            	        desc_key53=desc_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesearch_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, desc_key53.tree);


            	    }
            	    break;

                }
            }

            // OracleDML.g:174:47: ( nulls_key first_key )?
            {
                ANTLR_UINT32 alt17=2;
                {
                    ANTLR_UINT32 LA17_0 = this->LA(1);
                    if ( (LA17_0 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))))
                    {
                        {
                            ANTLR_UINT32 LA17_1 = this->LA(2);
                            if ( (LA17_1 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))))
                            {
                                {
                                    ANTLR_UINT32 LA17_3 = this->LA(3);
                                    if ( ((toUpper(LT(1)->getText()) == "NULLS")))
                                    {
                                        alt17=1;
                                    }
                                }
                            }
                        }
                    }
                }
                switch (alt17)
                {
            	case 1:
            	    // OracleDML.g:174:48: nulls_key first_key
            	    {
            	        this->followPush(FOLLOW_nulls_key_in_search_clause1238);
            	        nulls_key54=nulls_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesearch_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, nulls_key54.tree);


            	        this->followPush(FOLLOW_first_key_in_search_clause1240);
            	        first_key55=first_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesearch_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, first_key55.tree);


            	    }
            	    break;

                }
            }

            // OracleDML.g:174:70: ( nulls_key last_key )?
            {
                ANTLR_UINT32 alt18=2;
                alt18 = cdfa18.predict(this, this->get_rec(), this->get_istream(), cdfa18 );
                if  (this->hasException())
                {
                    goto rulesearch_clauseEx;
                }
                if (this->hasFailed())
                {
                    return retval;
                }

                switch (alt18)
                {
            	case 1:
            	    // OracleDML.g:174:71: nulls_key last_key
            	    {
            	        this->followPush(FOLLOW_nulls_key_in_search_clause1245);
            	        nulls_key56=nulls_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesearch_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, nulls_key56.tree);


            	        this->followPush(FOLLOW_last_key_in_search_clause1247);
            	        last_key57=last_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesearch_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, last_key57.tree);


            	    }
            	    break;

                }
            }

            // OracleDML.g:175:14: ( COMMA column_name ( asc_key )? ( desc_key )? ( nulls_key first_key )? ( nulls_key last_key )? )*

            for (;;)
            {
                ANTLR_UINT32 alt23=2;
                switch ( this->LA(1) )
                {
                case COMMA:
                	{
                		alt23=1;
                	}
                    break;

                }

                switch (alt23)
                {
            	case 1:
            	    // OracleDML.g:175:15: COMMA column_name ( asc_key )? ( desc_key )? ( nulls_key first_key )? ( nulls_key last_key )?
            	    {
            	        COMMA58 =  this->matchToken(COMMA, &FOLLOW_COMMA_in_search_clause1265);
            	        if  (this->hasException())
            	        {
            	            goto rulesearch_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) {
            	        COMMA58_tree = std::move(get_psrstate()->get_treeAdaptor()->create(COMMA58));
            	        get_psrstate()->get_treeAdaptor()->addChild(root_0, COMMA58_tree);
            	        }


            	        this->followPush(FOLLOW_column_name_in_search_clause1267);
            	        column_name59=column_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesearch_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, column_name59.tree);


            	        // OracleDML.g:175:33: ( asc_key )?
            	        {
            	            ANTLR_UINT32 alt19=2;
            	            switch ( this->LA(1) )
            	            {
            	                case SQL92_RESERVED_ASC:
            	                	{
            	                		alt19=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt19)
            	            {
            	        	case 1:
            	        	    // OracleDML.g:175:33: asc_key
            	        	    {
            	        	        this->followPush(FOLLOW_asc_key_in_search_clause1269);
            	        	        asc_key60=asc_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulesearch_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, asc_key60.tree);


            	        	    }
            	        	    break;

            	            }
            	        }

            	        // OracleDML.g:175:43: ( desc_key )?
            	        {
            	            ANTLR_UINT32 alt20=2;
            	            switch ( this->LA(1) )
            	            {
            	                case SQL92_RESERVED_DESC:
            	                	{
            	                		alt20=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt20)
            	            {
            	        	case 1:
            	        	    // OracleDML.g:175:43: desc_key
            	        	    {
            	        	        this->followPush(FOLLOW_desc_key_in_search_clause1273);
            	        	        desc_key61=desc_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulesearch_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, desc_key61.tree);


            	        	    }
            	        	    break;

            	            }
            	        }

            	        // OracleDML.g:175:54: ( nulls_key first_key )?
            	        {
            	            ANTLR_UINT32 alt21=2;
            	            {
            	                ANTLR_UINT32 LA21_0 = this->LA(1);
            	                if ( (LA21_0 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))))
            	                {
            	                    {
            	                        ANTLR_UINT32 LA21_1 = this->LA(2);
            	                        if ( (LA21_1 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "NULLS")))))
            	                        {
            	                            {
            	                                ANTLR_UINT32 LA21_3 = this->LA(3);
            	                                if ( ((toUpper(LT(1)->getText()) == "NULLS")))
            	                                {
            	                                    alt21=1;
            	                                }
            	                            }
            	                        }
            	                    }
            	                }
            	            }
            	            switch (alt21)
            	            {
            	        	case 1:
            	        	    // OracleDML.g:175:55: nulls_key first_key
            	        	    {
            	        	        this->followPush(FOLLOW_nulls_key_in_search_clause1278);
            	        	        nulls_key62=nulls_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulesearch_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, nulls_key62.tree);


            	        	        this->followPush(FOLLOW_first_key_in_search_clause1280);
            	        	        first_key63=first_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulesearch_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, first_key63.tree);


            	        	    }
            	        	    break;

            	            }
            	        }

            	        // OracleDML.g:175:77: ( nulls_key last_key )?
            	        {
            	            ANTLR_UINT32 alt22=2;
            	            alt22 = cdfa22.predict(this, this->get_rec(), this->get_istream(), cdfa22 );
            	            if  (this->hasException())
            	            {
            	                goto rulesearch_clauseEx;
            	            }
            	            if (this->hasFailed())
            	            {
            	                return retval;
            	            }

            	            switch (alt22)
            	            {
            	        	case 1:
            	        	    // OracleDML.g:175:78: nulls_key last_key
            	        	    {
            	        	        this->followPush(FOLLOW_nulls_key_in_search_clause1285);
            	        	        nulls_key64=nulls_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulesearch_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, nulls_key64.tree);


            	        	        this->followPush(FOLLOW_last_key_in_search_clause1287);
            	        	        last_key65=last_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulesearch_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, last_key65.tree);


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

            	default:
            	    goto loop23;	/* break out of the loop */
            	    break;
                }
            }
            loop23: ; /* Jump out to here if this rule does not match */


            this->followPush(FOLLOW_set_key_in_search_clause1307);
            set_key66=set_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesearch_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, set_key66.tree);


            this->followPush(FOLLOW_column_name_in_search_clause1309);
            column_name67=column_name();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesearch_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, column_name67.tree);


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulesearch_clauseEx; /* Prevent compiler warnings */
    rulesearch_clauseEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end search_clause */

/**
 * $ANTLR start cycle_clause
 * OracleDML.g:179:1: cycle_clause : cycle_key column_name ( COMMA column_name )* set_key column_name to_key expression default_key expression ;
 */
OracleDML::cycle_clause_return
OracleDML::cycle_clause()
{
    OracleDML::cycle_clause_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* COMMA70 = NULL;
    OracleDML_OracleDMLKeys::cycle_key_return cycle_key68;
    ImplTraits::TreeTypePtr::pointer cycle_key68_last = NULL;
    OracleDML_OracleDMLCommons::column_name_return column_name69;
    ImplTraits::TreeTypePtr::pointer column_name69_last = NULL;
    OracleDML_OracleDMLCommons::column_name_return column_name71;
    ImplTraits::TreeTypePtr::pointer column_name71_last = NULL;
    OracleDML_OracleDMLKeys::set_key_return set_key72;
    ImplTraits::TreeTypePtr::pointer set_key72_last = NULL;
    OracleDML_OracleDMLCommons::column_name_return column_name73;
    ImplTraits::TreeTypePtr::pointer column_name73_last = NULL;
    OracleDML_OracleDMLKeys::to_key_return to_key74;
    ImplTraits::TreeTypePtr::pointer to_key74_last = NULL;
    OracleDML::expression_return expression75;
    ImplTraits::TreeTypePtr::pointer expression75_last = NULL;
    OracleDML_OracleDMLKeys::default_key_return default_key76;
    ImplTraits::TreeTypePtr::pointer default_key76_last = NULL;
    OracleDML::expression_return expression77;
    ImplTraits::TreeTypePtr::pointer expression77_last = NULL;
    ImplTraits::TreeTypePtr COMMA70_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:180:5: ( cycle_key column_name ( COMMA column_name )* set_key column_name to_key expression default_key expression )
        // OracleDML.g:180:10: cycle_key column_name ( COMMA column_name )* set_key column_name to_key expression default_key expression
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            this->followPush(FOLLOW_cycle_key_in_cycle_clause1329);
            cycle_key68=cycle_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecycle_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, cycle_key68.tree);


            this->followPush(FOLLOW_column_name_in_cycle_clause1331);
            column_name69=column_name();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecycle_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, column_name69.tree);


            // OracleDML.g:180:32: ( COMMA column_name )*

            for (;;)
            {
                ANTLR_UINT32 alt24=2;
                switch ( this->LA(1) )
                {
                case COMMA:
                	{
                		alt24=1;
                	}
                    break;

                }

                switch (alt24)
                {
            	case 1:
            	    // OracleDML.g:180:34: COMMA column_name
            	    {
            	        COMMA70 =  this->matchToken(COMMA, &FOLLOW_COMMA_in_cycle_clause1335);
            	        if  (this->hasException())
            	        {
            	            goto rulecycle_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) {
            	        COMMA70_tree = std::move(get_psrstate()->get_treeAdaptor()->create(COMMA70));
            	        get_psrstate()->get_treeAdaptor()->addChild(root_0, COMMA70_tree);
            	        }


            	        this->followPush(FOLLOW_column_name_in_cycle_clause1337);
            	        column_name71=column_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecycle_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, column_name71.tree);


            	    }
            	    break;

            	default:
            	    goto loop24;	/* break out of the loop */
            	    break;
                }
            }
            loop24: ; /* Jump out to here if this rule does not match */


            this->followPush(FOLLOW_set_key_in_cycle_clause1341);
            set_key72=set_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecycle_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, set_key72.tree);


            this->followPush(FOLLOW_column_name_in_cycle_clause1343);
            column_name73=column_name();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecycle_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, column_name73.tree);


            this->followPush(FOLLOW_to_key_in_cycle_clause1345);
            to_key74=to_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecycle_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, to_key74.tree);


            this->followPush(FOLLOW_expression_in_cycle_clause1347);
            expression75=expression();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecycle_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, expression75.tree);


            this->followPush(FOLLOW_default_key_in_cycle_clause1349);
            default_key76=default_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecycle_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, default_key76.tree);


            this->followPush(FOLLOW_expression_in_cycle_clause1351);
            expression77=expression();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecycle_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, expression77.tree);


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulecycle_clauseEx; /* Prevent compiler warnings */
    rulecycle_clauseEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end cycle_clause */

/**
 * $ANTLR start subquery
 * OracleDML.g:183:1: subquery : subquery_basic_elements ( subquery_operation_part )* -> ^( SUBQUERY subquery_basic_elements ( subquery_operation_part )* ) ;
 */
OracleDML::subquery_return
OracleDML::subquery()
{
    OracleDML::subquery_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML::subquery_basic_elements_return subquery_basic_elements78;
    ImplTraits::TreeTypePtr::pointer subquery_basic_elements78_last = NULL;
    OracleDML::subquery_operation_part_return subquery_operation_part79;
    ImplTraits::TreeTypePtr::pointer subquery_operation_part79_last = NULL;
    RewriteRuleSubtreeStream<ImplTraits> stream_subquery_operation_part(get_psrstate()->get_treeAdaptor(), "rule subquery_operation_part");
    RewriteRuleSubtreeStream<ImplTraits> stream_subquery_basic_elements(get_psrstate()->get_treeAdaptor(), "rule subquery_basic_elements");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:184:5: ( subquery_basic_elements ( subquery_operation_part )* -> ^( SUBQUERY subquery_basic_elements ( subquery_operation_part )* ) )
        // OracleDML.g:184:10: subquery_basic_elements ( subquery_operation_part )*
        {
            this->followPush(FOLLOW_subquery_basic_elements_in_subquery1371);
            subquery_basic_elements78=subquery_basic_elements();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesubqueryEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                subquery_basic_elements78_last = subquery_basic_elements78.tree.get();
                stream_subquery_basic_elements.add(subquery_basic_elements78.tree);
            }

            // OracleDML.g:184:34: ( subquery_operation_part )*

            for (;;)
            {
                ANTLR_UINT32 alt25=2;
                switch ( this->LA(1) )
                {
                case PLSQL_RESERVED_MINUS:
                case SQL92_RESERVED_INTERSECT:
                case SQL92_RESERVED_UNION:
                	{
                		alt25=1;
                	}
                    break;

                }

                switch (alt25)
                {
            	case 1:
            	    // OracleDML.g:184:34: subquery_operation_part
            	    {
            	        this->followPush(FOLLOW_subquery_operation_part_in_subquery1373);
            	        subquery_operation_part79=subquery_operation_part();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesubqueryEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            subquery_operation_part79_last = subquery_operation_part79.tree.get();
            	            stream_subquery_operation_part.add(subquery_operation_part79.tree);
            	        }

            	    }
            	    break;

            	default:
            	    goto loop25;	/* break out of the loop */
            	    break;
                }
            }
            loop25: ; /* Jump out to here if this rule does not match */


            // AST REWRITE
            // elements: subquery_operation_part, subquery_basic_elements
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 185:9: -> ^( SUBQUERY subquery_basic_elements ( subquery_operation_part )* )
            {
            	// OracleDML.g:185:12: ^( SUBQUERY subquery_basic_elements ( subquery_operation_part )* )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(SUBQUERY, "SUBQUERY"), root_1);
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_subquery_basic_elements.nextTree());
            	// OracleDML.g:185:47: ( subquery_operation_part )*
            	while ( stream_subquery_operation_part.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_subquery_operation_part.nextTree());
            	}
            	stream_subquery_operation_part.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulesubqueryEx; /* Prevent compiler warnings */
    rulesubqueryEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end subquery */

/**
 * $ANTLR start subquery_operation_part
 * OracleDML.g:188:1: subquery_operation_part : ( union_key ^ ( all_key )? | intersect_key ^| minus_key ^) subquery_basic_elements ;
 */
OracleDML::subquery_operation_part_return
OracleDML::subquery_operation_part()
{
    OracleDML::subquery_operation_part_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML_OracleDMLKeys::union_key_return union_key80;
    ImplTraits::TreeTypePtr::pointer union_key80_last = NULL;
    OracleDML_OracleDMLKeys::all_key_return all_key81;
    ImplTraits::TreeTypePtr::pointer all_key81_last = NULL;
    OracleDML_OracleDMLKeys::intersect_key_return intersect_key82;
    ImplTraits::TreeTypePtr::pointer intersect_key82_last = NULL;
    OracleDML_OracleDMLKeys::minus_key_return minus_key83;
    ImplTraits::TreeTypePtr::pointer minus_key83_last = NULL;
    OracleDML::subquery_basic_elements_return subquery_basic_elements84;
    ImplTraits::TreeTypePtr::pointer subquery_basic_elements84_last = NULL;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:189:5: ( ( union_key ^ ( all_key )? | intersect_key ^| minus_key ^) subquery_basic_elements )
        // OracleDML.g:189:10: ( union_key ^ ( all_key )? | intersect_key ^| minus_key ^) subquery_basic_elements
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            // OracleDML.g:189:10: ( union_key ^ ( all_key )? | intersect_key ^| minus_key ^)
            {
                ANTLR_UINT32 alt27=3;
                switch ( this->LA(1) )
                {
                case SQL92_RESERVED_UNION:
                	{
                		alt27=1;
                	}
                    break;
                case SQL92_RESERVED_INTERSECT:
                	{
                		alt27=2;
                	}
                    break;
                case PLSQL_RESERVED_MINUS:
                	{
                		alt27=3;
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return retval;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 27 );
                    ex->set_state( 0 );


                    goto rulesubquery_operation_partEx;

                }

                switch (alt27)
                {
            	case 1:
            	    // OracleDML.g:189:11: union_key ^ ( all_key )?
            	    {
            	        this->followPush(FOLLOW_union_key_in_subquery_operation_part1414);
            	        union_key80=union_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesubquery_operation_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(union_key80.tree, root_0);

            	        // OracleDML.g:189:22: ( all_key )?
            	        {
            	            ANTLR_UINT32 alt26=2;
            	            switch ( this->LA(1) )
            	            {
            	                case SQL92_RESERVED_ALL:
            	                	{
            	                		alt26=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt26)
            	            {
            	        	case 1:
            	        	    // OracleDML.g:189:22: all_key
            	        	    {
            	        	        this->followPush(FOLLOW_all_key_in_subquery_operation_part1417);
            	        	        all_key81=all_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulesubquery_operation_partEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, all_key81.tree);


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;
            	case 2:
            	    // OracleDML.g:189:31: intersect_key ^
            	    {
            	        this->followPush(FOLLOW_intersect_key_in_subquery_operation_part1420);
            	        intersect_key82=intersect_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesubquery_operation_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(intersect_key82.tree, root_0);

            	    }
            	    break;
            	case 3:
            	    // OracleDML.g:189:46: minus_key ^
            	    {
            	        this->followPush(FOLLOW_minus_key_in_subquery_operation_part1423);
            	        minus_key83=minus_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesubquery_operation_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(minus_key83.tree, root_0);

            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_subquery_basic_elements_in_subquery_operation_part1427);
            subquery_basic_elements84=subquery_basic_elements();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesubquery_operation_partEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, subquery_basic_elements84.tree);


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulesubquery_operation_partEx; /* Prevent compiler warnings */
    rulesubquery_operation_partEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end subquery_operation_part */

/**
 * $ANTLR start subquery_basic_elements
 * OracleDML.g:192:1: subquery_basic_elements : ( query_block | LEFT_PAREN ^ subquery RIGHT_PAREN );
 */
OracleDML::subquery_basic_elements_return
OracleDML::subquery_basic_elements()
{
    OracleDML::subquery_basic_elements_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* LEFT_PAREN86 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN88 = NULL;
    OracleDML::query_block_return query_block85;
    ImplTraits::TreeTypePtr::pointer query_block85_last = NULL;
    OracleDML::subquery_return subquery87;
    ImplTraits::TreeTypePtr::pointer subquery87_last = NULL;
    ImplTraits::TreeTypePtr LEFT_PAREN86_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN88_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        {
            //  OracleDML.g:193:5: ( query_block | LEFT_PAREN ^ subquery RIGHT_PAREN )

            ANTLR_UINT32 alt28;

            alt28=2;

            switch ( this->LA(1) )
            {
            case SQL92_RESERVED_SELECT:
            	{
            		alt28=1;
            	}
                break;
            case LEFT_PAREN:
            	{
            		alt28=2;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 28 );
                ex->set_state( 0 );


                goto rulesubquery_basic_elementsEx;

            }

            switch (alt28)
            {
        	case 1:
        	    // OracleDML.g:193:10: query_block
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_query_block_in_subquery_basic_elements1447);
        	        query_block85=query_block();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesubquery_basic_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, query_block85.tree);


        	    }
        	    break;
        	case 2:
        	    // OracleDML.g:194:10: LEFT_PAREN ^ subquery RIGHT_PAREN
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        LEFT_PAREN86 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_subquery_basic_elements1458);
        	        if  (this->hasException())
        	        {
        	            goto rulesubquery_basic_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) {
        	        LEFT_PAREN86_tree = get_psrstate()->get_treeAdaptor()->create(LEFT_PAREN86);
        	        root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(LEFT_PAREN86_tree, root_0);
        	        }


        	        this->followPush(FOLLOW_subquery_in_subquery_basic_elements1461);
        	        subquery87=subquery();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesubquery_basic_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, subquery87.tree);


        	        RIGHT_PAREN88 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_subquery_basic_elements1463);
        	        if  (this->hasException())
        	        {
        	            goto rulesubquery_basic_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) {
        	        RIGHT_PAREN88_tree = std::move(get_psrstate()->get_treeAdaptor()->create(RIGHT_PAREN88));
        	        get_psrstate()->get_treeAdaptor()->addChild(root_0, RIGHT_PAREN88_tree);
        	        }


        	    }
        	    break;

            }
        }
    }//...
    // This is where rules clean up and exit
    //
    goto rulesubquery_basic_elementsEx; /* Prevent compiler warnings */
    rulesubquery_basic_elementsEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end subquery_basic_elements */

/**
 * $ANTLR start query_block
 * OracleDML.g:197:1: query_block : select_key selected_list ( into_clause )? from_clause ( where_clause )? ( hierarchical_query_clause )? ( group_by_clause )? ( model_clause )? -> ^( select_key selected_list ( into_clause )? from_clause ( where_clause )? ( hierarchical_query_clause )? ( group_by_clause )? ( model_clause )? ) ;
 */
OracleDML::query_block_return
OracleDML::query_block()
{
    OracleDML::query_block_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML_OracleDMLKeys::select_key_return select_key89;
    ImplTraits::TreeTypePtr::pointer select_key89_last = NULL;
    OracleDML::selected_list_return selected_list90;
    ImplTraits::TreeTypePtr::pointer selected_list90_last = NULL;
    OracleDML_OracleDMLCommons::into_clause_return into_clause91;
    ImplTraits::TreeTypePtr::pointer into_clause91_last = NULL;
    OracleDML::from_clause_return from_clause92;
    ImplTraits::TreeTypePtr::pointer from_clause92_last = NULL;
    OracleDML_OracleDMLCommons::where_clause_return where_clause93;
    ImplTraits::TreeTypePtr::pointer where_clause93_last = NULL;
    OracleDML::hierarchical_query_clause_return hierarchical_query_clause94;
    ImplTraits::TreeTypePtr::pointer hierarchical_query_clause94_last = NULL;
    OracleDML::group_by_clause_return group_by_clause95;
    ImplTraits::TreeTypePtr::pointer group_by_clause95_last = NULL;
    OracleDML::model_clause_return model_clause96;
    ImplTraits::TreeTypePtr::pointer model_clause96_last = NULL;
    RewriteRuleSubtreeStream<ImplTraits> stream_from_clause(get_psrstate()->get_treeAdaptor(), "rule from_clause");
    RewriteRuleSubtreeStream<ImplTraits> stream_where_clause(get_psrstate()->get_treeAdaptor(), "rule where_clause");
    RewriteRuleSubtreeStream<ImplTraits> stream_into_clause(get_psrstate()->get_treeAdaptor(), "rule into_clause");
    RewriteRuleSubtreeStream<ImplTraits> stream_group_by_clause(get_psrstate()->get_treeAdaptor(), "rule group_by_clause");
    RewriteRuleSubtreeStream<ImplTraits> stream_selected_list(get_psrstate()->get_treeAdaptor(), "rule selected_list");
    RewriteRuleSubtreeStream<ImplTraits> stream_model_clause(get_psrstate()->get_treeAdaptor(), "rule model_clause");
    RewriteRuleSubtreeStream<ImplTraits> stream_select_key(get_psrstate()->get_treeAdaptor(), "rule select_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_hierarchical_query_clause(get_psrstate()->get_treeAdaptor(), "rule hierarchical_query_clause");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:198:5: ( select_key selected_list ( into_clause )? from_clause ( where_clause )? ( hierarchical_query_clause )? ( group_by_clause )? ( model_clause )? -> ^( select_key selected_list ( into_clause )? from_clause ( where_clause )? ( hierarchical_query_clause )? ( group_by_clause )? ( model_clause )? ) )
        // OracleDML.g:198:9: select_key selected_list ( into_clause )? from_clause ( where_clause )? ( hierarchical_query_clause )? ( group_by_clause )? ( model_clause )?
        {
            this->followPush(FOLLOW_select_key_in_query_block1482);
            select_key89=select_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulequery_blockEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                select_key89_last = select_key89.tree.get();
                stream_select_key.add(select_key89.tree);
            }

            this->followPush(FOLLOW_selected_list_in_query_block1492);
            selected_list90=selected_list();

            this->followPop();
            if  (this->hasException())
            {
                goto rulequery_blockEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                selected_list90_last = selected_list90.tree.get();
                stream_selected_list.add(selected_list90.tree);
            }

            // OracleDML.g:200:9: ( into_clause )?
            {
                ANTLR_UINT32 alt29=2;
                {
                    ANTLR_UINT32 LA29_0 = this->LA(1);
                    if ( (LA29_0 == SQL92_RESERVED_INTO))
                    {
                        alt29=1;
                    }
                    else if ( (LA29_0 == REGULAR_ID) && ((toUpper(LT(1)->getText()) == "BULK")))
                    {
                        alt29=1;
                    }
                }
                switch (alt29)
                {
            	case 1:
            	    // OracleDML.g:200:9: into_clause
            	    {
            	        this->followPush(FOLLOW_into_clause_in_query_block1502);
            	        into_clause91=into_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulequery_blockEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            into_clause91_last = into_clause91.tree.get();
            	            stream_into_clause.add(into_clause91.tree);
            	        }

            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_from_clause_in_query_block1513);
            from_clause92=from_clause();

            this->followPop();
            if  (this->hasException())
            {
                goto rulequery_blockEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                from_clause92_last = from_clause92.tree.get();
                stream_from_clause.add(from_clause92.tree);
            }

            // OracleDML.g:202:9: ( where_clause )?
            {
                ANTLR_UINT32 alt30=2;
                switch ( this->LA(1) )
                {
                    case SQL92_RESERVED_WHERE:
                    	{
                    		alt30=1;
                    	}
                        break;
                }

                switch (alt30)
                {
            	case 1:
            	    // OracleDML.g:202:9: where_clause
            	    {
            	        this->followPush(FOLLOW_where_clause_in_query_block1524);
            	        where_clause93=where_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulequery_blockEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            where_clause93_last = where_clause93.tree.get();
            	            stream_where_clause.add(where_clause93.tree);
            	        }

            	    }
            	    break;

                }
            }

            // OracleDML.g:203:9: ( hierarchical_query_clause )?
            {
                ANTLR_UINT32 alt31=2;
                switch ( this->LA(1) )
                {
                    case SQL92_RESERVED_CONNECT:
                    	{
                    		alt31=1;
                    	}
                        break;
                    case PLSQL_RESERVED_START:
                    	{
                    		alt31=1;
                    	}
                        break;
                }

                switch (alt31)
                {
            	case 1:
            	    // OracleDML.g:203:9: hierarchical_query_clause
            	    {
            	        this->followPush(FOLLOW_hierarchical_query_clause_in_query_block1536);
            	        hierarchical_query_clause94=hierarchical_query_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulequery_blockEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            hierarchical_query_clause94_last = hierarchical_query_clause94.tree.get();
            	            stream_hierarchical_query_clause.add(hierarchical_query_clause94.tree);
            	        }

            	    }
            	    break;

                }
            }

            // OracleDML.g:204:9: ( group_by_clause )?
            {
                ANTLR_UINT32 alt32=2;
                switch ( this->LA(1) )
                {
                    case SQL92_RESERVED_GROUP:
                    	{
                    		alt32=1;
                    	}
                        break;
                    case SQL92_RESERVED_HAVING:
                    	{
                    		alt32=1;
                    	}
                        break;
                }

                switch (alt32)
                {
            	case 1:
            	    // OracleDML.g:204:9: group_by_clause
            	    {
            	        this->followPush(FOLLOW_group_by_clause_in_query_block1548);
            	        group_by_clause95=group_by_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulequery_blockEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            group_by_clause95_last = group_by_clause95.tree.get();
            	            stream_group_by_clause.add(group_by_clause95.tree);
            	        }

            	    }
            	    break;

                }
            }

            // OracleDML.g:205:9: ( model_clause )?
            {
                ANTLR_UINT32 alt33=2;
                switch ( this->LA(1) )
                {
                    case PLSQL_NON_RESERVED_MODEL:
                    	{
                    		alt33=1;
                    	}
                        break;
                }

                switch (alt33)
                {
            	case 1:
            	    // OracleDML.g:205:9: model_clause
            	    {
            	        this->followPush(FOLLOW_model_clause_in_query_block1559);
            	        model_clause96=model_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulequery_blockEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            model_clause96_last = model_clause96.tree.get();
            	            stream_model_clause.add(model_clause96.tree);
            	        }

            	    }
            	    break;

                }
            }

            // AST REWRITE
            // elements: from_clause, model_clause, hierarchical_query_clause, select_key, group_by_clause, into_clause, where_clause, selected_list
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 206:9: -> ^( select_key selected_list ( into_clause )? from_clause ( where_clause )? ( hierarchical_query_clause )? ( group_by_clause )? ( model_clause )? )
            {
            	// OracleDML.g:206:12: ^( select_key selected_list ( into_clause )? from_clause ( where_clause )? ( hierarchical_query_clause )? ( group_by_clause )? ( model_clause )? )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(stream_select_key.nextNode(), root_1);
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_selected_list.nextTree());
            	// OracleDML.g:206:39: ( into_clause )?
            	if ( stream_into_clause.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_into_clause.nextTree());
            	}
            	stream_into_clause.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_from_clause.nextTree());
            	// OracleDML.g:206:64: ( where_clause )?
            	if ( stream_where_clause.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_where_clause.nextTree());
            	}
            	stream_where_clause.reset();

            	// OracleDML.g:206:78: ( hierarchical_query_clause )?
            	if ( stream_hierarchical_query_clause.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_hierarchical_query_clause.nextTree());
            	}
            	stream_hierarchical_query_clause.reset();

            	// OracleDML.g:206:105: ( group_by_clause )?
            	if ( stream_group_by_clause.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_group_by_clause.nextTree());
            	}
            	stream_group_by_clause.reset();

            	// OracleDML.g:206:122: ( model_clause )?
            	if ( stream_model_clause.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_model_clause.nextTree());
            	}
            	stream_model_clause.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulequery_blockEx; /* Prevent compiler warnings */
    rulequery_blockEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end query_block */

/**
 * $ANTLR start selected_list
 * OracleDML.g:209:1: selected_list : ( ( distinct_key | unique_key | all_key )=> ( distinct_key | unique_key | all_key ) )? ( ASTERISK | selected_element ( selected_element_seq )* ) -> { mode == 1}? ^( SELECT_LIST ( distinct_key )? ( unique_key )? ( all_key )? ASTERISK ) -> ^( SELECT_LIST ( distinct_key )? ( unique_key )? ( all_key )? selected_element ( selected_element_seq )* ) ;
 */
OracleDML::selected_list_return
OracleDML::selected_list()
{
    OracleDML::selected_list_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* ASTERISK100 = NULL;
    OracleDML_OracleDMLKeys::distinct_key_return distinct_key97;
    ImplTraits::TreeTypePtr::pointer distinct_key97_last = NULL;
    OracleDML_OracleDMLKeys::unique_key_return unique_key98;
    ImplTraits::TreeTypePtr::pointer unique_key98_last = NULL;
    OracleDML_OracleDMLKeys::all_key_return all_key99;
    ImplTraits::TreeTypePtr::pointer all_key99_last = NULL;
    OracleDML::selected_element_return selected_element101;
    ImplTraits::TreeTypePtr::pointer selected_element101_last = NULL;
    OracleDML::selected_element_seq_return selected_element_seq102;
    ImplTraits::TreeTypePtr::pointer selected_element_seq102_last = NULL;
    ImplTraits::TreeTypePtr ASTERISK100_tree;
    RewriteRuleTokenStream<ImplTraits> stream_ASTERISK(get_psrstate()->get_treeAdaptor(), "token ASTERISK");
    RewriteRuleSubtreeStream<ImplTraits> stream_all_key(get_psrstate()->get_treeAdaptor(), "rule all_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_selected_element_seq(get_psrstate()->get_treeAdaptor(), "rule selected_element_seq");
    RewriteRuleSubtreeStream<ImplTraits> stream_distinct_key(get_psrstate()->get_treeAdaptor(), "rule distinct_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_selected_element(get_psrstate()->get_treeAdaptor(), "rule selected_element");
    RewriteRuleSubtreeStream<ImplTraits> stream_unique_key(get_psrstate()->get_treeAdaptor(), "rule unique_key");

    /* Initialize rule variables
     */

     int mode = 0; 
    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:211:5: ( ( ( distinct_key | unique_key | all_key )=> ( distinct_key | unique_key | all_key ) )? ( ASTERISK | selected_element ( selected_element_seq )* ) -> { mode == 1}? ^( SELECT_LIST ( distinct_key )? ( unique_key )? ( all_key )? ASTERISK ) -> ^( SELECT_LIST ( distinct_key )? ( unique_key )? ( all_key )? selected_element ( selected_element_seq )* ) )
        // OracleDML.g:212:9: ( ( distinct_key | unique_key | all_key )=> ( distinct_key | unique_key | all_key ) )? ( ASTERISK | selected_element ( selected_element_seq )* )
        {
            // OracleDML.g:212:9: ( ( distinct_key | unique_key | all_key )=> ( distinct_key | unique_key | all_key ) )?
            {
                ANTLR_UINT32 alt35=2;
                {
                    ANTLR_UINT32 LA35_0 = this->LA(1);
                    if ( (LA35_0 == SQL92_RESERVED_DISTINCT))
                    {
                        {
                            ANTLR_UINT32 LA35_1 = this->LA(2);
                            if ( (this->msynpred( antlr3::ClassForwarder<synpred2_OracleDML>() )))
                            {
                                alt35=1;
                            }
                        }
                    }
                    else if ( (LA35_0 == SQL92_RESERVED_UNIQUE) && (this->msynpred( antlr3::ClassForwarder<synpred2_OracleDML>() )))
                    {
                        alt35=1;
                    }
                    else if ( (LA35_0 == SQL92_RESERVED_ALL))
                    {
                        {
                            ANTLR_UINT32 LA35_3 = this->LA(2);
                            if ( (this->msynpred( antlr3::ClassForwarder<synpred2_OracleDML>() )))
                            {
                                alt35=1;
                            }
                        }
                    }
                }
                switch (alt35)
                {
            	case 1:
            	    // OracleDML.g:212:10: ( distinct_key | unique_key | all_key )=> ( distinct_key | unique_key | all_key )
            	    {
            	        // OracleDML.g:212:46: ( distinct_key | unique_key | all_key )
            	        {
            	            ANTLR_UINT32 alt34=3;
            	            switch ( this->LA(1) )
            	            {
            	            case SQL92_RESERVED_DISTINCT:
            	            	{
            	            		alt34=1;
            	            	}
            	                break;
            	            case SQL92_RESERVED_UNIQUE:
            	            	{
            	            		alt34=2;
            	            	}
            	                break;
            	            case SQL92_RESERVED_ALL:
            	            	{
            	            		alt34=3;
            	            	}
            	                break;

            	            default:
            	                if (this->get_backtracking()>0)
            	                {
            	                    this->set_failedflag( true );
            	                    return retval;
            	                }

            	                ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                ex->set_decisionNum( 34 );
            	                ex->set_state( 0 );


            	                goto ruleselected_listEx;

            	            }

            	            switch (alt34)
            	            {
            	        	case 1:
            	        	    // OracleDML.g:212:47: distinct_key
            	        	    {
            	        	        this->followPush(FOLLOW_distinct_key_in_selected_list1637);
            	        	        distinct_key97=distinct_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleselected_listEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) 
            	        	        {
            	        	            distinct_key97_last = distinct_key97.tree.get();
            	        	            stream_distinct_key.add(distinct_key97.tree);
            	        	        }

            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // OracleDML.g:212:60: unique_key
            	        	    {
            	        	        this->followPush(FOLLOW_unique_key_in_selected_list1639);
            	        	        unique_key98=unique_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleselected_listEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) 
            	        	        {
            	        	            unique_key98_last = unique_key98.tree.get();
            	        	            stream_unique_key.add(unique_key98.tree);
            	        	        }

            	        	    }
            	        	    break;
            	        	case 3:
            	        	    // OracleDML.g:212:71: all_key
            	        	    {
            	        	        this->followPush(FOLLOW_all_key_in_selected_list1641);
            	        	        all_key99=all_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleselected_listEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) 
            	        	        {
            	        	            all_key99_last = all_key99.tree.get();
            	        	            stream_all_key.add(all_key99.tree);
            	        	        }

            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

                }
            }

            // OracleDML.g:213:9: ( ASTERISK | selected_element ( selected_element_seq )* )
            {
                ANTLR_UINT32 alt37=2;
                switch ( this->LA(1) )
                {
                case ASTERISK:
                	{
                		alt37=1;
                	}
                    break;
                case APPROXIMATE_NUM_LIT:
                case BINDVAR:
                case CHAR_STRING:
                case CHAR_STRING_PERL:
                case COLON:
                case DELIMITED_ID:
                case EXACT_NUM_LIT:
                case INTRODUCER:
                case LEFT_PAREN:
                case MINUS_SIGN:
                case NATIONAL_CHAR_STRING_LIT:
                case PLSQL_NON_RESERVED_CAST:
                case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
                case PLUS_SIGN:
                case REGULAR_ID:
                case SQL92_RESERVED_ALL:
                case SQL92_RESERVED_ANY:
                case SQL92_RESERVED_CASE:
                case SQL92_RESERVED_CURSOR:
                case SQL92_RESERVED_DATE:
                case SQL92_RESERVED_DEFAULT:
                case SQL92_RESERVED_DISTINCT:
                case SQL92_RESERVED_EXISTS:
                case SQL92_RESERVED_FALSE:
                case SQL92_RESERVED_NOT:
                case SQL92_RESERVED_NULL:
                case SQL92_RESERVED_PRIOR:
                case SQL92_RESERVED_TRUE:
                case UNSIGNED_INTEGER:
                	{
                		alt37=2;
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return retval;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 37 );
                    ex->set_state( 0 );


                    goto ruleselected_listEx;

                }

                switch (alt37)
                {
            	case 1:
            	    // OracleDML.g:213:11: ASTERISK
            	    {
            	        ASTERISK100 =  this->matchToken(ASTERISK, &FOLLOW_ASTERISK_in_selected_list1656);
            	        if  (this->hasException())
            	        {
            	            goto ruleselected_listEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( this->get_backtracking()==0 ) stream_ASTERISK.add(ASTERISK100);


            	        if ( this->get_backtracking()==0 )
            	        {
            	            mode = 1;
            	        }


            	    }
            	    break;
            	case 2:
            	    // OracleDML.g:214:11: selected_element ( selected_element_seq )*
            	    {
            	        this->followPush(FOLLOW_selected_element_in_selected_list1670);
            	        selected_element101=selected_element();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleselected_listEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            selected_element101_last = selected_element101.tree.get();
            	            stream_selected_element.add(selected_element101.tree);
            	        }

            	        // OracleDML.g:214:28: ( selected_element_seq )*

            	        for (;;)
            	        {
            	            ANTLR_UINT32 alt36=2;
            	            switch ( this->LA(1) )
            	            {
            	            case COMMA:
            	            	{
            	            		alt36=1;
            	            	}
            	                break;

            	            }

            	            switch (alt36)
            	            {
            	        	case 1:
            	        	    // OracleDML.g:214:28: selected_element_seq
            	        	    {
            	        	        this->followPush(FOLLOW_selected_element_seq_in_selected_list1672);
            	        	        selected_element_seq102=selected_element_seq();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleselected_listEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) 
            	        	        {
            	        	            selected_element_seq102_last = selected_element_seq102.tree.get();
            	        	            stream_selected_element_seq.add(selected_element_seq102.tree);
            	        	        }

            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop36;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop36: ; /* Jump out to here if this rule does not match */


            	    }
            	    break;

                }
            }

            // AST REWRITE
            // elements: selected_element_seq, distinct_key, unique_key, unique_key, distinct_key, selected_element, all_key, all_key, ASTERISK
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 216:9: -> { mode == 1}? ^( SELECT_LIST ( distinct_key )? ( unique_key )? ( all_key )? ASTERISK )
            if ( mode == 1) {
            	// OracleDML.g:216:26: ^( SELECT_LIST ( distinct_key )? ( unique_key )? ( all_key )? ASTERISK )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(SELECT_LIST, "SELECT_LIST"), root_1);
            	// OracleDML.g:216:40: ( distinct_key )?
            	if ( stream_distinct_key.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_distinct_key.nextTree());
            	}
            	stream_distinct_key.reset();

            	// OracleDML.g:216:54: ( unique_key )?
            	if ( stream_unique_key.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_unique_key.nextTree());
            	}
            	stream_unique_key.reset();

            	// OracleDML.g:216:66: ( all_key )?
            	if ( stream_all_key.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_all_key.nextTree());
            	}
            	stream_all_key.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_ASTERISK.nextNode());
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }

            else // 217:9: -> ^( SELECT_LIST ( distinct_key )? ( unique_key )? ( all_key )? selected_element ( selected_element_seq )* )
            {
            	// OracleDML.g:217:12: ^( SELECT_LIST ( distinct_key )? ( unique_key )? ( all_key )? selected_element ( selected_element_seq )* )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(SELECT_LIST, "SELECT_LIST"), root_1);
            	// OracleDML.g:217:26: ( distinct_key )?
            	if ( stream_distinct_key.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_distinct_key.nextTree());
            	}
            	stream_distinct_key.reset();

            	// OracleDML.g:217:40: ( unique_key )?
            	if ( stream_unique_key.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_unique_key.nextTree());
            	}
            	stream_unique_key.reset();

            	// OracleDML.g:217:52: ( all_key )?
            	if ( stream_all_key.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_all_key.nextTree());
            	}
            	stream_all_key.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_selected_element.nextTree());
            	// OracleDML.g:217:78: ( selected_element_seq )*
            	while ( stream_selected_element_seq.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_selected_element_seq.nextTree());
            	}
            	stream_selected_element_seq.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleselected_listEx; /* Prevent compiler warnings */
    ruleselected_listEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end selected_list */

/**
 * $ANTLR start selected_element
 * OracleDML.g:220:1: selected_element : select_list_elements ( column_alias )? -> ^( SELECT_ITEM select_list_elements ( column_alias )? ) ;
 */
OracleDML::selected_element_return
OracleDML::selected_element()
{
    OracleDML::selected_element_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML::select_list_elements_return select_list_elements103;
    ImplTraits::TreeTypePtr::pointer select_list_elements103_last = NULL;
    OracleDML_OracleDMLCommons::column_alias_return column_alias104;
    ImplTraits::TreeTypePtr::pointer column_alias104_last = NULL;
    RewriteRuleSubtreeStream<ImplTraits> stream_column_alias(get_psrstate()->get_treeAdaptor(), "rule column_alias");
    RewriteRuleSubtreeStream<ImplTraits> stream_select_list_elements(get_psrstate()->get_treeAdaptor(), "rule select_list_elements");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:221:5: ( select_list_elements ( column_alias )? -> ^( SELECT_ITEM select_list_elements ( column_alias )? ) )
        // OracleDML.g:221:10: select_list_elements ( column_alias )?
        {
            this->followPush(FOLLOW_select_list_elements_in_selected_element1758);
            select_list_elements103=select_list_elements();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleselected_elementEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                select_list_elements103_last = select_list_elements103.tree.get();
                stream_select_list_elements.add(select_list_elements103.tree);
            }

            // OracleDML.g:221:31: ( column_alias )?
            {
                ANTLR_UINT32 alt38=2;
                switch ( this->LA(1) )
                {
                    case CHAR_STRING:
                    case CHAR_STRING_PERL:
                    case DELIMITED_ID:
                    case INTRODUCER:
                    case NATIONAL_CHAR_STRING_LIT:
                    case SQL92_RESERVED_AS:
                    	{
                    		alt38=1;
                    	}
                        break;
                    case REGULAR_ID:
                    	{
                    		switch ( this->LA(2) )
                    		{
                    		    case COMMA:
                    		    case SQL92_RESERVED_FROM:
                    		    case SQL92_RESERVED_INTO:
                    		    	{
                    		    		alt38=1;
                    		    	}
                    		        break;
                    		    case REGULAR_ID:
                    		    	{
                    		    		switch ( this->LA(3) )
                    		    		{
                    		    		    case REGULAR_ID:
                    		    		    	{
                    		    		    		alt38=1;
                    		    		    	}
                    		    		        break;
                    		    		}

                    		    	}
                    		        break;
                    		}

                    	}
                        break;
                }

                switch (alt38)
                {
            	case 1:
            	    // OracleDML.g:221:31: column_alias
            	    {
            	        this->followPush(FOLLOW_column_alias_in_selected_element1760);
            	        column_alias104=column_alias();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleselected_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            column_alias104_last = column_alias104.tree.get();
            	            stream_column_alias.add(column_alias104.tree);
            	        }

            	    }
            	    break;

                }
            }

            // AST REWRITE
            // elements: column_alias, select_list_elements
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 222:9: -> ^( SELECT_ITEM select_list_elements ( column_alias )? )
            {
            	// OracleDML.g:222:12: ^( SELECT_ITEM select_list_elements ( column_alias )? )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(SELECT_ITEM, "SELECT_ITEM"), root_1);
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_select_list_elements.nextTree());
            	// OracleDML.g:222:47: ( column_alias )?
            	if ( stream_column_alias.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_column_alias.nextTree());
            	}
            	stream_column_alias.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleselected_elementEx; /* Prevent compiler warnings */
    ruleselected_elementEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end selected_element */

/**
 * $ANTLR start selected_element_seq
 * OracleDML.g:225:1: selected_element_seq : COMMA select_list_elements ( column_alias )? -> ^( SELECT_ITEM[$COMMA] select_list_elements ( column_alias )? ) ;
 */
OracleDML::selected_element_seq_return
OracleDML::selected_element_seq()
{
    OracleDML::selected_element_seq_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* COMMA105 = NULL;
    OracleDML::select_list_elements_return select_list_elements106;
    ImplTraits::TreeTypePtr::pointer select_list_elements106_last = NULL;
    OracleDML_OracleDMLCommons::column_alias_return column_alias107;
    ImplTraits::TreeTypePtr::pointer column_alias107_last = NULL;
    ImplTraits::TreeTypePtr COMMA105_tree;
    RewriteRuleTokenStream<ImplTraits> stream_COMMA(get_psrstate()->get_treeAdaptor(), "token COMMA");
    RewriteRuleSubtreeStream<ImplTraits> stream_column_alias(get_psrstate()->get_treeAdaptor(), "rule column_alias");
    RewriteRuleSubtreeStream<ImplTraits> stream_select_list_elements(get_psrstate()->get_treeAdaptor(), "rule select_list_elements");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:226:5: ( COMMA select_list_elements ( column_alias )? -> ^( SELECT_ITEM[$COMMA] select_list_elements ( column_alias )? ) )
        // OracleDML.g:226:10: COMMA select_list_elements ( column_alias )?
        {
            COMMA105 =  this->matchToken(COMMA, &FOLLOW_COMMA_in_selected_element_seq1800);
            if  (this->hasException())
            {
                goto ruleselected_element_seqEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_COMMA.add(COMMA105);


            this->followPush(FOLLOW_select_list_elements_in_selected_element_seq1802);
            select_list_elements106=select_list_elements();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleselected_element_seqEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                select_list_elements106_last = select_list_elements106.tree.get();
                stream_select_list_elements.add(select_list_elements106.tree);
            }

            // OracleDML.g:226:37: ( column_alias )?
            {
                ANTLR_UINT32 alt39=2;
                switch ( this->LA(1) )
                {
                    case CHAR_STRING:
                    case CHAR_STRING_PERL:
                    case DELIMITED_ID:
                    case INTRODUCER:
                    case NATIONAL_CHAR_STRING_LIT:
                    case SQL92_RESERVED_AS:
                    	{
                    		alt39=1;
                    	}
                        break;
                    case REGULAR_ID:
                    	{
                    		switch ( this->LA(2) )
                    		{
                    		    case COMMA:
                    		    case SQL92_RESERVED_FROM:
                    		    case SQL92_RESERVED_INTO:
                    		    	{
                    		    		alt39=1;
                    		    	}
                    		        break;
                    		    case REGULAR_ID:
                    		    	{
                    		    		switch ( this->LA(3) )
                    		    		{
                    		    		    case REGULAR_ID:
                    		    		    	{
                    		    		    		alt39=1;
                    		    		    	}
                    		    		        break;
                    		    		}

                    		    	}
                    		        break;
                    		}

                    	}
                        break;
                }

                switch (alt39)
                {
            	case 1:
            	    // OracleDML.g:226:37: column_alias
            	    {
            	        this->followPush(FOLLOW_column_alias_in_selected_element_seq1804);
            	        column_alias107=column_alias();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleselected_element_seqEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            column_alias107_last = column_alias107.tree.get();
            	            stream_column_alias.add(column_alias107.tree);
            	        }

            	    }
            	    break;

                }
            }

            // AST REWRITE
            // elements: column_alias, select_list_elements
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 227:9: -> ^( SELECT_ITEM[$COMMA] select_list_elements ( column_alias )? )
            {
            	// OracleDML.g:227:12: ^( SELECT_ITEM[$COMMA] select_list_elements ( column_alias )? )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(SELECT_ITEM, COMMA105), root_1);
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_select_list_elements.nextTree());
            	// OracleDML.g:227:55: ( column_alias )?
            	if ( stream_column_alias.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_column_alias.nextTree());
            	}
            	stream_column_alias.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleselected_element_seqEx; /* Prevent compiler warnings */
    ruleselected_element_seqEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end selected_element_seq */

/**
 * $ANTLR start from_clause
 * OracleDML.g:230:1: from_clause : from_key ^ table_ref_list ;
 */
OracleDML::from_clause_return
OracleDML::from_clause()
{
    OracleDML::from_clause_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML_OracleDMLKeys::from_key_return from_key108;
    ImplTraits::TreeTypePtr::pointer from_key108_last = NULL;
    OracleDML::table_ref_list_return table_ref_list109;
    ImplTraits::TreeTypePtr::pointer table_ref_list109_last = NULL;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:231:5: ( from_key ^ table_ref_list )
        // OracleDML.g:231:10: from_key ^ table_ref_list
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            this->followPush(FOLLOW_from_key_in_from_clause1845);
            from_key108=from_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulefrom_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(from_key108.tree, root_0);

            this->followPush(FOLLOW_table_ref_list_in_from_clause1848);
            table_ref_list109=table_ref_list();

            this->followPop();
            if  (this->hasException())
            {
                goto rulefrom_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, table_ref_list109.tree);


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulefrom_clauseEx; /* Prevent compiler warnings */
    rulefrom_clauseEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end from_clause */

/**
 * $ANTLR start select_list_elements
 * OracleDML.g:234:1: select_list_elements : ( ( tableview_name PERIOD ASTERISK )=> tableview_name PERIOD ASTERISK -> ^( EXPR ^( DOT_ASTERISK[$ASTERISK] tableview_name ) ) | expression -> ^( EXPR expression ) );
 */
OracleDML::select_list_elements_return
OracleDML::select_list_elements()
{
    OracleDML::select_list_elements_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* PERIOD111 = NULL;
    ImplTraits::CommonTokenType const* ASTERISK112 = NULL;
    OracleDML_OracleDMLCommons::tableview_name_return tableview_name110;
    ImplTraits::TreeTypePtr::pointer tableview_name110_last = NULL;
    OracleDML::expression_return expression113;
    ImplTraits::TreeTypePtr::pointer expression113_last = NULL;
    ImplTraits::TreeTypePtr PERIOD111_tree;
    ImplTraits::TreeTypePtr ASTERISK112_tree;
    RewriteRuleTokenStream<ImplTraits> stream_PERIOD(get_psrstate()->get_treeAdaptor(), "token PERIOD");
    RewriteRuleTokenStream<ImplTraits> stream_ASTERISK(get_psrstate()->get_treeAdaptor(), "token ASTERISK");
    RewriteRuleSubtreeStream<ImplTraits> stream_expression(get_psrstate()->get_treeAdaptor(), "rule expression");
    RewriteRuleSubtreeStream<ImplTraits> stream_tableview_name(get_psrstate()->get_treeAdaptor(), "rule tableview_name");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        {
            //  OracleDML.g:235:5: ( ( tableview_name PERIOD ASTERISK )=> tableview_name PERIOD ASTERISK -> ^( EXPR ^( DOT_ASTERISK[$ASTERISK] tableview_name ) ) | expression -> ^( EXPR expression ) )

            ANTLR_UINT32 alt40;

            alt40=2;

            switch ( this->LA(1) )
            {
            case INTRODUCER:
            	{
            		{
            		    ANTLR_UINT32 LA40_1 = this->LA(2);
            		    if ( (this->msynpred( antlr3::ClassForwarder<synpred3_OracleDML>() )))
            		    {
            		        alt40=1;
            		    }
            		    else if ( (true))
            		    {
            		        alt40=2;
            		    }
            		    else
            		    {
            		        if (this->get_backtracking()>0)
            		        {
            		            this->set_failedflag( true );
            		            return retval;
            		        }


            		        ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 40 );
            		        ex->set_state( 1 );


            		        goto ruleselect_list_elementsEx;

            		    }
            		}
            	}
                break;
            case REGULAR_ID:
            	{
            		{
            		    ANTLR_UINT32 LA40_2 = this->LA(2);
            		    if ( (this->msynpred( antlr3::ClassForwarder<synpred3_OracleDML>() )))
            		    {
            		        alt40=1;
            		    }
            		    else if ( (true))
            		    {
            		        alt40=2;
            		    }
            		    else
            		    {
            		        if (this->get_backtracking()>0)
            		        {
            		            this->set_failedflag( true );
            		            return retval;
            		        }


            		        ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 40 );
            		        ex->set_state( 2 );


            		        goto ruleselect_list_elementsEx;

            		    }
            		}
            	}
                break;
            case DELIMITED_ID:
            	{
            		{
            		    ANTLR_UINT32 LA40_3 = this->LA(2);
            		    if ( (this->msynpred( antlr3::ClassForwarder<synpred3_OracleDML>() )))
            		    {
            		        alt40=1;
            		    }
            		    else if ( (true))
            		    {
            		        alt40=2;
            		    }
            		    else
            		    {
            		        if (this->get_backtracking()>0)
            		        {
            		            this->set_failedflag( true );
            		            return retval;
            		        }


            		        ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 40 );
            		        ex->set_state( 3 );


            		        goto ruleselect_list_elementsEx;

            		    }
            		}
            	}
                break;
            case APPROXIMATE_NUM_LIT:
            case BINDVAR:
            case CHAR_STRING:
            case CHAR_STRING_PERL:
            case COLON:
            case EXACT_NUM_LIT:
            case LEFT_PAREN:
            case MINUS_SIGN:
            case NATIONAL_CHAR_STRING_LIT:
            case PLSQL_NON_RESERVED_CAST:
            case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
            case PLUS_SIGN:
            case SQL92_RESERVED_ALL:
            case SQL92_RESERVED_ANY:
            case SQL92_RESERVED_CASE:
            case SQL92_RESERVED_CURSOR:
            case SQL92_RESERVED_DATE:
            case SQL92_RESERVED_DEFAULT:
            case SQL92_RESERVED_DISTINCT:
            case SQL92_RESERVED_EXISTS:
            case SQL92_RESERVED_FALSE:
            case SQL92_RESERVED_NOT:
            case SQL92_RESERVED_NULL:
            case SQL92_RESERVED_PRIOR:
            case SQL92_RESERVED_TRUE:
            case UNSIGNED_INTEGER:
            	{
            		alt40=2;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 40 );
                ex->set_state( 0 );


                goto ruleselect_list_elementsEx;

            }

            switch (alt40)
            {
        	case 1:
        	    // OracleDML.g:235:10: ( tableview_name PERIOD ASTERISK )=> tableview_name PERIOD ASTERISK
        	    {
        	        this->followPush(FOLLOW_tableview_name_in_select_list_elements1877);
        	        tableview_name110=tableview_name();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleselect_list_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) 
        	        {
        	            tableview_name110_last = tableview_name110.tree.get();
        	            stream_tableview_name.add(tableview_name110.tree);
        	        }

        	        PERIOD111 =  this->matchToken(PERIOD, &FOLLOW_PERIOD_in_select_list_elements1879);
        	        if  (this->hasException())
        	        {
        	            goto ruleselect_list_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }
        	         
        	        if ( this->get_backtracking()==0 ) stream_PERIOD.add(PERIOD111);


        	        ASTERISK112 =  this->matchToken(ASTERISK, &FOLLOW_ASTERISK_in_select_list_elements1881);
        	        if  (this->hasException())
        	        {
        	            goto ruleselect_list_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }
        	         
        	        if ( this->get_backtracking()==0 ) stream_ASTERISK.add(ASTERISK112);


        	        // AST REWRITE
        	        // elements: tableview_name
        	        // token labels: 
        	        // rule labels: retval
        	        // token list labels: 
        	        // rule list labels: 
        	        // wildcard labels: 
        	        if ( this->get_backtracking()==0 ) {
        	        retval.tree = std::move(root_0);
        	        RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
        	        // 235:76: -> ^( EXPR ^( DOT_ASTERISK[$ASTERISK] tableview_name ) )
        	        {
        	        	// OracleDML.g:235:79: ^( EXPR ^( DOT_ASTERISK[$ASTERISK] tableview_name ) )
        	        	{
        	        	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
        	        	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(EXPR, "EXPR"), root_1);
        	        	// OracleDML.g:235:86: ^( DOT_ASTERISK[$ASTERISK] tableview_name )
        	        	{
        	        	ImplTraits::TreeTypePtr root_2 = get_psrstate()->get_treeAdaptor()->nilNode();
        	        	root_2 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(DOT_ASTERISK, ASTERISK112), root_2);
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_2, stream_tableview_name.nextTree());
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_1, root_2);
        	        	}
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
        	        	}
        	        }


        	        //retval.tree = std::move(root_0);
        	        }

        	    }
        	    break;
        	case 2:
        	    // OracleDML.g:236:10: expression
        	    {
        	        this->followPush(FOLLOW_expression_in_select_list_elements1907);
        	        expression113=expression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleselect_list_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) 
        	        {
        	            expression113_last = expression113.tree.get();
        	            stream_expression.add(expression113.tree);
        	        }

        	        // AST REWRITE
        	        // elements: expression
        	        // token labels: 
        	        // rule labels: retval
        	        // token list labels: 
        	        // rule list labels: 
        	        // wildcard labels: 
        	        if ( this->get_backtracking()==0 ) {
        	        retval.tree = std::move(root_0);
        	        RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
        	        // 236:21: -> ^( EXPR expression )
        	        {
        	        	// OracleDML.g:236:24: ^( EXPR expression )
        	        	{
        	        	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
        	        	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(EXPR, "EXPR"), root_1);
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_expression.nextTree());
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
        	        	}
        	        }


        	        //retval.tree = std::move(root_0);
        	        }

        	    }
        	    break;

            }
        }
    }//...
    // This is where rules clean up and exit
    //
    goto ruleselect_list_elementsEx; /* Prevent compiler warnings */
    ruleselect_list_elementsEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end select_list_elements */

/**
 * $ANTLR start table_ref_list
 * OracleDML.g:239:1: table_ref_list : table_ref ( table_ref_list_seq )* ;
 */
OracleDML::table_ref_list_return
OracleDML::table_ref_list()
{
    OracleDML::table_ref_list_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML::table_ref_return table_ref114;
    ImplTraits::TreeTypePtr::pointer table_ref114_last = NULL;
    OracleDML::table_ref_list_seq_return table_ref_list_seq115;
    ImplTraits::TreeTypePtr::pointer table_ref_list_seq115_last = NULL;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:240:5: ( table_ref ( table_ref_list_seq )* )
        // OracleDML.g:240:10: table_ref ( table_ref_list_seq )*
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            this->followPush(FOLLOW_table_ref_in_table_ref_list1935);
            table_ref114=table_ref();

            this->followPop();
            if  (this->hasException())
            {
                goto ruletable_ref_listEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, table_ref114.tree);


            // OracleDML.g:240:20: ( table_ref_list_seq )*

            for (;;)
            {
                ANTLR_UINT32 alt41=2;
                switch ( this->LA(1) )
                {
                case COMMA:
                	{
                		alt41=1;
                	}
                    break;

                }

                switch (alt41)
                {
            	case 1:
            	    // OracleDML.g:240:20: table_ref_list_seq
            	    {
            	        this->followPush(FOLLOW_table_ref_list_seq_in_table_ref_list1937);
            	        table_ref_list_seq115=table_ref_list_seq();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletable_ref_listEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, table_ref_list_seq115.tree);


            	    }
            	    break;

            	default:
            	    goto loop41;	/* break out of the loop */
            	    break;
                }
            }
            loop41: ; /* Jump out to here if this rule does not match */


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruletable_ref_listEx; /* Prevent compiler warnings */
    ruletable_ref_listEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end table_ref_list */

/**
 * $ANTLR start table_ref_list_seq
 * OracleDML.g:244:1: table_ref_list_seq : COMMA table_ref -> ^( TABLE_REF_ELEMENT[$COMMA] table_ref ) ;
 */
OracleDML::table_ref_list_seq_return
OracleDML::table_ref_list_seq()
{
    OracleDML::table_ref_list_seq_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* COMMA116 = NULL;
    OracleDML::table_ref_return table_ref117;
    ImplTraits::TreeTypePtr::pointer table_ref117_last = NULL;
    ImplTraits::TreeTypePtr COMMA116_tree;
    RewriteRuleTokenStream<ImplTraits> stream_COMMA(get_psrstate()->get_treeAdaptor(), "token COMMA");
    RewriteRuleSubtreeStream<ImplTraits> stream_table_ref(get_psrstate()->get_treeAdaptor(), "rule table_ref");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:245:5: ( COMMA table_ref -> ^( TABLE_REF_ELEMENT[$COMMA] table_ref ) )
        // OracleDML.g:245:10: COMMA table_ref
        {
            COMMA116 =  this->matchToken(COMMA, &FOLLOW_COMMA_in_table_ref_list_seq1963);
            if  (this->hasException())
            {
                goto ruletable_ref_list_seqEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_COMMA.add(COMMA116);


            this->followPush(FOLLOW_table_ref_in_table_ref_list_seq1965);
            table_ref117=table_ref();

            this->followPop();
            if  (this->hasException())
            {
                goto ruletable_ref_list_seqEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                table_ref117_last = table_ref117.tree.get();
                stream_table_ref.add(table_ref117.tree);
            }

            // AST REWRITE
            // elements: table_ref
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 246:9: -> ^( TABLE_REF_ELEMENT[$COMMA] table_ref )
            {
            	// OracleDML.g:246:12: ^( TABLE_REF_ELEMENT[$COMMA] table_ref )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(TABLE_REF_ELEMENT, COMMA116), root_1);
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_table_ref.nextTree());
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruletable_ref_list_seqEx; /* Prevent compiler warnings */
    ruletable_ref_list_seqEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end table_ref_list_seq */

/**
 * $ANTLR start table_ref
 * OracleDML.g:253:1: table_ref : table_ref_aux ( join_clause )* ( pivot_clause | unpivot_clause )? -> ^( TABLE_REF[ToraType(T_TABLE_REF)] table_ref_aux ( join_clause )* ( pivot_clause )? ( unpivot_clause )? ) ;
 */
OracleDML::table_ref_return
OracleDML::table_ref()
{
    OracleDML::table_ref_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML::table_ref_aux_return table_ref_aux118;
    ImplTraits::TreeTypePtr::pointer table_ref_aux118_last = NULL;
    OracleDML::join_clause_return join_clause119;
    ImplTraits::TreeTypePtr::pointer join_clause119_last = NULL;
    OracleDML::pivot_clause_return pivot_clause120;
    ImplTraits::TreeTypePtr::pointer pivot_clause120_last = NULL;
    OracleDML::unpivot_clause_return unpivot_clause121;
    ImplTraits::TreeTypePtr::pointer unpivot_clause121_last = NULL;
    RewriteRuleSubtreeStream<ImplTraits> stream_join_clause(get_psrstate()->get_treeAdaptor(), "rule join_clause");
    RewriteRuleSubtreeStream<ImplTraits> stream_unpivot_clause(get_psrstate()->get_treeAdaptor(), "rule unpivot_clause");
    RewriteRuleSubtreeStream<ImplTraits> stream_pivot_clause(get_psrstate()->get_treeAdaptor(), "rule pivot_clause");
    RewriteRuleSubtreeStream<ImplTraits> stream_table_ref_aux(get_psrstate()->get_treeAdaptor(), "rule table_ref_aux");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:254:5: ( table_ref_aux ( join_clause )* ( pivot_clause | unpivot_clause )? -> ^( TABLE_REF[ToraType(T_TABLE_REF)] table_ref_aux ( join_clause )* ( pivot_clause )? ( unpivot_clause )? ) )
        // OracleDML.g:254:10: table_ref_aux ( join_clause )* ( pivot_clause | unpivot_clause )?
        {
            this->followPush(FOLLOW_table_ref_aux_in_table_ref2006);
            table_ref_aux118=table_ref_aux();

            this->followPop();
            if  (this->hasException())
            {
                goto ruletable_refEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                table_ref_aux118_last = table_ref_aux118.tree.get();
                stream_table_ref_aux.add(table_ref_aux118.tree);
            }

            // OracleDML.g:254:24: ( join_clause )*

            for (;;)
            {
                ANTLR_UINT32 alt42=2;
                switch ( this->LA(1) )
                {
                case REGULAR_ID:
                	{
                		{
                		   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                		    */
                		    ANTLR_UINT32 LA42_2 = this->LA(2);
                		    if ( ((((toUpper(LT(1)->getText()) == "NATURAL"))||((toUpper(LT(1)->getText()) == "JOIN"))||((toUpper(LT(1)->getText()) == "FULL"))||((toUpper(LT(1)->getText()) == "CROSS"))||((toUpper(LT(1)->getText()) == "PARTITION"))||((toUpper(LT(1)->getText()) == "LEFT"))||((toUpper(LT(1)->getText()) == "RIGHT"))||((toUpper(LT(1)->getText()) == "INNER")))))
                		    {
                		        alt42=1;
                		    }

                		}
                	}
                    break;

                }

                switch (alt42)
                {
            	case 1:
            	    // OracleDML.g:254:24: join_clause
            	    {
            	        this->followPush(FOLLOW_join_clause_in_table_ref2008);
            	        join_clause119=join_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletable_refEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            join_clause119_last = join_clause119.tree.get();
            	            stream_join_clause.add(join_clause119.tree);
            	        }

            	    }
            	    break;

            	default:
            	    goto loop42;	/* break out of the loop */
            	    break;
                }
            }
            loop42: ; /* Jump out to here if this rule does not match */


            // OracleDML.g:254:37: ( pivot_clause | unpivot_clause )?
            {
                ANTLR_UINT32 alt43=3;
                switch ( this->LA(1) )
                {
                    case PLSQL_NON_RESERVED_PIVOT:
                    	{
                    		alt43=1;
                    	}
                        break;
                    case PLSQL_NON_RESERVED_UNPIVOT:
                    	{
                    		alt43=2;
                    	}
                        break;
                }

                switch (alt43)
                {
            	case 1:
            	    // OracleDML.g:254:38: pivot_clause
            	    {
            	        this->followPush(FOLLOW_pivot_clause_in_table_ref2012);
            	        pivot_clause120=pivot_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletable_refEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            pivot_clause120_last = pivot_clause120.tree.get();
            	            stream_pivot_clause.add(pivot_clause120.tree);
            	        }

            	    }
            	    break;
            	case 2:
            	    // OracleDML.g:254:51: unpivot_clause
            	    {
            	        this->followPush(FOLLOW_unpivot_clause_in_table_ref2014);
            	        unpivot_clause121=unpivot_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletable_refEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            unpivot_clause121_last = unpivot_clause121.tree.get();
            	            stream_unpivot_clause.add(unpivot_clause121.tree);
            	        }

            	    }
            	    break;

                }
            }

            // AST REWRITE
            // elements: table_ref_aux, join_clause, pivot_clause, unpivot_clause
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 255:9: -> ^( TABLE_REF[ToraType(T_TABLE_REF)] table_ref_aux ( join_clause )* ( pivot_clause )? ( unpivot_clause )? )
            {
            	// OracleDML.g:255:12: ^( TABLE_REF[ToraType(T_TABLE_REF)] table_ref_aux ( join_clause )* ( pivot_clause )? ( unpivot_clause )? )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(TABLE_REF, ToraType(T_TABLE_REF)), root_1);
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_table_ref_aux.nextTree());
            	// OracleDML.g:255:61: ( join_clause )*
            	while ( stream_join_clause.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_join_clause.nextTree());
            	}
            	stream_join_clause.reset();

            	// OracleDML.g:255:74: ( pivot_clause )?
            	if ( stream_pivot_clause.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_pivot_clause.nextTree());
            	}
            	stream_pivot_clause.reset();

            	// OracleDML.g:255:88: ( unpivot_clause )?
            	if ( stream_unpivot_clause.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_unpivot_clause.nextTree());
            	}
            	stream_unpivot_clause.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruletable_refEx; /* Prevent compiler warnings */
    ruletable_refEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end table_ref */

/**
 * $ANTLR start table_ref_aux
 * OracleDML.g:270:1: table_ref_aux : ( ( LEFT_PAREN ( select_key | with_key ) )=> table_ref_aux_ver1 | ( LEFT_PAREN )=> table_ref_aux_ver2 | ( only_key LEFT_PAREN )=> table_ref_aux_ver3 | table_ref_aux_ver4 ) ;
 */
OracleDML::table_ref_aux_return
OracleDML::table_ref_aux()
{
    OracleDML::table_ref_aux_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML::table_ref_aux_ver1_return table_ref_aux_ver1122;
    ImplTraits::TreeTypePtr::pointer table_ref_aux_ver1122_last = NULL;
    OracleDML::table_ref_aux_ver2_return table_ref_aux_ver2123;
    ImplTraits::TreeTypePtr::pointer table_ref_aux_ver2123_last = NULL;
    OracleDML::table_ref_aux_ver3_return table_ref_aux_ver3124;
    ImplTraits::TreeTypePtr::pointer table_ref_aux_ver3124_last = NULL;
    OracleDML::table_ref_aux_ver4_return table_ref_aux_ver4125;
    ImplTraits::TreeTypePtr::pointer table_ref_aux_ver4125_last = NULL;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:271:5: ( ( ( LEFT_PAREN ( select_key | with_key ) )=> table_ref_aux_ver1 | ( LEFT_PAREN )=> table_ref_aux_ver2 | ( only_key LEFT_PAREN )=> table_ref_aux_ver3 | table_ref_aux_ver4 ) )
        // OracleDML.g:272:5: ( ( LEFT_PAREN ( select_key | with_key ) )=> table_ref_aux_ver1 | ( LEFT_PAREN )=> table_ref_aux_ver2 | ( only_key LEFT_PAREN )=> table_ref_aux_ver3 | table_ref_aux_ver4 )
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            // OracleDML.g:272:5: ( ( LEFT_PAREN ( select_key | with_key ) )=> table_ref_aux_ver1 | ( LEFT_PAREN )=> table_ref_aux_ver2 | ( only_key LEFT_PAREN )=> table_ref_aux_ver3 | table_ref_aux_ver4 )
            {
                ANTLR_UINT32 alt44=4;
                switch ( this->LA(1) )
                {
                case SQL92_RESERVED_TABLE:
                	{
                		{
                		    ANTLR_UINT32 LA44_1 = this->LA(2);
                		    if ( (this->msynpred( antlr3::ClassForwarder<synpred4_OracleDML>() )))
                		    {
                		        alt44=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt44=4;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return retval;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 44 );
                		        ex->set_state( 1 );


                		        goto ruletable_ref_auxEx;

                		    }
                		}
                	}
                    break;
                case SQL92_RESERVED_THE:
                	{
                		{
                		    ANTLR_UINT32 LA44_2 = this->LA(2);
                		    if ( (this->msynpred( antlr3::ClassForwarder<synpred4_OracleDML>() )))
                		    {
                		        alt44=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt44=4;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return retval;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 44 );
                		        ex->set_state( 2 );


                		        goto ruletable_ref_auxEx;

                		    }
                		}
                	}
                    break;
                case LEFT_PAREN:
                	{
                		{
                		    ANTLR_UINT32 LA44_3 = this->LA(2);
                		    if ( (this->msynpred( antlr3::ClassForwarder<synpred4_OracleDML>() )))
                		    {
                		        alt44=1;
                		    }
                		    else if ( (this->msynpred( antlr3::ClassForwarder<synpred5_OracleDML>() )))
                		    {
                		        alt44=2;
                		    }
                		    else if ( (true))
                		    {
                		        alt44=4;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return retval;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 44 );
                		        ex->set_state( 3 );


                		        goto ruletable_ref_auxEx;

                		    }
                		}
                	}
                    break;
                case INTRODUCER:
                	{
                		{
                		    ANTLR_UINT32 LA44_4 = this->LA(2);
                		    if ( (this->msynpred( antlr3::ClassForwarder<synpred4_OracleDML>() )))
                		    {
                		        alt44=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt44=4;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return retval;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 44 );
                		        ex->set_state( 4 );


                		        goto ruletable_ref_auxEx;

                		    }
                		}
                	}
                    break;
                case REGULAR_ID:
                	{
                		{
                		    ANTLR_UINT32 LA44_5 = this->LA(2);
                		    if ( (this->msynpred( antlr3::ClassForwarder<synpred4_OracleDML>() )))
                		    {
                		        alt44=1;
                		    }
                		    else if ( (( (this->msynpred( antlr3::ClassForwarder<synpred6_OracleDML>() )) && ((toUpper(LT(1)->getText()) == "ONLY")) )))
                		    {
                		        alt44=3;
                		    }
                		    else if ( (true))
                		    {
                		        alt44=4;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return retval;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 44 );
                		        ex->set_state( 5 );


                		        goto ruletable_ref_auxEx;

                		    }
                		}
                	}
                    break;
                case DELIMITED_ID:
                	{
                		{
                		    ANTLR_UINT32 LA44_6 = this->LA(2);
                		    if ( (this->msynpred( antlr3::ClassForwarder<synpred4_OracleDML>() )))
                		    {
                		        alt44=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt44=4;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return retval;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 44 );
                		        ex->set_state( 6 );


                		        goto ruletable_ref_auxEx;

                		    }
                		}
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return retval;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 44 );
                    ex->set_state( 0 );


                    goto ruletable_ref_auxEx;

                }

                switch (alt44)
                {
            	case 1:
            	    // OracleDML.g:272:10: ( LEFT_PAREN ( select_key | with_key ) )=> table_ref_aux_ver1
            	    {
            	        this->followPush(FOLLOW_table_ref_aux_ver1_in_table_ref_aux2092);
            	        table_ref_aux_ver1122=table_ref_aux_ver1();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletable_ref_auxEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, table_ref_aux_ver1122.tree);


            	    }
            	    break;
            	case 2:
            	    // OracleDML.g:273:10: ( LEFT_PAREN )=> table_ref_aux_ver2
            	    {
            	        this->followPush(FOLLOW_table_ref_aux_ver2_in_table_ref_aux2109);
            	        table_ref_aux_ver2123=table_ref_aux_ver2();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletable_ref_auxEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, table_ref_aux_ver2123.tree);


            	    }
            	    break;
            	case 3:
            	    // OracleDML.g:274:10: ( only_key LEFT_PAREN )=> table_ref_aux_ver3
            	    {
            	        this->followPush(FOLLOW_table_ref_aux_ver3_in_table_ref_aux2128);
            	        table_ref_aux_ver3124=table_ref_aux_ver3();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletable_ref_auxEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, table_ref_aux_ver3124.tree);


            	    }
            	    break;
            	case 4:
            	    // OracleDML.g:275:10: table_ref_aux_ver4
            	    {
            	        this->followPush(FOLLOW_table_ref_aux_ver4_in_table_ref_aux2139);
            	        table_ref_aux_ver4125=table_ref_aux_ver4();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletable_ref_auxEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, table_ref_aux_ver4125.tree);


            	    }
            	    break;

                }
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruletable_ref_auxEx; /* Prevent compiler warnings */
    ruletable_ref_auxEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end table_ref_aux */

/**
 * $ANTLR start table_ref_aux_ver1
 * OracleDML.g:279:1: table_ref_aux_ver1 : ( LEFT_PAREN ( select_key | with_key ) )=> dml_table_expression_clause ( pivot_clause | unpivot_clause )? ( flashback_query_clause )* ({...}? table_alias )? -> ^( TABLE_REF_ELEMENT dml_table_expression_clause ( pivot_clause )? ( unpivot_clause )? ( flashback_query_clause )* ( table_alias )? ) ;
 */
OracleDML::table_ref_aux_ver1_return
OracleDML::table_ref_aux_ver1()
{
    OracleDML::table_ref_aux_ver1_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML::dml_table_expression_clause_return dml_table_expression_clause126;
    ImplTraits::TreeTypePtr::pointer dml_table_expression_clause126_last = NULL;
    OracleDML::pivot_clause_return pivot_clause127;
    ImplTraits::TreeTypePtr::pointer pivot_clause127_last = NULL;
    OracleDML::unpivot_clause_return unpivot_clause128;
    ImplTraits::TreeTypePtr::pointer unpivot_clause128_last = NULL;
    OracleDML::flashback_query_clause_return flashback_query_clause129;
    ImplTraits::TreeTypePtr::pointer flashback_query_clause129_last = NULL;
    OracleDML_OracleDMLCommons::table_alias_return table_alias130;
    ImplTraits::TreeTypePtr::pointer table_alias130_last = NULL;
    RewriteRuleSubtreeStream<ImplTraits> stream_dml_table_expression_clause(get_psrstate()->get_treeAdaptor(), "rule dml_table_expression_clause");
    RewriteRuleSubtreeStream<ImplTraits> stream_unpivot_clause(get_psrstate()->get_treeAdaptor(), "rule unpivot_clause");
    RewriteRuleSubtreeStream<ImplTraits> stream_table_alias(get_psrstate()->get_treeAdaptor(), "rule table_alias");
    RewriteRuleSubtreeStream<ImplTraits> stream_pivot_clause(get_psrstate()->get_treeAdaptor(), "rule pivot_clause");
    RewriteRuleSubtreeStream<ImplTraits> stream_flashback_query_clause(get_psrstate()->get_treeAdaptor(), "rule flashback_query_clause");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:280:5: ( ( LEFT_PAREN ( select_key | with_key ) )=> dml_table_expression_clause ( pivot_clause | unpivot_clause )? ( flashback_query_clause )* ({...}? table_alias )? -> ^( TABLE_REF_ELEMENT dml_table_expression_clause ( pivot_clause )? ( unpivot_clause )? ( flashback_query_clause )* ( table_alias )? ) )
        // OracleDML.g:281:9: ( LEFT_PAREN ( select_key | with_key ) )=> dml_table_expression_clause ( pivot_clause | unpivot_clause )? ( flashback_query_clause )* ({...}? table_alias )?
        {
            this->followPush(FOLLOW_dml_table_expression_clause_in_table_ref_aux_ver12182);
            dml_table_expression_clause126=dml_table_expression_clause();

            this->followPop();
            if  (this->hasException())
            {
                goto ruletable_ref_aux_ver1Ex;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                dml_table_expression_clause126_last = dml_table_expression_clause126.tree.get();
                stream_dml_table_expression_clause.add(dml_table_expression_clause126.tree);
            }

            // OracleDML.g:282:9: ( pivot_clause | unpivot_clause )?
            {
                ANTLR_UINT32 alt45=3;
                switch ( this->LA(1) )
                {
                    case PLSQL_NON_RESERVED_PIVOT:
                    	{
                    		alt45=1;
                    	}
                        break;
                    case PLSQL_NON_RESERVED_UNPIVOT:
                    	{
                    		alt45=2;
                    	}
                        break;
                }

                switch (alt45)
                {
            	case 1:
            	    // OracleDML.g:282:10: pivot_clause
            	    {
            	        this->followPush(FOLLOW_pivot_clause_in_table_ref_aux_ver12193);
            	        pivot_clause127=pivot_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletable_ref_aux_ver1Ex;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            pivot_clause127_last = pivot_clause127.tree.get();
            	            stream_pivot_clause.add(pivot_clause127.tree);
            	        }

            	    }
            	    break;
            	case 2:
            	    // OracleDML.g:282:23: unpivot_clause
            	    {
            	        this->followPush(FOLLOW_unpivot_clause_in_table_ref_aux_ver12195);
            	        unpivot_clause128=unpivot_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletable_ref_aux_ver1Ex;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            unpivot_clause128_last = unpivot_clause128.tree.get();
            	            stream_unpivot_clause.add(unpivot_clause128.tree);
            	        }

            	    }
            	    break;

                }
            }

            // OracleDML.g:282:40: ( flashback_query_clause )*

            for (;;)
            {
                ANTLR_UINT32 alt46=2;
                switch ( this->LA(1) )
                {
                case REGULAR_ID:
                	{
                		{
                		   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                		    */
                		    ANTLR_UINT32 LA46_2 = this->LA(2);
                		    if ( ((toUpper(LT(1)->getText()) == "VERSIONS")))
                		    {
                		        alt46=1;
                		    }

                		}
                	}
                    break;
                case SQL92_RESERVED_AS:
                	{
                		alt46=1;
                	}
                    break;

                }

                switch (alt46)
                {
            	case 1:
            	    // OracleDML.g:282:40: flashback_query_clause
            	    {
            	        this->followPush(FOLLOW_flashback_query_clause_in_table_ref_aux_ver12199);
            	        flashback_query_clause129=flashback_query_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletable_ref_aux_ver1Ex;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            flashback_query_clause129_last = flashback_query_clause129.tree.get();
            	            stream_flashback_query_clause.add(flashback_query_clause129.tree);
            	        }

            	    }
            	    break;

            	default:
            	    goto loop46;	/* break out of the loop */
            	    break;
                }
            }
            loop46: ; /* Jump out to here if this rule does not match */


            // OracleDML.g:282:64: ({...}? table_alias )?
            {
                ANTLR_UINT32 alt47=2;
                switch ( this->LA(1) )
                {
                    case INTRODUCER:
                    	{
                    		{
                    		    ANTLR_UINT32 LA47_1 = this->LA(2);
                    		    if ( ((isTableAlias(LT(1), LT(2)))))
                    		    {
                    		        alt47=1;
                    		    }
                    		}
                    	}
                        break;
                    case REGULAR_ID:
                    	{
                    		{
                    		    ANTLR_UINT32 LA47_2 = this->LA(2);
                    		    if ( ((isTableAlias(LT(1), LT(2)))))
                    		    {
                    		        alt47=1;
                    		    }
                    		}
                    	}
                        break;
                    case DELIMITED_ID:
                    	{
                    		{
                    		    ANTLR_UINT32 LA47_3 = this->LA(2);
                    		    if ( ((isTableAlias(LT(1), LT(2)))))
                    		    {
                    		        alt47=1;
                    		    }
                    		}
                    	}
                        break;
                    case CHAR_STRING:
                    case CHAR_STRING_PERL:
                    case NATIONAL_CHAR_STRING_LIT:
                    	{
                    		{
                    		    ANTLR_UINT32 LA47_4 = this->LA(2);
                    		    if ( ((isTableAlias(LT(1), LT(2)))))
                    		    {
                    		        alt47=1;
                    		    }
                    		}
                    	}
                        break;
                }

                switch (alt47)
                {
            	case 1:
            	    // OracleDML.g:282:65: {...}? table_alias
            	    {
            	        if ( !((isTableAlias(LT(1), LT(2)))) )
            	        {
            	            if (this->get_backtracking()>0)
            	            {
            	                this->set_failedflag( true );
            	                return retval;
            	            }

            	            	ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "isTableAlias(LT(1), LT(2))" );
            	                ex->set_ruleName( "table_ref_aux_ver1" );


            	        }

            	        this->followPush(FOLLOW_table_alias_in_table_ref_aux_ver12205);
            	        table_alias130=table_alias();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletable_ref_aux_ver1Ex;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            table_alias130_last = table_alias130.tree.get();
            	            stream_table_alias.add(table_alias130.tree);
            	        }

            	    }
            	    break;

                }
            }

            // AST REWRITE
            // elements: pivot_clause, flashback_query_clause, unpivot_clause, table_alias, dml_table_expression_clause
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 283:9: -> ^( TABLE_REF_ELEMENT dml_table_expression_clause ( pivot_clause )? ( unpivot_clause )? ( flashback_query_clause )* ( table_alias )? )
            {
            	// OracleDML.g:283:12: ^( TABLE_REF_ELEMENT dml_table_expression_clause ( pivot_clause )? ( unpivot_clause )? ( flashback_query_clause )* ( table_alias )? )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(TABLE_REF_ELEMENT, "TABLE_REF_ELEMENT"), root_1);
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_dml_table_expression_clause.nextTree());
            	// OracleDML.g:283:60: ( pivot_clause )?
            	if ( stream_pivot_clause.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_pivot_clause.nextTree());
            	}
            	stream_pivot_clause.reset();

            	// OracleDML.g:283:74: ( unpivot_clause )?
            	if ( stream_unpivot_clause.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_unpivot_clause.nextTree());
            	}
            	stream_unpivot_clause.reset();

            	// OracleDML.g:283:90: ( flashback_query_clause )*
            	while ( stream_flashback_query_clause.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_flashback_query_clause.nextTree());
            	}
            	stream_flashback_query_clause.reset();

            	// OracleDML.g:283:114: ( table_alias )?
            	if ( stream_table_alias.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_table_alias.nextTree());
            	}
            	stream_table_alias.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruletable_ref_aux_ver1Ex; /* Prevent compiler warnings */
    ruletable_ref_aux_ver1Ex: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end table_ref_aux_ver1 */

/**
 * $ANTLR start table_ref_aux_ver2
 * OracleDML.g:286:1: table_ref_aux_ver2 : ( LEFT_PAREN )=> LEFT_PAREN table_ref ( subquery_operation_part )* RIGHT_PAREN ( pivot_clause | unpivot_clause )? ( flashback_query_clause )* ({...}? table_alias )? -> ^( TABLE_REF_ELEMENT ^( TABLE_REF_ELEMENT[$LEFT_PAREN] table_ref ( subquery_operation_part )* RIGHT_PAREN ) ( pivot_clause )? ( unpivot_clause )? ( flashback_query_clause )* ( table_alias )? ) ;
 */
OracleDML::table_ref_aux_ver2_return
OracleDML::table_ref_aux_ver2()
{
    OracleDML::table_ref_aux_ver2_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* LEFT_PAREN131 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN134 = NULL;
    OracleDML::table_ref_return table_ref132;
    ImplTraits::TreeTypePtr::pointer table_ref132_last = NULL;
    OracleDML::subquery_operation_part_return subquery_operation_part133;
    ImplTraits::TreeTypePtr::pointer subquery_operation_part133_last = NULL;
    OracleDML::pivot_clause_return pivot_clause135;
    ImplTraits::TreeTypePtr::pointer pivot_clause135_last = NULL;
    OracleDML::unpivot_clause_return unpivot_clause136;
    ImplTraits::TreeTypePtr::pointer unpivot_clause136_last = NULL;
    OracleDML::flashback_query_clause_return flashback_query_clause137;
    ImplTraits::TreeTypePtr::pointer flashback_query_clause137_last = NULL;
    OracleDML_OracleDMLCommons::table_alias_return table_alias138;
    ImplTraits::TreeTypePtr::pointer table_alias138_last = NULL;
    ImplTraits::TreeTypePtr LEFT_PAREN131_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN134_tree;
    RewriteRuleTokenStream<ImplTraits> stream_LEFT_PAREN(get_psrstate()->get_treeAdaptor(), "token LEFT_PAREN");
    RewriteRuleTokenStream<ImplTraits> stream_RIGHT_PAREN(get_psrstate()->get_treeAdaptor(), "token RIGHT_PAREN");
    RewriteRuleSubtreeStream<ImplTraits> stream_subquery_operation_part(get_psrstate()->get_treeAdaptor(), "rule subquery_operation_part");
    RewriteRuleSubtreeStream<ImplTraits> stream_unpivot_clause(get_psrstate()->get_treeAdaptor(), "rule unpivot_clause");
    RewriteRuleSubtreeStream<ImplTraits> stream_table_ref(get_psrstate()->get_treeAdaptor(), "rule table_ref");
    RewriteRuleSubtreeStream<ImplTraits> stream_table_alias(get_psrstate()->get_treeAdaptor(), "rule table_alias");
    RewriteRuleSubtreeStream<ImplTraits> stream_pivot_clause(get_psrstate()->get_treeAdaptor(), "rule pivot_clause");
    RewriteRuleSubtreeStream<ImplTraits> stream_flashback_query_clause(get_psrstate()->get_treeAdaptor(), "rule flashback_query_clause");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:287:5: ( ( LEFT_PAREN )=> LEFT_PAREN table_ref ( subquery_operation_part )* RIGHT_PAREN ( pivot_clause | unpivot_clause )? ( flashback_query_clause )* ({...}? table_alias )? -> ^( TABLE_REF_ELEMENT ^( TABLE_REF_ELEMENT[$LEFT_PAREN] table_ref ( subquery_operation_part )* RIGHT_PAREN ) ( pivot_clause )? ( unpivot_clause )? ( flashback_query_clause )* ( table_alias )? ) )
        // OracleDML.g:288:9: ( LEFT_PAREN )=> LEFT_PAREN table_ref ( subquery_operation_part )* RIGHT_PAREN ( pivot_clause | unpivot_clause )? ( flashback_query_clause )* ({...}? table_alias )?
        {
            LEFT_PAREN131 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_table_ref_aux_ver22266);
            if  (this->hasException())
            {
                goto ruletable_ref_aux_ver2Ex;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_LEFT_PAREN.add(LEFT_PAREN131);


            this->followPush(FOLLOW_table_ref_in_table_ref_aux_ver22268);
            table_ref132=table_ref();

            this->followPop();
            if  (this->hasException())
            {
                goto ruletable_ref_aux_ver2Ex;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                table_ref132_last = table_ref132.tree.get();
                stream_table_ref.add(table_ref132.tree);
            }

            // OracleDML.g:288:46: ( subquery_operation_part )*

            for (;;)
            {
                ANTLR_UINT32 alt48=2;
                switch ( this->LA(1) )
                {
                case PLSQL_RESERVED_MINUS:
                case SQL92_RESERVED_INTERSECT:
                case SQL92_RESERVED_UNION:
                	{
                		alt48=1;
                	}
                    break;

                }

                switch (alt48)
                {
            	case 1:
            	    // OracleDML.g:288:46: subquery_operation_part
            	    {
            	        this->followPush(FOLLOW_subquery_operation_part_in_table_ref_aux_ver22270);
            	        subquery_operation_part133=subquery_operation_part();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletable_ref_aux_ver2Ex;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            subquery_operation_part133_last = subquery_operation_part133.tree.get();
            	            stream_subquery_operation_part.add(subquery_operation_part133.tree);
            	        }

            	    }
            	    break;

            	default:
            	    goto loop48;	/* break out of the loop */
            	    break;
                }
            }
            loop48: ; /* Jump out to here if this rule does not match */


            RIGHT_PAREN134 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_table_ref_aux_ver22273);
            if  (this->hasException())
            {
                goto ruletable_ref_aux_ver2Ex;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN134);


            // OracleDML.g:289:9: ( pivot_clause | unpivot_clause )?
            {
                ANTLR_UINT32 alt49=3;
                switch ( this->LA(1) )
                {
                    case PLSQL_NON_RESERVED_PIVOT:
                    	{
                    		alt49=1;
                    	}
                        break;
                    case PLSQL_NON_RESERVED_UNPIVOT:
                    	{
                    		alt49=2;
                    	}
                        break;
                }

                switch (alt49)
                {
            	case 1:
            	    // OracleDML.g:289:10: pivot_clause
            	    {
            	        this->followPush(FOLLOW_pivot_clause_in_table_ref_aux_ver22284);
            	        pivot_clause135=pivot_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletable_ref_aux_ver2Ex;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            pivot_clause135_last = pivot_clause135.tree.get();
            	            stream_pivot_clause.add(pivot_clause135.tree);
            	        }

            	    }
            	    break;
            	case 2:
            	    // OracleDML.g:289:23: unpivot_clause
            	    {
            	        this->followPush(FOLLOW_unpivot_clause_in_table_ref_aux_ver22286);
            	        unpivot_clause136=unpivot_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletable_ref_aux_ver2Ex;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            unpivot_clause136_last = unpivot_clause136.tree.get();
            	            stream_unpivot_clause.add(unpivot_clause136.tree);
            	        }

            	    }
            	    break;

                }
            }

            // OracleDML.g:289:40: ( flashback_query_clause )*

            for (;;)
            {
                ANTLR_UINT32 alt50=2;
                switch ( this->LA(1) )
                {
                case REGULAR_ID:
                	{
                		{
                		   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                		    */
                		    ANTLR_UINT32 LA50_2 = this->LA(2);
                		    if ( ((toUpper(LT(1)->getText()) == "VERSIONS")))
                		    {
                		        alt50=1;
                		    }

                		}
                	}
                    break;
                case SQL92_RESERVED_AS:
                	{
                		alt50=1;
                	}
                    break;

                }

                switch (alt50)
                {
            	case 1:
            	    // OracleDML.g:289:40: flashback_query_clause
            	    {
            	        this->followPush(FOLLOW_flashback_query_clause_in_table_ref_aux_ver22290);
            	        flashback_query_clause137=flashback_query_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletable_ref_aux_ver2Ex;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            flashback_query_clause137_last = flashback_query_clause137.tree.get();
            	            stream_flashback_query_clause.add(flashback_query_clause137.tree);
            	        }

            	    }
            	    break;

            	default:
            	    goto loop50;	/* break out of the loop */
            	    break;
                }
            }
            loop50: ; /* Jump out to here if this rule does not match */


            // OracleDML.g:289:64: ({...}? table_alias )?
            {
                ANTLR_UINT32 alt51=2;
                switch ( this->LA(1) )
                {
                    case INTRODUCER:
                    	{
                    		{
                    		    ANTLR_UINT32 LA51_1 = this->LA(2);
                    		    if ( ((isTableAlias(LT(1), LT(2)))))
                    		    {
                    		        alt51=1;
                    		    }
                    		}
                    	}
                        break;
                    case REGULAR_ID:
                    	{
                    		{
                    		    ANTLR_UINT32 LA51_2 = this->LA(2);
                    		    if ( ((isTableAlias(LT(1), LT(2)))))
                    		    {
                    		        alt51=1;
                    		    }
                    		}
                    	}
                        break;
                    case DELIMITED_ID:
                    	{
                    		{
                    		    ANTLR_UINT32 LA51_3 = this->LA(2);
                    		    if ( ((isTableAlias(LT(1), LT(2)))))
                    		    {
                    		        alt51=1;
                    		    }
                    		}
                    	}
                        break;
                    case CHAR_STRING:
                    case CHAR_STRING_PERL:
                    case NATIONAL_CHAR_STRING_LIT:
                    	{
                    		{
                    		    ANTLR_UINT32 LA51_4 = this->LA(2);
                    		    if ( ((isTableAlias(LT(1), LT(2)))))
                    		    {
                    		        alt51=1;
                    		    }
                    		}
                    	}
                        break;
                }

                switch (alt51)
                {
            	case 1:
            	    // OracleDML.g:289:65: {...}? table_alias
            	    {
            	        if ( !((isTableAlias(LT(1), LT(2)))) )
            	        {
            	            if (this->get_backtracking()>0)
            	            {
            	                this->set_failedflag( true );
            	                return retval;
            	            }

            	            	ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "isTableAlias(LT(1), LT(2))" );
            	                ex->set_ruleName( "table_ref_aux_ver2" );


            	        }

            	        this->followPush(FOLLOW_table_alias_in_table_ref_aux_ver22296);
            	        table_alias138=table_alias();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletable_ref_aux_ver2Ex;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            table_alias138_last = table_alias138.tree.get();
            	            stream_table_alias.add(table_alias138.tree);
            	        }

            	    }
            	    break;

                }
            }

            // AST REWRITE
            // elements: flashback_query_clause, RIGHT_PAREN, unpivot_clause, subquery_operation_part, table_ref, table_alias, pivot_clause
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 290:9: -> ^( TABLE_REF_ELEMENT ^( TABLE_REF_ELEMENT[$LEFT_PAREN] table_ref ( subquery_operation_part )* RIGHT_PAREN ) ( pivot_clause )? ( unpivot_clause )? ( flashback_query_clause )* ( table_alias )? )
            {
            	// OracleDML.g:290:12: ^( TABLE_REF_ELEMENT ^( TABLE_REF_ELEMENT[$LEFT_PAREN] table_ref ( subquery_operation_part )* RIGHT_PAREN ) ( pivot_clause )? ( unpivot_clause )? ( flashback_query_clause )* ( table_alias )? )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(TABLE_REF_ELEMENT, "TABLE_REF_ELEMENT"), root_1);
            	// OracleDML.g:290:32: ^( TABLE_REF_ELEMENT[$LEFT_PAREN] table_ref ( subquery_operation_part )* RIGHT_PAREN )
            	{
            	ImplTraits::TreeTypePtr root_2 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_2 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(TABLE_REF_ELEMENT, LEFT_PAREN131), root_2);
            	get_psrstate()->get_treeAdaptor()->addChild(root_2, stream_table_ref.nextTree());
            	// OracleDML.g:290:75: ( subquery_operation_part )*
            	while ( stream_subquery_operation_part.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_2, stream_subquery_operation_part.nextTree());
            	}
            	stream_subquery_operation_part.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_2, stream_RIGHT_PAREN.nextNode());
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, root_2);
            	}
            	// OracleDML.g:290:113: ( pivot_clause )?
            	if ( stream_pivot_clause.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_pivot_clause.nextTree());
            	}
            	stream_pivot_clause.reset();

            	// OracleDML.g:290:127: ( unpivot_clause )?
            	if ( stream_unpivot_clause.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_unpivot_clause.nextTree());
            	}
            	stream_unpivot_clause.reset();

            	// OracleDML.g:290:143: ( flashback_query_clause )*
            	while ( stream_flashback_query_clause.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_flashback_query_clause.nextTree());
            	}
            	stream_flashback_query_clause.reset();

            	// OracleDML.g:290:167: ( table_alias )?
            	if ( stream_table_alias.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_table_alias.nextTree());
            	}
            	stream_table_alias.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruletable_ref_aux_ver2Ex; /* Prevent compiler warnings */
    ruletable_ref_aux_ver2Ex: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end table_ref_aux_ver2 */

/**
 * $ANTLR start table_ref_aux_ver3
 * OracleDML.g:293:1: table_ref_aux_ver3 : ( only_key LEFT_PAREN )=> only_key LEFT_PAREN dml_table_expression_clause RIGHT_PAREN ( flashback_query_clause )* ({...}? table_alias )? -> ^( TABLE_REF_ELEMENT[$only_key.start] ^( TABLE_REF_ELEMENT[$LEFT_PAREN] dml_table_expression_clause RIGHT_PAREN ) ( flashback_query_clause )* ( table_alias )? ) ;
 */
OracleDML::table_ref_aux_ver3_return
OracleDML::table_ref_aux_ver3()
{
    OracleDML::table_ref_aux_ver3_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* LEFT_PAREN140 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN142 = NULL;
    OracleDML_OracleDMLKeys::only_key_return only_key139;
    ImplTraits::TreeTypePtr::pointer only_key139_last = NULL;
    OracleDML::dml_table_expression_clause_return dml_table_expression_clause141;
    ImplTraits::TreeTypePtr::pointer dml_table_expression_clause141_last = NULL;
    OracleDML::flashback_query_clause_return flashback_query_clause143;
    ImplTraits::TreeTypePtr::pointer flashback_query_clause143_last = NULL;
    OracleDML_OracleDMLCommons::table_alias_return table_alias144;
    ImplTraits::TreeTypePtr::pointer table_alias144_last = NULL;
    ImplTraits::TreeTypePtr LEFT_PAREN140_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN142_tree;
    RewriteRuleTokenStream<ImplTraits> stream_LEFT_PAREN(get_psrstate()->get_treeAdaptor(), "token LEFT_PAREN");
    RewriteRuleTokenStream<ImplTraits> stream_RIGHT_PAREN(get_psrstate()->get_treeAdaptor(), "token RIGHT_PAREN");
    RewriteRuleSubtreeStream<ImplTraits> stream_dml_table_expression_clause(get_psrstate()->get_treeAdaptor(), "rule dml_table_expression_clause");
    RewriteRuleSubtreeStream<ImplTraits> stream_table_alias(get_psrstate()->get_treeAdaptor(), "rule table_alias");
    RewriteRuleSubtreeStream<ImplTraits> stream_only_key(get_psrstate()->get_treeAdaptor(), "rule only_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_flashback_query_clause(get_psrstate()->get_treeAdaptor(), "rule flashback_query_clause");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:294:5: ( ( only_key LEFT_PAREN )=> only_key LEFT_PAREN dml_table_expression_clause RIGHT_PAREN ( flashback_query_clause )* ({...}? table_alias )? -> ^( TABLE_REF_ELEMENT[$only_key.start] ^( TABLE_REF_ELEMENT[$LEFT_PAREN] dml_table_expression_clause RIGHT_PAREN ) ( flashback_query_clause )* ( table_alias )? ) )
        // OracleDML.g:295:9: ( only_key LEFT_PAREN )=> only_key LEFT_PAREN dml_table_expression_clause RIGHT_PAREN ( flashback_query_clause )* ({...}? table_alias )?
        {
            this->followPush(FOLLOW_only_key_in_table_ref_aux_ver32369);
            only_key139=only_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruletable_ref_aux_ver3Ex;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                only_key139_last = only_key139.tree.get();
                stream_only_key.add(only_key139.tree);
            }

            LEFT_PAREN140 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_table_ref_aux_ver32371);
            if  (this->hasException())
            {
                goto ruletable_ref_aux_ver3Ex;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_LEFT_PAREN.add(LEFT_PAREN140);


            this->followPush(FOLLOW_dml_table_expression_clause_in_table_ref_aux_ver32373);
            dml_table_expression_clause141=dml_table_expression_clause();

            this->followPop();
            if  (this->hasException())
            {
                goto ruletable_ref_aux_ver3Ex;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                dml_table_expression_clause141_last = dml_table_expression_clause141.tree.get();
                stream_dml_table_expression_clause.add(dml_table_expression_clause141.tree);
            }

            RIGHT_PAREN142 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_table_ref_aux_ver32375);
            if  (this->hasException())
            {
                goto ruletable_ref_aux_ver3Ex;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN142);


            // OracleDML.g:296:9: ( flashback_query_clause )*

            for (;;)
            {
                ANTLR_UINT32 alt52=2;
                switch ( this->LA(1) )
                {
                case REGULAR_ID:
                	{
                		{
                		   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                		    */
                		    ANTLR_UINT32 LA52_2 = this->LA(2);
                		    if ( ((toUpper(LT(1)->getText()) == "VERSIONS")))
                		    {
                		        alt52=1;
                		    }

                		}
                	}
                    break;
                case SQL92_RESERVED_AS:
                	{
                		alt52=1;
                	}
                    break;

                }

                switch (alt52)
                {
            	case 1:
            	    // OracleDML.g:296:9: flashback_query_clause
            	    {
            	        this->followPush(FOLLOW_flashback_query_clause_in_table_ref_aux_ver32385);
            	        flashback_query_clause143=flashback_query_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletable_ref_aux_ver3Ex;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            flashback_query_clause143_last = flashback_query_clause143.tree.get();
            	            stream_flashback_query_clause.add(flashback_query_clause143.tree);
            	        }

            	    }
            	    break;

            	default:
            	    goto loop52;	/* break out of the loop */
            	    break;
                }
            }
            loop52: ; /* Jump out to here if this rule does not match */


            // OracleDML.g:296:33: ({...}? table_alias )?
            {
                ANTLR_UINT32 alt53=2;
                switch ( this->LA(1) )
                {
                    case INTRODUCER:
                    	{
                    		{
                    		    ANTLR_UINT32 LA53_1 = this->LA(2);
                    		    if ( ((isTableAlias(LT(1), LT(2)))))
                    		    {
                    		        alt53=1;
                    		    }
                    		}
                    	}
                        break;
                    case REGULAR_ID:
                    	{
                    		{
                    		    ANTLR_UINT32 LA53_2 = this->LA(2);
                    		    if ( ((isTableAlias(LT(1), LT(2)))))
                    		    {
                    		        alt53=1;
                    		    }
                    		}
                    	}
                        break;
                    case DELIMITED_ID:
                    	{
                    		{
                    		    ANTLR_UINT32 LA53_3 = this->LA(2);
                    		    if ( ((isTableAlias(LT(1), LT(2)))))
                    		    {
                    		        alt53=1;
                    		    }
                    		}
                    	}
                        break;
                    case CHAR_STRING:
                    case CHAR_STRING_PERL:
                    case NATIONAL_CHAR_STRING_LIT:
                    	{
                    		{
                    		    ANTLR_UINT32 LA53_4 = this->LA(2);
                    		    if ( ((isTableAlias(LT(1), LT(2)))))
                    		    {
                    		        alt53=1;
                    		    }
                    		}
                    	}
                        break;
                }

                switch (alt53)
                {
            	case 1:
            	    // OracleDML.g:296:34: {...}? table_alias
            	    {
            	        if ( !((isTableAlias(LT(1), LT(2)))) )
            	        {
            	            if (this->get_backtracking()>0)
            	            {
            	                this->set_failedflag( true );
            	                return retval;
            	            }

            	            	ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "isTableAlias(LT(1), LT(2))" );
            	                ex->set_ruleName( "table_ref_aux_ver3" );


            	        }

            	        this->followPush(FOLLOW_table_alias_in_table_ref_aux_ver32391);
            	        table_alias144=table_alias();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletable_ref_aux_ver3Ex;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            table_alias144_last = table_alias144.tree.get();
            	            stream_table_alias.add(table_alias144.tree);
            	        }

            	    }
            	    break;

                }
            }

            // AST REWRITE
            // elements: RIGHT_PAREN, table_alias, flashback_query_clause, dml_table_expression_clause
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 297:9: -> ^( TABLE_REF_ELEMENT[$only_key.start] ^( TABLE_REF_ELEMENT[$LEFT_PAREN] dml_table_expression_clause RIGHT_PAREN ) ( flashback_query_clause )* ( table_alias )? )
            {
            	// OracleDML.g:297:12: ^( TABLE_REF_ELEMENT[$only_key.start] ^( TABLE_REF_ELEMENT[$LEFT_PAREN] dml_table_expression_clause RIGHT_PAREN ) ( flashback_query_clause )* ( table_alias )? )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(TABLE_REF_ELEMENT, (only_key139.start)), root_1);
            	// OracleDML.g:297:49: ^( TABLE_REF_ELEMENT[$LEFT_PAREN] dml_table_expression_clause RIGHT_PAREN )
            	{
            	ImplTraits::TreeTypePtr root_2 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_2 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(TABLE_REF_ELEMENT, LEFT_PAREN140), root_2);
            	get_psrstate()->get_treeAdaptor()->addChild(root_2, stream_dml_table_expression_clause.nextTree());
            	get_psrstate()->get_treeAdaptor()->addChild(root_2, stream_RIGHT_PAREN.nextNode());
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, root_2);
            	}
            	// OracleDML.g:297:123: ( flashback_query_clause )*
            	while ( stream_flashback_query_clause.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_flashback_query_clause.nextTree());
            	}
            	stream_flashback_query_clause.reset();

            	// OracleDML.g:297:147: ( table_alias )?
            	if ( stream_table_alias.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_table_alias.nextTree());
            	}
            	stream_table_alias.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruletable_ref_aux_ver3Ex; /* Prevent compiler warnings */
    ruletable_ref_aux_ver3Ex: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end table_ref_aux_ver3 */

/**
 * $ANTLR start table_ref_aux_ver4
 * OracleDML.g:300:1: table_ref_aux_ver4 : dml_table_expression_clause ( pivot_clause | unpivot_clause )? ( flashback_query_clause )* ({...}? table_alias )? -> ^( TABLE_REF_ELEMENT dml_table_expression_clause ( pivot_clause )? ( unpivot_clause )? ( flashback_query_clause )* ( table_alias )? ) ;
 */
OracleDML::table_ref_aux_ver4_return
OracleDML::table_ref_aux_ver4()
{
    OracleDML::table_ref_aux_ver4_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML::dml_table_expression_clause_return dml_table_expression_clause145;
    ImplTraits::TreeTypePtr::pointer dml_table_expression_clause145_last = NULL;
    OracleDML::pivot_clause_return pivot_clause146;
    ImplTraits::TreeTypePtr::pointer pivot_clause146_last = NULL;
    OracleDML::unpivot_clause_return unpivot_clause147;
    ImplTraits::TreeTypePtr::pointer unpivot_clause147_last = NULL;
    OracleDML::flashback_query_clause_return flashback_query_clause148;
    ImplTraits::TreeTypePtr::pointer flashback_query_clause148_last = NULL;
    OracleDML_OracleDMLCommons::table_alias_return table_alias149;
    ImplTraits::TreeTypePtr::pointer table_alias149_last = NULL;
    RewriteRuleSubtreeStream<ImplTraits> stream_dml_table_expression_clause(get_psrstate()->get_treeAdaptor(), "rule dml_table_expression_clause");
    RewriteRuleSubtreeStream<ImplTraits> stream_unpivot_clause(get_psrstate()->get_treeAdaptor(), "rule unpivot_clause");
    RewriteRuleSubtreeStream<ImplTraits> stream_table_alias(get_psrstate()->get_treeAdaptor(), "rule table_alias");
    RewriteRuleSubtreeStream<ImplTraits> stream_pivot_clause(get_psrstate()->get_treeAdaptor(), "rule pivot_clause");
    RewriteRuleSubtreeStream<ImplTraits> stream_flashback_query_clause(get_psrstate()->get_treeAdaptor(), "rule flashback_query_clause");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:301:5: ( dml_table_expression_clause ( pivot_clause | unpivot_clause )? ( flashback_query_clause )* ({...}? table_alias )? -> ^( TABLE_REF_ELEMENT dml_table_expression_clause ( pivot_clause )? ( unpivot_clause )? ( flashback_query_clause )* ( table_alias )? ) )
        // OracleDML.g:302:9: dml_table_expression_clause ( pivot_clause | unpivot_clause )? ( flashback_query_clause )* ({...}? table_alias )?
        {
            this->followPush(FOLLOW_dml_table_expression_clause_in_table_ref_aux_ver42448);
            dml_table_expression_clause145=dml_table_expression_clause();

            this->followPop();
            if  (this->hasException())
            {
                goto ruletable_ref_aux_ver4Ex;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                dml_table_expression_clause145_last = dml_table_expression_clause145.tree.get();
                stream_dml_table_expression_clause.add(dml_table_expression_clause145.tree);
            }

            // OracleDML.g:302:37: ( pivot_clause | unpivot_clause )?
            {
                ANTLR_UINT32 alt54=3;
                switch ( this->LA(1) )
                {
                    case PLSQL_NON_RESERVED_PIVOT:
                    	{
                    		alt54=1;
                    	}
                        break;
                    case PLSQL_NON_RESERVED_UNPIVOT:
                    	{
                    		alt54=2;
                    	}
                        break;
                }

                switch (alt54)
                {
            	case 1:
            	    // OracleDML.g:302:38: pivot_clause
            	    {
            	        this->followPush(FOLLOW_pivot_clause_in_table_ref_aux_ver42451);
            	        pivot_clause146=pivot_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletable_ref_aux_ver4Ex;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            pivot_clause146_last = pivot_clause146.tree.get();
            	            stream_pivot_clause.add(pivot_clause146.tree);
            	        }

            	    }
            	    break;
            	case 2:
            	    // OracleDML.g:302:51: unpivot_clause
            	    {
            	        this->followPush(FOLLOW_unpivot_clause_in_table_ref_aux_ver42453);
            	        unpivot_clause147=unpivot_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletable_ref_aux_ver4Ex;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            unpivot_clause147_last = unpivot_clause147.tree.get();
            	            stream_unpivot_clause.add(unpivot_clause147.tree);
            	        }

            	    }
            	    break;

                }
            }

            // OracleDML.g:303:9: ( flashback_query_clause )*

            for (;;)
            {
                ANTLR_UINT32 alt55=2;
                switch ( this->LA(1) )
                {
                case REGULAR_ID:
                	{
                		{
                		   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                		    */
                		    ANTLR_UINT32 LA55_2 = this->LA(2);
                		    if ( ((toUpper(LT(1)->getText()) == "VERSIONS")))
                		    {
                		        alt55=1;
                		    }

                		}
                	}
                    break;
                case SQL92_RESERVED_AS:
                	{
                		alt55=1;
                	}
                    break;

                }

                switch (alt55)
                {
            	case 1:
            	    // OracleDML.g:303:9: flashback_query_clause
            	    {
            	        this->followPush(FOLLOW_flashback_query_clause_in_table_ref_aux_ver42465);
            	        flashback_query_clause148=flashback_query_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletable_ref_aux_ver4Ex;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            flashback_query_clause148_last = flashback_query_clause148.tree.get();
            	            stream_flashback_query_clause.add(flashback_query_clause148.tree);
            	        }

            	    }
            	    break;

            	default:
            	    goto loop55;	/* break out of the loop */
            	    break;
                }
            }
            loop55: ; /* Jump out to here if this rule does not match */


            // OracleDML.g:303:33: ({...}? table_alias )?
            {
                ANTLR_UINT32 alt56=2;
                switch ( this->LA(1) )
                {
                    case INTRODUCER:
                    	{
                    		{
                    		    ANTLR_UINT32 LA56_1 = this->LA(2);
                    		    if ( ((isTableAlias(LT(1), LT(2)))))
                    		    {
                    		        alt56=1;
                    		    }
                    		}
                    	}
                        break;
                    case REGULAR_ID:
                    	{
                    		{
                    		    ANTLR_UINT32 LA56_2 = this->LA(2);
                    		    if ( ((isTableAlias(LT(1), LT(2)))))
                    		    {
                    		        alt56=1;
                    		    }
                    		}
                    	}
                        break;
                    case DELIMITED_ID:
                    	{
                    		{
                    		    ANTLR_UINT32 LA56_3 = this->LA(2);
                    		    if ( ((isTableAlias(LT(1), LT(2)))))
                    		    {
                    		        alt56=1;
                    		    }
                    		}
                    	}
                        break;
                    case CHAR_STRING:
                    case CHAR_STRING_PERL:
                    case NATIONAL_CHAR_STRING_LIT:
                    	{
                    		{
                    		    ANTLR_UINT32 LA56_4 = this->LA(2);
                    		    if ( ((isTableAlias(LT(1), LT(2)))))
                    		    {
                    		        alt56=1;
                    		    }
                    		}
                    	}
                        break;
                }

                switch (alt56)
                {
            	case 1:
            	    // OracleDML.g:303:34: {...}? table_alias
            	    {
            	        if ( !((isTableAlias(LT(1), LT(2)))) )
            	        {
            	            if (this->get_backtracking()>0)
            	            {
            	                this->set_failedflag( true );
            	                return retval;
            	            }

            	            	ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "isTableAlias(LT(1), LT(2))" );
            	                ex->set_ruleName( "table_ref_aux_ver4" );


            	        }

            	        this->followPush(FOLLOW_table_alias_in_table_ref_aux_ver42471);
            	        table_alias149=table_alias();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletable_ref_aux_ver4Ex;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            table_alias149_last = table_alias149.tree.get();
            	            stream_table_alias.add(table_alias149.tree);
            	        }

            	    }
            	    break;

                }
            }

            // AST REWRITE
            // elements: dml_table_expression_clause, pivot_clause, flashback_query_clause, unpivot_clause, table_alias
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 304:9: -> ^( TABLE_REF_ELEMENT dml_table_expression_clause ( pivot_clause )? ( unpivot_clause )? ( flashback_query_clause )* ( table_alias )? )
            {
            	// OracleDML.g:304:12: ^( TABLE_REF_ELEMENT dml_table_expression_clause ( pivot_clause )? ( unpivot_clause )? ( flashback_query_clause )* ( table_alias )? )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(TABLE_REF_ELEMENT, "TABLE_REF_ELEMENT"), root_1);
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_dml_table_expression_clause.nextTree());
            	// OracleDML.g:304:60: ( pivot_clause )?
            	if ( stream_pivot_clause.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_pivot_clause.nextTree());
            	}
            	stream_pivot_clause.reset();

            	// OracleDML.g:304:74: ( unpivot_clause )?
            	if ( stream_unpivot_clause.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_unpivot_clause.nextTree());
            	}
            	stream_unpivot_clause.reset();

            	// OracleDML.g:304:90: ( flashback_query_clause )*
            	while ( stream_flashback_query_clause.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_flashback_query_clause.nextTree());
            	}
            	stream_flashback_query_clause.reset();

            	// OracleDML.g:304:114: ( table_alias )?
            	if ( stream_table_alias.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_table_alias.nextTree());
            	}
            	stream_table_alias.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruletable_ref_aux_ver4Ex; /* Prevent compiler warnings */
    ruletable_ref_aux_ver4Ex: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end table_ref_aux_ver4 */

/**
 * $ANTLR start join_clause
 * OracleDML.g:307:1: join_clause : (qpc1= query_partition_clause )? ( cross_key | natural_key )? ( inner_key | outer_join_type )? join_key table_ref_aux (qpc2= query_partition_clause )? ( join_on_part | join_using_part )* -> ^( JOIN_DEF[$join_key.start] ( $qpc1)? table_ref_aux ( $qpc2)? ( join_on_part )* ( join_using_part )* ) ;
 */
OracleDML::join_clause_return
OracleDML::join_clause()
{
    OracleDML::join_clause_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML::query_partition_clause_return qpc1;
    ImplTraits::TreeTypePtr::pointer qpc1_last = NULL;
    OracleDML::query_partition_clause_return qpc2;
    ImplTraits::TreeTypePtr::pointer qpc2_last = NULL;
    OracleDML_OracleDMLKeys::cross_key_return cross_key150;
    ImplTraits::TreeTypePtr::pointer cross_key150_last = NULL;
    OracleDML_OracleDMLKeys::natural_key_return natural_key151;
    ImplTraits::TreeTypePtr::pointer natural_key151_last = NULL;
    OracleDML_OracleDMLKeys::inner_key_return inner_key152;
    ImplTraits::TreeTypePtr::pointer inner_key152_last = NULL;
    OracleDML::outer_join_type_return outer_join_type153;
    ImplTraits::TreeTypePtr::pointer outer_join_type153_last = NULL;
    OracleDML_OracleDMLKeys::join_key_return join_key154;
    ImplTraits::TreeTypePtr::pointer join_key154_last = NULL;
    OracleDML::table_ref_aux_return table_ref_aux155;
    ImplTraits::TreeTypePtr::pointer table_ref_aux155_last = NULL;
    OracleDML::join_on_part_return join_on_part156;
    ImplTraits::TreeTypePtr::pointer join_on_part156_last = NULL;
    OracleDML::join_using_part_return join_using_part157;
    ImplTraits::TreeTypePtr::pointer join_using_part157_last = NULL;
    RewriteRuleSubtreeStream<ImplTraits> stream_inner_key(get_psrstate()->get_treeAdaptor(), "rule inner_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_join_using_part(get_psrstate()->get_treeAdaptor(), "rule join_using_part");
    RewriteRuleSubtreeStream<ImplTraits> stream_join_on_part(get_psrstate()->get_treeAdaptor(), "rule join_on_part");
    RewriteRuleSubtreeStream<ImplTraits> stream_join_key(get_psrstate()->get_treeAdaptor(), "rule join_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_outer_join_type(get_psrstate()->get_treeAdaptor(), "rule outer_join_type");
    RewriteRuleSubtreeStream<ImplTraits> stream_query_partition_clause(get_psrstate()->get_treeAdaptor(), "rule query_partition_clause");
    RewriteRuleSubtreeStream<ImplTraits> stream_cross_key(get_psrstate()->get_treeAdaptor(), "rule cross_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_natural_key(get_psrstate()->get_treeAdaptor(), "rule natural_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_table_ref_aux(get_psrstate()->get_treeAdaptor(), "rule table_ref_aux");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:308:5: ( (qpc1= query_partition_clause )? ( cross_key | natural_key )? ( inner_key | outer_join_type )? join_key table_ref_aux (qpc2= query_partition_clause )? ( join_on_part | join_using_part )* -> ^( JOIN_DEF[$join_key.start] ( $qpc1)? table_ref_aux ( $qpc2)? ( join_on_part )* ( join_using_part )* ) )
        // OracleDML.g:308:9: (qpc1= query_partition_clause )? ( cross_key | natural_key )? ( inner_key | outer_join_type )? join_key table_ref_aux (qpc2= query_partition_clause )? ( join_on_part | join_using_part )*
        {
            // OracleDML.g:308:13: (qpc1= query_partition_clause )?
            {
                ANTLR_UINT32 alt57=2;
                {
                    ANTLR_UINT32 LA57_0 = this->LA(1);
                    if ( (LA57_0 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "NATURAL"))||((toUpper(LT(1)->getText()) == "JOIN"))||((toUpper(LT(1)->getText()) == "FULL"))||((toUpper(LT(1)->getText()) == "CROSS"))||((toUpper(LT(1)->getText()) == "PARTITION"))||((toUpper(LT(1)->getText()) == "LEFT"))||((toUpper(LT(1)->getText()) == "RIGHT"))||((toUpper(LT(1)->getText()) == "INNER")))))
                    {
                        {
                            ANTLR_UINT32 LA57_1 = this->LA(2);
                            if ( (LA57_1 == SQL92_RESERVED_BY) && ((toUpper(LT(1)->getText()) == "PARTITION")))
                            {
                                alt57=1;
                            }
                        }
                    }
                }
                switch (alt57)
                {
            	case 1:
            	    // OracleDML.g:308:13: qpc1= query_partition_clause
            	    {
            	        this->followPush(FOLLOW_query_partition_clause_in_join_clause2522);
            	        qpc1=query_partition_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulejoin_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            qpc1_last = qpc1.tree.get();
            	            stream_query_partition_clause.add(qpc1.tree);
            	        }

            	    }
            	    break;

                }
            }

            // OracleDML.g:309:9: ( cross_key | natural_key )?
            {
                ANTLR_UINT32 alt58=3;
                {
                    ANTLR_UINT32 LA58_0 = this->LA(1);
                    if ( (LA58_0 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "NATURAL"))||((toUpper(LT(1)->getText()) == "JOIN"))||((toUpper(LT(1)->getText()) == "FULL"))||((toUpper(LT(1)->getText()) == "CROSS"))||((toUpper(LT(1)->getText()) == "LEFT"))||((toUpper(LT(1)->getText()) == "RIGHT"))||((toUpper(LT(1)->getText()) == "INNER")))))
                    {
                        {
                            ANTLR_UINT32 LA58_1 = this->LA(2);
                            if ( ((toUpper(LT(1)->getText()) == "CROSS")))
                            {
                                alt58=1;
                            }
                            else if ( ((toUpper(LT(1)->getText()) == "NATURAL")))
                            {
                                alt58=2;
                            }
                        }
                    }
                }
                switch (alt58)
                {
            	case 1:
            	    // OracleDML.g:309:10: cross_key
            	    {
            	        this->followPush(FOLLOW_cross_key_in_join_clause2534);
            	        cross_key150=cross_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulejoin_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            cross_key150_last = cross_key150.tree.get();
            	            stream_cross_key.add(cross_key150.tree);
            	        }

            	    }
            	    break;
            	case 2:
            	    // OracleDML.g:309:20: natural_key
            	    {
            	        this->followPush(FOLLOW_natural_key_in_join_clause2536);
            	        natural_key151=natural_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulejoin_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            natural_key151_last = natural_key151.tree.get();
            	            stream_natural_key.add(natural_key151.tree);
            	        }

            	    }
            	    break;

                }
            }

            // OracleDML.g:309:34: ( inner_key | outer_join_type )?
            {
                ANTLR_UINT32 alt59=3;
                {
                    ANTLR_UINT32 LA59_0 = this->LA(1);
                    if ( (LA59_0 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "JOIN"))||((toUpper(LT(1)->getText()) == "FULL"))||((toUpper(LT(1)->getText()) == "LEFT"))||((toUpper(LT(1)->getText()) == "RIGHT"))||((toUpper(LT(1)->getText()) == "INNER")))))
                    {
                        {
                            ANTLR_UINT32 LA59_1 = this->LA(2);
                            if ( ((toUpper(LT(1)->getText()) == "INNER")))
                            {
                                alt59=1;
                            }
                            else if ( ((((toUpper(LT(1)->getText()) == "FULL"))||((toUpper(LT(1)->getText()) == "LEFT"))||((toUpper(LT(1)->getText()) == "RIGHT")))))
                            {
                                alt59=2;
                            }
                        }
                    }
                }
                switch (alt59)
                {
            	case 1:
            	    // OracleDML.g:309:35: inner_key
            	    {
            	        this->followPush(FOLLOW_inner_key_in_join_clause2541);
            	        inner_key152=inner_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulejoin_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            inner_key152_last = inner_key152.tree.get();
            	            stream_inner_key.add(inner_key152.tree);
            	        }

            	    }
            	    break;
            	case 2:
            	    // OracleDML.g:309:45: outer_join_type
            	    {
            	        this->followPush(FOLLOW_outer_join_type_in_join_clause2543);
            	        outer_join_type153=outer_join_type();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulejoin_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            outer_join_type153_last = outer_join_type153.tree.get();
            	            stream_outer_join_type.add(outer_join_type153.tree);
            	        }

            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_join_key_in_join_clause2547);
            join_key154=join_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulejoin_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                join_key154_last = join_key154.tree.get();
                stream_join_key.add(join_key154.tree);
            }

            this->followPush(FOLLOW_table_ref_aux_in_join_clause2557);
            table_ref_aux155=table_ref_aux();

            this->followPop();
            if  (this->hasException())
            {
                goto rulejoin_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                table_ref_aux155_last = table_ref_aux155.tree.get();
                stream_table_ref_aux.add(table_ref_aux155.tree);
            }

            // OracleDML.g:311:13: (qpc2= query_partition_clause )?
            {
                ANTLR_UINT32 alt60=2;
                switch ( this->LA(1) )
                {
                    case REGULAR_ID:
                    	{
                    		{
                    		    ANTLR_UINT32 LA60_1 = this->LA(2);
                    		    if ( ((toUpper(LT(1)->getText()) == "PARTITION")))
                    		    {
                    		        alt60=1;
                    		    }
                    		}
                    	}
                        break;
                }

                switch (alt60)
                {
            	case 1:
            	    // OracleDML.g:311:13: qpc2= query_partition_clause
            	    {
            	        this->followPush(FOLLOW_query_partition_clause_in_join_clause2569);
            	        qpc2=query_partition_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulejoin_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            qpc2_last = qpc2.tree.get();
            	            stream_query_partition_clause.add(qpc2.tree);
            	        }

            	    }
            	    break;

                }
            }

            // OracleDML.g:312:5: ( join_on_part | join_using_part )*

            for (;;)
            {
                ANTLR_UINT32 alt61=3;
                switch ( this->LA(1) )
                {
                case SQL92_RESERVED_ON:
                	{
                		alt61=1;
                	}
                    break;
                case PLSQL_NON_RESERVED_USING:
                	{
                		alt61=2;
                	}
                    break;

                }

                switch (alt61)
                {
            	case 1:
            	    // OracleDML.g:312:10: join_on_part
            	    {
            	        this->followPush(FOLLOW_join_on_part_in_join_clause2581);
            	        join_on_part156=join_on_part();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulejoin_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            join_on_part156_last = join_on_part156.tree.get();
            	            stream_join_on_part.add(join_on_part156.tree);
            	        }

            	    }
            	    break;
            	case 2:
            	    // OracleDML.g:313:10: join_using_part
            	    {
            	        this->followPush(FOLLOW_join_using_part_in_join_clause2592);
            	        join_using_part157=join_using_part();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulejoin_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            join_using_part157_last = join_using_part157.tree.get();
            	            stream_join_using_part.add(join_using_part157.tree);
            	        }

            	    }
            	    break;

            	default:
            	    goto loop61;	/* break out of the loop */
            	    break;
                }
            }
            loop61: ; /* Jump out to here if this rule does not match */


            // AST REWRITE
            // elements: join_on_part, join_using_part, table_ref_aux, qpc2, qpc1
            // token labels: 
            // rule labels: retval, qpc1, qpc2
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval
            RewriteRuleSubtreeStream<ImplTraits> stream_qpc1(get_psrstate()->get_treeAdaptor(), "rule qpc1",qpc1_last); // rewrite alias
            RewriteRuleSubtreeStream<ImplTraits> stream_qpc2(get_psrstate()->get_treeAdaptor(), "rule qpc2",qpc2_last); // rewrite alias

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 315:9: -> ^( JOIN_DEF[$join_key.start] ( $qpc1)? table_ref_aux ( $qpc2)? ( join_on_part )* ( join_using_part )* )
            {
            	// OracleDML.g:315:12: ^( JOIN_DEF[$join_key.start] ( $qpc1)? table_ref_aux ( $qpc2)? ( join_on_part )* ( join_using_part )* )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(JOIN_DEF, (join_key154.start)), root_1);
            	// OracleDML.g:315:41: ( $qpc1)?
            	if ( stream_qpc1.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_qpc1.nextTree());
            	}
            	stream_qpc1.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_table_ref_aux.nextTree());
            	// OracleDML.g:317:28: ( $qpc2)?
            	if ( stream_qpc2.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_qpc2.nextTree());
            	}
            	stream_qpc2.reset();

            	// OracleDML.g:317:34: ( join_on_part )*
            	while ( stream_join_on_part.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_join_on_part.nextTree());
            	}
            	stream_join_on_part.reset();

            	// OracleDML.g:317:48: ( join_using_part )*
            	while ( stream_join_using_part.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_join_using_part.nextTree());
            	}
            	stream_join_using_part.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulejoin_clauseEx; /* Prevent compiler warnings */
    rulejoin_clauseEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end join_clause */

/**
 * $ANTLR start join_on_part
 * OracleDML.g:320:1: join_on_part : on_key condition -> ^( on_key ^( LOGIC_EXPR condition ) ) ;
 */
OracleDML::join_on_part_return
OracleDML::join_on_part()
{
    OracleDML::join_on_part_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML_OracleDMLKeys::on_key_return on_key158;
    ImplTraits::TreeTypePtr::pointer on_key158_last = NULL;
    OracleDML::condition_return condition159;
    ImplTraits::TreeTypePtr::pointer condition159_last = NULL;
    RewriteRuleSubtreeStream<ImplTraits> stream_condition(get_psrstate()->get_treeAdaptor(), "rule condition");
    RewriteRuleSubtreeStream<ImplTraits> stream_on_key(get_psrstate()->get_treeAdaptor(), "rule on_key");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:321:5: ( on_key condition -> ^( on_key ^( LOGIC_EXPR condition ) ) )
        // OracleDML.g:321:10: on_key condition
        {
            this->followPush(FOLLOW_on_key_in_join_on_part2675);
            on_key158=on_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulejoin_on_partEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                on_key158_last = on_key158.tree.get();
                stream_on_key.add(on_key158.tree);
            }

            this->followPush(FOLLOW_condition_in_join_on_part2677);
            condition159=condition();

            this->followPop();
            if  (this->hasException())
            {
                goto rulejoin_on_partEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                condition159_last = condition159.tree.get();
                stream_condition.add(condition159.tree);
            }

            // AST REWRITE
            // elements: on_key, condition
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 322:9: -> ^( on_key ^( LOGIC_EXPR condition ) )
            {
            	// OracleDML.g:322:12: ^( on_key ^( LOGIC_EXPR condition ) )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(stream_on_key.nextNode(), root_1);
            	// OracleDML.g:322:21: ^( LOGIC_EXPR condition )
            	{
            	ImplTraits::TreeTypePtr root_2 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_2 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(LOGIC_EXPR, "LOGIC_EXPR"), root_2);
            	get_psrstate()->get_treeAdaptor()->addChild(root_2, stream_condition.nextTree());
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, root_2);
            	}
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulejoin_on_partEx; /* Prevent compiler warnings */
    rulejoin_on_partEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end join_on_part */

/**
 * $ANTLR start join_using_part
 * OracleDML.g:325:1: join_using_part : using_key ^ LEFT_PAREN column_name ( COMMA ^ column_name )* RIGHT_PAREN ;
 */
OracleDML::join_using_part_return
OracleDML::join_using_part()
{
    OracleDML::join_using_part_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* LEFT_PAREN161 = NULL;
    ImplTraits::CommonTokenType const* COMMA163 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN165 = NULL;
    OracleDML_OracleDMLKeys::using_key_return using_key160;
    ImplTraits::TreeTypePtr::pointer using_key160_last = NULL;
    OracleDML_OracleDMLCommons::column_name_return column_name162;
    ImplTraits::TreeTypePtr::pointer column_name162_last = NULL;
    OracleDML_OracleDMLCommons::column_name_return column_name164;
    ImplTraits::TreeTypePtr::pointer column_name164_last = NULL;
    ImplTraits::TreeTypePtr LEFT_PAREN161_tree;
    ImplTraits::TreeTypePtr COMMA163_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN165_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:326:5: ( using_key ^ LEFT_PAREN column_name ( COMMA ^ column_name )* RIGHT_PAREN )
        // OracleDML.g:326:10: using_key ^ LEFT_PAREN column_name ( COMMA ^ column_name )* RIGHT_PAREN
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            this->followPush(FOLLOW_using_key_in_join_using_part2718);
            using_key160=using_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulejoin_using_partEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(using_key160.tree, root_0);

            LEFT_PAREN161 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_join_using_part2721);
            if  (this->hasException())
            {
                goto rulejoin_using_partEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            LEFT_PAREN161_tree = std::move(get_psrstate()->get_treeAdaptor()->create(LEFT_PAREN161));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, LEFT_PAREN161_tree);
            }


            this->followPush(FOLLOW_column_name_in_join_using_part2723);
            column_name162=column_name();

            this->followPop();
            if  (this->hasException())
            {
                goto rulejoin_using_partEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, column_name162.tree);


            // OracleDML.g:326:44: ( COMMA ^ column_name )*

            for (;;)
            {
                ANTLR_UINT32 alt62=2;
                switch ( this->LA(1) )
                {
                case COMMA:
                	{
                		alt62=1;
                	}
                    break;

                }

                switch (alt62)
                {
            	case 1:
            	    // OracleDML.g:326:45: COMMA ^ column_name
            	    {
            	        COMMA163 =  this->matchToken(COMMA, &FOLLOW_COMMA_in_join_using_part2726);
            	        if  (this->hasException())
            	        {
            	            goto rulejoin_using_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) {
            	        COMMA163_tree = get_psrstate()->get_treeAdaptor()->create(COMMA163);
            	        root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(COMMA163_tree, root_0);
            	        }


            	        this->followPush(FOLLOW_column_name_in_join_using_part2729);
            	        column_name164=column_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulejoin_using_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, column_name164.tree);


            	    }
            	    break;

            	default:
            	    goto loop62;	/* break out of the loop */
            	    break;
                }
            }
            loop62: ; /* Jump out to here if this rule does not match */


            RIGHT_PAREN165 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_join_using_part2733);
            if  (this->hasException())
            {
                goto rulejoin_using_partEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            RIGHT_PAREN165_tree = std::move(get_psrstate()->get_treeAdaptor()->create(RIGHT_PAREN165));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, RIGHT_PAREN165_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulejoin_using_partEx; /* Prevent compiler warnings */
    rulejoin_using_partEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end join_using_part */

/**
 * $ANTLR start outer_join_type
 * OracleDML.g:329:1: outer_join_type : ( full_key | left_key | right_key ) ( outer_key !)? ;
 */
OracleDML::outer_join_type_return
OracleDML::outer_join_type()
{
    OracleDML::outer_join_type_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML_OracleDMLKeys::full_key_return full_key166;
    ImplTraits::TreeTypePtr::pointer full_key166_last = NULL;
    OracleDML_OracleDMLKeys::left_key_return left_key167;
    ImplTraits::TreeTypePtr::pointer left_key167_last = NULL;
    OracleDML_OracleDMLKeys::right_key_return right_key168;
    ImplTraits::TreeTypePtr::pointer right_key168_last = NULL;
    OracleDML_OracleDMLKeys::outer_key_return outer_key169;
    ImplTraits::TreeTypePtr::pointer outer_key169_last = NULL;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:330:5: ( ( full_key | left_key | right_key ) ( outer_key !)? )
        // OracleDML.g:331:5: ( full_key | left_key | right_key ) ( outer_key !)?
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            // OracleDML.g:331:5: ( full_key | left_key | right_key )
            {
                ANTLR_UINT32 alt63=3;
                {
                    ANTLR_UINT32 LA63_0 = this->LA(1);
                    if ( (LA63_0 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "FULL"))||((toUpper(LT(1)->getText()) == "LEFT"))||((toUpper(LT(1)->getText()) == "RIGHT")))))
                    {
                        {
                            ANTLR_UINT32 LA63_1 = this->LA(2);
                            if ( ((toUpper(LT(1)->getText()) == "FULL")))
                            {
                                alt63=1;
                            }
                            else if ( ((toUpper(LT(1)->getText()) == "LEFT")))
                            {
                                alt63=2;
                            }
                            else if ( ((toUpper(LT(1)->getText()) == "RIGHT")))
                            {
                                alt63=3;
                            }
                            else
                            {
                                if (this->get_backtracking()>0)
                                {
                                    this->set_failedflag( true );
                                    return retval;
                                }


                                ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                ex->set_decisionNum( 63 );
                                ex->set_state( 1 );


                                goto ruleouter_join_typeEx;

                            }
                        }
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return retval;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 63 );
                        ex->set_state( 0 );


                        goto ruleouter_join_typeEx;

                    }
                }
                switch (alt63)
                {
            	case 1:
            	    // OracleDML.g:331:10: full_key
            	    {
            	        this->followPush(FOLLOW_full_key_in_outer_join_type2763);
            	        full_key166=full_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleouter_join_typeEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, full_key166.tree);


            	    }
            	    break;
            	case 2:
            	    // OracleDML.g:332:10: left_key
            	    {
            	        this->followPush(FOLLOW_left_key_in_outer_join_type2774);
            	        left_key167=left_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleouter_join_typeEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, left_key167.tree);


            	    }
            	    break;
            	case 3:
            	    // OracleDML.g:333:10: right_key
            	    {
            	        this->followPush(FOLLOW_right_key_in_outer_join_type2785);
            	        right_key168=right_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleouter_join_typeEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, right_key168.tree);


            	    }
            	    break;

                }
            }

            // OracleDML.g:335:18: ( outer_key !)?
            {
                ANTLR_UINT32 alt64=2;
                {
                    ANTLR_UINT32 LA64_0 = this->LA(1);
                    if ( (LA64_0 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "JOIN"))||((toUpper(LT(1)->getText()) == "OUTER")))))
                    {
                        {
                            ANTLR_UINT32 LA64_1 = this->LA(2);
                            if ( ((toUpper(LT(1)->getText()) == "OUTER")))
                            {
                                alt64=1;
                            }
                        }
                    }
                }
                switch (alt64)
                {
            	case 1:
            	    // OracleDML.g:335:18: outer_key !
            	    {
            	        this->followPush(FOLLOW_outer_key_in_outer_join_type2801);
            	        outer_key169=outer_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleouter_join_typeEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }


            	    }
            	    break;

                }
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleouter_join_typeEx; /* Prevent compiler warnings */
    ruleouter_join_typeEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end outer_join_type */

/**
 * $ANTLR start query_partition_clause
 * OracleDML.g:338:1: query_partition_clause : partition_key by_key ( ( LEFT_PAREN ( select_key | with_key ) )=> LEFT_PAREN subquery RIGHT_PAREN | ( LEFT_PAREN )=> expression_list | expression ( COMMA expression )* ) -> ^( partition_key ( LEFT_PAREN )? ( subquery )? ( expression_list )? ( EXPR expression )* ( RIGHT_PAREN )? ) ;
 */
OracleDML::query_partition_clause_return
OracleDML::query_partition_clause()
{
    OracleDML::query_partition_clause_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* LEFT_PAREN172 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN174 = NULL;
    ImplTraits::CommonTokenType const* COMMA177 = NULL;
    OracleDML_OracleDMLKeys::partition_key_return partition_key170;
    ImplTraits::TreeTypePtr::pointer partition_key170_last = NULL;
    OracleDML_OracleDMLKeys::by_key_return by_key171;
    ImplTraits::TreeTypePtr::pointer by_key171_last = NULL;
    OracleDML::subquery_return subquery173;
    ImplTraits::TreeTypePtr::pointer subquery173_last = NULL;
    OracleDML::expression_list_return expression_list175;
    ImplTraits::TreeTypePtr::pointer expression_list175_last = NULL;
    OracleDML::expression_return expression176;
    ImplTraits::TreeTypePtr::pointer expression176_last = NULL;
    OracleDML::expression_return expression178;
    ImplTraits::TreeTypePtr::pointer expression178_last = NULL;
    ImplTraits::TreeTypePtr LEFT_PAREN172_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN174_tree;
    ImplTraits::TreeTypePtr COMMA177_tree;
    RewriteRuleTokenStream<ImplTraits> stream_LEFT_PAREN(get_psrstate()->get_treeAdaptor(), "token LEFT_PAREN");
    RewriteRuleTokenStream<ImplTraits> stream_RIGHT_PAREN(get_psrstate()->get_treeAdaptor(), "token RIGHT_PAREN");
    RewriteRuleTokenStream<ImplTraits> stream_COMMA(get_psrstate()->get_treeAdaptor(), "token COMMA");
    RewriteRuleSubtreeStream<ImplTraits> stream_expression(get_psrstate()->get_treeAdaptor(), "rule expression");
    RewriteRuleSubtreeStream<ImplTraits> stream_expression_list(get_psrstate()->get_treeAdaptor(), "rule expression_list");
    RewriteRuleSubtreeStream<ImplTraits> stream_partition_key(get_psrstate()->get_treeAdaptor(), "rule partition_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_by_key(get_psrstate()->get_treeAdaptor(), "rule by_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_subquery(get_psrstate()->get_treeAdaptor(), "rule subquery");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:339:5: ( partition_key by_key ( ( LEFT_PAREN ( select_key | with_key ) )=> LEFT_PAREN subquery RIGHT_PAREN | ( LEFT_PAREN )=> expression_list | expression ( COMMA expression )* ) -> ^( partition_key ( LEFT_PAREN )? ( subquery )? ( expression_list )? ( EXPR expression )* ( RIGHT_PAREN )? ) )
        // OracleDML.g:339:10: partition_key by_key ( ( LEFT_PAREN ( select_key | with_key ) )=> LEFT_PAREN subquery RIGHT_PAREN | ( LEFT_PAREN )=> expression_list | expression ( COMMA expression )* )
        {
            this->followPush(FOLLOW_partition_key_in_query_partition_clause2823);
            partition_key170=partition_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulequery_partition_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                partition_key170_last = partition_key170.tree.get();
                stream_partition_key.add(partition_key170.tree);
            }

            this->followPush(FOLLOW_by_key_in_query_partition_clause2825);
            by_key171=by_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulequery_partition_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                by_key171_last = by_key171.tree.get();
                stream_by_key.add(by_key171.tree);
            }

            // OracleDML.g:340:5: ( ( LEFT_PAREN ( select_key | with_key ) )=> LEFT_PAREN subquery RIGHT_PAREN | ( LEFT_PAREN )=> expression_list | expression ( COMMA expression )* )
            {
                ANTLR_UINT32 alt66=3;
                switch ( this->LA(1) )
                {
                case LEFT_PAREN:
                	{
                		{
                		    ANTLR_UINT32 LA66_1 = this->LA(2);
                		    if ( (this->msynpred( antlr3::ClassForwarder<synpred10_OracleDML>() )))
                		    {
                		        alt66=1;
                		    }
                		    else if ( (this->msynpred( antlr3::ClassForwarder<synpred11_OracleDML>() )))
                		    {
                		        alt66=2;
                		    }
                		    else if ( (true))
                		    {
                		        alt66=3;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return retval;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 66 );
                		        ex->set_state( 1 );


                		        goto rulequery_partition_clauseEx;

                		    }
                		}
                	}
                    break;
                case APPROXIMATE_NUM_LIT:
                case BINDVAR:
                case CHAR_STRING:
                case CHAR_STRING_PERL:
                case COLON:
                case DELIMITED_ID:
                case EXACT_NUM_LIT:
                case INTRODUCER:
                case MINUS_SIGN:
                case NATIONAL_CHAR_STRING_LIT:
                case PLSQL_NON_RESERVED_CAST:
                case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
                case PLUS_SIGN:
                case REGULAR_ID:
                case SQL92_RESERVED_ALL:
                case SQL92_RESERVED_ANY:
                case SQL92_RESERVED_CASE:
                case SQL92_RESERVED_CURSOR:
                case SQL92_RESERVED_DATE:
                case SQL92_RESERVED_DEFAULT:
                case SQL92_RESERVED_DISTINCT:
                case SQL92_RESERVED_EXISTS:
                case SQL92_RESERVED_FALSE:
                case SQL92_RESERVED_NOT:
                case SQL92_RESERVED_NULL:
                case SQL92_RESERVED_PRIOR:
                case SQL92_RESERVED_TRUE:
                case UNSIGNED_INTEGER:
                	{
                		alt66=3;
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return retval;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 66 );
                    ex->set_state( 0 );


                    goto rulequery_partition_clauseEx;

                }

                switch (alt66)
                {
            	case 1:
            	    // OracleDML.g:340:10: ( LEFT_PAREN ( select_key | with_key ) )=> LEFT_PAREN subquery RIGHT_PAREN
            	    {
            	        LEFT_PAREN172 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_query_partition_clause2848);
            	        if  (this->hasException())
            	        {
            	            goto rulequery_partition_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( this->get_backtracking()==0 ) stream_LEFT_PAREN.add(LEFT_PAREN172);


            	        this->followPush(FOLLOW_subquery_in_query_partition_clause2850);
            	        subquery173=subquery();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulequery_partition_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            subquery173_last = subquery173.tree.get();
            	            stream_subquery.add(subquery173.tree);
            	        }

            	        RIGHT_PAREN174 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_query_partition_clause2852);
            	        if  (this->hasException())
            	        {
            	            goto rulequery_partition_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( this->get_backtracking()==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN174);


            	    }
            	    break;
            	case 2:
            	    // OracleDML.g:341:10: ( LEFT_PAREN )=> expression_list
            	    {
            	        this->followPush(FOLLOW_expression_list_in_query_partition_clause2868);
            	        expression_list175=expression_list();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulequery_partition_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            expression_list175_last = expression_list175.tree.get();
            	            stream_expression_list.add(expression_list175.tree);
            	        }

            	    }
            	    break;
            	case 3:
            	    // OracleDML.g:342:10: expression ( COMMA expression )*
            	    {
            	        this->followPush(FOLLOW_expression_in_query_partition_clause2879);
            	        expression176=expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulequery_partition_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            expression176_last = expression176.tree.get();
            	            stream_expression.add(expression176.tree);
            	        }

            	        // OracleDML.g:342:21: ( COMMA expression )*

            	        for (;;)
            	        {
            	            ANTLR_UINT32 alt65=2;
            	            switch ( this->LA(1) )
            	            {
            	            case COMMA:
            	            	{
            	            		alt65=1;
            	            	}
            	                break;

            	            }

            	            switch (alt65)
            	            {
            	        	case 1:
            	        	    // OracleDML.g:342:22: COMMA expression
            	        	    {
            	        	        COMMA177 =  this->matchToken(COMMA, &FOLLOW_COMMA_in_query_partition_clause2882);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulequery_partition_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }
            	        	         
            	        	        if ( this->get_backtracking()==0 ) stream_COMMA.add(COMMA177);


            	        	        this->followPush(FOLLOW_expression_in_query_partition_clause2884);
            	        	        expression178=expression();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulequery_partition_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) 
            	        	        {
            	        	            expression178_last = expression178.tree.get();
            	        	            stream_expression.add(expression178.tree);
            	        	        }

            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop65;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop65: ; /* Jump out to here if this rule does not match */


            	    }
            	    break;

                }
            }

            // AST REWRITE
            // elements: expression, expression_list, LEFT_PAREN, partition_key, RIGHT_PAREN, subquery
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 344:9: -> ^( partition_key ( LEFT_PAREN )? ( subquery )? ( expression_list )? ( EXPR expression )* ( RIGHT_PAREN )? )
            {
            	// OracleDML.g:344:12: ^( partition_key ( LEFT_PAREN )? ( subquery )? ( expression_list )? ( EXPR expression )* ( RIGHT_PAREN )? )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(stream_partition_key.nextNode(), root_1);
            	// OracleDML.g:344:28: ( LEFT_PAREN )?
            	if ( stream_LEFT_PAREN.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_LEFT_PAREN.nextNode());
            	}
            	stream_LEFT_PAREN.reset();

            	// OracleDML.g:344:40: ( subquery )?
            	if ( stream_subquery.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_subquery.nextTree());
            	}
            	stream_subquery.reset();

            	// OracleDML.g:344:50: ( expression_list )?
            	if ( stream_expression_list.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_expression_list.nextTree());
            	}
            	stream_expression_list.reset();

            	// OracleDML.g:344:67: ( EXPR expression )*
            	while ( stream_expression.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, get_psrstate()->get_treeAdaptor()->create(EXPR, "EXPR"));
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_expression.nextTree());
            	}
            	stream_expression.reset();

            	// OracleDML.g:344:86: ( RIGHT_PAREN )?
            	if ( stream_RIGHT_PAREN.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_RIGHT_PAREN.nextNode());
            	}
            	stream_RIGHT_PAREN.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulequery_partition_clauseEx; /* Prevent compiler warnings */
    rulequery_partition_clauseEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end query_partition_clause */

/**
 * $ANTLR start flashback_query_clause
 * OracleDML.g:347:1: flashback_query_clause : ( versions_key between_key ( scn_key | timestamp_key ) expression -> ^( versions_key ( scn_key )? ( timestamp_key )? ^( EXPR expression ) ) | as_key of_key ( scn_key | timestamp_key | snapshot_key ) expression -> ^( as_key ( scn_key )? ( timestamp_key )? ( snapshot_key )? ^( EXPR expression ) ) );
 */
OracleDML::flashback_query_clause_return
OracleDML::flashback_query_clause()
{
    OracleDML::flashback_query_clause_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML_OracleDMLKeys::versions_key_return versions_key179;
    ImplTraits::TreeTypePtr::pointer versions_key179_last = NULL;
    OracleDML_OracleDMLKeys::between_key_return between_key180;
    ImplTraits::TreeTypePtr::pointer between_key180_last = NULL;
    OracleDML_OracleDMLKeys::scn_key_return scn_key181;
    ImplTraits::TreeTypePtr::pointer scn_key181_last = NULL;
    OracleDML_OracleDMLKeys::timestamp_key_return timestamp_key182;
    ImplTraits::TreeTypePtr::pointer timestamp_key182_last = NULL;
    OracleDML::expression_return expression183;
    ImplTraits::TreeTypePtr::pointer expression183_last = NULL;
    OracleDML_OracleDMLKeys::as_key_return as_key184;
    ImplTraits::TreeTypePtr::pointer as_key184_last = NULL;
    OracleDML_OracleDMLKeys::of_key_return of_key185;
    ImplTraits::TreeTypePtr::pointer of_key185_last = NULL;
    OracleDML_OracleDMLKeys::scn_key_return scn_key186;
    ImplTraits::TreeTypePtr::pointer scn_key186_last = NULL;
    OracleDML_OracleDMLKeys::timestamp_key_return timestamp_key187;
    ImplTraits::TreeTypePtr::pointer timestamp_key187_last = NULL;
    OracleDML_OracleDMLKeys::snapshot_key_return snapshot_key188;
    ImplTraits::TreeTypePtr::pointer snapshot_key188_last = NULL;
    OracleDML::expression_return expression189;
    ImplTraits::TreeTypePtr::pointer expression189_last = NULL;
    RewriteRuleSubtreeStream<ImplTraits> stream_expression(get_psrstate()->get_treeAdaptor(), "rule expression");
    RewriteRuleSubtreeStream<ImplTraits> stream_snapshot_key(get_psrstate()->get_treeAdaptor(), "rule snapshot_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_scn_key(get_psrstate()->get_treeAdaptor(), "rule scn_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_versions_key(get_psrstate()->get_treeAdaptor(), "rule versions_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_between_key(get_psrstate()->get_treeAdaptor(), "rule between_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_as_key(get_psrstate()->get_treeAdaptor(), "rule as_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_timestamp_key(get_psrstate()->get_treeAdaptor(), "rule timestamp_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_of_key(get_psrstate()->get_treeAdaptor(), "rule of_key");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        {
            //  OracleDML.g:348:5: ( versions_key between_key ( scn_key | timestamp_key ) expression -> ^( versions_key ( scn_key )? ( timestamp_key )? ^( EXPR expression ) ) | as_key of_key ( scn_key | timestamp_key | snapshot_key ) expression -> ^( as_key ( scn_key )? ( timestamp_key )? ( snapshot_key )? ^( EXPR expression ) ) )

            ANTLR_UINT32 alt69;

            alt69=2;

            {
                ANTLR_UINT32 LA69_0 = this->LA(1);
                if ( (LA69_0 == REGULAR_ID) && ((toUpper(LT(1)->getText()) == "VERSIONS")))
                {
                    alt69=1;
                }
                else if ( (LA69_0 == SQL92_RESERVED_AS))
                {
                    alt69=2;
                }
                else
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return retval;
                    }


                    ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 69 );
                    ex->set_state( 0 );


                    goto ruleflashback_query_clauseEx;

                }
            }
            switch (alt69)
            {
        	case 1:
        	    // OracleDML.g:348:10: versions_key between_key ( scn_key | timestamp_key ) expression
        	    {
        	        this->followPush(FOLLOW_versions_key_in_flashback_query_clause2945);
        	        versions_key179=versions_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleflashback_query_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) 
        	        {
        	            versions_key179_last = versions_key179.tree.get();
        	            stream_versions_key.add(versions_key179.tree);
        	        }

        	        this->followPush(FOLLOW_between_key_in_flashback_query_clause2947);
        	        between_key180=between_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleflashback_query_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) 
        	        {
        	            between_key180_last = between_key180.tree.get();
        	            stream_between_key.add(between_key180.tree);
        	        }

        	        // OracleDML.g:348:35: ( scn_key | timestamp_key )
        	        {
        	            ANTLR_UINT32 alt67=2;
        	            switch ( this->LA(1) )
        	            {
        	            case REGULAR_ID:
        	            	{
        	            		{
        	            		    ANTLR_UINT32 LA67_1 = this->LA(2);
        	            		    if ( ((toUpper(LT(1)->getText()) == "SCN")))
        	            		    {
        	            		        alt67=1;
        	            		    }
        	            		    else if ( ((toUpper(LT(1)->getText()) == "TIMESTAMP")))
        	            		    {
        	            		        alt67=2;
        	            		    }
        	            		    else
        	            		    {
        	            		        if (this->get_backtracking()>0)
        	            		        {
        	            		            this->set_failedflag( true );
        	            		            return retval;
        	            		        }


        	            		        ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	            		        ex->set_decisionNum( 67 );
        	            		        ex->set_state( 1 );


        	            		        goto ruleflashback_query_clauseEx;

        	            		    }
        	            		}
        	            	}
        	                break;

        	            default:
        	                if (this->get_backtracking()>0)
        	                {
        	                    this->set_failedflag( true );
        	                    return retval;
        	                }

        	                ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                ex->set_decisionNum( 67 );
        	                ex->set_state( 0 );


        	                goto ruleflashback_query_clauseEx;

        	            }

        	            switch (alt67)
        	            {
        	        	case 1:
        	        	    // OracleDML.g:348:36: scn_key
        	        	    {
        	        	        this->followPush(FOLLOW_scn_key_in_flashback_query_clause2950);
        	        	        scn_key181=scn_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleflashback_query_clauseEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) 
        	        	        {
        	        	            scn_key181_last = scn_key181.tree.get();
        	        	            stream_scn_key.add(scn_key181.tree);
        	        	        }

        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // OracleDML.g:348:44: timestamp_key
        	        	    {
        	        	        this->followPush(FOLLOW_timestamp_key_in_flashback_query_clause2952);
        	        	        timestamp_key182=timestamp_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleflashback_query_clauseEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) 
        	        	        {
        	        	            timestamp_key182_last = timestamp_key182.tree.get();
        	        	            stream_timestamp_key.add(timestamp_key182.tree);
        	        	        }

        	        	    }
        	        	    break;

        	            }
        	        }

        	        this->followPush(FOLLOW_expression_in_flashback_query_clause2955);
        	        expression183=expression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleflashback_query_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) 
        	        {
        	            expression183_last = expression183.tree.get();
        	            stream_expression.add(expression183.tree);
        	        }

        	        // AST REWRITE
        	        // elements: versions_key, scn_key, expression, timestamp_key
        	        // token labels: 
        	        // rule labels: retval
        	        // token list labels: 
        	        // rule list labels: 
        	        // wildcard labels: 
        	        if ( this->get_backtracking()==0 ) {
        	        retval.tree = std::move(root_0);
        	        RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
        	        // 348:70: -> ^( versions_key ( scn_key )? ( timestamp_key )? ^( EXPR expression ) )
        	        {
        	        	// OracleDML.g:348:73: ^( versions_key ( scn_key )? ( timestamp_key )? ^( EXPR expression ) )
        	        	{
        	        	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
        	        	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(stream_versions_key.nextNode(), root_1);
        	        	// OracleDML.g:348:88: ( scn_key )?
        	        	if ( stream_scn_key.hasNext() ) {
        	        		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_scn_key.nextTree());
        	        	}
        	        	stream_scn_key.reset();

        	        	// OracleDML.g:348:97: ( timestamp_key )?
        	        	if ( stream_timestamp_key.hasNext() ) {
        	        		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_timestamp_key.nextTree());
        	        	}
        	        	stream_timestamp_key.reset();

        	        	// OracleDML.g:348:112: ^( EXPR expression )
        	        	{
        	        	ImplTraits::TreeTypePtr root_2 = get_psrstate()->get_treeAdaptor()->nilNode();
        	        	root_2 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(EXPR, "EXPR"), root_2);
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_2, stream_expression.nextTree());
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_1, root_2);
        	        	}
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
        	        	}
        	        }


        	        //retval.tree = std::move(root_0);
        	        }

        	    }
        	    break;
        	case 2:
        	    // OracleDML.g:349:10: as_key of_key ( scn_key | timestamp_key | snapshot_key ) expression
        	    {
        	        this->followPush(FOLLOW_as_key_in_flashback_query_clause2985);
        	        as_key184=as_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleflashback_query_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) 
        	        {
        	            as_key184_last = as_key184.tree.get();
        	            stream_as_key.add(as_key184.tree);
        	        }

        	        this->followPush(FOLLOW_of_key_in_flashback_query_clause2987);
        	        of_key185=of_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleflashback_query_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) 
        	        {
        	            of_key185_last = of_key185.tree.get();
        	            stream_of_key.add(of_key185.tree);
        	        }

        	        // OracleDML.g:349:24: ( scn_key | timestamp_key | snapshot_key )
        	        {
        	            ANTLR_UINT32 alt68=3;
        	            switch ( this->LA(1) )
        	            {
        	            case REGULAR_ID:
        	            	{
        	            		{
        	            		    ANTLR_UINT32 LA68_1 = this->LA(2);
        	            		    if ( ((toUpper(LT(1)->getText()) == "SCN")))
        	            		    {
        	            		        alt68=1;
        	            		    }
        	            		    else if ( ((toUpper(LT(1)->getText()) == "TIMESTAMP")))
        	            		    {
        	            		        alt68=2;
        	            		    }
        	            		    else if ( ((toUpper(LT(1)->getText()) == "SNAPSHOT")))
        	            		    {
        	            		        alt68=3;
        	            		    }
        	            		    else
        	            		    {
        	            		        if (this->get_backtracking()>0)
        	            		        {
        	            		            this->set_failedflag( true );
        	            		            return retval;
        	            		        }


        	            		        ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	            		        ex->set_decisionNum( 68 );
        	            		        ex->set_state( 1 );


        	            		        goto ruleflashback_query_clauseEx;

        	            		    }
        	            		}
        	            	}
        	                break;

        	            default:
        	                if (this->get_backtracking()>0)
        	                {
        	                    this->set_failedflag( true );
        	                    return retval;
        	                }

        	                ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                ex->set_decisionNum( 68 );
        	                ex->set_state( 0 );


        	                goto ruleflashback_query_clauseEx;

        	            }

        	            switch (alt68)
        	            {
        	        	case 1:
        	        	    // OracleDML.g:349:25: scn_key
        	        	    {
        	        	        this->followPush(FOLLOW_scn_key_in_flashback_query_clause2990);
        	        	        scn_key186=scn_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleflashback_query_clauseEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) 
        	        	        {
        	        	            scn_key186_last = scn_key186.tree.get();
        	        	            stream_scn_key.add(scn_key186.tree);
        	        	        }

        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // OracleDML.g:349:33: timestamp_key
        	        	    {
        	        	        this->followPush(FOLLOW_timestamp_key_in_flashback_query_clause2992);
        	        	        timestamp_key187=timestamp_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleflashback_query_clauseEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) 
        	        	        {
        	        	            timestamp_key187_last = timestamp_key187.tree.get();
        	        	            stream_timestamp_key.add(timestamp_key187.tree);
        	        	        }

        	        	    }
        	        	    break;
        	        	case 3:
        	        	    // OracleDML.g:349:47: snapshot_key
        	        	    {
        	        	        this->followPush(FOLLOW_snapshot_key_in_flashback_query_clause2994);
        	        	        snapshot_key188=snapshot_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleflashback_query_clauseEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) 
        	        	        {
        	        	            snapshot_key188_last = snapshot_key188.tree.get();
        	        	            stream_snapshot_key.add(snapshot_key188.tree);
        	        	        }

        	        	    }
        	        	    break;

        	            }
        	        }

        	        this->followPush(FOLLOW_expression_in_flashback_query_clause2997);
        	        expression189=expression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleflashback_query_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) 
        	        {
        	            expression189_last = expression189.tree.get();
        	            stream_expression.add(expression189.tree);
        	        }

        	        // AST REWRITE
        	        // elements: timestamp_key, as_key, expression, scn_key, snapshot_key
        	        // token labels: 
        	        // rule labels: retval
        	        // token list labels: 
        	        // rule list labels: 
        	        // wildcard labels: 
        	        if ( this->get_backtracking()==0 ) {
        	        retval.tree = std::move(root_0);
        	        RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
        	        // 349:72: -> ^( as_key ( scn_key )? ( timestamp_key )? ( snapshot_key )? ^( EXPR expression ) )
        	        {
        	        	// OracleDML.g:349:75: ^( as_key ( scn_key )? ( timestamp_key )? ( snapshot_key )? ^( EXPR expression ) )
        	        	{
        	        	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
        	        	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(stream_as_key.nextNode(), root_1);
        	        	// OracleDML.g:349:84: ( scn_key )?
        	        	if ( stream_scn_key.hasNext() ) {
        	        		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_scn_key.nextTree());
        	        	}
        	        	stream_scn_key.reset();

        	        	// OracleDML.g:349:93: ( timestamp_key )?
        	        	if ( stream_timestamp_key.hasNext() ) {
        	        		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_timestamp_key.nextTree());
        	        	}
        	        	stream_timestamp_key.reset();

        	        	// OracleDML.g:349:108: ( snapshot_key )?
        	        	if ( stream_snapshot_key.hasNext() ) {
        	        		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_snapshot_key.nextTree());
        	        	}
        	        	stream_snapshot_key.reset();

        	        	// OracleDML.g:349:122: ^( EXPR expression )
        	        	{
        	        	ImplTraits::TreeTypePtr root_2 = get_psrstate()->get_treeAdaptor()->nilNode();
        	        	root_2 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(EXPR, "EXPR"), root_2);
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_2, stream_expression.nextTree());
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_1, root_2);
        	        	}
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
        	        	}
        	        }


        	        //retval.tree = std::move(root_0);
        	        }

        	    }
        	    break;

            }
        }
    }//...
    // This is where rules clean up and exit
    //
    goto ruleflashback_query_clauseEx; /* Prevent compiler warnings */
    ruleflashback_query_clauseEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end flashback_query_clause */

/**
 * $ANTLR start pivot_clause
 * OracleDML.g:352:1: pivot_clause : pivot_key ( xml_key )? LEFT_PAREN pivot_element ( COMMA pivot_element )* pivot_for_clause pivot_in_clause RIGHT_PAREN -> ^( pivot_key ( xml_key )? LEFT_PAREN ( pivot_element )+ pivot_for_clause pivot_in_clause RIGHT_PAREN ) ;
 */
OracleDML::pivot_clause_return
OracleDML::pivot_clause()
{
    OracleDML::pivot_clause_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* LEFT_PAREN192 = NULL;
    ImplTraits::CommonTokenType const* COMMA194 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN198 = NULL;
    OracleDML_OracleDMLKeys::pivot_key_return pivot_key190;
    ImplTraits::TreeTypePtr::pointer pivot_key190_last = NULL;
    OracleDML_OracleDMLKeys::xml_key_return xml_key191;
    ImplTraits::TreeTypePtr::pointer xml_key191_last = NULL;
    OracleDML::pivot_element_return pivot_element193;
    ImplTraits::TreeTypePtr::pointer pivot_element193_last = NULL;
    OracleDML::pivot_element_return pivot_element195;
    ImplTraits::TreeTypePtr::pointer pivot_element195_last = NULL;
    OracleDML::pivot_for_clause_return pivot_for_clause196;
    ImplTraits::TreeTypePtr::pointer pivot_for_clause196_last = NULL;
    OracleDML::pivot_in_clause_return pivot_in_clause197;
    ImplTraits::TreeTypePtr::pointer pivot_in_clause197_last = NULL;
    ImplTraits::TreeTypePtr LEFT_PAREN192_tree;
    ImplTraits::TreeTypePtr COMMA194_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN198_tree;
    RewriteRuleTokenStream<ImplTraits> stream_LEFT_PAREN(get_psrstate()->get_treeAdaptor(), "token LEFT_PAREN");
    RewriteRuleTokenStream<ImplTraits> stream_RIGHT_PAREN(get_psrstate()->get_treeAdaptor(), "token RIGHT_PAREN");
    RewriteRuleTokenStream<ImplTraits> stream_COMMA(get_psrstate()->get_treeAdaptor(), "token COMMA");
    RewriteRuleSubtreeStream<ImplTraits> stream_pivot_in_clause(get_psrstate()->get_treeAdaptor(), "rule pivot_in_clause");
    RewriteRuleSubtreeStream<ImplTraits> stream_pivot_element(get_psrstate()->get_treeAdaptor(), "rule pivot_element");
    RewriteRuleSubtreeStream<ImplTraits> stream_pivot_key(get_psrstate()->get_treeAdaptor(), "rule pivot_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_pivot_for_clause(get_psrstate()->get_treeAdaptor(), "rule pivot_for_clause");
    RewriteRuleSubtreeStream<ImplTraits> stream_xml_key(get_psrstate()->get_treeAdaptor(), "rule xml_key");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:353:5: ( pivot_key ( xml_key )? LEFT_PAREN pivot_element ( COMMA pivot_element )* pivot_for_clause pivot_in_clause RIGHT_PAREN -> ^( pivot_key ( xml_key )? LEFT_PAREN ( pivot_element )+ pivot_for_clause pivot_in_clause RIGHT_PAREN ) )
        // OracleDML.g:353:10: pivot_key ( xml_key )? LEFT_PAREN pivot_element ( COMMA pivot_element )* pivot_for_clause pivot_in_clause RIGHT_PAREN
        {
            this->followPush(FOLLOW_pivot_key_in_pivot_clause3038);
            pivot_key190=pivot_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulepivot_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                pivot_key190_last = pivot_key190.tree.get();
                stream_pivot_key.add(pivot_key190.tree);
            }

            // OracleDML.g:353:20: ( xml_key )?
            {
                ANTLR_UINT32 alt70=2;
                {
                    ANTLR_UINT32 LA70_0 = this->LA(1);
                    if ( (LA70_0 == REGULAR_ID) && ((toUpper(LT(1)->getText()) == "XML")))
                    {
                        alt70=1;
                    }
                }
                switch (alt70)
                {
            	case 1:
            	    // OracleDML.g:353:20: xml_key
            	    {
            	        this->followPush(FOLLOW_xml_key_in_pivot_clause3040);
            	        xml_key191=xml_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulepivot_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            xml_key191_last = xml_key191.tree.get();
            	            stream_xml_key.add(xml_key191.tree);
            	        }

            	    }
            	    break;

                }
            }

            LEFT_PAREN192 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_pivot_clause3051);
            if  (this->hasException())
            {
                goto rulepivot_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_LEFT_PAREN.add(LEFT_PAREN192);


            this->followPush(FOLLOW_pivot_element_in_pivot_clause3065);
            pivot_element193=pivot_element();

            this->followPop();
            if  (this->hasException())
            {
                goto rulepivot_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                pivot_element193_last = pivot_element193.tree.get();
                stream_pivot_element.add(pivot_element193.tree);
            }

            // OracleDML.g:355:27: ( COMMA pivot_element )*

            for (;;)
            {
                ANTLR_UINT32 alt71=2;
                switch ( this->LA(1) )
                {
                case COMMA:
                	{
                		alt71=1;
                	}
                    break;

                }

                switch (alt71)
                {
            	case 1:
            	    // OracleDML.g:355:28: COMMA pivot_element
            	    {
            	        COMMA194 =  this->matchToken(COMMA, &FOLLOW_COMMA_in_pivot_clause3068);
            	        if  (this->hasException())
            	        {
            	            goto rulepivot_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( this->get_backtracking()==0 ) stream_COMMA.add(COMMA194);


            	        this->followPush(FOLLOW_pivot_element_in_pivot_clause3070);
            	        pivot_element195=pivot_element();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulepivot_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            pivot_element195_last = pivot_element195.tree.get();
            	            stream_pivot_element.add(pivot_element195.tree);
            	        }

            	    }
            	    break;

            	default:
            	    goto loop71;	/* break out of the loop */
            	    break;
                }
            }
            loop71: ; /* Jump out to here if this rule does not match */


            this->followPush(FOLLOW_pivot_for_clause_in_pivot_clause3086);
            pivot_for_clause196=pivot_for_clause();

            this->followPop();
            if  (this->hasException())
            {
                goto rulepivot_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                pivot_for_clause196_last = pivot_for_clause196.tree.get();
                stream_pivot_for_clause.add(pivot_for_clause196.tree);
            }

            this->followPush(FOLLOW_pivot_in_clause_in_pivot_clause3100);
            pivot_in_clause197=pivot_in_clause();

            this->followPop();
            if  (this->hasException())
            {
                goto rulepivot_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                pivot_in_clause197_last = pivot_in_clause197.tree.get();
                stream_pivot_in_clause.add(pivot_in_clause197.tree);
            }

            RIGHT_PAREN198 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_pivot_clause3112);
            if  (this->hasException())
            {
                goto rulepivot_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN198);


            // AST REWRITE
            // elements: pivot_key, LEFT_PAREN, pivot_element, RIGHT_PAREN, xml_key, pivot_in_clause, pivot_for_clause
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 359:9: -> ^( pivot_key ( xml_key )? LEFT_PAREN ( pivot_element )+ pivot_for_clause pivot_in_clause RIGHT_PAREN )
            {
            	// OracleDML.g:359:12: ^( pivot_key ( xml_key )? LEFT_PAREN ( pivot_element )+ pivot_for_clause pivot_in_clause RIGHT_PAREN )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(stream_pivot_key.nextNode(), root_1);
            	// OracleDML.g:359:24: ( xml_key )?
            	if ( stream_xml_key.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_xml_key.nextTree());
            	}
            	stream_xml_key.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_LEFT_PAREN.nextNode());
            	if ( !(stream_pivot_element.hasNext()) ) {
            		ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, REWRITE_EARLY_EXCEPTION, StreamType>( this->get_rec(), "pivot_element empty" );
            		goto rulepivot_clauseEx;
            	}
            	while ( stream_pivot_element.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_pivot_element.nextTree());
            	}
            	stream_pivot_element.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_pivot_for_clause.nextTree());
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_pivot_in_clause.nextTree());
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_RIGHT_PAREN.nextNode());
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulepivot_clauseEx; /* Prevent compiler warnings */
    rulepivot_clauseEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end pivot_clause */

/**
 * $ANTLR start pivot_element
 * OracleDML.g:362:1: pivot_element : aggregate_function_name LEFT_PAREN expression RIGHT_PAREN ( column_alias )? -> ^( PIVOT_ELEMENT ^( EXPR ^( ROUTINE_CALL aggregate_function_name ^( ARGUMENTS[$LEFT_PAREN] ^( ARGUMENT ^( EXPR expression ) ) RIGHT_PAREN ) ) ) ( column_alias )? ) ;
 */
OracleDML::pivot_element_return
OracleDML::pivot_element()
{
    OracleDML::pivot_element_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* LEFT_PAREN200 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN202 = NULL;
    OracleDML_OracleDMLCommons::aggregate_function_name_return aggregate_function_name199;
    ImplTraits::TreeTypePtr::pointer aggregate_function_name199_last = NULL;
    OracleDML::expression_return expression201;
    ImplTraits::TreeTypePtr::pointer expression201_last = NULL;
    OracleDML_OracleDMLCommons::column_alias_return column_alias203;
    ImplTraits::TreeTypePtr::pointer column_alias203_last = NULL;
    ImplTraits::TreeTypePtr LEFT_PAREN200_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN202_tree;
    RewriteRuleTokenStream<ImplTraits> stream_LEFT_PAREN(get_psrstate()->get_treeAdaptor(), "token LEFT_PAREN");
    RewriteRuleTokenStream<ImplTraits> stream_RIGHT_PAREN(get_psrstate()->get_treeAdaptor(), "token RIGHT_PAREN");
    RewriteRuleSubtreeStream<ImplTraits> stream_expression(get_psrstate()->get_treeAdaptor(), "rule expression");
    RewriteRuleSubtreeStream<ImplTraits> stream_column_alias(get_psrstate()->get_treeAdaptor(), "rule column_alias");
    RewriteRuleSubtreeStream<ImplTraits> stream_aggregate_function_name(get_psrstate()->get_treeAdaptor(), "rule aggregate_function_name");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:363:5: ( aggregate_function_name LEFT_PAREN expression RIGHT_PAREN ( column_alias )? -> ^( PIVOT_ELEMENT ^( EXPR ^( ROUTINE_CALL aggregate_function_name ^( ARGUMENTS[$LEFT_PAREN] ^( ARGUMENT ^( EXPR expression ) ) RIGHT_PAREN ) ) ) ( column_alias )? ) )
        // OracleDML.g:363:10: aggregate_function_name LEFT_PAREN expression RIGHT_PAREN ( column_alias )?
        {
            this->followPush(FOLLOW_aggregate_function_name_in_pivot_element3160);
            aggregate_function_name199=aggregate_function_name();

            this->followPop();
            if  (this->hasException())
            {
                goto rulepivot_elementEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                aggregate_function_name199_last = aggregate_function_name199.tree.get();
                stream_aggregate_function_name.add(aggregate_function_name199.tree);
            }

            LEFT_PAREN200 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_pivot_element3162);
            if  (this->hasException())
            {
                goto rulepivot_elementEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_LEFT_PAREN.add(LEFT_PAREN200);


            this->followPush(FOLLOW_expression_in_pivot_element3164);
            expression201=expression();

            this->followPop();
            if  (this->hasException())
            {
                goto rulepivot_elementEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                expression201_last = expression201.tree.get();
                stream_expression.add(expression201.tree);
            }

            RIGHT_PAREN202 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_pivot_element3166);
            if  (this->hasException())
            {
                goto rulepivot_elementEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN202);


            // OracleDML.g:363:68: ( column_alias )?
            {
                ANTLR_UINT32 alt72=2;
                switch ( this->LA(1) )
                {
                    case CHAR_STRING:
                    case CHAR_STRING_PERL:
                    case DELIMITED_ID:
                    case INTRODUCER:
                    case NATIONAL_CHAR_STRING_LIT:
                    case REGULAR_ID:
                    case SQL92_RESERVED_AS:
                    	{
                    		alt72=1;
                    	}
                        break;
                }

                switch (alt72)
                {
            	case 1:
            	    // OracleDML.g:363:68: column_alias
            	    {
            	        this->followPush(FOLLOW_column_alias_in_pivot_element3168);
            	        column_alias203=column_alias();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulepivot_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            column_alias203_last = column_alias203.tree.get();
            	            stream_column_alias.add(column_alias203.tree);
            	        }

            	    }
            	    break;

                }
            }

            // AST REWRITE
            // elements: RIGHT_PAREN, aggregate_function_name, expression, column_alias
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 364:9: -> ^( PIVOT_ELEMENT ^( EXPR ^( ROUTINE_CALL aggregate_function_name ^( ARGUMENTS[$LEFT_PAREN] ^( ARGUMENT ^( EXPR expression ) ) RIGHT_PAREN ) ) ) ( column_alias )? )
            {
            	// OracleDML.g:364:12: ^( PIVOT_ELEMENT ^( EXPR ^( ROUTINE_CALL aggregate_function_name ^( ARGUMENTS[$LEFT_PAREN] ^( ARGUMENT ^( EXPR expression ) ) RIGHT_PAREN ) ) ) ( column_alias )? )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(PIVOT_ELEMENT, "PIVOT_ELEMENT"), root_1);
            	// OracleDML.g:364:28: ^( EXPR ^( ROUTINE_CALL aggregate_function_name ^( ARGUMENTS[$LEFT_PAREN] ^( ARGUMENT ^( EXPR expression ) ) RIGHT_PAREN ) ) )
            	{
            	ImplTraits::TreeTypePtr root_2 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_2 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(EXPR, "EXPR"), root_2);
            	// OracleDML.g:364:35: ^( ROUTINE_CALL aggregate_function_name ^( ARGUMENTS[$LEFT_PAREN] ^( ARGUMENT ^( EXPR expression ) ) RIGHT_PAREN ) )
            	{
            	ImplTraits::TreeTypePtr root_3 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_3 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(ROUTINE_CALL, "ROUTINE_CALL"), root_3);
            	get_psrstate()->get_treeAdaptor()->addChild(root_3, stream_aggregate_function_name.nextTree());
            	// OracleDML.g:364:74: ^( ARGUMENTS[$LEFT_PAREN] ^( ARGUMENT ^( EXPR expression ) ) RIGHT_PAREN )
            	{
            	ImplTraits::TreeTypePtr root_4 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_4 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(ARGUMENTS, LEFT_PAREN200), root_4);
            	// OracleDML.g:364:99: ^( ARGUMENT ^( EXPR expression ) )
            	{
            	ImplTraits::TreeTypePtr root_5 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_5 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(ARGUMENT, "ARGUMENT"), root_5);
            	// OracleDML.g:364:110: ^( EXPR expression )
            	{
            	ImplTraits::TreeTypePtr root_6 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_6 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(EXPR, "EXPR"), root_6);
            	get_psrstate()->get_treeAdaptor()->addChild(root_6, stream_expression.nextTree());
            	get_psrstate()->get_treeAdaptor()->addChild(root_5, root_6);
            	}
            	get_psrstate()->get_treeAdaptor()->addChild(root_4, root_5);
            	}
            	get_psrstate()->get_treeAdaptor()->addChild(root_4, stream_RIGHT_PAREN.nextNode());
            	get_psrstate()->get_treeAdaptor()->addChild(root_3, root_4);
            	}
            	get_psrstate()->get_treeAdaptor()->addChild(root_2, root_3);
            	}
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, root_2);
            	}
            	// OracleDML.g:364:145: ( column_alias )?
            	if ( stream_column_alias.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_column_alias.nextTree());
            	}
            	stream_column_alias.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulepivot_elementEx; /* Prevent compiler warnings */
    rulepivot_elementEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end pivot_element */

/**
 * $ANTLR start pivot_for_clause
 * OracleDML.g:367:1: pivot_for_clause : for_key ( column_name | LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN ) -> ^( for_key LEFT_PAREN ( column_name )+ RIGHT_PAREN ) ;
 */
OracleDML::pivot_for_clause_return
OracleDML::pivot_for_clause()
{
    OracleDML::pivot_for_clause_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* LEFT_PAREN206 = NULL;
    ImplTraits::CommonTokenType const* COMMA208 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN210 = NULL;
    OracleDML_OracleDMLKeys::for_key_return for_key204;
    ImplTraits::TreeTypePtr::pointer for_key204_last = NULL;
    OracleDML_OracleDMLCommons::column_name_return column_name205;
    ImplTraits::TreeTypePtr::pointer column_name205_last = NULL;
    OracleDML_OracleDMLCommons::column_name_return column_name207;
    ImplTraits::TreeTypePtr::pointer column_name207_last = NULL;
    OracleDML_OracleDMLCommons::column_name_return column_name209;
    ImplTraits::TreeTypePtr::pointer column_name209_last = NULL;
    ImplTraits::TreeTypePtr LEFT_PAREN206_tree;
    ImplTraits::TreeTypePtr COMMA208_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN210_tree;
    RewriteRuleTokenStream<ImplTraits> stream_LEFT_PAREN(get_psrstate()->get_treeAdaptor(), "token LEFT_PAREN");
    RewriteRuleTokenStream<ImplTraits> stream_RIGHT_PAREN(get_psrstate()->get_treeAdaptor(), "token RIGHT_PAREN");
    RewriteRuleTokenStream<ImplTraits> stream_COMMA(get_psrstate()->get_treeAdaptor(), "token COMMA");
    RewriteRuleSubtreeStream<ImplTraits> stream_column_name(get_psrstate()->get_treeAdaptor(), "rule column_name");
    RewriteRuleSubtreeStream<ImplTraits> stream_for_key(get_psrstate()->get_treeAdaptor(), "rule for_key");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:368:5: ( for_key ( column_name | LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN ) -> ^( for_key LEFT_PAREN ( column_name )+ RIGHT_PAREN ) )
        // OracleDML.g:368:10: for_key ( column_name | LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN )
        {
            this->followPush(FOLLOW_for_key_in_pivot_for_clause3233);
            for_key204=for_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulepivot_for_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                for_key204_last = for_key204.tree.get();
                stream_for_key.add(for_key204.tree);
            }

            // OracleDML.g:369:5: ( column_name | LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN )
            {
                ANTLR_UINT32 alt74=2;
                switch ( this->LA(1) )
                {
                case DELIMITED_ID:
                case INTRODUCER:
                case REGULAR_ID:
                	{
                		alt74=1;
                	}
                    break;
                case LEFT_PAREN:
                	{
                		alt74=2;
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return retval;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 74 );
                    ex->set_state( 0 );


                    goto rulepivot_for_clauseEx;

                }

                switch (alt74)
                {
            	case 1:
            	    // OracleDML.g:369:10: column_name
            	    {
            	        this->followPush(FOLLOW_column_name_in_pivot_for_clause3245);
            	        column_name205=column_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulepivot_for_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            column_name205_last = column_name205.tree.get();
            	            stream_column_name.add(column_name205.tree);
            	        }

            	    }
            	    break;
            	case 2:
            	    // OracleDML.g:370:10: LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN
            	    {
            	        LEFT_PAREN206 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_pivot_for_clause3256);
            	        if  (this->hasException())
            	        {
            	            goto rulepivot_for_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( this->get_backtracking()==0 ) stream_LEFT_PAREN.add(LEFT_PAREN206);


            	        this->followPush(FOLLOW_column_name_in_pivot_for_clause3258);
            	        column_name207=column_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulepivot_for_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            column_name207_last = column_name207.tree.get();
            	            stream_column_name.add(column_name207.tree);
            	        }

            	        // OracleDML.g:370:33: ( COMMA column_name )*

            	        for (;;)
            	        {
            	            ANTLR_UINT32 alt73=2;
            	            switch ( this->LA(1) )
            	            {
            	            case COMMA:
            	            	{
            	            		alt73=1;
            	            	}
            	                break;

            	            }

            	            switch (alt73)
            	            {
            	        	case 1:
            	        	    // OracleDML.g:370:34: COMMA column_name
            	        	    {
            	        	        COMMA208 =  this->matchToken(COMMA, &FOLLOW_COMMA_in_pivot_for_clause3261);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulepivot_for_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }
            	        	         
            	        	        if ( this->get_backtracking()==0 ) stream_COMMA.add(COMMA208);


            	        	        this->followPush(FOLLOW_column_name_in_pivot_for_clause3263);
            	        	        column_name209=column_name();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulepivot_for_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) 
            	        	        {
            	        	            column_name209_last = column_name209.tree.get();
            	        	            stream_column_name.add(column_name209.tree);
            	        	        }

            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop73;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop73: ; /* Jump out to here if this rule does not match */


            	        RIGHT_PAREN210 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_pivot_for_clause3267);
            	        if  (this->hasException())
            	        {
            	            goto rulepivot_for_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( this->get_backtracking()==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN210);


            	    }
            	    break;

                }
            }

            // AST REWRITE
            // elements: RIGHT_PAREN, LEFT_PAREN, for_key, column_name
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 372:9: -> ^( for_key LEFT_PAREN ( column_name )+ RIGHT_PAREN )
            {
            	// OracleDML.g:372:12: ^( for_key LEFT_PAREN ( column_name )+ RIGHT_PAREN )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(stream_for_key.nextNode(), root_1);
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_LEFT_PAREN.nextNode());
            	if ( !(stream_column_name.hasNext()) ) {
            		ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, REWRITE_EARLY_EXCEPTION, StreamType>( this->get_rec(), "column_name empty" );
            		goto rulepivot_for_clauseEx;
            	}
            	while ( stream_column_name.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_column_name.nextTree());
            	}
            	stream_column_name.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_RIGHT_PAREN.nextNode());
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulepivot_for_clauseEx; /* Prevent compiler warnings */
    rulepivot_for_clauseEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end pivot_for_clause */

/**
 * $ANTLR start pivot_in_clause
 * OracleDML.g:375:1: pivot_in_clause : in_key LEFT_PAREN ( ( select_key )=> subquery | ( any_key )=> any_key ( COMMA any_key )* | pivot_in_clause_element ( COMMA pivot_in_clause_element )* ) RIGHT_PAREN -> {mode == 1}? ^( in_key subquery ) -> {mode == 2}? ^( in_key ^( ANY_MODE ( any_key )+ ) ) -> ^( in_key ^( ELEMENTS_MODE ( pivot_in_clause_element )+ ) ) ;
 */
OracleDML::pivot_in_clause_return
OracleDML::pivot_in_clause()
{
    OracleDML::pivot_in_clause_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* LEFT_PAREN212 = NULL;
    ImplTraits::CommonTokenType const* COMMA215 = NULL;
    ImplTraits::CommonTokenType const* COMMA218 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN220 = NULL;
    OracleDML_OracleDMLKeys::in_key_return in_key211;
    ImplTraits::TreeTypePtr::pointer in_key211_last = NULL;
    OracleDML::subquery_return subquery213;
    ImplTraits::TreeTypePtr::pointer subquery213_last = NULL;
    OracleDML_OracleDMLKeys::any_key_return any_key214;
    ImplTraits::TreeTypePtr::pointer any_key214_last = NULL;
    OracleDML_OracleDMLKeys::any_key_return any_key216;
    ImplTraits::TreeTypePtr::pointer any_key216_last = NULL;
    OracleDML::pivot_in_clause_element_return pivot_in_clause_element217;
    ImplTraits::TreeTypePtr::pointer pivot_in_clause_element217_last = NULL;
    OracleDML::pivot_in_clause_element_return pivot_in_clause_element219;
    ImplTraits::TreeTypePtr::pointer pivot_in_clause_element219_last = NULL;
    ImplTraits::TreeTypePtr LEFT_PAREN212_tree;
    ImplTraits::TreeTypePtr COMMA215_tree;
    ImplTraits::TreeTypePtr COMMA218_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN220_tree;
    RewriteRuleTokenStream<ImplTraits> stream_LEFT_PAREN(get_psrstate()->get_treeAdaptor(), "token LEFT_PAREN");
    RewriteRuleTokenStream<ImplTraits> stream_RIGHT_PAREN(get_psrstate()->get_treeAdaptor(), "token RIGHT_PAREN");
    RewriteRuleTokenStream<ImplTraits> stream_COMMA(get_psrstate()->get_treeAdaptor(), "token COMMA");
    RewriteRuleSubtreeStream<ImplTraits> stream_any_key(get_psrstate()->get_treeAdaptor(), "rule any_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_pivot_in_clause_element(get_psrstate()->get_treeAdaptor(), "rule pivot_in_clause_element");
    RewriteRuleSubtreeStream<ImplTraits> stream_in_key(get_psrstate()->get_treeAdaptor(), "rule in_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_subquery(get_psrstate()->get_treeAdaptor(), "rule subquery");

    /* Initialize rule variables
     */

        int mode = 0;    
    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:377:5: ( in_key LEFT_PAREN ( ( select_key )=> subquery | ( any_key )=> any_key ( COMMA any_key )* | pivot_in_clause_element ( COMMA pivot_in_clause_element )* ) RIGHT_PAREN -> {mode == 1}? ^( in_key subquery ) -> {mode == 2}? ^( in_key ^( ANY_MODE ( any_key )+ ) ) -> ^( in_key ^( ELEMENTS_MODE ( pivot_in_clause_element )+ ) ) )
        // OracleDML.g:377:10: in_key LEFT_PAREN ( ( select_key )=> subquery | ( any_key )=> any_key ( COMMA any_key )* | pivot_in_clause_element ( COMMA pivot_in_clause_element )* ) RIGHT_PAREN
        {
            this->followPush(FOLLOW_in_key_in_pivot_in_clause3322);
            in_key211=in_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulepivot_in_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                in_key211_last = in_key211.tree.get();
                stream_in_key.add(in_key211.tree);
            }

            LEFT_PAREN212 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_pivot_in_clause3332);
            if  (this->hasException())
            {
                goto rulepivot_in_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_LEFT_PAREN.add(LEFT_PAREN212);


            // OracleDML.g:379:13: ( ( select_key )=> subquery | ( any_key )=> any_key ( COMMA any_key )* | pivot_in_clause_element ( COMMA pivot_in_clause_element )* )
            {
                ANTLR_UINT32 alt77=3;
                {
                    ANTLR_UINT32 LA77_0 = this->LA(1);
                    if ( (LA77_0 == SQL92_RESERVED_SELECT) && (this->msynpred( antlr3::ClassForwarder<synpred12_OracleDML>() )))
                    {
                        alt77=1;
                    }
                    else if ( (LA77_0 == LEFT_PAREN))
                    {
                        {
                            ANTLR_UINT32 LA77_2 = this->LA(2);
                            if ( (this->msynpred( antlr3::ClassForwarder<synpred12_OracleDML>() )))
                            {
                                alt77=1;
                            }
                            else if ( (true))
                            {
                                alt77=3;
                            }
                            else
                            {
                                if (this->get_backtracking()>0)
                                {
                                    this->set_failedflag( true );
                                    return retval;
                                }


                                ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                ex->set_decisionNum( 77 );
                                ex->set_state( 2 );


                                goto rulepivot_in_clauseEx;

                            }
                        }
                    }
                    else if ( (LA77_0 == SQL92_RESERVED_ANY))
                    {
                        {
                            ANTLR_UINT32 LA77_3 = this->LA(2);
                            if ( (this->msynpred( antlr3::ClassForwarder<synpred13_OracleDML>() )))
                            {
                                alt77=2;
                            }
                            else if ( (true))
                            {
                                alt77=3;
                            }
                            else
                            {
                                if (this->get_backtracking()>0)
                                {
                                    this->set_failedflag( true );
                                    return retval;
                                }


                                ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                ex->set_decisionNum( 77 );
                                ex->set_state( 3 );


                                goto rulepivot_in_clauseEx;

                            }
                        }
                    }
                    else if ( (LA77_0 == APPROXIMATE_NUM_LIT || LA77_0 == BINDVAR || ((LA77_0 >= CHAR_STRING) && (LA77_0 <= CHAR_STRING_PERL)) || LA77_0 == COLON || LA77_0 == DELIMITED_ID || LA77_0 == EXACT_NUM_LIT || LA77_0 == INTRODUCER || LA77_0 == MINUS_SIGN || LA77_0 == NATIONAL_CHAR_STRING_LIT || ((LA77_0 >= PLSQL_NON_RESERVED_CAST) && (LA77_0 <= PLSQL_NON_RESERVED_CONNECT_BY_ROOT)) || LA77_0 == PLUS_SIGN || LA77_0 == REGULAR_ID || LA77_0 == SQL92_RESERVED_ALL || LA77_0 == SQL92_RESERVED_CASE || ((LA77_0 >= SQL92_RESERVED_CURSOR) && (LA77_0 <= SQL92_RESERVED_DATE)) || LA77_0 == SQL92_RESERVED_DEFAULT || LA77_0 == SQL92_RESERVED_DISTINCT || ((LA77_0 >= SQL92_RESERVED_EXISTS) && (LA77_0 <= SQL92_RESERVED_FALSE)) || ((LA77_0 >= SQL92_RESERVED_NOT) && (LA77_0 <= SQL92_RESERVED_NULL)) || LA77_0 == SQL92_RESERVED_PRIOR || LA77_0 == SQL92_RESERVED_TRUE || LA77_0 == UNSIGNED_INTEGER))
                    {
                        alt77=3;
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return retval;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 77 );
                        ex->set_state( 0 );


                        goto rulepivot_in_clauseEx;

                    }
                }
                switch (alt77)
                {
            	case 1:
            	    // OracleDML.g:379:18: ( select_key )=> subquery
            	    {
            	        this->followPush(FOLLOW_subquery_in_pivot_in_clause3356);
            	        subquery213=subquery();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulepivot_in_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            subquery213_last = subquery213.tree.get();
            	            stream_subquery.add(subquery213.tree);
            	        }

            	        if ( this->get_backtracking()==0 )
            	        {
            	            mode = 1;
            	        }


            	    }
            	    break;
            	case 2:
            	    // OracleDML.g:380:18: ( any_key )=> any_key ( COMMA any_key )*
            	    {
            	        this->followPush(FOLLOW_any_key_in_pivot_in_clause3382);
            	        any_key214=any_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulepivot_in_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            any_key214_last = any_key214.tree.get();
            	            stream_any_key.add(any_key214.tree);
            	        }

            	        // OracleDML.g:380:38: ( COMMA any_key )*

            	        for (;;)
            	        {
            	            ANTLR_UINT32 alt75=2;
            	            switch ( this->LA(1) )
            	            {
            	            case COMMA:
            	            	{
            	            		alt75=1;
            	            	}
            	                break;

            	            }

            	            switch (alt75)
            	            {
            	        	case 1:
            	        	    // OracleDML.g:380:39: COMMA any_key
            	        	    {
            	        	        COMMA215 =  this->matchToken(COMMA, &FOLLOW_COMMA_in_pivot_in_clause3385);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulepivot_in_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }
            	        	         
            	        	        if ( this->get_backtracking()==0 ) stream_COMMA.add(COMMA215);


            	        	        this->followPush(FOLLOW_any_key_in_pivot_in_clause3387);
            	        	        any_key216=any_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulepivot_in_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) 
            	        	        {
            	        	            any_key216_last = any_key216.tree.get();
            	        	            stream_any_key.add(any_key216.tree);
            	        	        }

            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop75;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop75: ; /* Jump out to here if this rule does not match */


            	        if ( this->get_backtracking()==0 )
            	        {
            	            mode = 2;
            	        }


            	    }
            	    break;
            	case 3:
            	    // OracleDML.g:381:18: pivot_in_clause_element ( COMMA pivot_in_clause_element )*
            	    {
            	        this->followPush(FOLLOW_pivot_in_clause_element_in_pivot_in_clause3410);
            	        pivot_in_clause_element217=pivot_in_clause_element();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulepivot_in_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            pivot_in_clause_element217_last = pivot_in_clause_element217.tree.get();
            	            stream_pivot_in_clause_element.add(pivot_in_clause_element217.tree);
            	        }

            	        // OracleDML.g:381:42: ( COMMA pivot_in_clause_element )*

            	        for (;;)
            	        {
            	            ANTLR_UINT32 alt76=2;
            	            switch ( this->LA(1) )
            	            {
            	            case COMMA:
            	            	{
            	            		alt76=1;
            	            	}
            	                break;

            	            }

            	            switch (alt76)
            	            {
            	        	case 1:
            	        	    // OracleDML.g:381:43: COMMA pivot_in_clause_element
            	        	    {
            	        	        COMMA218 =  this->matchToken(COMMA, &FOLLOW_COMMA_in_pivot_in_clause3413);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulepivot_in_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }
            	        	         
            	        	        if ( this->get_backtracking()==0 ) stream_COMMA.add(COMMA218);


            	        	        this->followPush(FOLLOW_pivot_in_clause_element_in_pivot_in_clause3415);
            	        	        pivot_in_clause_element219=pivot_in_clause_element();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulepivot_in_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) 
            	        	        {
            	        	            pivot_in_clause_element219_last = pivot_in_clause_element219.tree.get();
            	        	            stream_pivot_in_clause_element.add(pivot_in_clause_element219.tree);
            	        	        }

            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop76;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop76: ; /* Jump out to here if this rule does not match */


            	    }
            	    break;

                }
            }

            RIGHT_PAREN220 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_pivot_in_clause3441);
            if  (this->hasException())
            {
                goto rulepivot_in_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN220);


            // AST REWRITE
            // elements: subquery, in_key, in_key, pivot_in_clause_element, in_key, any_key
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 384:9: -> {mode == 1}? ^( in_key subquery )
            if (mode == 1) {
            	// OracleDML.g:384:24: ^( in_key subquery )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(stream_in_key.nextNode(), root_1);
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_subquery.nextTree());
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }

            else // 385:9: -> {mode == 2}? ^( in_key ^( ANY_MODE ( any_key )+ ) )
            if (mode == 2) {
            	// OracleDML.g:385:24: ^( in_key ^( ANY_MODE ( any_key )+ ) )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(stream_in_key.nextNode(), root_1);
            	// OracleDML.g:385:33: ^( ANY_MODE ( any_key )+ )
            	{
            	ImplTraits::TreeTypePtr root_2 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_2 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(ANY_MODE, "ANY_MODE"), root_2);
            	if ( !(stream_any_key.hasNext()) ) {
            		ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, REWRITE_EARLY_EXCEPTION, StreamType>( this->get_rec(), "any_key empty" );
            		goto rulepivot_in_clauseEx;
            	}
            	while ( stream_any_key.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_2, stream_any_key.nextTree());
            	}
            	stream_any_key.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_1, root_2);
            	}
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }

            else // 386:9: -> ^( in_key ^( ELEMENTS_MODE ( pivot_in_clause_element )+ ) )
            {
            	// OracleDML.g:386:12: ^( in_key ^( ELEMENTS_MODE ( pivot_in_clause_element )+ ) )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(stream_in_key.nextNode(), root_1);
            	// OracleDML.g:386:21: ^( ELEMENTS_MODE ( pivot_in_clause_element )+ )
            	{
            	ImplTraits::TreeTypePtr root_2 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_2 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(ELEMENTS_MODE, "ELEMENTS_MODE"), root_2);
            	if ( !(stream_pivot_in_clause_element.hasNext()) ) {
            		ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, REWRITE_EARLY_EXCEPTION, StreamType>( this->get_rec(), "pivot_in_clause_element empty" );
            		goto rulepivot_in_clauseEx;
            	}
            	while ( stream_pivot_in_clause_element.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_2, stream_pivot_in_clause_element.nextTree());
            	}
            	stream_pivot_in_clause_element.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_1, root_2);
            	}
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulepivot_in_clauseEx; /* Prevent compiler warnings */
    rulepivot_in_clauseEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end pivot_in_clause */

/**
 * $ANTLR start pivot_in_clause_element
 * OracleDML.g:389:1: pivot_in_clause_element : pivot_in_clause_elements ( column_alias )? -> ^( PIVOT_IN_ELEMENT pivot_in_clause_elements ( column_alias )? ) ;
 */
OracleDML::pivot_in_clause_element_return
OracleDML::pivot_in_clause_element()
{
    OracleDML::pivot_in_clause_element_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML::pivot_in_clause_elements_return pivot_in_clause_elements221;
    ImplTraits::TreeTypePtr::pointer pivot_in_clause_elements221_last = NULL;
    OracleDML_OracleDMLCommons::column_alias_return column_alias222;
    ImplTraits::TreeTypePtr::pointer column_alias222_last = NULL;
    RewriteRuleSubtreeStream<ImplTraits> stream_column_alias(get_psrstate()->get_treeAdaptor(), "rule column_alias");
    RewriteRuleSubtreeStream<ImplTraits> stream_pivot_in_clause_elements(get_psrstate()->get_treeAdaptor(), "rule pivot_in_clause_elements");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:390:5: ( pivot_in_clause_elements ( column_alias )? -> ^( PIVOT_IN_ELEMENT pivot_in_clause_elements ( column_alias )? ) )
        // OracleDML.g:390:10: pivot_in_clause_elements ( column_alias )?
        {
            this->followPush(FOLLOW_pivot_in_clause_elements_in_pivot_in_clause_element3521);
            pivot_in_clause_elements221=pivot_in_clause_elements();

            this->followPop();
            if  (this->hasException())
            {
                goto rulepivot_in_clause_elementEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                pivot_in_clause_elements221_last = pivot_in_clause_elements221.tree.get();
                stream_pivot_in_clause_elements.add(pivot_in_clause_elements221.tree);
            }

            // OracleDML.g:390:35: ( column_alias )?
            {
                ANTLR_UINT32 alt78=2;
                switch ( this->LA(1) )
                {
                    case CHAR_STRING:
                    case CHAR_STRING_PERL:
                    case DELIMITED_ID:
                    case INTRODUCER:
                    case NATIONAL_CHAR_STRING_LIT:
                    case REGULAR_ID:
                    case SQL92_RESERVED_AS:
                    	{
                    		alt78=1;
                    	}
                        break;
                }

                switch (alt78)
                {
            	case 1:
            	    // OracleDML.g:390:35: column_alias
            	    {
            	        this->followPush(FOLLOW_column_alias_in_pivot_in_clause_element3523);
            	        column_alias222=column_alias();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulepivot_in_clause_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            column_alias222_last = column_alias222.tree.get();
            	            stream_column_alias.add(column_alias222.tree);
            	        }

            	    }
            	    break;

                }
            }

            // AST REWRITE
            // elements: pivot_in_clause_elements, column_alias
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 391:9: -> ^( PIVOT_IN_ELEMENT pivot_in_clause_elements ( column_alias )? )
            {
            	// OracleDML.g:391:12: ^( PIVOT_IN_ELEMENT pivot_in_clause_elements ( column_alias )? )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(PIVOT_IN_ELEMENT, "PIVOT_IN_ELEMENT"), root_1);
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_pivot_in_clause_elements.nextTree());
            	// OracleDML.g:391:56: ( column_alias )?
            	if ( stream_column_alias.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_column_alias.nextTree());
            	}
            	stream_column_alias.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulepivot_in_clause_elementEx; /* Prevent compiler warnings */
    rulepivot_in_clause_elementEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end pivot_in_clause_element */

/**
 * $ANTLR start pivot_in_clause_elements
 * OracleDML.g:394:1: pivot_in_clause_elements : ( expression -> ^( EXPR expression ) | ( LEFT_PAREN )=> expression_list );
 */
OracleDML::pivot_in_clause_elements_return
OracleDML::pivot_in_clause_elements()
{
    OracleDML::pivot_in_clause_elements_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML::expression_return expression223;
    ImplTraits::TreeTypePtr::pointer expression223_last = NULL;
    OracleDML::expression_list_return expression_list224;
    ImplTraits::TreeTypePtr::pointer expression_list224_last = NULL;
    RewriteRuleSubtreeStream<ImplTraits> stream_expression(get_psrstate()->get_treeAdaptor(), "rule expression");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        {
            //  OracleDML.g:395:5: ( expression -> ^( EXPR expression ) | ( LEFT_PAREN )=> expression_list )

            ANTLR_UINT32 alt79;

            alt79=2;

            switch ( this->LA(1) )
            {
            case APPROXIMATE_NUM_LIT:
            case BINDVAR:
            case CHAR_STRING:
            case CHAR_STRING_PERL:
            case COLON:
            case DELIMITED_ID:
            case EXACT_NUM_LIT:
            case INTRODUCER:
            case MINUS_SIGN:
            case NATIONAL_CHAR_STRING_LIT:
            case PLSQL_NON_RESERVED_CAST:
            case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
            case PLUS_SIGN:
            case REGULAR_ID:
            case SQL92_RESERVED_ALL:
            case SQL92_RESERVED_ANY:
            case SQL92_RESERVED_CASE:
            case SQL92_RESERVED_CURSOR:
            case SQL92_RESERVED_DATE:
            case SQL92_RESERVED_DEFAULT:
            case SQL92_RESERVED_DISTINCT:
            case SQL92_RESERVED_EXISTS:
            case SQL92_RESERVED_FALSE:
            case SQL92_RESERVED_NOT:
            case SQL92_RESERVED_NULL:
            case SQL92_RESERVED_PRIOR:
            case SQL92_RESERVED_TRUE:
            case UNSIGNED_INTEGER:
            	{
            		alt79=1;
            	}
                break;
            case LEFT_PAREN:
            	{
            		{
            		    ANTLR_UINT32 LA79_25 = this->LA(2);
            		    if ( (true))
            		    {
            		        alt79=1;
            		    }
            		    else if ( (this->msynpred( antlr3::ClassForwarder<synpred14_OracleDML>() )))
            		    {
            		        alt79=2;
            		    }
            		    else
            		    {
            		        if (this->get_backtracking()>0)
            		        {
            		            this->set_failedflag( true );
            		            return retval;
            		        }


            		        ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 79 );
            		        ex->set_state( 25 );


            		        goto rulepivot_in_clause_elementsEx;

            		    }
            		}
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 79 );
                ex->set_state( 0 );


                goto rulepivot_in_clause_elementsEx;

            }

            switch (alt79)
            {
        	case 1:
        	    // OracleDML.g:395:10: expression
        	    {
        	        this->followPush(FOLLOW_expression_in_pivot_in_clause_elements3563);
        	        expression223=expression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulepivot_in_clause_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) 
        	        {
        	            expression223_last = expression223.tree.get();
        	            stream_expression.add(expression223.tree);
        	        }

        	        // AST REWRITE
        	        // elements: expression
        	        // token labels: 
        	        // rule labels: retval
        	        // token list labels: 
        	        // rule list labels: 
        	        // wildcard labels: 
        	        if ( this->get_backtracking()==0 ) {
        	        retval.tree = std::move(root_0);
        	        RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
        	        // 395:21: -> ^( EXPR expression )
        	        {
        	        	// OracleDML.g:395:24: ^( EXPR expression )
        	        	{
        	        	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
        	        	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(EXPR, "EXPR"), root_1);
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_expression.nextTree());
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
        	        	}
        	        }


        	        //retval.tree = std::move(root_0);
        	        }

        	    }
        	    break;
        	case 2:
        	    // OracleDML.g:396:10: ( LEFT_PAREN )=> expression_list
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_expression_list_in_pivot_in_clause_elements3587);
        	        expression_list224=expression_list();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulepivot_in_clause_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, expression_list224.tree);


        	    }
        	    break;

            }
        }
    }//...
    // This is where rules clean up and exit
    //
    goto rulepivot_in_clause_elementsEx; /* Prevent compiler warnings */
    rulepivot_in_clause_elementsEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end pivot_in_clause_elements */

/**
 * $ANTLR start unpivot_clause
 * OracleDML.g:399:1: unpivot_clause : unpivot_key ( ( include_key | exclude_key ) nulls_key )? LEFT_PAREN ( column_name | LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN ) pivot_for_clause unpivot_in_clause RIGHT_PAREN -> ^( unpivot_key ( include_key )? ( exclude_key )? ( nulls_key )? ( column_name )+ pivot_for_clause unpivot_in_clause ) ;
 */
OracleDML::unpivot_clause_return
OracleDML::unpivot_clause()
{
    OracleDML::unpivot_clause_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* LEFT_PAREN229 = NULL;
    ImplTraits::CommonTokenType const* LEFT_PAREN231 = NULL;
    ImplTraits::CommonTokenType const* COMMA233 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN235 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN238 = NULL;
    OracleDML_OracleDMLKeys::unpivot_key_return unpivot_key225;
    ImplTraits::TreeTypePtr::pointer unpivot_key225_last = NULL;
    OracleDML_OracleDMLKeys::include_key_return include_key226;
    ImplTraits::TreeTypePtr::pointer include_key226_last = NULL;
    OracleDML_OracleDMLKeys::exclude_key_return exclude_key227;
    ImplTraits::TreeTypePtr::pointer exclude_key227_last = NULL;
    OracleDML_OracleDMLKeys::nulls_key_return nulls_key228;
    ImplTraits::TreeTypePtr::pointer nulls_key228_last = NULL;
    OracleDML_OracleDMLCommons::column_name_return column_name230;
    ImplTraits::TreeTypePtr::pointer column_name230_last = NULL;
    OracleDML_OracleDMLCommons::column_name_return column_name232;
    ImplTraits::TreeTypePtr::pointer column_name232_last = NULL;
    OracleDML_OracleDMLCommons::column_name_return column_name234;
    ImplTraits::TreeTypePtr::pointer column_name234_last = NULL;
    OracleDML::pivot_for_clause_return pivot_for_clause236;
    ImplTraits::TreeTypePtr::pointer pivot_for_clause236_last = NULL;
    OracleDML::unpivot_in_clause_return unpivot_in_clause237;
    ImplTraits::TreeTypePtr::pointer unpivot_in_clause237_last = NULL;
    ImplTraits::TreeTypePtr LEFT_PAREN229_tree;
    ImplTraits::TreeTypePtr LEFT_PAREN231_tree;
    ImplTraits::TreeTypePtr COMMA233_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN235_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN238_tree;
    RewriteRuleTokenStream<ImplTraits> stream_LEFT_PAREN(get_psrstate()->get_treeAdaptor(), "token LEFT_PAREN");
    RewriteRuleTokenStream<ImplTraits> stream_RIGHT_PAREN(get_psrstate()->get_treeAdaptor(), "token RIGHT_PAREN");
    RewriteRuleTokenStream<ImplTraits> stream_COMMA(get_psrstate()->get_treeAdaptor(), "token COMMA");
    RewriteRuleSubtreeStream<ImplTraits> stream_nulls_key(get_psrstate()->get_treeAdaptor(), "rule nulls_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_exclude_key(get_psrstate()->get_treeAdaptor(), "rule exclude_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_include_key(get_psrstate()->get_treeAdaptor(), "rule include_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_unpivot_key(get_psrstate()->get_treeAdaptor(), "rule unpivot_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_pivot_for_clause(get_psrstate()->get_treeAdaptor(), "rule pivot_for_clause");
    RewriteRuleSubtreeStream<ImplTraits> stream_unpivot_in_clause(get_psrstate()->get_treeAdaptor(), "rule unpivot_in_clause");
    RewriteRuleSubtreeStream<ImplTraits> stream_column_name(get_psrstate()->get_treeAdaptor(), "rule column_name");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:400:5: ( unpivot_key ( ( include_key | exclude_key ) nulls_key )? LEFT_PAREN ( column_name | LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN ) pivot_for_clause unpivot_in_clause RIGHT_PAREN -> ^( unpivot_key ( include_key )? ( exclude_key )? ( nulls_key )? ( column_name )+ pivot_for_clause unpivot_in_clause ) )
        // OracleDML.g:400:10: unpivot_key ( ( include_key | exclude_key ) nulls_key )? LEFT_PAREN ( column_name | LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN ) pivot_for_clause unpivot_in_clause RIGHT_PAREN
        {
            this->followPush(FOLLOW_unpivot_key_in_unpivot_clause3607);
            unpivot_key225=unpivot_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleunpivot_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                unpivot_key225_last = unpivot_key225.tree.get();
                stream_unpivot_key.add(unpivot_key225.tree);
            }

            // OracleDML.g:401:9: ( ( include_key | exclude_key ) nulls_key )?
            {
                ANTLR_UINT32 alt81=2;
                {
                    ANTLR_UINT32 LA81_0 = this->LA(1);
                    if ( (LA81_0 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "INCLUDE"))||((toUpper(LT(1)->getText()) == "EXCLUDE")))))
                    {
                        alt81=1;
                    }
                }
                switch (alt81)
                {
            	case 1:
            	    // OracleDML.g:401:10: ( include_key | exclude_key ) nulls_key
            	    {
            	        // OracleDML.g:401:10: ( include_key | exclude_key )
            	        {
            	            ANTLR_UINT32 alt80=2;
            	            {
            	                ANTLR_UINT32 LA80_0 = this->LA(1);
            	                if ( (LA80_0 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "INCLUDE"))||((toUpper(LT(1)->getText()) == "EXCLUDE")))))
            	                {
            	                    {
            	                        ANTLR_UINT32 LA80_1 = this->LA(2);
            	                        if ( ((toUpper(LT(1)->getText()) == "INCLUDE")))
            	                        {
            	                            alt80=1;
            	                        }
            	                        else if ( ((toUpper(LT(1)->getText()) == "EXCLUDE")))
            	                        {
            	                            alt80=2;
            	                        }
            	                        else
            	                        {
            	                            if (this->get_backtracking()>0)
            	                            {
            	                                this->set_failedflag( true );
            	                                return retval;
            	                            }


            	                            ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                            ex->set_decisionNum( 80 );
            	                            ex->set_state( 1 );


            	                            goto ruleunpivot_clauseEx;

            	                        }
            	                    }
            	                }
            	                else
            	                {
            	                    if (this->get_backtracking()>0)
            	                    {
            	                        this->set_failedflag( true );
            	                        return retval;
            	                    }


            	                    ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                    ex->set_decisionNum( 80 );
            	                    ex->set_state( 0 );


            	                    goto ruleunpivot_clauseEx;

            	                }
            	            }
            	            switch (alt80)
            	            {
            	        	case 1:
            	        	    // OracleDML.g:401:11: include_key
            	        	    {
            	        	        this->followPush(FOLLOW_include_key_in_unpivot_clause3620);
            	        	        include_key226=include_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleunpivot_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) 
            	        	        {
            	        	            include_key226_last = include_key226.tree.get();
            	        	            stream_include_key.add(include_key226.tree);
            	        	        }

            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // OracleDML.g:401:23: exclude_key
            	        	    {
            	        	        this->followPush(FOLLOW_exclude_key_in_unpivot_clause3622);
            	        	        exclude_key227=exclude_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleunpivot_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) 
            	        	        {
            	        	            exclude_key227_last = exclude_key227.tree.get();
            	        	            stream_exclude_key.add(exclude_key227.tree);
            	        	        }

            	        	    }
            	        	    break;

            	            }
            	        }

            	        this->followPush(FOLLOW_nulls_key_in_unpivot_clause3625);
            	        nulls_key228=nulls_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleunpivot_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            nulls_key228_last = nulls_key228.tree.get();
            	            stream_nulls_key.add(nulls_key228.tree);
            	        }

            	    }
            	    break;

                }
            }

            LEFT_PAREN229 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_unpivot_clause3637);
            if  (this->hasException())
            {
                goto ruleunpivot_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_LEFT_PAREN.add(LEFT_PAREN229);


            // OracleDML.g:403:13: ( column_name | LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN )
            {
                ANTLR_UINT32 alt83=2;
                switch ( this->LA(1) )
                {
                case DELIMITED_ID:
                case INTRODUCER:
                case REGULAR_ID:
                	{
                		alt83=1;
                	}
                    break;
                case LEFT_PAREN:
                	{
                		alt83=2;
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return retval;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 83 );
                    ex->set_state( 0 );


                    goto ruleunpivot_clauseEx;

                }

                switch (alt83)
                {
            	case 1:
            	    // OracleDML.g:403:18: column_name
            	    {
            	        this->followPush(FOLLOW_column_name_in_unpivot_clause3656);
            	        column_name230=column_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleunpivot_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            column_name230_last = column_name230.tree.get();
            	            stream_column_name.add(column_name230.tree);
            	        }

            	    }
            	    break;
            	case 2:
            	    // OracleDML.g:404:18: LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN
            	    {
            	        LEFT_PAREN231 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_unpivot_clause3675);
            	        if  (this->hasException())
            	        {
            	            goto ruleunpivot_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( this->get_backtracking()==0 ) stream_LEFT_PAREN.add(LEFT_PAREN231);


            	        this->followPush(FOLLOW_column_name_in_unpivot_clause3677);
            	        column_name232=column_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleunpivot_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            column_name232_last = column_name232.tree.get();
            	            stream_column_name.add(column_name232.tree);
            	        }

            	        // OracleDML.g:404:41: ( COMMA column_name )*

            	        for (;;)
            	        {
            	            ANTLR_UINT32 alt82=2;
            	            switch ( this->LA(1) )
            	            {
            	            case COMMA:
            	            	{
            	            		alt82=1;
            	            	}
            	                break;

            	            }

            	            switch (alt82)
            	            {
            	        	case 1:
            	        	    // OracleDML.g:404:42: COMMA column_name
            	        	    {
            	        	        COMMA233 =  this->matchToken(COMMA, &FOLLOW_COMMA_in_unpivot_clause3680);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleunpivot_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }
            	        	         
            	        	        if ( this->get_backtracking()==0 ) stream_COMMA.add(COMMA233);


            	        	        this->followPush(FOLLOW_column_name_in_unpivot_clause3682);
            	        	        column_name234=column_name();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleunpivot_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) 
            	        	        {
            	        	            column_name234_last = column_name234.tree.get();
            	        	            stream_column_name.add(column_name234.tree);
            	        	        }

            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop82;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop82: ; /* Jump out to here if this rule does not match */


            	        RIGHT_PAREN235 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_unpivot_clause3686);
            	        if  (this->hasException())
            	        {
            	            goto ruleunpivot_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( this->get_backtracking()==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN235);


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_pivot_for_clause_in_unpivot_clause3714);
            pivot_for_clause236=pivot_for_clause();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleunpivot_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                pivot_for_clause236_last = pivot_for_clause236.tree.get();
                stream_pivot_for_clause.add(pivot_for_clause236.tree);
            }

            this->followPush(FOLLOW_unpivot_in_clause_in_unpivot_clause3728);
            unpivot_in_clause237=unpivot_in_clause();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleunpivot_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                unpivot_in_clause237_last = unpivot_in_clause237.tree.get();
                stream_unpivot_in_clause.add(unpivot_in_clause237.tree);
            }

            RIGHT_PAREN238 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_unpivot_clause3738);
            if  (this->hasException())
            {
                goto ruleunpivot_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN238);


            // AST REWRITE
            // elements: unpivot_in_clause, column_name, exclude_key, include_key, pivot_for_clause, unpivot_key, nulls_key
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 409:9: -> ^( unpivot_key ( include_key )? ( exclude_key )? ( nulls_key )? ( column_name )+ pivot_for_clause unpivot_in_clause )
            {
            	// OracleDML.g:409:12: ^( unpivot_key ( include_key )? ( exclude_key )? ( nulls_key )? ( column_name )+ pivot_for_clause unpivot_in_clause )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(stream_unpivot_key.nextNode(), root_1);
            	// OracleDML.g:409:26: ( include_key )?
            	if ( stream_include_key.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_include_key.nextTree());
            	}
            	stream_include_key.reset();

            	// OracleDML.g:409:39: ( exclude_key )?
            	if ( stream_exclude_key.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_exclude_key.nextTree());
            	}
            	stream_exclude_key.reset();

            	// OracleDML.g:409:52: ( nulls_key )?
            	if ( stream_nulls_key.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_nulls_key.nextTree());
            	}
            	stream_nulls_key.reset();

            	if ( !(stream_column_name.hasNext()) ) {
            		ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, REWRITE_EARLY_EXCEPTION, StreamType>( this->get_rec(), "column_name empty" );
            		goto ruleunpivot_clauseEx;
            	}
            	while ( stream_column_name.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_column_name.nextTree());
            	}
            	stream_column_name.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_pivot_for_clause.nextTree());
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_unpivot_in_clause.nextTree());
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleunpivot_clauseEx; /* Prevent compiler warnings */
    ruleunpivot_clauseEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end unpivot_clause */

/**
 * $ANTLR start unpivot_in_clause
 * OracleDML.g:412:1: unpivot_in_clause : in_key LEFT_PAREN unpivot_in_elements ( COMMA unpivot_in_elements )* RIGHT_PAREN -> ^( in_key ( ^( UNPIVOT_IN_ELEMENT unpivot_in_elements ) )+ ) ;
 */
OracleDML::unpivot_in_clause_return
OracleDML::unpivot_in_clause()
{
    OracleDML::unpivot_in_clause_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* LEFT_PAREN240 = NULL;
    ImplTraits::CommonTokenType const* COMMA242 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN244 = NULL;
    OracleDML_OracleDMLKeys::in_key_return in_key239;
    ImplTraits::TreeTypePtr::pointer in_key239_last = NULL;
    OracleDML::unpivot_in_elements_return unpivot_in_elements241;
    ImplTraits::TreeTypePtr::pointer unpivot_in_elements241_last = NULL;
    OracleDML::unpivot_in_elements_return unpivot_in_elements243;
    ImplTraits::TreeTypePtr::pointer unpivot_in_elements243_last = NULL;
    ImplTraits::TreeTypePtr LEFT_PAREN240_tree;
    ImplTraits::TreeTypePtr COMMA242_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN244_tree;
    RewriteRuleTokenStream<ImplTraits> stream_LEFT_PAREN(get_psrstate()->get_treeAdaptor(), "token LEFT_PAREN");
    RewriteRuleTokenStream<ImplTraits> stream_RIGHT_PAREN(get_psrstate()->get_treeAdaptor(), "token RIGHT_PAREN");
    RewriteRuleTokenStream<ImplTraits> stream_COMMA(get_psrstate()->get_treeAdaptor(), "token COMMA");
    RewriteRuleSubtreeStream<ImplTraits> stream_unpivot_in_elements(get_psrstate()->get_treeAdaptor(), "rule unpivot_in_elements");
    RewriteRuleSubtreeStream<ImplTraits> stream_in_key(get_psrstate()->get_treeAdaptor(), "rule in_key");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:413:5: ( in_key LEFT_PAREN unpivot_in_elements ( COMMA unpivot_in_elements )* RIGHT_PAREN -> ^( in_key ( ^( UNPIVOT_IN_ELEMENT unpivot_in_elements ) )+ ) )
        // OracleDML.g:413:10: in_key LEFT_PAREN unpivot_in_elements ( COMMA unpivot_in_elements )* RIGHT_PAREN
        {
            this->followPush(FOLLOW_in_key_in_unpivot_in_clause3788);
            in_key239=in_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleunpivot_in_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                in_key239_last = in_key239.tree.get();
                stream_in_key.add(in_key239.tree);
            }

            LEFT_PAREN240 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_unpivot_in_clause3798);
            if  (this->hasException())
            {
                goto ruleunpivot_in_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_LEFT_PAREN.add(LEFT_PAREN240);


            this->followPush(FOLLOW_unpivot_in_elements_in_unpivot_in_clause3812);
            unpivot_in_elements241=unpivot_in_elements();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleunpivot_in_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                unpivot_in_elements241_last = unpivot_in_elements241.tree.get();
                stream_unpivot_in_elements.add(unpivot_in_elements241.tree);
            }

            // OracleDML.g:415:33: ( COMMA unpivot_in_elements )*

            for (;;)
            {
                ANTLR_UINT32 alt84=2;
                switch ( this->LA(1) )
                {
                case COMMA:
                	{
                		alt84=1;
                	}
                    break;

                }

                switch (alt84)
                {
            	case 1:
            	    // OracleDML.g:415:34: COMMA unpivot_in_elements
            	    {
            	        COMMA242 =  this->matchToken(COMMA, &FOLLOW_COMMA_in_unpivot_in_clause3815);
            	        if  (this->hasException())
            	        {
            	            goto ruleunpivot_in_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( this->get_backtracking()==0 ) stream_COMMA.add(COMMA242);


            	        this->followPush(FOLLOW_unpivot_in_elements_in_unpivot_in_clause3817);
            	        unpivot_in_elements243=unpivot_in_elements();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleunpivot_in_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            unpivot_in_elements243_last = unpivot_in_elements243.tree.get();
            	            stream_unpivot_in_elements.add(unpivot_in_elements243.tree);
            	        }

            	    }
            	    break;

            	default:
            	    goto loop84;	/* break out of the loop */
            	    break;
                }
            }
            loop84: ; /* Jump out to here if this rule does not match */


            RIGHT_PAREN244 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_unpivot_in_clause3829);
            if  (this->hasException())
            {
                goto ruleunpivot_in_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN244);


            // AST REWRITE
            // elements: in_key, unpivot_in_elements
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 417:9: -> ^( in_key ( ^( UNPIVOT_IN_ELEMENT unpivot_in_elements ) )+ )
            {
            	// OracleDML.g:417:12: ^( in_key ( ^( UNPIVOT_IN_ELEMENT unpivot_in_elements ) )+ )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(stream_in_key.nextNode(), root_1);
            	if ( !(stream_unpivot_in_elements.hasNext()) ) {
            		ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, REWRITE_EARLY_EXCEPTION, StreamType>( this->get_rec(), "unpivot_in_elements empty" );
            		goto ruleunpivot_in_clauseEx;
            	}
            	while ( stream_unpivot_in_elements.hasNext() ) {
            		// OracleDML.g:417:21: ^( UNPIVOT_IN_ELEMENT unpivot_in_elements )
            		{
            		ImplTraits::TreeTypePtr root_2 = get_psrstate()->get_treeAdaptor()->nilNode();
            		root_2 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(UNPIVOT_IN_ELEMENT, "UNPIVOT_IN_ELEMENT"), root_2);
            		get_psrstate()->get_treeAdaptor()->addChild(root_2, stream_unpivot_in_elements.nextTree());
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, root_2);
            		}
            	}
            	stream_unpivot_in_elements.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleunpivot_in_clauseEx; /* Prevent compiler warnings */
    ruleunpivot_in_clauseEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end unpivot_in_clause */

/**
 * $ANTLR start unpivot_in_elements
 * OracleDML.g:420:1: unpivot_in_elements : ( column_name | LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN ) ( as_key ( constant | ( LEFT_PAREN )=> LEFT_PAREN constant ( COMMA constant )* RIGHT_PAREN ) )? -> ( column_name )+ ( ^( PIVOT_ALIAS ( constant )+ ) )? ;
 */
OracleDML::unpivot_in_elements_return
OracleDML::unpivot_in_elements()
{
    OracleDML::unpivot_in_elements_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* LEFT_PAREN246 = NULL;
    ImplTraits::CommonTokenType const* COMMA248 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN250 = NULL;
    ImplTraits::CommonTokenType const* LEFT_PAREN253 = NULL;
    ImplTraits::CommonTokenType const* COMMA255 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN257 = NULL;
    OracleDML_OracleDMLCommons::column_name_return column_name245;
    ImplTraits::TreeTypePtr::pointer column_name245_last = NULL;
    OracleDML_OracleDMLCommons::column_name_return column_name247;
    ImplTraits::TreeTypePtr::pointer column_name247_last = NULL;
    OracleDML_OracleDMLCommons::column_name_return column_name249;
    ImplTraits::TreeTypePtr::pointer column_name249_last = NULL;
    OracleDML_OracleDMLKeys::as_key_return as_key251;
    ImplTraits::TreeTypePtr::pointer as_key251_last = NULL;
    OracleDML_OracleDMLCommons::constant_return constant252;
    ImplTraits::TreeTypePtr::pointer constant252_last = NULL;
    OracleDML_OracleDMLCommons::constant_return constant254;
    ImplTraits::TreeTypePtr::pointer constant254_last = NULL;
    OracleDML_OracleDMLCommons::constant_return constant256;
    ImplTraits::TreeTypePtr::pointer constant256_last = NULL;
    ImplTraits::TreeTypePtr LEFT_PAREN246_tree;
    ImplTraits::TreeTypePtr COMMA248_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN250_tree;
    ImplTraits::TreeTypePtr LEFT_PAREN253_tree;
    ImplTraits::TreeTypePtr COMMA255_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN257_tree;
    RewriteRuleTokenStream<ImplTraits> stream_LEFT_PAREN(get_psrstate()->get_treeAdaptor(), "token LEFT_PAREN");
    RewriteRuleTokenStream<ImplTraits> stream_RIGHT_PAREN(get_psrstate()->get_treeAdaptor(), "token RIGHT_PAREN");
    RewriteRuleTokenStream<ImplTraits> stream_COMMA(get_psrstate()->get_treeAdaptor(), "token COMMA");
    RewriteRuleSubtreeStream<ImplTraits> stream_constant(get_psrstate()->get_treeAdaptor(), "rule constant");
    RewriteRuleSubtreeStream<ImplTraits> stream_as_key(get_psrstate()->get_treeAdaptor(), "rule as_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_column_name(get_psrstate()->get_treeAdaptor(), "rule column_name");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:421:5: ( ( column_name | LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN ) ( as_key ( constant | ( LEFT_PAREN )=> LEFT_PAREN constant ( COMMA constant )* RIGHT_PAREN ) )? -> ( column_name )+ ( ^( PIVOT_ALIAS ( constant )+ ) )? )
        // OracleDML.g:421:9: ( column_name | LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN ) ( as_key ( constant | ( LEFT_PAREN )=> LEFT_PAREN constant ( COMMA constant )* RIGHT_PAREN ) )?
        {
            // OracleDML.g:421:9: ( column_name | LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN )
            {
                ANTLR_UINT32 alt86=2;
                switch ( this->LA(1) )
                {
                case DELIMITED_ID:
                case INTRODUCER:
                case REGULAR_ID:
                	{
                		alt86=1;
                	}
                    break;
                case LEFT_PAREN:
                	{
                		alt86=2;
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return retval;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 86 );
                    ex->set_state( 0 );


                    goto ruleunpivot_in_elementsEx;

                }

                switch (alt86)
                {
            	case 1:
            	    // OracleDML.g:421:14: column_name
            	    {
            	        this->followPush(FOLLOW_column_name_in_unpivot_in_elements3874);
            	        column_name245=column_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleunpivot_in_elementsEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            column_name245_last = column_name245.tree.get();
            	            stream_column_name.add(column_name245.tree);
            	        }

            	    }
            	    break;
            	case 2:
            	    // OracleDML.g:422:14: LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN
            	    {
            	        LEFT_PAREN246 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_unpivot_in_elements3889);
            	        if  (this->hasException())
            	        {
            	            goto ruleunpivot_in_elementsEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( this->get_backtracking()==0 ) stream_LEFT_PAREN.add(LEFT_PAREN246);


            	        this->followPush(FOLLOW_column_name_in_unpivot_in_elements3891);
            	        column_name247=column_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleunpivot_in_elementsEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            column_name247_last = column_name247.tree.get();
            	            stream_column_name.add(column_name247.tree);
            	        }

            	        // OracleDML.g:422:37: ( COMMA column_name )*

            	        for (;;)
            	        {
            	            ANTLR_UINT32 alt85=2;
            	            switch ( this->LA(1) )
            	            {
            	            case COMMA:
            	            	{
            	            		alt85=1;
            	            	}
            	                break;

            	            }

            	            switch (alt85)
            	            {
            	        	case 1:
            	        	    // OracleDML.g:422:38: COMMA column_name
            	        	    {
            	        	        COMMA248 =  this->matchToken(COMMA, &FOLLOW_COMMA_in_unpivot_in_elements3894);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleunpivot_in_elementsEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }
            	        	         
            	        	        if ( this->get_backtracking()==0 ) stream_COMMA.add(COMMA248);


            	        	        this->followPush(FOLLOW_column_name_in_unpivot_in_elements3896);
            	        	        column_name249=column_name();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleunpivot_in_elementsEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) 
            	        	        {
            	        	            column_name249_last = column_name249.tree.get();
            	        	            stream_column_name.add(column_name249.tree);
            	        	        }

            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop85;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop85: ; /* Jump out to here if this rule does not match */


            	        RIGHT_PAREN250 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_unpivot_in_elements3900);
            	        if  (this->hasException())
            	        {
            	            goto ruleunpivot_in_elementsEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( this->get_backtracking()==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN250);


            	    }
            	    break;

                }
            }

            // OracleDML.g:424:9: ( as_key ( constant | ( LEFT_PAREN )=> LEFT_PAREN constant ( COMMA constant )* RIGHT_PAREN ) )?
            {
                ANTLR_UINT32 alt89=2;
                switch ( this->LA(1) )
                {
                    case SQL92_RESERVED_AS:
                    	{
                    		alt89=1;
                    	}
                        break;
                }

                switch (alt89)
                {
            	case 1:
            	    // OracleDML.g:424:14: as_key ( constant | ( LEFT_PAREN )=> LEFT_PAREN constant ( COMMA constant )* RIGHT_PAREN )
            	    {
            	        this->followPush(FOLLOW_as_key_in_unpivot_in_elements3925);
            	        as_key251=as_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleunpivot_in_elementsEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            as_key251_last = as_key251.tree.get();
            	            stream_as_key.add(as_key251.tree);
            	        }

            	        // OracleDML.g:425:9: ( constant | ( LEFT_PAREN )=> LEFT_PAREN constant ( COMMA constant )* RIGHT_PAREN )
            	        {
            	            ANTLR_UINT32 alt88=2;
            	            {
            	                ANTLR_UINT32 LA88_0 = this->LA(1);
            	                if ( (LA88_0 == APPROXIMATE_NUM_LIT || ((LA88_0 >= CHAR_STRING) && (LA88_0 <= CHAR_STRING_PERL)) || LA88_0 == EXACT_NUM_LIT || LA88_0 == NATIONAL_CHAR_STRING_LIT || LA88_0 == REGULAR_ID || LA88_0 == SQL92_RESERVED_DATE || LA88_0 == SQL92_RESERVED_DEFAULT || LA88_0 == SQL92_RESERVED_FALSE || LA88_0 == SQL92_RESERVED_NULL || LA88_0 == SQL92_RESERVED_TRUE || LA88_0 == UNSIGNED_INTEGER))
            	                {
            	                    alt88=1;
            	                }
            	                else if ( (LA88_0 == LEFT_PAREN) && (this->msynpred( antlr3::ClassForwarder<synpred15_OracleDML>() )))
            	                {
            	                    alt88=2;
            	                }
            	                else
            	                {
            	                    if (this->get_backtracking()>0)
            	                    {
            	                        this->set_failedflag( true );
            	                        return retval;
            	                    }


            	                    ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                    ex->set_decisionNum( 88 );
            	                    ex->set_state( 0 );


            	                    goto ruleunpivot_in_elementsEx;

            	                }
            	            }
            	            switch (alt88)
            	            {
            	        	case 1:
            	        	    // OracleDML.g:425:14: constant
            	        	    {
            	        	        this->followPush(FOLLOW_constant_in_unpivot_in_elements3940);
            	        	        constant252=constant();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleunpivot_in_elementsEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) 
            	        	        {
            	        	            constant252_last = constant252.tree.get();
            	        	            stream_constant.add(constant252.tree);
            	        	        }

            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // OracleDML.g:426:14: ( LEFT_PAREN )=> LEFT_PAREN constant ( COMMA constant )* RIGHT_PAREN
            	        	    {
            	        	        LEFT_PAREN253 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_unpivot_in_elements3960);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleunpivot_in_elementsEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }
            	        	         
            	        	        if ( this->get_backtracking()==0 ) stream_LEFT_PAREN.add(LEFT_PAREN253);


            	        	        this->followPush(FOLLOW_constant_in_unpivot_in_elements3962);
            	        	        constant254=constant();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleunpivot_in_elementsEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) 
            	        	        {
            	        	            constant254_last = constant254.tree.get();
            	        	            stream_constant.add(constant254.tree);
            	        	        }

            	        	        // OracleDML.g:426:49: ( COMMA constant )*

            	        	        for (;;)
            	        	        {
            	        	            ANTLR_UINT32 alt87=2;
            	        	            switch ( this->LA(1) )
            	        	            {
            	        	            case COMMA:
            	        	            	{
            	        	            		alt87=1;
            	        	            	}
            	        	                break;

            	        	            }

            	        	            switch (alt87)
            	        	            {
            	        	        	case 1:
            	        	        	    // OracleDML.g:426:50: COMMA constant
            	        	        	    {
            	        	        	        COMMA255 =  this->matchToken(COMMA, &FOLLOW_COMMA_in_unpivot_in_elements3965);
            	        	        	        if  (this->hasException())
            	        	        	        {
            	        	        	            goto ruleunpivot_in_elementsEx;
            	        	        	        }
            	        	        	        if (this->hasFailed())
            	        	        	        {
            	        	        	            return retval;
            	        	        	        }
            	        	        	         
            	        	        	        if ( this->get_backtracking()==0 ) stream_COMMA.add(COMMA255);


            	        	        	        this->followPush(FOLLOW_constant_in_unpivot_in_elements3967);
            	        	        	        constant256=constant();

            	        	        	        this->followPop();
            	        	        	        if  (this->hasException())
            	        	        	        {
            	        	        	            goto ruleunpivot_in_elementsEx;
            	        	        	        }
            	        	        	        if (this->hasFailed())
            	        	        	        {
            	        	        	            return retval;
            	        	        	        }

            	        	        	        if ( this->get_backtracking()==0 ) 
            	        	        	        {
            	        	        	            constant256_last = constant256.tree.get();
            	        	        	            stream_constant.add(constant256.tree);
            	        	        	        }

            	        	        	    }
            	        	        	    break;

            	        	        	default:
            	        	        	    goto loop87;	/* break out of the loop */
            	        	        	    break;
            	        	            }
            	        	        }
            	        	        loop87: ; /* Jump out to here if this rule does not match */


            	        	        RIGHT_PAREN257 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_unpivot_in_elements3971);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleunpivot_in_elementsEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }
            	        	         
            	        	        if ( this->get_backtracking()==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN257);


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

                }
            }

            // AST REWRITE
            // elements: column_name, constant
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 429:9: -> ( column_name )+ ( ^( PIVOT_ALIAS ( constant )+ ) )?
            {
            	if ( !(stream_column_name.hasNext()) ) {
            		ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, REWRITE_EARLY_EXCEPTION, StreamType>( this->get_rec(), "column_name empty" );
            		goto ruleunpivot_in_elementsEx;
            	}
            	while ( stream_column_name.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_0, stream_column_name.nextTree());
            	}
            	stream_column_name.reset();

            	// OracleDML.g:429:25: ( ^( PIVOT_ALIAS ( constant )+ ) )?
            	if ( stream_constant.hasNext() ) {
            		// OracleDML.g:429:25: ^( PIVOT_ALIAS ( constant )+ )
            		{
            		ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            		root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(PIVOT_ALIAS, "PIVOT_ALIAS"), root_1);
            		if ( !(stream_constant.hasNext()) ) {
            			ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, REWRITE_EARLY_EXCEPTION, StreamType>( this->get_rec(), "constant empty" );
            			goto ruleunpivot_in_elementsEx;
            		}
            		while ( stream_constant.hasNext() ) {
            			get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_constant.nextTree());
            		}
            		stream_constant.reset();

            		get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            		}
            	}
            	stream_constant.reset();

            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleunpivot_in_elementsEx; /* Prevent compiler warnings */
    ruleunpivot_in_elementsEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end unpivot_in_elements */

/**
 * $ANTLR start hierarchical_query_clause
 * OracleDML.g:432:1: hierarchical_query_clause : ( connect_key by_key ( nocycle_key )? condition ( start_part )? -> ^( HIERARCHICAL ^( connect_key ( nocycle_key )? ^( LOGIC_EXPR condition ) ) ( start_part )? ) | start_part connect_key by_key ( nocycle_key )? condition -> ^( HIERARCHICAL start_part ^( connect_key ( nocycle_key )? ^( LOGIC_EXPR condition ) ) ) );
 */
OracleDML::hierarchical_query_clause_return
OracleDML::hierarchical_query_clause()
{
    OracleDML::hierarchical_query_clause_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML_OracleDMLKeys::connect_key_return connect_key258;
    ImplTraits::TreeTypePtr::pointer connect_key258_last = NULL;
    OracleDML_OracleDMLKeys::by_key_return by_key259;
    ImplTraits::TreeTypePtr::pointer by_key259_last = NULL;
    OracleDML_OracleDMLKeys::nocycle_key_return nocycle_key260;
    ImplTraits::TreeTypePtr::pointer nocycle_key260_last = NULL;
    OracleDML::condition_return condition261;
    ImplTraits::TreeTypePtr::pointer condition261_last = NULL;
    OracleDML::start_part_return start_part262;
    ImplTraits::TreeTypePtr::pointer start_part262_last = NULL;
    OracleDML::start_part_return start_part263;
    ImplTraits::TreeTypePtr::pointer start_part263_last = NULL;
    OracleDML_OracleDMLKeys::connect_key_return connect_key264;
    ImplTraits::TreeTypePtr::pointer connect_key264_last = NULL;
    OracleDML_OracleDMLKeys::by_key_return by_key265;
    ImplTraits::TreeTypePtr::pointer by_key265_last = NULL;
    OracleDML_OracleDMLKeys::nocycle_key_return nocycle_key266;
    ImplTraits::TreeTypePtr::pointer nocycle_key266_last = NULL;
    OracleDML::condition_return condition267;
    ImplTraits::TreeTypePtr::pointer condition267_last = NULL;
    RewriteRuleSubtreeStream<ImplTraits> stream_connect_key(get_psrstate()->get_treeAdaptor(), "rule connect_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_condition(get_psrstate()->get_treeAdaptor(), "rule condition");
    RewriteRuleSubtreeStream<ImplTraits> stream_start_part(get_psrstate()->get_treeAdaptor(), "rule start_part");
    RewriteRuleSubtreeStream<ImplTraits> stream_by_key(get_psrstate()->get_treeAdaptor(), "rule by_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_nocycle_key(get_psrstate()->get_treeAdaptor(), "rule nocycle_key");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        {
            //  OracleDML.g:433:5: ( connect_key by_key ( nocycle_key )? condition ( start_part )? -> ^( HIERARCHICAL ^( connect_key ( nocycle_key )? ^( LOGIC_EXPR condition ) ) ( start_part )? ) | start_part connect_key by_key ( nocycle_key )? condition -> ^( HIERARCHICAL start_part ^( connect_key ( nocycle_key )? ^( LOGIC_EXPR condition ) ) ) )

            ANTLR_UINT32 alt93;

            alt93=2;

            switch ( this->LA(1) )
            {
            case SQL92_RESERVED_CONNECT:
            	{
            		alt93=1;
            	}
                break;
            case PLSQL_RESERVED_START:
            	{
            		alt93=2;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 93 );
                ex->set_state( 0 );


                goto rulehierarchical_query_clauseEx;

            }

            switch (alt93)
            {
        	case 1:
        	    // OracleDML.g:433:10: connect_key by_key ( nocycle_key )? condition ( start_part )?
        	    {
        	        this->followPush(FOLLOW_connect_key_in_hierarchical_query_clause4033);
        	        connect_key258=connect_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulehierarchical_query_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) 
        	        {
        	            connect_key258_last = connect_key258.tree.get();
        	            stream_connect_key.add(connect_key258.tree);
        	        }

        	        this->followPush(FOLLOW_by_key_in_hierarchical_query_clause4035);
        	        by_key259=by_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulehierarchical_query_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) 
        	        {
        	            by_key259_last = by_key259.tree.get();
        	            stream_by_key.add(by_key259.tree);
        	        }

        	        // OracleDML.g:433:29: ( nocycle_key )?
        	        {
        	            ANTLR_UINT32 alt90=2;
        	            switch ( this->LA(1) )
        	            {
        	                case REGULAR_ID:
        	                	{
        	                		{
        	                		    ANTLR_UINT32 LA90_1 = this->LA(2);
        	                		    if ( ((toUpper(LT(1)->getText()) == "NOCYCLE")))
        	                		    {
        	                		        alt90=1;
        	                		    }
        	                		}
        	                	}
        	                    break;
        	            }

        	            switch (alt90)
        	            {
        	        	case 1:
        	        	    // OracleDML.g:433:29: nocycle_key
        	        	    {
        	        	        this->followPush(FOLLOW_nocycle_key_in_hierarchical_query_clause4037);
        	        	        nocycle_key260=nocycle_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulehierarchical_query_clauseEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) 
        	        	        {
        	        	            nocycle_key260_last = nocycle_key260.tree.get();
        	        	            stream_nocycle_key.add(nocycle_key260.tree);
        	        	        }

        	        	    }
        	        	    break;

        	            }
        	        }

        	        this->followPush(FOLLOW_condition_in_hierarchical_query_clause4040);
        	        condition261=condition();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulehierarchical_query_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) 
        	        {
        	            condition261_last = condition261.tree.get();
        	            stream_condition.add(condition261.tree);
        	        }

        	        // OracleDML.g:433:52: ( start_part )?
        	        {
        	            ANTLR_UINT32 alt91=2;
        	            switch ( this->LA(1) )
        	            {
        	                case PLSQL_RESERVED_START:
        	                	{
        	                		alt91=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt91)
        	            {
        	        	case 1:
        	        	    // OracleDML.g:433:52: start_part
        	        	    {
        	        	        this->followPush(FOLLOW_start_part_in_hierarchical_query_clause4042);
        	        	        start_part262=start_part();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulehierarchical_query_clauseEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) 
        	        	        {
        	        	            start_part262_last = start_part262.tree.get();
        	        	            stream_start_part.add(start_part262.tree);
        	        	        }

        	        	    }
        	        	    break;

        	            }
        	        }

        	        // AST REWRITE
        	        // elements: connect_key, start_part, nocycle_key, condition
        	        // token labels: 
        	        // rule labels: retval
        	        // token list labels: 
        	        // rule list labels: 
        	        // wildcard labels: 
        	        if ( this->get_backtracking()==0 ) {
        	        retval.tree = std::move(root_0);
        	        RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
        	        // 434:9: -> ^( HIERARCHICAL ^( connect_key ( nocycle_key )? ^( LOGIC_EXPR condition ) ) ( start_part )? )
        	        {
        	        	// OracleDML.g:434:12: ^( HIERARCHICAL ^( connect_key ( nocycle_key )? ^( LOGIC_EXPR condition ) ) ( start_part )? )
        	        	{
        	        	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
        	        	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(HIERARCHICAL, "HIERARCHICAL"), root_1);
        	        	// OracleDML.g:434:27: ^( connect_key ( nocycle_key )? ^( LOGIC_EXPR condition ) )
        	        	{
        	        	ImplTraits::TreeTypePtr root_2 = get_psrstate()->get_treeAdaptor()->nilNode();
        	        	root_2 = get_psrstate()->get_treeAdaptor()->becomeRoot(stream_connect_key.nextNode(), root_2);
        	        	// OracleDML.g:434:41: ( nocycle_key )?
        	        	if ( stream_nocycle_key.hasNext() ) {
        	        		get_psrstate()->get_treeAdaptor()->addChild(root_2, stream_nocycle_key.nextTree());
        	        	}
        	        	stream_nocycle_key.reset();

        	        	// OracleDML.g:434:54: ^( LOGIC_EXPR condition )
        	        	{
        	        	ImplTraits::TreeTypePtr root_3 = get_psrstate()->get_treeAdaptor()->nilNode();
        	        	root_3 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(LOGIC_EXPR, "LOGIC_EXPR"), root_3);
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_3, stream_condition.nextTree());
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_2, root_3);
        	        	}
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_1, root_2);
        	        	}
        	        	// OracleDML.g:434:79: ( start_part )?
        	        	if ( stream_start_part.hasNext() ) {
        	        		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_start_part.nextTree());
        	        	}
        	        	stream_start_part.reset();

        	        	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
        	        	}
        	        }


        	        //retval.tree = std::move(root_0);
        	        }

        	    }
        	    break;
        	case 2:
        	    // OracleDML.g:435:10: start_part connect_key by_key ( nocycle_key )? condition
        	    {
        	        this->followPush(FOLLOW_start_part_in_hierarchical_query_clause4084);
        	        start_part263=start_part();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulehierarchical_query_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) 
        	        {
        	            start_part263_last = start_part263.tree.get();
        	            stream_start_part.add(start_part263.tree);
        	        }

        	        this->followPush(FOLLOW_connect_key_in_hierarchical_query_clause4086);
        	        connect_key264=connect_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulehierarchical_query_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) 
        	        {
        	            connect_key264_last = connect_key264.tree.get();
        	            stream_connect_key.add(connect_key264.tree);
        	        }

        	        this->followPush(FOLLOW_by_key_in_hierarchical_query_clause4088);
        	        by_key265=by_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulehierarchical_query_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) 
        	        {
        	            by_key265_last = by_key265.tree.get();
        	            stream_by_key.add(by_key265.tree);
        	        }

        	        // OracleDML.g:435:40: ( nocycle_key )?
        	        {
        	            ANTLR_UINT32 alt92=2;
        	            switch ( this->LA(1) )
        	            {
        	                case REGULAR_ID:
        	                	{
        	                		{
        	                		    ANTLR_UINT32 LA92_1 = this->LA(2);
        	                		    if ( ((toUpper(LT(1)->getText()) == "NOCYCLE")))
        	                		    {
        	                		        alt92=1;
        	                		    }
        	                		}
        	                	}
        	                    break;
        	            }

        	            switch (alt92)
        	            {
        	        	case 1:
        	        	    // OracleDML.g:435:40: nocycle_key
        	        	    {
        	        	        this->followPush(FOLLOW_nocycle_key_in_hierarchical_query_clause4090);
        	        	        nocycle_key266=nocycle_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulehierarchical_query_clauseEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) 
        	        	        {
        	        	            nocycle_key266_last = nocycle_key266.tree.get();
        	        	            stream_nocycle_key.add(nocycle_key266.tree);
        	        	        }

        	        	    }
        	        	    break;

        	            }
        	        }

        	        this->followPush(FOLLOW_condition_in_hierarchical_query_clause4093);
        	        condition267=condition();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulehierarchical_query_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) 
        	        {
        	            condition267_last = condition267.tree.get();
        	            stream_condition.add(condition267.tree);
        	        }

        	        // AST REWRITE
        	        // elements: start_part, connect_key, nocycle_key, condition
        	        // token labels: 
        	        // rule labels: retval
        	        // token list labels: 
        	        // rule list labels: 
        	        // wildcard labels: 
        	        if ( this->get_backtracking()==0 ) {
        	        retval.tree = std::move(root_0);
        	        RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
        	        // 436:9: -> ^( HIERARCHICAL start_part ^( connect_key ( nocycle_key )? ^( LOGIC_EXPR condition ) ) )
        	        {
        	        	// OracleDML.g:436:12: ^( HIERARCHICAL start_part ^( connect_key ( nocycle_key )? ^( LOGIC_EXPR condition ) ) )
        	        	{
        	        	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
        	        	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(HIERARCHICAL, "HIERARCHICAL"), root_1);
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_start_part.nextTree());
        	        	// OracleDML.g:436:39: ^( connect_key ( nocycle_key )? ^( LOGIC_EXPR condition ) )
        	        	{
        	        	ImplTraits::TreeTypePtr root_2 = get_psrstate()->get_treeAdaptor()->nilNode();
        	        	root_2 = get_psrstate()->get_treeAdaptor()->becomeRoot(stream_connect_key.nextNode(), root_2);
        	        	// OracleDML.g:436:53: ( nocycle_key )?
        	        	if ( stream_nocycle_key.hasNext() ) {
        	        		get_psrstate()->get_treeAdaptor()->addChild(root_2, stream_nocycle_key.nextTree());
        	        	}
        	        	stream_nocycle_key.reset();

        	        	// OracleDML.g:436:66: ^( LOGIC_EXPR condition )
        	        	{
        	        	ImplTraits::TreeTypePtr root_3 = get_psrstate()->get_treeAdaptor()->nilNode();
        	        	root_3 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(LOGIC_EXPR, "LOGIC_EXPR"), root_3);
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_3, stream_condition.nextTree());
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_2, root_3);
        	        	}
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_1, root_2);
        	        	}
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
        	        	}
        	        }


        	        //retval.tree = std::move(root_0);
        	        }

        	    }
        	    break;

            }
        }
    }//...
    // This is where rules clean up and exit
    //
    goto rulehierarchical_query_clauseEx; /* Prevent compiler warnings */
    rulehierarchical_query_clauseEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end hierarchical_query_clause */

/**
 * $ANTLR start start_part
 * OracleDML.g:439:1: start_part : start_key with_key condition -> ^( start_key ^( LOGIC_EXPR condition ) ) ;
 */
OracleDML::start_part_return
OracleDML::start_part()
{
    OracleDML::start_part_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML_OracleDMLKeys::start_key_return start_key268;
    ImplTraits::TreeTypePtr::pointer start_key268_last = NULL;
    OracleDML_OracleDMLKeys::with_key_return with_key269;
    ImplTraits::TreeTypePtr::pointer with_key269_last = NULL;
    OracleDML::condition_return condition270;
    ImplTraits::TreeTypePtr::pointer condition270_last = NULL;
    RewriteRuleSubtreeStream<ImplTraits> stream_start_key(get_psrstate()->get_treeAdaptor(), "rule start_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_with_key(get_psrstate()->get_treeAdaptor(), "rule with_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_condition(get_psrstate()->get_treeAdaptor(), "rule condition");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:440:5: ( start_key with_key condition -> ^( start_key ^( LOGIC_EXPR condition ) ) )
        // OracleDML.g:440:10: start_key with_key condition
        {
            this->followPush(FOLLOW_start_key_in_start_part4143);
            start_key268=start_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulestart_partEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                start_key268_last = start_key268.tree.get();
                stream_start_key.add(start_key268.tree);
            }

            this->followPush(FOLLOW_with_key_in_start_part4145);
            with_key269=with_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulestart_partEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                with_key269_last = with_key269.tree.get();
                stream_with_key.add(with_key269.tree);
            }

            this->followPush(FOLLOW_condition_in_start_part4147);
            condition270=condition();

            this->followPop();
            if  (this->hasException())
            {
                goto rulestart_partEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                condition270_last = condition270.tree.get();
                stream_condition.add(condition270.tree);
            }

            // AST REWRITE
            // elements: condition, start_key
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 441:9: -> ^( start_key ^( LOGIC_EXPR condition ) )
            {
            	// OracleDML.g:441:12: ^( start_key ^( LOGIC_EXPR condition ) )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(stream_start_key.nextNode(), root_1);
            	// OracleDML.g:441:24: ^( LOGIC_EXPR condition )
            	{
            	ImplTraits::TreeTypePtr root_2 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_2 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(LOGIC_EXPR, "LOGIC_EXPR"), root_2);
            	get_psrstate()->get_treeAdaptor()->addChild(root_2, stream_condition.nextTree());
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, root_2);
            	}
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulestart_partEx; /* Prevent compiler warnings */
    rulestart_partEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end start_part */

/**
 * $ANTLR start group_by_clause
 * OracleDML.g:444:1: group_by_clause : ( ( group_key )=> group_key by_key ( LEFT_PAREN RIGHT_PAREN | group_by_elements ( ( COMMA group_by_elements )=> COMMA group_by_elements )* ) ( having_clause )? -> ^( GROUP_BY_CLAUSE[$group_key.start] ^( group_key ( ^( GROUP_BY_ELEMENT group_by_elements ) )* ) ( having_clause )? ) | ( having_key )=> having_clause ( group_key by_key ( LEFT_PAREN RIGHT_PAREN | group_by_elements ( ( COMMA group_by_elements )=> COMMA group_by_elements )* ) )? -> ^( GROUP_BY_CLAUSE[$having_clause.start] having_clause ( ^( group_key ( ^( GROUP_BY_ELEMENT group_by_elements ) )* ) )? ) );
 */
OracleDML::group_by_clause_return
OracleDML::group_by_clause()
{
    OracleDML::group_by_clause_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* LEFT_PAREN273 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN274 = NULL;
    ImplTraits::CommonTokenType const* COMMA276 = NULL;
    ImplTraits::CommonTokenType const* LEFT_PAREN282 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN283 = NULL;
    ImplTraits::CommonTokenType const* COMMA285 = NULL;
    OracleDML_OracleDMLKeys::group_key_return group_key271;
    ImplTraits::TreeTypePtr::pointer group_key271_last = NULL;
    OracleDML_OracleDMLKeys::by_key_return by_key272;
    ImplTraits::TreeTypePtr::pointer by_key272_last = NULL;
    OracleDML::group_by_elements_return group_by_elements275;
    ImplTraits::TreeTypePtr::pointer group_by_elements275_last = NULL;
    OracleDML::group_by_elements_return group_by_elements277;
    ImplTraits::TreeTypePtr::pointer group_by_elements277_last = NULL;
    OracleDML::having_clause_return having_clause278;
    ImplTraits::TreeTypePtr::pointer having_clause278_last = NULL;
    OracleDML::having_clause_return having_clause279;
    ImplTraits::TreeTypePtr::pointer having_clause279_last = NULL;
    OracleDML_OracleDMLKeys::group_key_return group_key280;
    ImplTraits::TreeTypePtr::pointer group_key280_last = NULL;
    OracleDML_OracleDMLKeys::by_key_return by_key281;
    ImplTraits::TreeTypePtr::pointer by_key281_last = NULL;
    OracleDML::group_by_elements_return group_by_elements284;
    ImplTraits::TreeTypePtr::pointer group_by_elements284_last = NULL;
    OracleDML::group_by_elements_return group_by_elements286;
    ImplTraits::TreeTypePtr::pointer group_by_elements286_last = NULL;
    ImplTraits::TreeTypePtr LEFT_PAREN273_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN274_tree;
    ImplTraits::TreeTypePtr COMMA276_tree;
    ImplTraits::TreeTypePtr LEFT_PAREN282_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN283_tree;
    ImplTraits::TreeTypePtr COMMA285_tree;
    RewriteRuleTokenStream<ImplTraits> stream_LEFT_PAREN(get_psrstate()->get_treeAdaptor(), "token LEFT_PAREN");
    RewriteRuleTokenStream<ImplTraits> stream_RIGHT_PAREN(get_psrstate()->get_treeAdaptor(), "token RIGHT_PAREN");
    RewriteRuleTokenStream<ImplTraits> stream_COMMA(get_psrstate()->get_treeAdaptor(), "token COMMA");
    RewriteRuleSubtreeStream<ImplTraits> stream_having_clause(get_psrstate()->get_treeAdaptor(), "rule having_clause");
    RewriteRuleSubtreeStream<ImplTraits> stream_group_key(get_psrstate()->get_treeAdaptor(), "rule group_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_by_key(get_psrstate()->get_treeAdaptor(), "rule by_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_group_by_elements(get_psrstate()->get_treeAdaptor(), "rule group_by_elements");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        {
            //  OracleDML.g:445:5: ( ( group_key )=> group_key by_key ( LEFT_PAREN RIGHT_PAREN | group_by_elements ( ( COMMA group_by_elements )=> COMMA group_by_elements )* ) ( having_clause )? -> ^( GROUP_BY_CLAUSE[$group_key.start] ^( group_key ( ^( GROUP_BY_ELEMENT group_by_elements ) )* ) ( having_clause )? ) | ( having_key )=> having_clause ( group_key by_key ( LEFT_PAREN RIGHT_PAREN | group_by_elements ( ( COMMA group_by_elements )=> COMMA group_by_elements )* ) )? -> ^( GROUP_BY_CLAUSE[$having_clause.start] having_clause ( ^( group_key ( ^( GROUP_BY_ELEMENT group_by_elements ) )* ) )? ) )

            ANTLR_UINT32 alt100;

            alt100=2;

            {
                ANTLR_UINT32 LA100_0 = this->LA(1);
                if ( (LA100_0 == SQL92_RESERVED_GROUP) && (this->msynpred( antlr3::ClassForwarder<synpred16_OracleDML>() )))
                {
                    alt100=1;
                }
                else if ( (LA100_0 == SQL92_RESERVED_HAVING) && (this->msynpred( antlr3::ClassForwarder<synpred18_OracleDML>() )))
                {
                    alt100=2;
                }
                else
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return retval;
                    }


                    ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 100 );
                    ex->set_state( 0 );


                    goto rulegroup_by_clauseEx;

                }
            }
            switch (alt100)
            {
        	case 1:
        	    // OracleDML.g:445:9: ( group_key )=> group_key by_key ( LEFT_PAREN RIGHT_PAREN | group_by_elements ( ( COMMA group_by_elements )=> COMMA group_by_elements )* ) ( having_clause )?
        	    {
        	        this->followPush(FOLLOW_group_key_in_group_by_clause4192);
        	        group_key271=group_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulegroup_by_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) 
        	        {
        	            group_key271_last = group_key271.tree.get();
        	            stream_group_key.add(group_key271.tree);
        	        }

        	        this->followPush(FOLLOW_by_key_in_group_by_clause4194);
        	        by_key272=by_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulegroup_by_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) 
        	        {
        	            by_key272_last = by_key272.tree.get();
        	            stream_by_key.add(by_key272.tree);
        	        }

        	        // OracleDML.g:446:4: ( LEFT_PAREN RIGHT_PAREN | group_by_elements ( ( COMMA group_by_elements )=> COMMA group_by_elements )* )
        	        {
        	            ANTLR_UINT32 alt95=2;
        	            switch ( this->LA(1) )
        	            {
        	            case LEFT_PAREN:
        	            	{
        	            		switch ( this->LA(2) )
        	            		{
        	            		case RIGHT_PAREN:
        	            			{
        	            				alt95=1;
        	            			}
        	            		    break;
        	            		case APPROXIMATE_NUM_LIT:
        	            		case BINDVAR:
        	            		case CHAR_STRING:
        	            		case CHAR_STRING_PERL:
        	            		case COLON:
        	            		case DELIMITED_ID:
        	            		case EXACT_NUM_LIT:
        	            		case INTRODUCER:
        	            		case LEFT_PAREN:
        	            		case MINUS_SIGN:
        	            		case NATIONAL_CHAR_STRING_LIT:
        	            		case PLSQL_NON_RESERVED_CAST:
        	            		case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
        	            		case PLUS_SIGN:
        	            		case REGULAR_ID:
        	            		case SQL92_RESERVED_ALL:
        	            		case SQL92_RESERVED_ANY:
        	            		case SQL92_RESERVED_CASE:
        	            		case SQL92_RESERVED_CURSOR:
        	            		case SQL92_RESERVED_DATE:
        	            		case SQL92_RESERVED_DEFAULT:
        	            		case SQL92_RESERVED_DISTINCT:
        	            		case SQL92_RESERVED_EXISTS:
        	            		case SQL92_RESERVED_FALSE:
        	            		case SQL92_RESERVED_NOT:
        	            		case SQL92_RESERVED_NULL:
        	            		case SQL92_RESERVED_PRIOR:
        	            		case SQL92_RESERVED_SELECT:
        	            		case SQL92_RESERVED_TRUE:
        	            		case UNSIGNED_INTEGER:
        	            			{
        	            				alt95=2;
        	            			}
        	            		    break;

        	            		default:
        	            		    if (this->get_backtracking()>0)
        	            		    {
        	            		        this->set_failedflag( true );
        	            		        return retval;
        	            		    }

        	            		    ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	            		    ex->set_decisionNum( 95 );
        	            		    ex->set_state( 1 );


        	            		    goto rulegroup_by_clauseEx;

        	            		}

        	            	}
        	                break;
        	            case APPROXIMATE_NUM_LIT:
        	            case BINDVAR:
        	            case CHAR_STRING:
        	            case CHAR_STRING_PERL:
        	            case COLON:
        	            case DELIMITED_ID:
        	            case EXACT_NUM_LIT:
        	            case INTRODUCER:
        	            case MINUS_SIGN:
        	            case NATIONAL_CHAR_STRING_LIT:
        	            case PLSQL_NON_RESERVED_CAST:
        	            case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
        	            case PLUS_SIGN:
        	            case REGULAR_ID:
        	            case SQL92_RESERVED_ALL:
        	            case SQL92_RESERVED_ANY:
        	            case SQL92_RESERVED_CASE:
        	            case SQL92_RESERVED_CURSOR:
        	            case SQL92_RESERVED_DATE:
        	            case SQL92_RESERVED_DEFAULT:
        	            case SQL92_RESERVED_DISTINCT:
        	            case SQL92_RESERVED_EXISTS:
        	            case SQL92_RESERVED_FALSE:
        	            case SQL92_RESERVED_NOT:
        	            case SQL92_RESERVED_NULL:
        	            case SQL92_RESERVED_PRIOR:
        	            case SQL92_RESERVED_TRUE:
        	            case UNSIGNED_INTEGER:
        	            	{
        	            		alt95=2;
        	            	}
        	                break;

        	            default:
        	                if (this->get_backtracking()>0)
        	                {
        	                    this->set_failedflag( true );
        	                    return retval;
        	                }

        	                ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                ex->set_decisionNum( 95 );
        	                ex->set_state( 0 );


        	                goto rulegroup_by_clauseEx;

        	            }

        	            switch (alt95)
        	            {
        	        	case 1:
        	        	    // OracleDML.g:446:5: LEFT_PAREN RIGHT_PAREN
        	        	    {
        	        	        LEFT_PAREN273 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_group_by_clause4200);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulegroup_by_clauseEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }
        	        	         
        	        	        if ( this->get_backtracking()==0 ) stream_LEFT_PAREN.add(LEFT_PAREN273);


        	        	        RIGHT_PAREN274 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_group_by_clause4202);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulegroup_by_clauseEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }
        	        	         
        	        	        if ( this->get_backtracking()==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN274);


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // OracleDML.g:447:6: group_by_elements ( ( COMMA group_by_elements )=> COMMA group_by_elements )*
        	        	    {
        	        	        this->followPush(FOLLOW_group_by_elements_in_group_by_clause4209);
        	        	        group_by_elements275=group_by_elements();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulegroup_by_clauseEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) 
        	        	        {
        	        	            group_by_elements275_last = group_by_elements275.tree.get();
        	        	            stream_group_by_elements.add(group_by_elements275.tree);
        	        	        }

        	        	        // OracleDML.g:447:24: ( ( COMMA group_by_elements )=> COMMA group_by_elements )*

        	        	        for (;;)
        	        	        {
        	        	            ANTLR_UINT32 alt94=2;
        	        	            switch ( this->LA(1) )
        	        	            {
        	        	            case COMMA:
        	        	            	{
        	        	            		{
        	        	            		   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
        	        	            		    */
        	        	            		    ANTLR_UINT32 LA94_2 = this->LA(2);
        	        	            		    if ( (this->msynpred( antlr3::ClassForwarder<synpred17_OracleDML>() )))
        	        	            		    {
        	        	            		        alt94=1;
        	        	            		    }

        	        	            		}
        	        	            	}
        	        	                break;

        	        	            }

        	        	            switch (alt94)
        	        	            {
        	        	        	case 1:
        	        	        	    // OracleDML.g:447:25: ( COMMA group_by_elements )=> COMMA group_by_elements
        	        	        	    {
        	        	        	        COMMA276 =  this->matchToken(COMMA, &FOLLOW_COMMA_in_group_by_clause4219);
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto rulegroup_by_clauseEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return retval;
        	        	        	        }
        	        	        	         
        	        	        	        if ( this->get_backtracking()==0 ) stream_COMMA.add(COMMA276);


        	        	        	        this->followPush(FOLLOW_group_by_elements_in_group_by_clause4221);
        	        	        	        group_by_elements277=group_by_elements();

        	        	        	        this->followPop();
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto rulegroup_by_clauseEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return retval;
        	        	        	        }

        	        	        	        if ( this->get_backtracking()==0 ) 
        	        	        	        {
        	        	        	            group_by_elements277_last = group_by_elements277.tree.get();
        	        	        	            stream_group_by_elements.add(group_by_elements277.tree);
        	        	        	        }

        	        	        	    }
        	        	        	    break;

        	        	        	default:
        	        	        	    goto loop94;	/* break out of the loop */
        	        	        	    break;
        	        	            }
        	        	        }
        	        	        loop94: ; /* Jump out to here if this rule does not match */


        	        	    }
        	        	    break;

        	            }
        	        }

        	        // OracleDML.g:449:3: ( having_clause )?
        	        {
        	            ANTLR_UINT32 alt96=2;
        	            switch ( this->LA(1) )
        	            {
        	                case SQL92_RESERVED_HAVING:
        	                	{
        	                		alt96=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt96)
        	            {
        	        	case 1:
        	        	    // OracleDML.g:449:3: having_clause
        	        	    {
        	        	        this->followPush(FOLLOW_having_clause_in_group_by_clause4232);
        	        	        having_clause278=having_clause();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulegroup_by_clauseEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) 
        	        	        {
        	        	            having_clause278_last = having_clause278.tree.get();
        	        	            stream_having_clause.add(having_clause278.tree);
        	        	        }

        	        	    }
        	        	    break;

        	            }
        	        }

        	        // AST REWRITE
        	        // elements: having_clause, group_by_elements, group_key
        	        // token labels: 
        	        // rule labels: retval
        	        // token list labels: 
        	        // rule list labels: 
        	        // wildcard labels: 
        	        if ( this->get_backtracking()==0 ) {
        	        retval.tree = std::move(root_0);
        	        RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
        	        // 450:3: -> ^( GROUP_BY_CLAUSE[$group_key.start] ^( group_key ( ^( GROUP_BY_ELEMENT group_by_elements ) )* ) ( having_clause )? )
        	        {
        	        	// OracleDML.g:450:6: ^( GROUP_BY_CLAUSE[$group_key.start] ^( group_key ( ^( GROUP_BY_ELEMENT group_by_elements ) )* ) ( having_clause )? )
        	        	{
        	        	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
        	        	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(GROUP_BY_CLAUSE, (group_key271.start)), root_1);
        	        	// OracleDML.g:450:42: ^( group_key ( ^( GROUP_BY_ELEMENT group_by_elements ) )* )
        	        	{
        	        	ImplTraits::TreeTypePtr root_2 = get_psrstate()->get_treeAdaptor()->nilNode();
        	        	root_2 = get_psrstate()->get_treeAdaptor()->becomeRoot(stream_group_key.nextNode(), root_2);
        	        	// OracleDML.g:450:54: ( ^( GROUP_BY_ELEMENT group_by_elements ) )*
        	        	while ( stream_group_by_elements.hasNext() ) {
        	        		// OracleDML.g:450:54: ^( GROUP_BY_ELEMENT group_by_elements )
        	        		{
        	        		ImplTraits::TreeTypePtr root_3 = get_psrstate()->get_treeAdaptor()->nilNode();
        	        		root_3 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(GROUP_BY_ELEMENT, "GROUP_BY_ELEMENT"), root_3);
        	        		get_psrstate()->get_treeAdaptor()->addChild(root_3, stream_group_by_elements.nextTree());
        	        		get_psrstate()->get_treeAdaptor()->addChild(root_2, root_3);
        	        		}
        	        	}
        	        	stream_group_by_elements.reset();

        	        	get_psrstate()->get_treeAdaptor()->addChild(root_1, root_2);
        	        	}
        	        	// OracleDML.g:450:94: ( having_clause )?
        	        	if ( stream_having_clause.hasNext() ) {
        	        		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_having_clause.nextTree());
        	        	}
        	        	stream_having_clause.reset();

        	        	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
        	        	}
        	        }


        	        //retval.tree = std::move(root_0);
        	        }

        	    }
        	    break;
        	case 2:
        	    // OracleDML.g:451:9: ( having_key )=> having_clause ( group_key by_key ( LEFT_PAREN RIGHT_PAREN | group_by_elements ( ( COMMA group_by_elements )=> COMMA group_by_elements )* ) )?
        	    {
        	        this->followPush(FOLLOW_having_clause_in_group_by_clause4272);
        	        having_clause279=having_clause();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulegroup_by_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) 
        	        {
        	            having_clause279_last = having_clause279.tree.get();
        	            stream_having_clause.add(having_clause279.tree);
        	        }

        	        // OracleDML.g:452:3: ( group_key by_key ( LEFT_PAREN RIGHT_PAREN | group_by_elements ( ( COMMA group_by_elements )=> COMMA group_by_elements )* ) )?
        	        {
        	            ANTLR_UINT32 alt99=2;
        	            switch ( this->LA(1) )
        	            {
        	                case SQL92_RESERVED_GROUP:
        	                	{
        	                		alt99=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt99)
        	            {
        	        	case 1:
        	        	    // OracleDML.g:452:4: group_key by_key ( LEFT_PAREN RIGHT_PAREN | group_by_elements ( ( COMMA group_by_elements )=> COMMA group_by_elements )* )
        	        	    {
        	        	        this->followPush(FOLLOW_group_key_in_group_by_clause4277);
        	        	        group_key280=group_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulegroup_by_clauseEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) 
        	        	        {
        	        	            group_key280_last = group_key280.tree.get();
        	        	            stream_group_key.add(group_key280.tree);
        	        	        }

        	        	        this->followPush(FOLLOW_by_key_in_group_by_clause4279);
        	        	        by_key281=by_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulegroup_by_clauseEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) 
        	        	        {
        	        	            by_key281_last = by_key281.tree.get();
        	        	            stream_by_key.add(by_key281.tree);
        	        	        }

        	        	        // OracleDML.g:453:4: ( LEFT_PAREN RIGHT_PAREN | group_by_elements ( ( COMMA group_by_elements )=> COMMA group_by_elements )* )
        	        	        {
        	        	            ANTLR_UINT32 alt98=2;
        	        	            switch ( this->LA(1) )
        	        	            {
        	        	            case LEFT_PAREN:
        	        	            	{
        	        	            		switch ( this->LA(2) )
        	        	            		{
        	        	            		case RIGHT_PAREN:
        	        	            			{
        	        	            				alt98=1;
        	        	            			}
        	        	            		    break;
        	        	            		case APPROXIMATE_NUM_LIT:
        	        	            		case BINDVAR:
        	        	            		case CHAR_STRING:
        	        	            		case CHAR_STRING_PERL:
        	        	            		case COLON:
        	        	            		case DELIMITED_ID:
        	        	            		case EXACT_NUM_LIT:
        	        	            		case INTRODUCER:
        	        	            		case LEFT_PAREN:
        	        	            		case MINUS_SIGN:
        	        	            		case NATIONAL_CHAR_STRING_LIT:
        	        	            		case PLSQL_NON_RESERVED_CAST:
        	        	            		case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
        	        	            		case PLUS_SIGN:
        	        	            		case REGULAR_ID:
        	        	            		case SQL92_RESERVED_ALL:
        	        	            		case SQL92_RESERVED_ANY:
        	        	            		case SQL92_RESERVED_CASE:
        	        	            		case SQL92_RESERVED_CURSOR:
        	        	            		case SQL92_RESERVED_DATE:
        	        	            		case SQL92_RESERVED_DEFAULT:
        	        	            		case SQL92_RESERVED_DISTINCT:
        	        	            		case SQL92_RESERVED_EXISTS:
        	        	            		case SQL92_RESERVED_FALSE:
        	        	            		case SQL92_RESERVED_NOT:
        	        	            		case SQL92_RESERVED_NULL:
        	        	            		case SQL92_RESERVED_PRIOR:
        	        	            		case SQL92_RESERVED_SELECT:
        	        	            		case SQL92_RESERVED_TRUE:
        	        	            		case UNSIGNED_INTEGER:
        	        	            			{
        	        	            				alt98=2;
        	        	            			}
        	        	            		    break;

        	        	            		default:
        	        	            		    if (this->get_backtracking()>0)
        	        	            		    {
        	        	            		        this->set_failedflag( true );
        	        	            		        return retval;
        	        	            		    }

        	        	            		    ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	        	            		    ex->set_decisionNum( 98 );
        	        	            		    ex->set_state( 1 );


        	        	            		    goto rulegroup_by_clauseEx;

        	        	            		}

        	        	            	}
        	        	                break;
        	        	            case APPROXIMATE_NUM_LIT:
        	        	            case BINDVAR:
        	        	            case CHAR_STRING:
        	        	            case CHAR_STRING_PERL:
        	        	            case COLON:
        	        	            case DELIMITED_ID:
        	        	            case EXACT_NUM_LIT:
        	        	            case INTRODUCER:
        	        	            case MINUS_SIGN:
        	        	            case NATIONAL_CHAR_STRING_LIT:
        	        	            case PLSQL_NON_RESERVED_CAST:
        	        	            case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
        	        	            case PLUS_SIGN:
        	        	            case REGULAR_ID:
        	        	            case SQL92_RESERVED_ALL:
        	        	            case SQL92_RESERVED_ANY:
        	        	            case SQL92_RESERVED_CASE:
        	        	            case SQL92_RESERVED_CURSOR:
        	        	            case SQL92_RESERVED_DATE:
        	        	            case SQL92_RESERVED_DEFAULT:
        	        	            case SQL92_RESERVED_DISTINCT:
        	        	            case SQL92_RESERVED_EXISTS:
        	        	            case SQL92_RESERVED_FALSE:
        	        	            case SQL92_RESERVED_NOT:
        	        	            case SQL92_RESERVED_NULL:
        	        	            case SQL92_RESERVED_PRIOR:
        	        	            case SQL92_RESERVED_TRUE:
        	        	            case UNSIGNED_INTEGER:
        	        	            	{
        	        	            		alt98=2;
        	        	            	}
        	        	                break;

        	        	            default:
        	        	                if (this->get_backtracking()>0)
        	        	                {
        	        	                    this->set_failedflag( true );
        	        	                    return retval;
        	        	                }

        	        	                ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	        	                ex->set_decisionNum( 98 );
        	        	                ex->set_state( 0 );


        	        	                goto rulegroup_by_clauseEx;

        	        	            }

        	        	            switch (alt98)
        	        	            {
        	        	        	case 1:
        	        	        	    // OracleDML.g:453:5: LEFT_PAREN RIGHT_PAREN
        	        	        	    {
        	        	        	        LEFT_PAREN282 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_group_by_clause4285);
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto rulegroup_by_clauseEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return retval;
        	        	        	        }
        	        	        	         
        	        	        	        if ( this->get_backtracking()==0 ) stream_LEFT_PAREN.add(LEFT_PAREN282);


        	        	        	        RIGHT_PAREN283 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_group_by_clause4287);
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto rulegroup_by_clauseEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return retval;
        	        	        	        }
        	        	        	         
        	        	        	        if ( this->get_backtracking()==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN283);


        	        	        	    }
        	        	        	    break;
        	        	        	case 2:
        	        	        	    // OracleDML.g:454:6: group_by_elements ( ( COMMA group_by_elements )=> COMMA group_by_elements )*
        	        	        	    {
        	        	        	        this->followPush(FOLLOW_group_by_elements_in_group_by_clause4294);
        	        	        	        group_by_elements284=group_by_elements();

        	        	        	        this->followPop();
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto rulegroup_by_clauseEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return retval;
        	        	        	        }

        	        	        	        if ( this->get_backtracking()==0 ) 
        	        	        	        {
        	        	        	            group_by_elements284_last = group_by_elements284.tree.get();
        	        	        	            stream_group_by_elements.add(group_by_elements284.tree);
        	        	        	        }

        	        	        	        // OracleDML.g:454:24: ( ( COMMA group_by_elements )=> COMMA group_by_elements )*

        	        	        	        for (;;)
        	        	        	        {
        	        	        	            ANTLR_UINT32 alt97=2;
        	        	        	            switch ( this->LA(1) )
        	        	        	            {
        	        	        	            case COMMA:
        	        	        	            	{
        	        	        	            		{
        	        	        	            		   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
        	        	        	            		    */
        	        	        	            		    ANTLR_UINT32 LA97_2 = this->LA(2);
        	        	        	            		    if ( (this->msynpred( antlr3::ClassForwarder<synpred19_OracleDML>() )))
        	        	        	            		    {
        	        	        	            		        alt97=1;
        	        	        	            		    }

        	        	        	            		}
        	        	        	            	}
        	        	        	                break;

        	        	        	            }

        	        	        	            switch (alt97)
        	        	        	            {
        	        	        	        	case 1:
        	        	        	        	    // OracleDML.g:454:25: ( COMMA group_by_elements )=> COMMA group_by_elements
        	        	        	        	    {
        	        	        	        	        COMMA285 =  this->matchToken(COMMA, &FOLLOW_COMMA_in_group_by_clause4304);
        	        	        	        	        if  (this->hasException())
        	        	        	        	        {
        	        	        	        	            goto rulegroup_by_clauseEx;
        	        	        	        	        }
        	        	        	        	        if (this->hasFailed())
        	        	        	        	        {
        	        	        	        	            return retval;
        	        	        	        	        }
        	        	        	        	         
        	        	        	        	        if ( this->get_backtracking()==0 ) stream_COMMA.add(COMMA285);


        	        	        	        	        this->followPush(FOLLOW_group_by_elements_in_group_by_clause4306);
        	        	        	        	        group_by_elements286=group_by_elements();

        	        	        	        	        this->followPop();
        	        	        	        	        if  (this->hasException())
        	        	        	        	        {
        	        	        	        	            goto rulegroup_by_clauseEx;
        	        	        	        	        }
        	        	        	        	        if (this->hasFailed())
        	        	        	        	        {
        	        	        	        	            return retval;
        	        	        	        	        }

        	        	        	        	        if ( this->get_backtracking()==0 ) 
        	        	        	        	        {
        	        	        	        	            group_by_elements286_last = group_by_elements286.tree.get();
        	        	        	        	            stream_group_by_elements.add(group_by_elements286.tree);
        	        	        	        	        }

        	        	        	        	    }
        	        	        	        	    break;

        	        	        	        	default:
        	        	        	        	    goto loop97;	/* break out of the loop */
        	        	        	        	    break;
        	        	        	            }
        	        	        	        }
        	        	        	        loop97: ; /* Jump out to here if this rule does not match */


        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	    }
        	        	    break;

        	            }
        	        }

        	        // AST REWRITE
        	        // elements: group_by_elements, having_clause, group_key
        	        // token labels: 
        	        // rule labels: retval
        	        // token list labels: 
        	        // rule list labels: 
        	        // wildcard labels: 
        	        if ( this->get_backtracking()==0 ) {
        	        retval.tree = std::move(root_0);
        	        RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
        	        // 457:3: -> ^( GROUP_BY_CLAUSE[$having_clause.start] having_clause ( ^( group_key ( ^( GROUP_BY_ELEMENT group_by_elements ) )* ) )? )
        	        {
        	        	// OracleDML.g:457:6: ^( GROUP_BY_CLAUSE[$having_clause.start] having_clause ( ^( group_key ( ^( GROUP_BY_ELEMENT group_by_elements ) )* ) )? )
        	        	{
        	        	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
        	        	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(GROUP_BY_CLAUSE, (having_clause279.start)), root_1);
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_having_clause.nextTree());
        	        	// OracleDML.g:457:60: ( ^( group_key ( ^( GROUP_BY_ELEMENT group_by_elements ) )* ) )?
        	        	if ( stream_group_by_elements.hasNext()||stream_group_key.hasNext() ) {
        	        		// OracleDML.g:457:60: ^( group_key ( ^( GROUP_BY_ELEMENT group_by_elements ) )* )
        	        		{
        	        		ImplTraits::TreeTypePtr root_2 = get_psrstate()->get_treeAdaptor()->nilNode();
        	        		root_2 = get_psrstate()->get_treeAdaptor()->becomeRoot(stream_group_key.nextNode(), root_2);
        	        		// OracleDML.g:457:72: ( ^( GROUP_BY_ELEMENT group_by_elements ) )*
        	        		while ( stream_group_by_elements.hasNext() ) {
        	        			// OracleDML.g:457:72: ^( GROUP_BY_ELEMENT group_by_elements )
        	        			{
        	        			ImplTraits::TreeTypePtr root_3 = get_psrstate()->get_treeAdaptor()->nilNode();
        	        			root_3 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(GROUP_BY_ELEMENT, "GROUP_BY_ELEMENT"), root_3);
        	        			get_psrstate()->get_treeAdaptor()->addChild(root_3, stream_group_by_elements.nextTree());
        	        			get_psrstate()->get_treeAdaptor()->addChild(root_2, root_3);
        	        			}
        	        		}
        	        		stream_group_by_elements.reset();

        	        		get_psrstate()->get_treeAdaptor()->addChild(root_1, root_2);
        	        		}
        	        	}
        	        	stream_group_by_elements.reset();
        	        	stream_group_key.reset();

        	        	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
        	        	}
        	        }


        	        //retval.tree = std::move(root_0);
        	        }

        	    }
        	    break;

            }
        }
    }//...
    // This is where rules clean up and exit
    //
    goto rulegroup_by_clauseEx; /* Prevent compiler warnings */
    rulegroup_by_clauseEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end group_by_clause */

/**
 * $ANTLR start group_by_elements
 * OracleDML.g:460:1: group_by_elements : ( grouping_sets_clause | rollup_cube_clause | expression -> ^( EXPR expression ) );
 */
OracleDML::group_by_elements_return
OracleDML::group_by_elements()
{
    OracleDML::group_by_elements_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML::grouping_sets_clause_return grouping_sets_clause287;
    ImplTraits::TreeTypePtr::pointer grouping_sets_clause287_last = NULL;
    OracleDML::rollup_cube_clause_return rollup_cube_clause288;
    ImplTraits::TreeTypePtr::pointer rollup_cube_clause288_last = NULL;
    OracleDML::expression_return expression289;
    ImplTraits::TreeTypePtr::pointer expression289_last = NULL;
    RewriteRuleSubtreeStream<ImplTraits> stream_expression(get_psrstate()->get_treeAdaptor(), "rule expression");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        {
            //  OracleDML.g:461:5: ( grouping_sets_clause | rollup_cube_clause | expression -> ^( EXPR expression ) )

            ANTLR_UINT32 alt101;

            alt101=3;

            switch ( this->LA(1) )
            {
            case REGULAR_ID:
            	{
            		{
            		    ANTLR_UINT32 LA101_1 = this->LA(2);
            		    if ( ((toUpper(LT(1)->getText()) == "GROUPING")))
            		    {
            		        alt101=1;
            		    }
            		    else if ( ((((toUpper(LT(1)->getText()) == "ROLLUP"))||((toUpper(LT(1)->getText()) == "CUBE")))))
            		    {
            		        alt101=2;
            		    }
            		    else if ( (true))
            		    {
            		        alt101=3;
            		    }
            		    else
            		    {
            		        if (this->get_backtracking()>0)
            		        {
            		            this->set_failedflag( true );
            		            return retval;
            		        }


            		        ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 101 );
            		        ex->set_state( 1 );


            		        goto rulegroup_by_elementsEx;

            		    }
            		}
            	}
                break;
            case APPROXIMATE_NUM_LIT:
            case BINDVAR:
            case CHAR_STRING:
            case CHAR_STRING_PERL:
            case COLON:
            case DELIMITED_ID:
            case EXACT_NUM_LIT:
            case INTRODUCER:
            case LEFT_PAREN:
            case MINUS_SIGN:
            case NATIONAL_CHAR_STRING_LIT:
            case PLSQL_NON_RESERVED_CAST:
            case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
            case PLUS_SIGN:
            case SQL92_RESERVED_ALL:
            case SQL92_RESERVED_ANY:
            case SQL92_RESERVED_CASE:
            case SQL92_RESERVED_CURSOR:
            case SQL92_RESERVED_DATE:
            case SQL92_RESERVED_DEFAULT:
            case SQL92_RESERVED_DISTINCT:
            case SQL92_RESERVED_EXISTS:
            case SQL92_RESERVED_FALSE:
            case SQL92_RESERVED_NOT:
            case SQL92_RESERVED_NULL:
            case SQL92_RESERVED_PRIOR:
            case SQL92_RESERVED_TRUE:
            case UNSIGNED_INTEGER:
            	{
            		alt101=3;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 101 );
                ex->set_state( 0 );


                goto rulegroup_by_elementsEx;

            }

            switch (alt101)
            {
        	case 1:
        	    // OracleDML.g:461:10: grouping_sets_clause
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_grouping_sets_clause_in_group_by_elements4361);
        	        grouping_sets_clause287=grouping_sets_clause();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulegroup_by_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, grouping_sets_clause287.tree);


        	    }
        	    break;
        	case 2:
        	    // OracleDML.g:462:10: rollup_cube_clause
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_rollup_cube_clause_in_group_by_elements4372);
        	        rollup_cube_clause288=rollup_cube_clause();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulegroup_by_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, rollup_cube_clause288.tree);


        	    }
        	    break;
        	case 3:
        	    // OracleDML.g:463:10: expression
        	    {
        	        this->followPush(FOLLOW_expression_in_group_by_elements4384);
        	        expression289=expression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulegroup_by_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) 
        	        {
        	            expression289_last = expression289.tree.get();
        	            stream_expression.add(expression289.tree);
        	        }

        	        // AST REWRITE
        	        // elements: expression
        	        // token labels: 
        	        // rule labels: retval
        	        // token list labels: 
        	        // rule list labels: 
        	        // wildcard labels: 
        	        if ( this->get_backtracking()==0 ) {
        	        retval.tree = std::move(root_0);
        	        RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
        	        // 463:21: -> ^( EXPR expression )
        	        {
        	        	// OracleDML.g:463:24: ^( EXPR expression )
        	        	{
        	        	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
        	        	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(EXPR, "EXPR"), root_1);
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_expression.nextTree());
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
        	        	}
        	        }


        	        //retval.tree = std::move(root_0);
        	        }

        	    }
        	    break;

            }
        }
    }//...
    // This is where rules clean up and exit
    //
    goto rulegroup_by_elementsEx; /* Prevent compiler warnings */
    rulegroup_by_elementsEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end group_by_elements */

/**
 * $ANTLR start rollup_cube_clause
 * OracleDML.g:466:1: rollup_cube_clause : ( rollup_key ^| cube_key ^) LEFT_PAREN grouping_sets_elements ( COMMA ! grouping_sets_elements )* RIGHT_PAREN ;
 */
OracleDML::rollup_cube_clause_return
OracleDML::rollup_cube_clause()
{
    OracleDML::rollup_cube_clause_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* LEFT_PAREN292 = NULL;
    ImplTraits::CommonTokenType const* COMMA294 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN296 = NULL;
    OracleDML_OracleDMLKeys::rollup_key_return rollup_key290;
    ImplTraits::TreeTypePtr::pointer rollup_key290_last = NULL;
    OracleDML_OracleDMLKeys::cube_key_return cube_key291;
    ImplTraits::TreeTypePtr::pointer cube_key291_last = NULL;
    OracleDML::grouping_sets_elements_return grouping_sets_elements293;
    ImplTraits::TreeTypePtr::pointer grouping_sets_elements293_last = NULL;
    OracleDML::grouping_sets_elements_return grouping_sets_elements295;
    ImplTraits::TreeTypePtr::pointer grouping_sets_elements295_last = NULL;
    ImplTraits::TreeTypePtr LEFT_PAREN292_tree;
    ImplTraits::TreeTypePtr COMMA294_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN296_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:467:5: ( ( rollup_key ^| cube_key ^) LEFT_PAREN grouping_sets_elements ( COMMA ! grouping_sets_elements )* RIGHT_PAREN )
        // OracleDML.g:467:10: ( rollup_key ^| cube_key ^) LEFT_PAREN grouping_sets_elements ( COMMA ! grouping_sets_elements )* RIGHT_PAREN
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            // OracleDML.g:467:10: ( rollup_key ^| cube_key ^)
            {
                ANTLR_UINT32 alt102=2;
                {
                    ANTLR_UINT32 LA102_0 = this->LA(1);
                    if ( (LA102_0 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "ROLLUP"))||((toUpper(LT(1)->getText()) == "CUBE")))))
                    {
                        {
                            ANTLR_UINT32 LA102_1 = this->LA(2);
                            if ( ((toUpper(LT(1)->getText()) == "ROLLUP")))
                            {
                                alt102=1;
                            }
                            else if ( ((toUpper(LT(1)->getText()) == "CUBE")))
                            {
                                alt102=2;
                            }
                            else
                            {
                                if (this->get_backtracking()>0)
                                {
                                    this->set_failedflag( true );
                                    return retval;
                                }


                                ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                ex->set_decisionNum( 102 );
                                ex->set_state( 1 );


                                goto rulerollup_cube_clauseEx;

                            }
                        }
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return retval;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 102 );
                        ex->set_state( 0 );


                        goto rulerollup_cube_clauseEx;

                    }
                }
                switch (alt102)
                {
            	case 1:
            	    // OracleDML.g:467:11: rollup_key ^
            	    {
            	        this->followPush(FOLLOW_rollup_key_in_rollup_cube_clause4413);
            	        rollup_key290=rollup_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulerollup_cube_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(rollup_key290.tree, root_0);

            	    }
            	    break;
            	case 2:
            	    // OracleDML.g:467:23: cube_key ^
            	    {
            	        this->followPush(FOLLOW_cube_key_in_rollup_cube_clause4416);
            	        cube_key291=cube_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulerollup_cube_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(cube_key291.tree, root_0);

            	    }
            	    break;

                }
            }

            LEFT_PAREN292 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_rollup_cube_clause4420);
            if  (this->hasException())
            {
                goto rulerollup_cube_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            LEFT_PAREN292_tree = std::move(get_psrstate()->get_treeAdaptor()->create(LEFT_PAREN292));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, LEFT_PAREN292_tree);
            }


            this->followPush(FOLLOW_grouping_sets_elements_in_rollup_cube_clause4422);
            grouping_sets_elements293=grouping_sets_elements();

            this->followPop();
            if  (this->hasException())
            {
                goto rulerollup_cube_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, grouping_sets_elements293.tree);


            // OracleDML.g:467:68: ( COMMA ! grouping_sets_elements )*

            for (;;)
            {
                ANTLR_UINT32 alt103=2;
                switch ( this->LA(1) )
                {
                case COMMA:
                	{
                		alt103=1;
                	}
                    break;

                }

                switch (alt103)
                {
            	case 1:
            	    // OracleDML.g:467:69: COMMA ! grouping_sets_elements
            	    {
            	        COMMA294 =  this->matchToken(COMMA, &FOLLOW_COMMA_in_rollup_cube_clause4425);
            	        if  (this->hasException())
            	        {
            	            goto rulerollup_cube_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }


            	        this->followPush(FOLLOW_grouping_sets_elements_in_rollup_cube_clause4428);
            	        grouping_sets_elements295=grouping_sets_elements();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulerollup_cube_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, grouping_sets_elements295.tree);


            	    }
            	    break;

            	default:
            	    goto loop103;	/* break out of the loop */
            	    break;
                }
            }
            loop103: ; /* Jump out to here if this rule does not match */


            RIGHT_PAREN296 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_rollup_cube_clause4432);
            if  (this->hasException())
            {
                goto rulerollup_cube_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            RIGHT_PAREN296_tree = std::move(get_psrstate()->get_treeAdaptor()->create(RIGHT_PAREN296));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, RIGHT_PAREN296_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulerollup_cube_clauseEx; /* Prevent compiler warnings */
    rulerollup_cube_clauseEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end rollup_cube_clause */

/**
 * $ANTLR start grouping_sets_clause
 * OracleDML.g:470:1: grouping_sets_clause : grouping_key sets_key LEFT_PAREN grouping_sets_elements ( COMMA grouping_sets_elements )* RIGHT_PAREN -> ^( grouping_key ( ^( GROUPIN_SET grouping_sets_elements ) )+ ) ;
 */
OracleDML::grouping_sets_clause_return
OracleDML::grouping_sets_clause()
{
    OracleDML::grouping_sets_clause_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* LEFT_PAREN299 = NULL;
    ImplTraits::CommonTokenType const* COMMA301 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN303 = NULL;
    OracleDML_OracleDMLKeys::grouping_key_return grouping_key297;
    ImplTraits::TreeTypePtr::pointer grouping_key297_last = NULL;
    OracleDML_OracleDMLKeys::sets_key_return sets_key298;
    ImplTraits::TreeTypePtr::pointer sets_key298_last = NULL;
    OracleDML::grouping_sets_elements_return grouping_sets_elements300;
    ImplTraits::TreeTypePtr::pointer grouping_sets_elements300_last = NULL;
    OracleDML::grouping_sets_elements_return grouping_sets_elements302;
    ImplTraits::TreeTypePtr::pointer grouping_sets_elements302_last = NULL;
    ImplTraits::TreeTypePtr LEFT_PAREN299_tree;
    ImplTraits::TreeTypePtr COMMA301_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN303_tree;
    RewriteRuleTokenStream<ImplTraits> stream_LEFT_PAREN(get_psrstate()->get_treeAdaptor(), "token LEFT_PAREN");
    RewriteRuleTokenStream<ImplTraits> stream_RIGHT_PAREN(get_psrstate()->get_treeAdaptor(), "token RIGHT_PAREN");
    RewriteRuleTokenStream<ImplTraits> stream_COMMA(get_psrstate()->get_treeAdaptor(), "token COMMA");
    RewriteRuleSubtreeStream<ImplTraits> stream_grouping_key(get_psrstate()->get_treeAdaptor(), "rule grouping_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_sets_key(get_psrstate()->get_treeAdaptor(), "rule sets_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_grouping_sets_elements(get_psrstate()->get_treeAdaptor(), "rule grouping_sets_elements");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:471:5: ( grouping_key sets_key LEFT_PAREN grouping_sets_elements ( COMMA grouping_sets_elements )* RIGHT_PAREN -> ^( grouping_key ( ^( GROUPIN_SET grouping_sets_elements ) )+ ) )
        // OracleDML.g:471:10: grouping_key sets_key LEFT_PAREN grouping_sets_elements ( COMMA grouping_sets_elements )* RIGHT_PAREN
        {
            this->followPush(FOLLOW_grouping_key_in_grouping_sets_clause4453);
            grouping_key297=grouping_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulegrouping_sets_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                grouping_key297_last = grouping_key297.tree.get();
                stream_grouping_key.add(grouping_key297.tree);
            }

            this->followPush(FOLLOW_sets_key_in_grouping_sets_clause4455);
            sets_key298=sets_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulegrouping_sets_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                sets_key298_last = sets_key298.tree.get();
                stream_sets_key.add(sets_key298.tree);
            }

            LEFT_PAREN299 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_grouping_sets_clause4466);
            if  (this->hasException())
            {
                goto rulegrouping_sets_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_LEFT_PAREN.add(LEFT_PAREN299);


            this->followPush(FOLLOW_grouping_sets_elements_in_grouping_sets_clause4468);
            grouping_sets_elements300=grouping_sets_elements();

            this->followPop();
            if  (this->hasException())
            {
                goto rulegrouping_sets_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                grouping_sets_elements300_last = grouping_sets_elements300.tree.get();
                stream_grouping_sets_elements.add(grouping_sets_elements300.tree);
            }

            // OracleDML.g:472:43: ( COMMA grouping_sets_elements )*

            for (;;)
            {
                ANTLR_UINT32 alt104=2;
                switch ( this->LA(1) )
                {
                case COMMA:
                	{
                		alt104=1;
                	}
                    break;

                }

                switch (alt104)
                {
            	case 1:
            	    // OracleDML.g:472:44: COMMA grouping_sets_elements
            	    {
            	        COMMA301 =  this->matchToken(COMMA, &FOLLOW_COMMA_in_grouping_sets_clause4471);
            	        if  (this->hasException())
            	        {
            	            goto rulegrouping_sets_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( this->get_backtracking()==0 ) stream_COMMA.add(COMMA301);


            	        this->followPush(FOLLOW_grouping_sets_elements_in_grouping_sets_clause4473);
            	        grouping_sets_elements302=grouping_sets_elements();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulegrouping_sets_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            grouping_sets_elements302_last = grouping_sets_elements302.tree.get();
            	            stream_grouping_sets_elements.add(grouping_sets_elements302.tree);
            	        }

            	    }
            	    break;

            	default:
            	    goto loop104;	/* break out of the loop */
            	    break;
                }
            }
            loop104: ; /* Jump out to here if this rule does not match */


            RIGHT_PAREN303 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_grouping_sets_clause4477);
            if  (this->hasException())
            {
                goto rulegrouping_sets_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN303);


            // AST REWRITE
            // elements: grouping_key, grouping_sets_elements
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 473:9: -> ^( grouping_key ( ^( GROUPIN_SET grouping_sets_elements ) )+ )
            {
            	// OracleDML.g:473:12: ^( grouping_key ( ^( GROUPIN_SET grouping_sets_elements ) )+ )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(stream_grouping_key.nextNode(), root_1);
            	if ( !(stream_grouping_sets_elements.hasNext()) ) {
            		ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, REWRITE_EARLY_EXCEPTION, StreamType>( this->get_rec(), "grouping_sets_elements empty" );
            		goto rulegrouping_sets_clauseEx;
            	}
            	while ( stream_grouping_sets_elements.hasNext() ) {
            		// OracleDML.g:473:27: ^( GROUPIN_SET grouping_sets_elements )
            		{
            		ImplTraits::TreeTypePtr root_2 = get_psrstate()->get_treeAdaptor()->nilNode();
            		root_2 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(GROUPIN_SET, "GROUPIN_SET"), root_2);
            		get_psrstate()->get_treeAdaptor()->addChild(root_2, stream_grouping_sets_elements.nextTree());
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, root_2);
            		}
            	}
            	stream_grouping_sets_elements.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulegrouping_sets_clauseEx; /* Prevent compiler warnings */
    rulegrouping_sets_clauseEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end grouping_sets_clause */

/**
 * $ANTLR start grouping_sets_elements
 * OracleDML.g:476:1: grouping_sets_elements : ( ( rollup_key | cube_key )=> rollup_cube_clause | ( LEFT_PAREN )=> expression_list | expression -> ^( EXPR expression ) );
 */
OracleDML::grouping_sets_elements_return
OracleDML::grouping_sets_elements()
{
    OracleDML::grouping_sets_elements_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML::rollup_cube_clause_return rollup_cube_clause304;
    ImplTraits::TreeTypePtr::pointer rollup_cube_clause304_last = NULL;
    OracleDML::expression_list_return expression_list305;
    ImplTraits::TreeTypePtr::pointer expression_list305_last = NULL;
    OracleDML::expression_return expression306;
    ImplTraits::TreeTypePtr::pointer expression306_last = NULL;
    RewriteRuleSubtreeStream<ImplTraits> stream_expression(get_psrstate()->get_treeAdaptor(), "rule expression");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        {
            //  OracleDML.g:477:5: ( ( rollup_key | cube_key )=> rollup_cube_clause | ( LEFT_PAREN )=> expression_list | expression -> ^( EXPR expression ) )

            ANTLR_UINT32 alt105;

            alt105=3;

            switch ( this->LA(1) )
            {
            case REGULAR_ID:
            	{
            		{
            		    ANTLR_UINT32 LA105_1 = this->LA(2);
            		    if ( (( ((((toUpper(LT(1)->getText()) == "ROLLUP"))||((toUpper(LT(1)->getText()) == "CUBE")))) && (this->msynpred( antlr3::ClassForwarder<synpred20_OracleDML>() )) )))
            		    {
            		        alt105=1;
            		    }
            		    else if ( (true))
            		    {
            		        alt105=3;
            		    }
            		    else
            		    {
            		        if (this->get_backtracking()>0)
            		        {
            		            this->set_failedflag( true );
            		            return retval;
            		        }


            		        ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 105 );
            		        ex->set_state( 1 );


            		        goto rulegrouping_sets_elementsEx;

            		    }
            		}
            	}
                break;
            case LEFT_PAREN:
            	{
            		{
            		    ANTLR_UINT32 LA105_2 = this->LA(2);
            		    if ( (this->msynpred( antlr3::ClassForwarder<synpred21_OracleDML>() )))
            		    {
            		        alt105=2;
            		    }
            		    else if ( (true))
            		    {
            		        alt105=3;
            		    }
            		    else
            		    {
            		        if (this->get_backtracking()>0)
            		        {
            		            this->set_failedflag( true );
            		            return retval;
            		        }


            		        ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 105 );
            		        ex->set_state( 2 );


            		        goto rulegrouping_sets_elementsEx;

            		    }
            		}
            	}
                break;
            case APPROXIMATE_NUM_LIT:
            case BINDVAR:
            case CHAR_STRING:
            case CHAR_STRING_PERL:
            case COLON:
            case DELIMITED_ID:
            case EXACT_NUM_LIT:
            case INTRODUCER:
            case MINUS_SIGN:
            case NATIONAL_CHAR_STRING_LIT:
            case PLSQL_NON_RESERVED_CAST:
            case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
            case PLUS_SIGN:
            case SQL92_RESERVED_ALL:
            case SQL92_RESERVED_ANY:
            case SQL92_RESERVED_CASE:
            case SQL92_RESERVED_CURSOR:
            case SQL92_RESERVED_DATE:
            case SQL92_RESERVED_DEFAULT:
            case SQL92_RESERVED_DISTINCT:
            case SQL92_RESERVED_EXISTS:
            case SQL92_RESERVED_FALSE:
            case SQL92_RESERVED_NOT:
            case SQL92_RESERVED_NULL:
            case SQL92_RESERVED_PRIOR:
            case SQL92_RESERVED_TRUE:
            case UNSIGNED_INTEGER:
            	{
            		alt105=3;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 105 );
                ex->set_state( 0 );


                goto rulegrouping_sets_elementsEx;

            }

            switch (alt105)
            {
        	case 1:
        	    // OracleDML.g:477:10: ( rollup_key | cube_key )=> rollup_cube_clause
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_rollup_cube_clause_in_grouping_sets_elements4525);
        	        rollup_cube_clause304=rollup_cube_clause();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulegrouping_sets_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, rollup_cube_clause304.tree);


        	    }
        	    break;
        	case 2:
        	    // OracleDML.g:478:10: ( LEFT_PAREN )=> expression_list
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_expression_list_in_grouping_sets_elements4541);
        	        expression_list305=expression_list();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulegrouping_sets_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, expression_list305.tree);


        	    }
        	    break;
        	case 3:
        	    // OracleDML.g:479:10: expression
        	    {
        	        this->followPush(FOLLOW_expression_in_grouping_sets_elements4552);
        	        expression306=expression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulegrouping_sets_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) 
        	        {
        	            expression306_last = expression306.tree.get();
        	            stream_expression.add(expression306.tree);
        	        }

        	        // AST REWRITE
        	        // elements: expression
        	        // token labels: 
        	        // rule labels: retval
        	        // token list labels: 
        	        // rule list labels: 
        	        // wildcard labels: 
        	        if ( this->get_backtracking()==0 ) {
        	        retval.tree = std::move(root_0);
        	        RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
        	        // 479:21: -> ^( EXPR expression )
        	        {
        	        	// OracleDML.g:479:24: ^( EXPR expression )
        	        	{
        	        	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
        	        	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(EXPR, "EXPR"), root_1);
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_expression.nextTree());
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
        	        	}
        	        }


        	        //retval.tree = std::move(root_0);
        	        }

        	    }
        	    break;

            }
        }
    }//...
    // This is where rules clean up and exit
    //
    goto rulegrouping_sets_elementsEx; /* Prevent compiler warnings */
    rulegrouping_sets_elementsEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end grouping_sets_elements */

/**
 * $ANTLR start having_clause
 * OracleDML.g:482:1: having_clause : having_key condition -> ^( having_key ^( LOGIC_EXPR condition ) ) ;
 */
OracleDML::having_clause_return
OracleDML::having_clause()
{
    OracleDML::having_clause_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML_OracleDMLKeys::having_key_return having_key307;
    ImplTraits::TreeTypePtr::pointer having_key307_last = NULL;
    OracleDML::condition_return condition308;
    ImplTraits::TreeTypePtr::pointer condition308_last = NULL;
    RewriteRuleSubtreeStream<ImplTraits> stream_having_key(get_psrstate()->get_treeAdaptor(), "rule having_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_condition(get_psrstate()->get_treeAdaptor(), "rule condition");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:483:5: ( having_key condition -> ^( having_key ^( LOGIC_EXPR condition ) ) )
        // OracleDML.g:483:10: having_key condition
        {
            this->followPush(FOLLOW_having_key_in_having_clause4580);
            having_key307=having_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulehaving_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                having_key307_last = having_key307.tree.get();
                stream_having_key.add(having_key307.tree);
            }

            this->followPush(FOLLOW_condition_in_having_clause4582);
            condition308=condition();

            this->followPop();
            if  (this->hasException())
            {
                goto rulehaving_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                condition308_last = condition308.tree.get();
                stream_condition.add(condition308.tree);
            }

            // AST REWRITE
            // elements: condition, having_key
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 484:9: -> ^( having_key ^( LOGIC_EXPR condition ) )
            {
            	// OracleDML.g:484:12: ^( having_key ^( LOGIC_EXPR condition ) )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(stream_having_key.nextNode(), root_1);
            	// OracleDML.g:484:25: ^( LOGIC_EXPR condition )
            	{
            	ImplTraits::TreeTypePtr root_2 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_2 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(LOGIC_EXPR, "LOGIC_EXPR"), root_2);
            	get_psrstate()->get_treeAdaptor()->addChild(root_2, stream_condition.nextTree());
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, root_2);
            	}
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulehaving_clauseEx; /* Prevent compiler warnings */
    rulehaving_clauseEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end having_clause */

/**
 * $ANTLR start model_clause
 * OracleDML.g:487:1: model_clause : model_key ( cell_reference_options )* ( return_rows_clause )? ( reference_model )* main_model -> ^( model_key ( cell_reference_options )* ( return_rows_clause )? ( reference_model )* main_model ) ;
 */
OracleDML::model_clause_return
OracleDML::model_clause()
{
    OracleDML::model_clause_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML_OracleDMLKeys::model_key_return model_key309;
    ImplTraits::TreeTypePtr::pointer model_key309_last = NULL;
    OracleDML::cell_reference_options_return cell_reference_options310;
    ImplTraits::TreeTypePtr::pointer cell_reference_options310_last = NULL;
    OracleDML::return_rows_clause_return return_rows_clause311;
    ImplTraits::TreeTypePtr::pointer return_rows_clause311_last = NULL;
    OracleDML::reference_model_return reference_model312;
    ImplTraits::TreeTypePtr::pointer reference_model312_last = NULL;
    OracleDML::main_model_return main_model313;
    ImplTraits::TreeTypePtr::pointer main_model313_last = NULL;
    RewriteRuleSubtreeStream<ImplTraits> stream_return_rows_clause(get_psrstate()->get_treeAdaptor(), "rule return_rows_clause");
    RewriteRuleSubtreeStream<ImplTraits> stream_model_key(get_psrstate()->get_treeAdaptor(), "rule model_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_cell_reference_options(get_psrstate()->get_treeAdaptor(), "rule cell_reference_options");
    RewriteRuleSubtreeStream<ImplTraits> stream_reference_model(get_psrstate()->get_treeAdaptor(), "rule reference_model");
    RewriteRuleSubtreeStream<ImplTraits> stream_main_model(get_psrstate()->get_treeAdaptor(), "rule main_model");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:488:5: ( model_key ( cell_reference_options )* ( return_rows_clause )? ( reference_model )* main_model -> ^( model_key ( cell_reference_options )* ( return_rows_clause )? ( reference_model )* main_model ) )
        // OracleDML.g:488:10: model_key ( cell_reference_options )* ( return_rows_clause )? ( reference_model )* main_model
        {
            this->followPush(FOLLOW_model_key_in_model_clause4622);
            model_key309=model_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemodel_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                model_key309_last = model_key309.tree.get();
                stream_model_key.add(model_key309.tree);
            }

            // OracleDML.g:488:20: ( cell_reference_options )*

            for (;;)
            {
                ANTLR_UINT32 alt106=2;
                switch ( this->LA(1) )
                {
                case REGULAR_ID:
                	{
                		switch ( this->LA(2) )
                		{
                		case REGULAR_ID:
                			{
                				{
                				   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                				    */
                				    ANTLR_UINT32 LA106_3 = this->LA(3);
                				    if ( ((((toUpper(LT(1)->getText()) == "KEEP"))||((toUpper(LT(1)->getText()) == "IGNORE")))))
                				    {
                				        alt106=1;
                				    }

                				}
                			}
                		    break;

                		}

                	}
                    break;
                case SQL92_RESERVED_UNIQUE:
                	{
                		alt106=1;
                	}
                    break;

                }

                switch (alt106)
                {
            	case 1:
            	    // OracleDML.g:488:20: cell_reference_options
            	    {
            	        this->followPush(FOLLOW_cell_reference_options_in_model_clause4624);
            	        cell_reference_options310=cell_reference_options();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemodel_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            cell_reference_options310_last = cell_reference_options310.tree.get();
            	            stream_cell_reference_options.add(cell_reference_options310.tree);
            	        }

            	    }
            	    break;

            	default:
            	    goto loop106;	/* break out of the loop */
            	    break;
                }
            }
            loop106: ; /* Jump out to here if this rule does not match */


            // OracleDML.g:488:44: ( return_rows_clause )?
            {
                ANTLR_UINT32 alt107=2;
                switch ( this->LA(1) )
                {
                    case REGULAR_ID:
                    	{
                    		switch ( this->LA(2) )
                    		{
                    		    case REGULAR_ID:
                    		    	{
                    		    		switch ( this->LA(3) )
                    		    		{
                    		    		    case REGULAR_ID:
                    		    		    	{
                    		    		    		switch ( this->LA(4) )
                    		    		    		{
                    		    		    		    case REGULAR_ID:
                    		    		    		    	{
                    		    		    		    		alt107=1;
                    		    		    		    	}
                    		    		    		        break;
                    		    		    		}

                    		    		    	}
                    		    		        break;
                    		    		}

                    		    	}
                    		        break;
                    		    case SQL92_RESERVED_ALL:
                    		    	{
                    		    		alt107=1;
                    		    	}
                    		        break;
                    		}

                    	}
                        break;
                }

                switch (alt107)
                {
            	case 1:
            	    // OracleDML.g:488:44: return_rows_clause
            	    {
            	        this->followPush(FOLLOW_return_rows_clause_in_model_clause4627);
            	        return_rows_clause311=return_rows_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemodel_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            return_rows_clause311_last = return_rows_clause311.tree.get();
            	            stream_return_rows_clause.add(return_rows_clause311.tree);
            	        }

            	    }
            	    break;

                }
            }

            // OracleDML.g:488:64: ( reference_model )*

            for (;;)
            {
                ANTLR_UINT32 alt108=2;
                alt108 = cdfa108.predict(this, this->get_rec(), this->get_istream(), cdfa108 );
                if  (this->hasException())
                {
                    goto rulemodel_clauseEx;
                }
                if (this->hasFailed())
                {
                    return retval;
                }

                switch (alt108)
                {
            	case 1:
            	    // OracleDML.g:488:64: reference_model
            	    {
            	        this->followPush(FOLLOW_reference_model_in_model_clause4630);
            	        reference_model312=reference_model();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemodel_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            reference_model312_last = reference_model312.tree.get();
            	            stream_reference_model.add(reference_model312.tree);
            	        }

            	    }
            	    break;

            	default:
            	    goto loop108;	/* break out of the loop */
            	    break;
                }
            }
            loop108: ; /* Jump out to here if this rule does not match */


            this->followPush(FOLLOW_main_model_in_model_clause4633);
            main_model313=main_model();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemodel_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                main_model313_last = main_model313.tree.get();
                stream_main_model.add(main_model313.tree);
            }

            // AST REWRITE
            // elements: main_model, return_rows_clause, model_key, cell_reference_options, reference_model
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 489:9: -> ^( model_key ( cell_reference_options )* ( return_rows_clause )? ( reference_model )* main_model )
            {
            	// OracleDML.g:489:12: ^( model_key ( cell_reference_options )* ( return_rows_clause )? ( reference_model )* main_model )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(stream_model_key.nextNode(), root_1);
            	// OracleDML.g:489:24: ( cell_reference_options )*
            	while ( stream_cell_reference_options.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_cell_reference_options.nextTree());
            	}
            	stream_cell_reference_options.reset();

            	// OracleDML.g:489:48: ( return_rows_clause )?
            	if ( stream_return_rows_clause.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_return_rows_clause.nextTree());
            	}
            	stream_return_rows_clause.reset();

            	// OracleDML.g:489:68: ( reference_model )*
            	while ( stream_reference_model.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_reference_model.nextTree());
            	}
            	stream_reference_model.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_main_model.nextTree());
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulemodel_clauseEx; /* Prevent compiler warnings */
    rulemodel_clauseEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end model_clause */

/**
 * $ANTLR start cell_reference_options
 * OracleDML.g:492:1: cell_reference_options : ( ( ignore_key ^| keep_key ^) nav_key | unique_key ^ ( dimension_key | single_key reference_key ) );
 */
OracleDML::cell_reference_options_return
OracleDML::cell_reference_options()
{
    OracleDML::cell_reference_options_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML_OracleDMLKeys::ignore_key_return ignore_key314;
    ImplTraits::TreeTypePtr::pointer ignore_key314_last = NULL;
    OracleDML_OracleDMLKeys::keep_key_return keep_key315;
    ImplTraits::TreeTypePtr::pointer keep_key315_last = NULL;
    OracleDML_OracleDMLKeys::nav_key_return nav_key316;
    ImplTraits::TreeTypePtr::pointer nav_key316_last = NULL;
    OracleDML_OracleDMLKeys::unique_key_return unique_key317;
    ImplTraits::TreeTypePtr::pointer unique_key317_last = NULL;
    OracleDML_OracleDMLKeys::dimension_key_return dimension_key318;
    ImplTraits::TreeTypePtr::pointer dimension_key318_last = NULL;
    OracleDML_OracleDMLKeys::single_key_return single_key319;
    ImplTraits::TreeTypePtr::pointer single_key319_last = NULL;
    OracleDML_OracleDMLKeys::reference_key_return reference_key320;
    ImplTraits::TreeTypePtr::pointer reference_key320_last = NULL;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        {
            //  OracleDML.g:493:5: ( ( ignore_key ^| keep_key ^) nav_key | unique_key ^ ( dimension_key | single_key reference_key ) )

            ANTLR_UINT32 alt111;

            alt111=2;

            {
                ANTLR_UINT32 LA111_0 = this->LA(1);
                if ( (LA111_0 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "KEEP"))||((toUpper(LT(1)->getText()) == "IGNORE")))))
                {
                    alt111=1;
                }
                else if ( (LA111_0 == SQL92_RESERVED_UNIQUE))
                {
                    alt111=2;
                }
                else
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return retval;
                    }


                    ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 111 );
                    ex->set_state( 0 );


                    goto rulecell_reference_optionsEx;

                }
            }
            switch (alt111)
            {
        	case 1:
        	    // OracleDML.g:493:10: ( ignore_key ^| keep_key ^) nav_key
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        // OracleDML.g:493:10: ( ignore_key ^| keep_key ^)
        	        {
        	            ANTLR_UINT32 alt109=2;
        	            {
        	                ANTLR_UINT32 LA109_0 = this->LA(1);
        	                if ( (LA109_0 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "KEEP"))||((toUpper(LT(1)->getText()) == "IGNORE")))))
        	                {
        	                    {
        	                        ANTLR_UINT32 LA109_1 = this->LA(2);
        	                        if ( ((toUpper(LT(1)->getText()) == "IGNORE")))
        	                        {
        	                            alt109=1;
        	                        }
        	                        else if ( ((toUpper(LT(1)->getText()) == "KEEP")))
        	                        {
        	                            alt109=2;
        	                        }
        	                        else
        	                        {
        	                            if (this->get_backtracking()>0)
        	                            {
        	                                this->set_failedflag( true );
        	                                return retval;
        	                            }


        	                            ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                            ex->set_decisionNum( 109 );
        	                            ex->set_state( 1 );


        	                            goto rulecell_reference_optionsEx;

        	                        }
        	                    }
        	                }
        	                else
        	                {
        	                    if (this->get_backtracking()>0)
        	                    {
        	                        this->set_failedflag( true );
        	                        return retval;
        	                    }


        	                    ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                    ex->set_decisionNum( 109 );
        	                    ex->set_state( 0 );


        	                    goto rulecell_reference_optionsEx;

        	                }
        	            }
        	            switch (alt109)
        	            {
        	        	case 1:
        	        	    // OracleDML.g:493:11: ignore_key ^
        	        	    {
        	        	        this->followPush(FOLLOW_ignore_key_in_cell_reference_options4679);
        	        	        ignore_key314=ignore_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulecell_reference_optionsEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(ignore_key314.tree, root_0);

        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // OracleDML.g:493:23: keep_key ^
        	        	    {
        	        	        this->followPush(FOLLOW_keep_key_in_cell_reference_options4682);
        	        	        keep_key315=keep_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulecell_reference_optionsEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(keep_key315.tree, root_0);

        	        	    }
        	        	    break;

        	            }
        	        }

        	        this->followPush(FOLLOW_nav_key_in_cell_reference_options4686);
        	        nav_key316=nav_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulecell_reference_optionsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, nav_key316.tree);


        	    }
        	    break;
        	case 2:
        	    // OracleDML.g:494:10: unique_key ^ ( dimension_key | single_key reference_key )
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_unique_key_in_cell_reference_options4697);
        	        unique_key317=unique_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulecell_reference_optionsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(unique_key317.tree, root_0);

        	        // OracleDML.g:494:22: ( dimension_key | single_key reference_key )
        	        {
        	            ANTLR_UINT32 alt110=2;
        	            {
        	                ANTLR_UINT32 LA110_0 = this->LA(1);
        	                if ( (LA110_0 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "DIMENSION"))||((toUpper(LT(1)->getText()) == "SINGLE")))))
        	                {
        	                    {
        	                        ANTLR_UINT32 LA110_1 = this->LA(2);
        	                        if ( (LA110_1 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "DIMENSION"))||((toUpper(LT(1)->getText()) == "SINGLE")))))
        	                        {
        	                            {
        	                                ANTLR_UINT32 LA110_2 = this->LA(3);
        	                                if ( ((toUpper(LT(1)->getText()) == "DIMENSION")))
        	                                {
        	                                    alt110=1;
        	                                }
        	                                else if ( ((toUpper(LT(1)->getText()) == "SINGLE")))
        	                                {
        	                                    alt110=2;
        	                                }
        	                                else
        	                                {
        	                                    if (this->get_backtracking()>0)
        	                                    {
        	                                        this->set_failedflag( true );
        	                                        return retval;
        	                                    }


        	                                    ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                                    ex->set_decisionNum( 110 );
        	                                    ex->set_state( 2 );


        	                                    goto rulecell_reference_optionsEx;

        	                                }
        	                            }
        	                        }
        	                        else if ( (LA110_1 == LEFT_PAREN || LA110_1 == SQL92_RESERVED_UNIQUE) && ((toUpper(LT(1)->getText()) == "DIMENSION")))
        	                        {
        	                            alt110=1;
        	                        }
        	                        else
        	                        {
        	                            if (this->get_backtracking()>0)
        	                            {
        	                                this->set_failedflag( true );
        	                                return retval;
        	                            }


        	                            ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                            ex->set_decisionNum( 110 );
        	                            ex->set_state( 1 );


        	                            goto rulecell_reference_optionsEx;

        	                        }
        	                    }
        	                }
        	                else
        	                {
        	                    if (this->get_backtracking()>0)
        	                    {
        	                        this->set_failedflag( true );
        	                        return retval;
        	                    }


        	                    ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                    ex->set_decisionNum( 110 );
        	                    ex->set_state( 0 );


        	                    goto rulecell_reference_optionsEx;

        	                }
        	            }
        	            switch (alt110)
        	            {
        	        	case 1:
        	        	    // OracleDML.g:494:23: dimension_key
        	        	    {
        	        	        this->followPush(FOLLOW_dimension_key_in_cell_reference_options4701);
        	        	        dimension_key318=dimension_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulecell_reference_optionsEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, dimension_key318.tree);


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // OracleDML.g:494:37: single_key reference_key
        	        	    {
        	        	        this->followPush(FOLLOW_single_key_in_cell_reference_options4703);
        	        	        single_key319=single_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulecell_reference_optionsEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, single_key319.tree);


        	        	        this->followPush(FOLLOW_reference_key_in_cell_reference_options4705);
        	        	        reference_key320=reference_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulecell_reference_optionsEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, reference_key320.tree);


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;

            }
        }
    }//...
    // This is where rules clean up and exit
    //
    goto rulecell_reference_optionsEx; /* Prevent compiler warnings */
    rulecell_reference_optionsEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end cell_reference_options */

/**
 * $ANTLR start return_rows_clause
 * OracleDML.g:497:1: return_rows_clause : return_key ^ ( updated_key | all_key ) rows_key !;
 */
OracleDML::return_rows_clause_return
OracleDML::return_rows_clause()
{
    OracleDML::return_rows_clause_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML_OracleDMLKeys::return_key_return return_key321;
    ImplTraits::TreeTypePtr::pointer return_key321_last = NULL;
    OracleDML_OracleDMLKeys::updated_key_return updated_key322;
    ImplTraits::TreeTypePtr::pointer updated_key322_last = NULL;
    OracleDML_OracleDMLKeys::all_key_return all_key323;
    ImplTraits::TreeTypePtr::pointer all_key323_last = NULL;
    OracleDML_OracleDMLKeys::rows_key_return rows_key324;
    ImplTraits::TreeTypePtr::pointer rows_key324_last = NULL;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:498:5: ( return_key ^ ( updated_key | all_key ) rows_key !)
        // OracleDML.g:498:10: return_key ^ ( updated_key | all_key ) rows_key !
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            this->followPush(FOLLOW_return_key_in_return_rows_clause4726);
            return_key321=return_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulereturn_rows_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(return_key321.tree, root_0);

            // OracleDML.g:498:22: ( updated_key | all_key )
            {
                ANTLR_UINT32 alt112=2;
                {
                    ANTLR_UINT32 LA112_0 = this->LA(1);
                    if ( (LA112_0 == REGULAR_ID) && ((toUpper(LT(1)->getText()) == "UPDATED")))
                    {
                        alt112=1;
                    }
                    else if ( (LA112_0 == SQL92_RESERVED_ALL))
                    {
                        alt112=2;
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return retval;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 112 );
                        ex->set_state( 0 );


                        goto rulereturn_rows_clauseEx;

                    }
                }
                switch (alt112)
                {
            	case 1:
            	    // OracleDML.g:498:23: updated_key
            	    {
            	        this->followPush(FOLLOW_updated_key_in_return_rows_clause4730);
            	        updated_key322=updated_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulereturn_rows_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, updated_key322.tree);


            	    }
            	    break;
            	case 2:
            	    // OracleDML.g:498:35: all_key
            	    {
            	        this->followPush(FOLLOW_all_key_in_return_rows_clause4732);
            	        all_key323=all_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulereturn_rows_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, all_key323.tree);


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_rows_key_in_return_rows_clause4735);
            rows_key324=rows_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulereturn_rows_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulereturn_rows_clauseEx; /* Prevent compiler warnings */
    rulereturn_rows_clauseEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end return_rows_clause */

/**
 * $ANTLR start reference_model
 * OracleDML.g:501:1: reference_model : reference_key ^ reference_model_name on_key ! LEFT_PAREN subquery RIGHT_PAREN model_column_clauses ( cell_reference_options )* ;
 */
OracleDML::reference_model_return
OracleDML::reference_model()
{
    OracleDML::reference_model_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* LEFT_PAREN328 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN330 = NULL;
    OracleDML_OracleDMLKeys::reference_key_return reference_key325;
    ImplTraits::TreeTypePtr::pointer reference_key325_last = NULL;
    OracleDML_OracleDMLCommons::reference_model_name_return reference_model_name326;
    ImplTraits::TreeTypePtr::pointer reference_model_name326_last = NULL;
    OracleDML_OracleDMLKeys::on_key_return on_key327;
    ImplTraits::TreeTypePtr::pointer on_key327_last = NULL;
    OracleDML::subquery_return subquery329;
    ImplTraits::TreeTypePtr::pointer subquery329_last = NULL;
    OracleDML::model_column_clauses_return model_column_clauses331;
    ImplTraits::TreeTypePtr::pointer model_column_clauses331_last = NULL;
    OracleDML::cell_reference_options_return cell_reference_options332;
    ImplTraits::TreeTypePtr::pointer cell_reference_options332_last = NULL;
    ImplTraits::TreeTypePtr LEFT_PAREN328_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN330_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:502:5: ( reference_key ^ reference_model_name on_key ! LEFT_PAREN subquery RIGHT_PAREN model_column_clauses ( cell_reference_options )* )
        // OracleDML.g:502:10: reference_key ^ reference_model_name on_key ! LEFT_PAREN subquery RIGHT_PAREN model_column_clauses ( cell_reference_options )*
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            this->followPush(FOLLOW_reference_key_in_reference_model4756);
            reference_key325=reference_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulereference_modelEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(reference_key325.tree, root_0);

            this->followPush(FOLLOW_reference_model_name_in_reference_model4759);
            reference_model_name326=reference_model_name();

            this->followPop();
            if  (this->hasException())
            {
                goto rulereference_modelEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, reference_model_name326.tree);


            this->followPush(FOLLOW_on_key_in_reference_model4761);
            on_key327=on_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulereference_modelEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }


            LEFT_PAREN328 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_reference_model4777);
            if  (this->hasException())
            {
                goto rulereference_modelEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            LEFT_PAREN328_tree = std::move(get_psrstate()->get_treeAdaptor()->create(LEFT_PAREN328));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, LEFT_PAREN328_tree);
            }


            this->followPush(FOLLOW_subquery_in_reference_model4779);
            subquery329=subquery();

            this->followPop();
            if  (this->hasException())
            {
                goto rulereference_modelEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, subquery329.tree);


            RIGHT_PAREN330 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_reference_model4781);
            if  (this->hasException())
            {
                goto rulereference_modelEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            RIGHT_PAREN330_tree = std::move(get_psrstate()->get_treeAdaptor()->create(RIGHT_PAREN330));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, RIGHT_PAREN330_tree);
            }


            this->followPush(FOLLOW_model_column_clauses_in_reference_model4783);
            model_column_clauses331=model_column_clauses();

            this->followPop();
            if  (this->hasException())
            {
                goto rulereference_modelEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, model_column_clauses331.tree);


            // OracleDML.g:504:13: ( cell_reference_options )*

            for (;;)
            {
                ANTLR_UINT32 alt113=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    ANTLR_UINT32 LA113_0 = this->LA(1);
                    if ( (LA113_0 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "KEEP"))||((toUpper(LT(1)->getText()) == "DIMENSION"))||((toUpper(LT(1)->getText()) == "PARTITION"))||((toUpper(LT(1)->getText()) == "MAIN"))||((toUpper(LT(1)->getText()) == "IGNORE"))||((toUpper(LT(1)->getText()) == "REFERENCE")))))
                    {
                        {
                           /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                            */
                            ANTLR_UINT32 LA113_1 = this->LA(2);
                            if ( (LA113_1 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "KEEP"))||((toUpper(LT(1)->getText()) == "MAIN"))||((toUpper(LT(1)->getText()) == "IGNORE"))||((toUpper(LT(1)->getText()) == "REFERENCE")))))
                            {
                                {
                                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                                    */
                                    ANTLR_UINT32 LA113_4 = this->LA(3);
                                    if ( ((((toUpper(LT(1)->getText()) == "KEEP"))||((toUpper(LT(1)->getText()) == "IGNORE")))))
                                    {
                                        alt113=1;
                                    }

                                }
                            }

                        }
                    }
                    else if ( (LA113_0 == SQL92_RESERVED_UNIQUE))
                    {
                        alt113=1;
                    }

                }
                switch (alt113)
                {
            	case 1:
            	    // OracleDML.g:504:13: cell_reference_options
            	    {
            	        this->followPush(FOLLOW_cell_reference_options_in_reference_model4798);
            	        cell_reference_options332=cell_reference_options();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulereference_modelEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, cell_reference_options332.tree);


            	    }
            	    break;

            	default:
            	    goto loop113;	/* break out of the loop */
            	    break;
                }
            }
            loop113: ; /* Jump out to here if this rule does not match */


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulereference_modelEx; /* Prevent compiler warnings */
    rulereference_modelEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end reference_model */

/**
 * $ANTLR start main_model
 * OracleDML.g:507:1: main_model : ( main_key main_model_name )? model_column_clauses ( cell_reference_options )* model_rules_clause -> ^( MAIN_MODEL ( main_model_name )? model_column_clauses ( cell_reference_options )* model_rules_clause ) ;
 */
OracleDML::main_model_return
OracleDML::main_model()
{
    OracleDML::main_model_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML_OracleDMLKeys::main_key_return main_key333;
    ImplTraits::TreeTypePtr::pointer main_key333_last = NULL;
    OracleDML_OracleDMLCommons::main_model_name_return main_model_name334;
    ImplTraits::TreeTypePtr::pointer main_model_name334_last = NULL;
    OracleDML::model_column_clauses_return model_column_clauses335;
    ImplTraits::TreeTypePtr::pointer model_column_clauses335_last = NULL;
    OracleDML::cell_reference_options_return cell_reference_options336;
    ImplTraits::TreeTypePtr::pointer cell_reference_options336_last = NULL;
    OracleDML::model_rules_clause_return model_rules_clause337;
    ImplTraits::TreeTypePtr::pointer model_rules_clause337_last = NULL;
    RewriteRuleSubtreeStream<ImplTraits> stream_main_key(get_psrstate()->get_treeAdaptor(), "rule main_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_main_model_name(get_psrstate()->get_treeAdaptor(), "rule main_model_name");
    RewriteRuleSubtreeStream<ImplTraits> stream_model_column_clauses(get_psrstate()->get_treeAdaptor(), "rule model_column_clauses");
    RewriteRuleSubtreeStream<ImplTraits> stream_cell_reference_options(get_psrstate()->get_treeAdaptor(), "rule cell_reference_options");
    RewriteRuleSubtreeStream<ImplTraits> stream_model_rules_clause(get_psrstate()->get_treeAdaptor(), "rule model_rules_clause");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:508:5: ( ( main_key main_model_name )? model_column_clauses ( cell_reference_options )* model_rules_clause -> ^( MAIN_MODEL ( main_model_name )? model_column_clauses ( cell_reference_options )* model_rules_clause ) )
        // OracleDML.g:508:10: ( main_key main_model_name )? model_column_clauses ( cell_reference_options )* model_rules_clause
        {
            // OracleDML.g:508:10: ( main_key main_model_name )?
            {
                ANTLR_UINT32 alt114=2;
                {
                    ANTLR_UINT32 LA114_0 = this->LA(1);
                    if ( (LA114_0 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "DIMENSION"))||((toUpper(LT(1)->getText()) == "MAIN"))||((toUpper(LT(1)->getText()) == "PARTITION")))))
                    {
                        {
                            ANTLR_UINT32 LA114_1 = this->LA(2);
                            if ( (LA114_1 == DELIMITED_ID || LA114_1 == INTRODUCER || LA114_1 == REGULAR_ID) && ((toUpper(LT(1)->getText()) == "MAIN")))
                            {
                                alt114=1;
                            }
                        }
                    }
                }
                switch (alt114)
                {
            	case 1:
            	    // OracleDML.g:508:11: main_key main_model_name
            	    {
            	        this->followPush(FOLLOW_main_key_in_main_model4820);
            	        main_key333=main_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemain_modelEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            main_key333_last = main_key333.tree.get();
            	            stream_main_key.add(main_key333.tree);
            	        }

            	        this->followPush(FOLLOW_main_model_name_in_main_model4822);
            	        main_model_name334=main_model_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemain_modelEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            main_model_name334_last = main_model_name334.tree.get();
            	            stream_main_model_name.add(main_model_name334.tree);
            	        }

            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_model_column_clauses_in_main_model4826);
            model_column_clauses335=model_column_clauses();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemain_modelEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                model_column_clauses335_last = model_column_clauses335.tree.get();
                stream_model_column_clauses.add(model_column_clauses335.tree);
            }

            // OracleDML.g:508:59: ( cell_reference_options )*

            for (;;)
            {
                ANTLR_UINT32 alt115=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    ANTLR_UINT32 LA115_0 = this->LA(1);
                    if ( (LA115_0 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "KEEP"))||((toUpper(LT(1)->getText()) == "RULES"))||((toUpper(LT(1)->getText()) == "IGNORE")))))
                    {
                        {
                           /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                            */
                            ANTLR_UINT32 LA115_1 = this->LA(2);
                            if ( (LA115_1 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "KEEP"))||((toUpper(LT(1)->getText()) == "RULES"))||((toUpper(LT(1)->getText()) == "IGNORE")))))
                            {
                                {
                                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                                    */
                                    ANTLR_UINT32 LA115_5 = this->LA(3);
                                    if ( ((((toUpper(LT(1)->getText()) == "KEEP"))||((toUpper(LT(1)->getText()) == "IGNORE")))))
                                    {
                                        alt115=1;
                                    }

                                }
                            }

                        }
                    }
                    else if ( (LA115_0 == SQL92_RESERVED_UNIQUE))
                    {
                        alt115=1;
                    }

                }
                switch (alt115)
                {
            	case 1:
            	    // OracleDML.g:508:59: cell_reference_options
            	    {
            	        this->followPush(FOLLOW_cell_reference_options_in_main_model4828);
            	        cell_reference_options336=cell_reference_options();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemain_modelEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            cell_reference_options336_last = cell_reference_options336.tree.get();
            	            stream_cell_reference_options.add(cell_reference_options336.tree);
            	        }

            	    }
            	    break;

            	default:
            	    goto loop115;	/* break out of the loop */
            	    break;
                }
            }
            loop115: ; /* Jump out to here if this rule does not match */


            this->followPush(FOLLOW_model_rules_clause_in_main_model4831);
            model_rules_clause337=model_rules_clause();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemain_modelEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                model_rules_clause337_last = model_rules_clause337.tree.get();
                stream_model_rules_clause.add(model_rules_clause337.tree);
            }

            // AST REWRITE
            // elements: model_rules_clause, main_model_name, model_column_clauses, cell_reference_options
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 509:9: -> ^( MAIN_MODEL ( main_model_name )? model_column_clauses ( cell_reference_options )* model_rules_clause )
            {
            	// OracleDML.g:509:12: ^( MAIN_MODEL ( main_model_name )? model_column_clauses ( cell_reference_options )* model_rules_clause )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(MAIN_MODEL, "MAIN_MODEL"), root_1);
            	// OracleDML.g:509:25: ( main_model_name )?
            	if ( stream_main_model_name.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_main_model_name.nextTree());
            	}
            	stream_main_model_name.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_model_column_clauses.nextTree());
            	// OracleDML.g:509:63: ( cell_reference_options )*
            	while ( stream_cell_reference_options.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_cell_reference_options.nextTree());
            	}
            	stream_cell_reference_options.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_model_rules_clause.nextTree());
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulemain_modelEx; /* Prevent compiler warnings */
    rulemain_modelEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end main_model */

/**
 * $ANTLR start model_column_clauses
 * OracleDML.g:512:1: model_column_clauses : ( model_column_partition_part )? dimension_key by_key model_column_list measures_key model_column_list -> ^( MODEL_COLUMN ( model_column_partition_part )? ^( dimension_key model_column_list ) ^( measures_key model_column_list ) ) ;
 */
OracleDML::model_column_clauses_return
OracleDML::model_column_clauses()
{
    OracleDML::model_column_clauses_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML::model_column_partition_part_return model_column_partition_part338;
    ImplTraits::TreeTypePtr::pointer model_column_partition_part338_last = NULL;
    OracleDML_OracleDMLKeys::dimension_key_return dimension_key339;
    ImplTraits::TreeTypePtr::pointer dimension_key339_last = NULL;
    OracleDML_OracleDMLKeys::by_key_return by_key340;
    ImplTraits::TreeTypePtr::pointer by_key340_last = NULL;
    OracleDML::model_column_list_return model_column_list341;
    ImplTraits::TreeTypePtr::pointer model_column_list341_last = NULL;
    OracleDML_OracleDMLKeys::measures_key_return measures_key342;
    ImplTraits::TreeTypePtr::pointer measures_key342_last = NULL;
    OracleDML::model_column_list_return model_column_list343;
    ImplTraits::TreeTypePtr::pointer model_column_list343_last = NULL;
    RewriteRuleSubtreeStream<ImplTraits> stream_model_column_list(get_psrstate()->get_treeAdaptor(), "rule model_column_list");
    RewriteRuleSubtreeStream<ImplTraits> stream_dimension_key(get_psrstate()->get_treeAdaptor(), "rule dimension_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_by_key(get_psrstate()->get_treeAdaptor(), "rule by_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_model_column_partition_part(get_psrstate()->get_treeAdaptor(), "rule model_column_partition_part");
    RewriteRuleSubtreeStream<ImplTraits> stream_measures_key(get_psrstate()->get_treeAdaptor(), "rule measures_key");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:513:5: ( ( model_column_partition_part )? dimension_key by_key model_column_list measures_key model_column_list -> ^( MODEL_COLUMN ( model_column_partition_part )? ^( dimension_key model_column_list ) ^( measures_key model_column_list ) ) )
        // OracleDML.g:513:10: ( model_column_partition_part )? dimension_key by_key model_column_list measures_key model_column_list
        {
            // OracleDML.g:513:10: ( model_column_partition_part )?
            {
                ANTLR_UINT32 alt116=2;
                {
                    ANTLR_UINT32 LA116_0 = this->LA(1);
                    if ( (LA116_0 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "DIMENSION"))||((toUpper(LT(1)->getText()) == "PARTITION")))))
                    {
                        {
                            ANTLR_UINT32 LA116_1 = this->LA(2);
                            if ( ((toUpper(LT(1)->getText()) == "PARTITION")))
                            {
                                alt116=1;
                            }
                        }
                    }
                }
                switch (alt116)
                {
            	case 1:
            	    // OracleDML.g:513:10: model_column_partition_part
            	    {
            	        this->followPush(FOLLOW_model_column_partition_part_in_model_column_clauses4875);
            	        model_column_partition_part338=model_column_partition_part();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemodel_column_clausesEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            model_column_partition_part338_last = model_column_partition_part338.tree.get();
            	            stream_model_column_partition_part.add(model_column_partition_part338.tree);
            	        }

            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_dimension_key_in_model_column_clauses4886);
            dimension_key339=dimension_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemodel_column_clausesEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                dimension_key339_last = dimension_key339.tree.get();
                stream_dimension_key.add(dimension_key339.tree);
            }

            this->followPush(FOLLOW_by_key_in_model_column_clauses4888);
            by_key340=by_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemodel_column_clausesEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                by_key340_last = by_key340.tree.get();
                stream_by_key.add(by_key340.tree);
            }

            this->followPush(FOLLOW_model_column_list_in_model_column_clauses4890);
            model_column_list341=model_column_list();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemodel_column_clausesEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                model_column_list341_last = model_column_list341.tree.get();
                stream_model_column_list.add(model_column_list341.tree);
            }

            this->followPush(FOLLOW_measures_key_in_model_column_clauses4892);
            measures_key342=measures_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemodel_column_clausesEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                measures_key342_last = measures_key342.tree.get();
                stream_measures_key.add(measures_key342.tree);
            }

            this->followPush(FOLLOW_model_column_list_in_model_column_clauses4894);
            model_column_list343=model_column_list();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemodel_column_clausesEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                model_column_list343_last = model_column_list343.tree.get();
                stream_model_column_list.add(model_column_list343.tree);
            }

            // AST REWRITE
            // elements: model_column_list, dimension_key, measures_key, model_column_list, model_column_partition_part
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 515:9: -> ^( MODEL_COLUMN ( model_column_partition_part )? ^( dimension_key model_column_list ) ^( measures_key model_column_list ) )
            {
            	// OracleDML.g:515:12: ^( MODEL_COLUMN ( model_column_partition_part )? ^( dimension_key model_column_list ) ^( measures_key model_column_list ) )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(MODEL_COLUMN, "MODEL_COLUMN"), root_1);
            	// OracleDML.g:515:27: ( model_column_partition_part )?
            	if ( stream_model_column_partition_part.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_model_column_partition_part.nextTree());
            	}
            	stream_model_column_partition_part.reset();

            	// OracleDML.g:515:56: ^( dimension_key model_column_list )
            	{
            	ImplTraits::TreeTypePtr root_2 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_2 = get_psrstate()->get_treeAdaptor()->becomeRoot(stream_dimension_key.nextNode(), root_2);
            	get_psrstate()->get_treeAdaptor()->addChild(root_2, stream_model_column_list.nextTree());
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, root_2);
            	}
            	// OracleDML.g:515:91: ^( measures_key model_column_list )
            	{
            	ImplTraits::TreeTypePtr root_2 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_2 = get_psrstate()->get_treeAdaptor()->becomeRoot(stream_measures_key.nextNode(), root_2);
            	get_psrstate()->get_treeAdaptor()->addChild(root_2, stream_model_column_list.nextTree());
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, root_2);
            	}
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulemodel_column_clausesEx; /* Prevent compiler warnings */
    rulemodel_column_clausesEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end model_column_clauses */

/**
 * $ANTLR start model_column_partition_part
 * OracleDML.g:518:1: model_column_partition_part : partition_key ^ by_key ! model_column_list ;
 */
OracleDML::model_column_partition_part_return
OracleDML::model_column_partition_part()
{
    OracleDML::model_column_partition_part_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML_OracleDMLKeys::partition_key_return partition_key344;
    ImplTraits::TreeTypePtr::pointer partition_key344_last = NULL;
    OracleDML_OracleDMLKeys::by_key_return by_key345;
    ImplTraits::TreeTypePtr::pointer by_key345_last = NULL;
    OracleDML::model_column_list_return model_column_list346;
    ImplTraits::TreeTypePtr::pointer model_column_list346_last = NULL;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:519:5: ( partition_key ^ by_key ! model_column_list )
        // OracleDML.g:519:10: partition_key ^ by_key ! model_column_list
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            this->followPush(FOLLOW_partition_key_in_model_column_partition_part4943);
            partition_key344=partition_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemodel_column_partition_partEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(partition_key344.tree, root_0);

            this->followPush(FOLLOW_by_key_in_model_column_partition_part4946);
            by_key345=by_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemodel_column_partition_partEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }


            this->followPush(FOLLOW_model_column_list_in_model_column_partition_part4949);
            model_column_list346=model_column_list();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemodel_column_partition_partEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, model_column_list346.tree);


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulemodel_column_partition_partEx; /* Prevent compiler warnings */
    rulemodel_column_partition_partEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end model_column_partition_part */

/**
 * $ANTLR start model_column_list
 * OracleDML.g:522:1: model_column_list : LEFT_PAREN model_column ( COMMA model_column )* RIGHT_PAREN -> ^( MODEL_COLUMNS ( model_column )+ ) ;
 */
OracleDML::model_column_list_return
OracleDML::model_column_list()
{
    OracleDML::model_column_list_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* LEFT_PAREN347 = NULL;
    ImplTraits::CommonTokenType const* COMMA349 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN351 = NULL;
    OracleDML::model_column_return model_column348;
    ImplTraits::TreeTypePtr::pointer model_column348_last = NULL;
    OracleDML::model_column_return model_column350;
    ImplTraits::TreeTypePtr::pointer model_column350_last = NULL;
    ImplTraits::TreeTypePtr LEFT_PAREN347_tree;
    ImplTraits::TreeTypePtr COMMA349_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN351_tree;
    RewriteRuleTokenStream<ImplTraits> stream_LEFT_PAREN(get_psrstate()->get_treeAdaptor(), "token LEFT_PAREN");
    RewriteRuleTokenStream<ImplTraits> stream_RIGHT_PAREN(get_psrstate()->get_treeAdaptor(), "token RIGHT_PAREN");
    RewriteRuleTokenStream<ImplTraits> stream_COMMA(get_psrstate()->get_treeAdaptor(), "token COMMA");
    RewriteRuleSubtreeStream<ImplTraits> stream_model_column(get_psrstate()->get_treeAdaptor(), "rule model_column");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:523:5: ( LEFT_PAREN model_column ( COMMA model_column )* RIGHT_PAREN -> ^( MODEL_COLUMNS ( model_column )+ ) )
        // OracleDML.g:523:10: LEFT_PAREN model_column ( COMMA model_column )* RIGHT_PAREN
        {
            LEFT_PAREN347 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_model_column_list4969);
            if  (this->hasException())
            {
                goto rulemodel_column_listEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_LEFT_PAREN.add(LEFT_PAREN347);


            this->followPush(FOLLOW_model_column_in_model_column_list4971);
            model_column348=model_column();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemodel_column_listEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                model_column348_last = model_column348.tree.get();
                stream_model_column.add(model_column348.tree);
            }

            // OracleDML.g:523:34: ( COMMA model_column )*

            for (;;)
            {
                ANTLR_UINT32 alt117=2;
                switch ( this->LA(1) )
                {
                case COMMA:
                	{
                		alt117=1;
                	}
                    break;

                }

                switch (alt117)
                {
            	case 1:
            	    // OracleDML.g:523:35: COMMA model_column
            	    {
            	        COMMA349 =  this->matchToken(COMMA, &FOLLOW_COMMA_in_model_column_list4974);
            	        if  (this->hasException())
            	        {
            	            goto rulemodel_column_listEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( this->get_backtracking()==0 ) stream_COMMA.add(COMMA349);


            	        this->followPush(FOLLOW_model_column_in_model_column_list4976);
            	        model_column350=model_column();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemodel_column_listEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            model_column350_last = model_column350.tree.get();
            	            stream_model_column.add(model_column350.tree);
            	        }

            	    }
            	    break;

            	default:
            	    goto loop117;	/* break out of the loop */
            	    break;
                }
            }
            loop117: ; /* Jump out to here if this rule does not match */


            RIGHT_PAREN351 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_model_column_list4981);
            if  (this->hasException())
            {
                goto rulemodel_column_listEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN351);


            // AST REWRITE
            // elements: model_column
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 524:9: -> ^( MODEL_COLUMNS ( model_column )+ )
            {
            	// OracleDML.g:524:12: ^( MODEL_COLUMNS ( model_column )+ )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(MODEL_COLUMNS, "MODEL_COLUMNS"), root_1);
            	if ( !(stream_model_column.hasNext()) ) {
            		ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, REWRITE_EARLY_EXCEPTION, StreamType>( this->get_rec(), "model_column empty" );
            		goto rulemodel_column_listEx;
            	}
            	while ( stream_model_column.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_model_column.nextTree());
            	}
            	stream_model_column.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulemodel_column_listEx; /* Prevent compiler warnings */
    rulemodel_column_listEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end model_column_list */

/**
 * $ANTLR start model_column
 * OracleDML.g:527:1: model_column : expression ( column_alias )? -> ^( MODEL_COLUMN ^( EXPR expression ) ( column_alias )? ) ;
 */
OracleDML::model_column_return
OracleDML::model_column()
{
    OracleDML::model_column_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML::expression_return expression352;
    ImplTraits::TreeTypePtr::pointer expression352_last = NULL;
    OracleDML_OracleDMLCommons::column_alias_return column_alias353;
    ImplTraits::TreeTypePtr::pointer column_alias353_last = NULL;
    RewriteRuleSubtreeStream<ImplTraits> stream_expression(get_psrstate()->get_treeAdaptor(), "rule expression");
    RewriteRuleSubtreeStream<ImplTraits> stream_column_alias(get_psrstate()->get_treeAdaptor(), "rule column_alias");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:528:5: ( expression ( column_alias )? -> ^( MODEL_COLUMN ^( EXPR expression ) ( column_alias )? ) )
        // OracleDML.g:528:10: expression ( column_alias )?
        {
            this->followPush(FOLLOW_expression_in_model_column5018);
            expression352=expression();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemodel_columnEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                expression352_last = expression352.tree.get();
                stream_expression.add(expression352.tree);
            }

            // OracleDML.g:528:21: ( column_alias )?
            {
                ANTLR_UINT32 alt118=2;
                switch ( this->LA(1) )
                {
                    case CHAR_STRING:
                    case CHAR_STRING_PERL:
                    case DELIMITED_ID:
                    case INTRODUCER:
                    case NATIONAL_CHAR_STRING_LIT:
                    case REGULAR_ID:
                    case SQL92_RESERVED_AS:
                    	{
                    		alt118=1;
                    	}
                        break;
                }

                switch (alt118)
                {
            	case 1:
            	    // OracleDML.g:528:21: column_alias
            	    {
            	        this->followPush(FOLLOW_column_alias_in_model_column5020);
            	        column_alias353=column_alias();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemodel_columnEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            column_alias353_last = column_alias353.tree.get();
            	            stream_column_alias.add(column_alias353.tree);
            	        }

            	    }
            	    break;

                }
            }

            // AST REWRITE
            // elements: column_alias, expression
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 529:9: -> ^( MODEL_COLUMN ^( EXPR expression ) ( column_alias )? )
            {
            	// OracleDML.g:529:12: ^( MODEL_COLUMN ^( EXPR expression ) ( column_alias )? )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(MODEL_COLUMN, "MODEL_COLUMN"), root_1);
            	// OracleDML.g:529:27: ^( EXPR expression )
            	{
            	ImplTraits::TreeTypePtr root_2 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_2 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(EXPR, "EXPR"), root_2);
            	get_psrstate()->get_treeAdaptor()->addChild(root_2, stream_expression.nextTree());
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, root_2);
            	}
            	// OracleDML.g:529:46: ( column_alias )?
            	if ( stream_column_alias.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_column_alias.nextTree());
            	}
            	stream_column_alias.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulemodel_columnEx; /* Prevent compiler warnings */
    rulemodel_columnEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end model_column */

/**
 * $ANTLR start model_rules_clause
 * OracleDML.g:532:1: model_rules_clause : ( model_rules_part )? LEFT_PAREN ( model_rules_element ( COMMA model_rules_element )* )? RIGHT_PAREN -> ^( MODEL_RULES ( model_rules_part )? ( model_rules_element )* ) ;
 */
OracleDML::model_rules_clause_return
OracleDML::model_rules_clause()
{
    OracleDML::model_rules_clause_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* LEFT_PAREN355 = NULL;
    ImplTraits::CommonTokenType const* COMMA357 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN359 = NULL;
    OracleDML::model_rules_part_return model_rules_part354;
    ImplTraits::TreeTypePtr::pointer model_rules_part354_last = NULL;
    OracleDML::model_rules_element_return model_rules_element356;
    ImplTraits::TreeTypePtr::pointer model_rules_element356_last = NULL;
    OracleDML::model_rules_element_return model_rules_element358;
    ImplTraits::TreeTypePtr::pointer model_rules_element358_last = NULL;
    ImplTraits::TreeTypePtr LEFT_PAREN355_tree;
    ImplTraits::TreeTypePtr COMMA357_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN359_tree;
    RewriteRuleTokenStream<ImplTraits> stream_LEFT_PAREN(get_psrstate()->get_treeAdaptor(), "token LEFT_PAREN");
    RewriteRuleTokenStream<ImplTraits> stream_RIGHT_PAREN(get_psrstate()->get_treeAdaptor(), "token RIGHT_PAREN");
    RewriteRuleTokenStream<ImplTraits> stream_COMMA(get_psrstate()->get_treeAdaptor(), "token COMMA");
    RewriteRuleSubtreeStream<ImplTraits> stream_model_rules_element(get_psrstate()->get_treeAdaptor(), "rule model_rules_element");
    RewriteRuleSubtreeStream<ImplTraits> stream_model_rules_part(get_psrstate()->get_treeAdaptor(), "rule model_rules_part");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:533:5: ( ( model_rules_part )? LEFT_PAREN ( model_rules_element ( COMMA model_rules_element )* )? RIGHT_PAREN -> ^( MODEL_RULES ( model_rules_part )? ( model_rules_element )* ) )
        // OracleDML.g:533:10: ( model_rules_part )? LEFT_PAREN ( model_rules_element ( COMMA model_rules_element )* )? RIGHT_PAREN
        {
            // OracleDML.g:533:10: ( model_rules_part )?
            {
                ANTLR_UINT32 alt119=2;
                {
                    ANTLR_UINT32 LA119_0 = this->LA(1);
                    if ( (LA119_0 == REGULAR_ID) && ((toUpper(LT(1)->getText()) == "RULES")))
                    {
                        alt119=1;
                    }
                }
                switch (alt119)
                {
            	case 1:
            	    // OracleDML.g:533:10: model_rules_part
            	    {
            	        this->followPush(FOLLOW_model_rules_part_in_model_rules_clause5064);
            	        model_rules_part354=model_rules_part();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemodel_rules_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            model_rules_part354_last = model_rules_part354.tree.get();
            	            stream_model_rules_part.add(model_rules_part354.tree);
            	        }

            	    }
            	    break;

                }
            }

            LEFT_PAREN355 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_model_rules_clause5067);
            if  (this->hasException())
            {
                goto rulemodel_rules_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_LEFT_PAREN.add(LEFT_PAREN355);


            // OracleDML.g:533:39: ( model_rules_element ( COMMA model_rules_element )* )?
            {
                ANTLR_UINT32 alt121=2;
                switch ( this->LA(1) )
                {
                    case APPROXIMATE_NUM_LIT:
                    case BINDVAR:
                    case CHAR_STRING:
                    case CHAR_STRING_PERL:
                    case COLON:
                    case DELIMITED_ID:
                    case EXACT_NUM_LIT:
                    case INTRODUCER:
                    case LEFT_PAREN:
                    case MINUS_SIGN:
                    case NATIONAL_CHAR_STRING_LIT:
                    case PLSQL_NON_RESERVED_CAST:
                    case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
                    case PLUS_SIGN:
                    case REGULAR_ID:
                    case SQL92_RESERVED_ALL:
                    case SQL92_RESERVED_ANY:
                    case SQL92_RESERVED_CASE:
                    case SQL92_RESERVED_DATE:
                    case SQL92_RESERVED_DEFAULT:
                    case SQL92_RESERVED_DISTINCT:
                    case SQL92_RESERVED_EXISTS:
                    case SQL92_RESERVED_FALSE:
                    case SQL92_RESERVED_NULL:
                    case SQL92_RESERVED_PRIOR:
                    case SQL92_RESERVED_TRUE:
                    case SQL92_RESERVED_UPDATE:
                    case UNSIGNED_INTEGER:
                    	{
                    		alt121=1;
                    	}
                        break;
                }

                switch (alt121)
                {
            	case 1:
            	    // OracleDML.g:533:40: model_rules_element ( COMMA model_rules_element )*
            	    {
            	        this->followPush(FOLLOW_model_rules_element_in_model_rules_clause5070);
            	        model_rules_element356=model_rules_element();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemodel_rules_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            model_rules_element356_last = model_rules_element356.tree.get();
            	            stream_model_rules_element.add(model_rules_element356.tree);
            	        }

            	        // OracleDML.g:533:60: ( COMMA model_rules_element )*

            	        for (;;)
            	        {
            	            ANTLR_UINT32 alt120=2;
            	            switch ( this->LA(1) )
            	            {
            	            case COMMA:
            	            	{
            	            		alt120=1;
            	            	}
            	                break;

            	            }

            	            switch (alt120)
            	            {
            	        	case 1:
            	        	    // OracleDML.g:533:61: COMMA model_rules_element
            	        	    {
            	        	        COMMA357 =  this->matchToken(COMMA, &FOLLOW_COMMA_in_model_rules_clause5073);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulemodel_rules_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }
            	        	         
            	        	        if ( this->get_backtracking()==0 ) stream_COMMA.add(COMMA357);


            	        	        this->followPush(FOLLOW_model_rules_element_in_model_rules_clause5075);
            	        	        model_rules_element358=model_rules_element();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulemodel_rules_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) 
            	        	        {
            	        	            model_rules_element358_last = model_rules_element358.tree.get();
            	        	            stream_model_rules_element.add(model_rules_element358.tree);
            	        	        }

            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop120;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop120: ; /* Jump out to here if this rule does not match */


            	    }
            	    break;

                }
            }

            RIGHT_PAREN359 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_model_rules_clause5081);
            if  (this->hasException())
            {
                goto rulemodel_rules_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN359);


            // AST REWRITE
            // elements: model_rules_element, model_rules_part
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 534:9: -> ^( MODEL_RULES ( model_rules_part )? ( model_rules_element )* )
            {
            	// OracleDML.g:534:12: ^( MODEL_RULES ( model_rules_part )? ( model_rules_element )* )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(MODEL_RULES, "MODEL_RULES"), root_1);
            	// OracleDML.g:534:26: ( model_rules_part )?
            	if ( stream_model_rules_part.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_model_rules_part.nextTree());
            	}
            	stream_model_rules_part.reset();

            	// OracleDML.g:534:44: ( model_rules_element )*
            	while ( stream_model_rules_element.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_model_rules_element.nextTree());
            	}
            	stream_model_rules_element.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulemodel_rules_clauseEx; /* Prevent compiler warnings */
    rulemodel_rules_clauseEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end model_rules_clause */

/**
 * $ANTLR start model_rules_part
 * OracleDML.g:537:1: model_rules_part : rules_key ( update_key | upsert_key ( all_key )? )? ( ( automatic_key | sequential_key ) order_key )? ( model_iterate_clause )? -> ^( rules_key ( update_key )? ( upsert_key )? ( all_key )? ( automatic_key )? ( sequential_key )? ( model_iterate_clause )? ) ;
 */
OracleDML::model_rules_part_return
OracleDML::model_rules_part()
{
    OracleDML::model_rules_part_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML_OracleDMLKeys::rules_key_return rules_key360;
    ImplTraits::TreeTypePtr::pointer rules_key360_last = NULL;
    OracleDML_OracleDMLKeys::update_key_return update_key361;
    ImplTraits::TreeTypePtr::pointer update_key361_last = NULL;
    OracleDML_OracleDMLKeys::upsert_key_return upsert_key362;
    ImplTraits::TreeTypePtr::pointer upsert_key362_last = NULL;
    OracleDML_OracleDMLKeys::all_key_return all_key363;
    ImplTraits::TreeTypePtr::pointer all_key363_last = NULL;
    OracleDML_OracleDMLKeys::automatic_key_return automatic_key364;
    ImplTraits::TreeTypePtr::pointer automatic_key364_last = NULL;
    OracleDML_OracleDMLKeys::sequential_key_return sequential_key365;
    ImplTraits::TreeTypePtr::pointer sequential_key365_last = NULL;
    OracleDML_OracleDMLKeys::order_key_return order_key366;
    ImplTraits::TreeTypePtr::pointer order_key366_last = NULL;
    OracleDML::model_iterate_clause_return model_iterate_clause367;
    ImplTraits::TreeTypePtr::pointer model_iterate_clause367_last = NULL;
    RewriteRuleSubtreeStream<ImplTraits> stream_all_key(get_psrstate()->get_treeAdaptor(), "rule all_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_sequential_key(get_psrstate()->get_treeAdaptor(), "rule sequential_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_order_key(get_psrstate()->get_treeAdaptor(), "rule order_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_rules_key(get_psrstate()->get_treeAdaptor(), "rule rules_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_model_iterate_clause(get_psrstate()->get_treeAdaptor(), "rule model_iterate_clause");
    RewriteRuleSubtreeStream<ImplTraits> stream_update_key(get_psrstate()->get_treeAdaptor(), "rule update_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_automatic_key(get_psrstate()->get_treeAdaptor(), "rule automatic_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_upsert_key(get_psrstate()->get_treeAdaptor(), "rule upsert_key");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:538:5: ( rules_key ( update_key | upsert_key ( all_key )? )? ( ( automatic_key | sequential_key ) order_key )? ( model_iterate_clause )? -> ^( rules_key ( update_key )? ( upsert_key )? ( all_key )? ( automatic_key )? ( sequential_key )? ( model_iterate_clause )? ) )
        // OracleDML.g:538:10: rules_key ( update_key | upsert_key ( all_key )? )? ( ( automatic_key | sequential_key ) order_key )? ( model_iterate_clause )?
        {
            this->followPush(FOLLOW_rules_key_in_model_rules_part5121);
            rules_key360=rules_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemodel_rules_partEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                rules_key360_last = rules_key360.tree.get();
                stream_rules_key.add(rules_key360.tree);
            }

            // OracleDML.g:538:20: ( update_key | upsert_key ( all_key )? )?
            {
                ANTLR_UINT32 alt123=3;
                {
                    ANTLR_UINT32 LA123_0 = this->LA(1);
                    if ( (LA123_0 == SQL92_RESERVED_UPDATE))
                    {
                        alt123=1;
                    }
                    else if ( (LA123_0 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "ITERATE"))||((toUpper(LT(1)->getText()) == "UPSERT"))||((toUpper(LT(1)->getText()) == "SEQUENTIAL"))||((toUpper(LT(1)->getText()) == "AUTOMATIC")))))
                    {
                        {
                            ANTLR_UINT32 LA123_2 = this->LA(2);
                            if ( ((toUpper(LT(1)->getText()) == "UPSERT")))
                            {
                                alt123=2;
                            }
                        }
                    }
                }
                switch (alt123)
                {
            	case 1:
            	    // OracleDML.g:538:21: update_key
            	    {
            	        this->followPush(FOLLOW_update_key_in_model_rules_part5124);
            	        update_key361=update_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemodel_rules_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            update_key361_last = update_key361.tree.get();
            	            stream_update_key.add(update_key361.tree);
            	        }

            	    }
            	    break;
            	case 2:
            	    // OracleDML.g:538:32: upsert_key ( all_key )?
            	    {
            	        this->followPush(FOLLOW_upsert_key_in_model_rules_part5126);
            	        upsert_key362=upsert_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemodel_rules_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            upsert_key362_last = upsert_key362.tree.get();
            	            stream_upsert_key.add(upsert_key362.tree);
            	        }

            	        // OracleDML.g:538:43: ( all_key )?
            	        {
            	            ANTLR_UINT32 alt122=2;
            	            switch ( this->LA(1) )
            	            {
            	                case SQL92_RESERVED_ALL:
            	                	{
            	                		alt122=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt122)
            	            {
            	        	case 1:
            	        	    // OracleDML.g:538:43: all_key
            	        	    {
            	        	        this->followPush(FOLLOW_all_key_in_model_rules_part5128);
            	        	        all_key363=all_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulemodel_rules_partEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) 
            	        	        {
            	        	            all_key363_last = all_key363.tree.get();
            	        	            stream_all_key.add(all_key363.tree);
            	        	        }

            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

                }
            }

            // OracleDML.g:538:54: ( ( automatic_key | sequential_key ) order_key )?
            {
                ANTLR_UINT32 alt125=2;
                {
                    ANTLR_UINT32 LA125_0 = this->LA(1);
                    if ( (LA125_0 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "ITERATE"))||((toUpper(LT(1)->getText()) == "SEQUENTIAL"))||((toUpper(LT(1)->getText()) == "AUTOMATIC")))))
                    {
                        {
                            ANTLR_UINT32 LA125_1 = this->LA(2);
                            if ( (LA125_1 == SQL92_RESERVED_ORDER) && ((((toUpper(LT(1)->getText()) == "SEQUENTIAL"))||((toUpper(LT(1)->getText()) == "AUTOMATIC")))))
                            {
                                alt125=1;
                            }
                        }
                    }
                }
                switch (alt125)
                {
            	case 1:
            	    // OracleDML.g:538:55: ( automatic_key | sequential_key ) order_key
            	    {
            	        // OracleDML.g:538:55: ( automatic_key | sequential_key )
            	        {
            	            ANTLR_UINT32 alt124=2;
            	            {
            	                ANTLR_UINT32 LA124_0 = this->LA(1);
            	                if ( (LA124_0 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SEQUENTIAL"))||((toUpper(LT(1)->getText()) == "AUTOMATIC")))))
            	                {
            	                    {
            	                        ANTLR_UINT32 LA124_1 = this->LA(2);
            	                        if ( ((toUpper(LT(1)->getText()) == "AUTOMATIC")))
            	                        {
            	                            alt124=1;
            	                        }
            	                        else if ( ((toUpper(LT(1)->getText()) == "SEQUENTIAL")))
            	                        {
            	                            alt124=2;
            	                        }
            	                        else
            	                        {
            	                            if (this->get_backtracking()>0)
            	                            {
            	                                this->set_failedflag( true );
            	                                return retval;
            	                            }


            	                            ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                            ex->set_decisionNum( 124 );
            	                            ex->set_state( 1 );


            	                            goto rulemodel_rules_partEx;

            	                        }
            	                    }
            	                }
            	                else
            	                {
            	                    if (this->get_backtracking()>0)
            	                    {
            	                        this->set_failedflag( true );
            	                        return retval;
            	                    }


            	                    ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                    ex->set_decisionNum( 124 );
            	                    ex->set_state( 0 );


            	                    goto rulemodel_rules_partEx;

            	                }
            	            }
            	            switch (alt124)
            	            {
            	        	case 1:
            	        	    // OracleDML.g:538:56: automatic_key
            	        	    {
            	        	        this->followPush(FOLLOW_automatic_key_in_model_rules_part5135);
            	        	        automatic_key364=automatic_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulemodel_rules_partEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) 
            	        	        {
            	        	            automatic_key364_last = automatic_key364.tree.get();
            	        	            stream_automatic_key.add(automatic_key364.tree);
            	        	        }

            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // OracleDML.g:538:70: sequential_key
            	        	    {
            	        	        this->followPush(FOLLOW_sequential_key_in_model_rules_part5137);
            	        	        sequential_key365=sequential_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulemodel_rules_partEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) 
            	        	        {
            	        	            sequential_key365_last = sequential_key365.tree.get();
            	        	            stream_sequential_key.add(sequential_key365.tree);
            	        	        }

            	        	    }
            	        	    break;

            	            }
            	        }

            	        this->followPush(FOLLOW_order_key_in_model_rules_part5140);
            	        order_key366=order_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemodel_rules_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            order_key366_last = order_key366.tree.get();
            	            stream_order_key.add(order_key366.tree);
            	        }

            	    }
            	    break;

                }
            }

            // OracleDML.g:538:98: ( model_iterate_clause )?
            {
                ANTLR_UINT32 alt126=2;
                {
                    ANTLR_UINT32 LA126_0 = this->LA(1);
                    if ( (LA126_0 == REGULAR_ID) && ((toUpper(LT(1)->getText()) == "ITERATE")))
                    {
                        alt126=1;
                    }
                }
                switch (alt126)
                {
            	case 1:
            	    // OracleDML.g:538:98: model_iterate_clause
            	    {
            	        this->followPush(FOLLOW_model_iterate_clause_in_model_rules_part5144);
            	        model_iterate_clause367=model_iterate_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemodel_rules_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            model_iterate_clause367_last = model_iterate_clause367.tree.get();
            	            stream_model_iterate_clause.add(model_iterate_clause367.tree);
            	        }

            	    }
            	    break;

                }
            }

            // AST REWRITE
            // elements: update_key, all_key, model_iterate_clause, sequential_key, rules_key, automatic_key, upsert_key
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 539:9: -> ^( rules_key ( update_key )? ( upsert_key )? ( all_key )? ( automatic_key )? ( sequential_key )? ( model_iterate_clause )? )
            {
            	// OracleDML.g:539:12: ^( rules_key ( update_key )? ( upsert_key )? ( all_key )? ( automatic_key )? ( sequential_key )? ( model_iterate_clause )? )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(stream_rules_key.nextNode(), root_1);
            	// OracleDML.g:539:24: ( update_key )?
            	if ( stream_update_key.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_update_key.nextTree());
            	}
            	stream_update_key.reset();

            	// OracleDML.g:539:36: ( upsert_key )?
            	if ( stream_upsert_key.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_upsert_key.nextTree());
            	}
            	stream_upsert_key.reset();

            	// OracleDML.g:539:48: ( all_key )?
            	if ( stream_all_key.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_all_key.nextTree());
            	}
            	stream_all_key.reset();

            	// OracleDML.g:539:57: ( automatic_key )?
            	if ( stream_automatic_key.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_automatic_key.nextTree());
            	}
            	stream_automatic_key.reset();

            	// OracleDML.g:539:72: ( sequential_key )?
            	if ( stream_sequential_key.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_sequential_key.nextTree());
            	}
            	stream_sequential_key.reset();

            	// OracleDML.g:539:88: ( model_iterate_clause )?
            	if ( stream_model_iterate_clause.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_model_iterate_clause.nextTree());
            	}
            	stream_model_iterate_clause.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulemodel_rules_partEx; /* Prevent compiler warnings */
    rulemodel_rules_partEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end model_rules_part */

/**
 * $ANTLR start model_rules_element
 * OracleDML.g:542:1: model_rules_element : ( update_key | upsert_key ( ( all_key )=> all_key )? )? cell_assignment ( order_by_clause )? EQUALS_OP expression -> ^( MODEL_RULE ^( ASSIGN[$EQUALS_OP] cell_assignment ^( EXPR expression ) ) ( update_key )? ( upsert_key )? ( all_key )? ( order_by_clause )? ) ;
 */
OracleDML::model_rules_element_return
OracleDML::model_rules_element()
{
    OracleDML::model_rules_element_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* EQUALS_OP373 = NULL;
    OracleDML_OracleDMLKeys::update_key_return update_key368;
    ImplTraits::TreeTypePtr::pointer update_key368_last = NULL;
    OracleDML_OracleDMLKeys::upsert_key_return upsert_key369;
    ImplTraits::TreeTypePtr::pointer upsert_key369_last = NULL;
    OracleDML_OracleDMLKeys::all_key_return all_key370;
    ImplTraits::TreeTypePtr::pointer all_key370_last = NULL;
    OracleDML::cell_assignment_return cell_assignment371;
    ImplTraits::TreeTypePtr::pointer cell_assignment371_last = NULL;
    OracleDML::order_by_clause_return order_by_clause372;
    ImplTraits::TreeTypePtr::pointer order_by_clause372_last = NULL;
    OracleDML::expression_return expression374;
    ImplTraits::TreeTypePtr::pointer expression374_last = NULL;
    ImplTraits::TreeTypePtr EQUALS_OP373_tree;
    RewriteRuleTokenStream<ImplTraits> stream_EQUALS_OP(get_psrstate()->get_treeAdaptor(), "token EQUALS_OP");
    RewriteRuleSubtreeStream<ImplTraits> stream_all_key(get_psrstate()->get_treeAdaptor(), "rule all_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_expression(get_psrstate()->get_treeAdaptor(), "rule expression");
    RewriteRuleSubtreeStream<ImplTraits> stream_order_by_clause(get_psrstate()->get_treeAdaptor(), "rule order_by_clause");
    RewriteRuleSubtreeStream<ImplTraits> stream_update_key(get_psrstate()->get_treeAdaptor(), "rule update_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_cell_assignment(get_psrstate()->get_treeAdaptor(), "rule cell_assignment");
    RewriteRuleSubtreeStream<ImplTraits> stream_upsert_key(get_psrstate()->get_treeAdaptor(), "rule upsert_key");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:543:5: ( ( update_key | upsert_key ( ( all_key )=> all_key )? )? cell_assignment ( order_by_clause )? EQUALS_OP expression -> ^( MODEL_RULE ^( ASSIGN[$EQUALS_OP] cell_assignment ^( EXPR expression ) ) ( update_key )? ( upsert_key )? ( all_key )? ( order_by_clause )? ) )
        // OracleDML.g:543:10: ( update_key | upsert_key ( ( all_key )=> all_key )? )? cell_assignment ( order_by_clause )? EQUALS_OP expression
        {
            // OracleDML.g:543:10: ( update_key | upsert_key ( ( all_key )=> all_key )? )?
            {
                ANTLR_UINT32 alt128=3;
                switch ( this->LA(1) )
                {
                    case SQL92_RESERVED_UPDATE:
                    	{
                    		alt128=1;
                    	}
                        break;
                    case REGULAR_ID:
                    	{
                    		{
                    		    ANTLR_UINT32 LA128_2 = this->LA(2);
                    		    if ( ((toUpper(LT(1)->getText()) == "UPSERT")))
                    		    {
                    		        alt128=2;
                    		    }
                    		}
                    	}
                        break;
                }

                switch (alt128)
                {
            	case 1:
            	    // OracleDML.g:543:11: update_key
            	    {
            	        this->followPush(FOLLOW_update_key_in_model_rules_element5198);
            	        update_key368=update_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemodel_rules_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            update_key368_last = update_key368.tree.get();
            	            stream_update_key.add(update_key368.tree);
            	        }

            	    }
            	    break;
            	case 2:
            	    // OracleDML.g:543:22: upsert_key ( ( all_key )=> all_key )?
            	    {
            	        this->followPush(FOLLOW_upsert_key_in_model_rules_element5200);
            	        upsert_key369=upsert_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemodel_rules_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            upsert_key369_last = upsert_key369.tree.get();
            	            stream_upsert_key.add(upsert_key369.tree);
            	        }

            	        // OracleDML.g:543:33: ( ( all_key )=> all_key )?
            	        {
            	            ANTLR_UINT32 alt127=2;
            	            switch ( this->LA(1) )
            	            {
            	                case SQL92_RESERVED_ALL:
            	                	{
            	                		{
            	                		    ANTLR_UINT32 LA127_1 = this->LA(2);
            	                		    if ( (this->msynpred( antlr3::ClassForwarder<synpred22_OracleDML>() )))
            	                		    {
            	                		        alt127=1;
            	                		    }
            	                		}
            	                	}
            	                    break;
            	            }

            	            switch (alt127)
            	            {
            	        	case 1:
            	        	    // OracleDML.g:543:34: ( all_key )=> all_key
            	        	    {
            	        	        this->followPush(FOLLOW_all_key_in_model_rules_element5208);
            	        	        all_key370=all_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulemodel_rules_elementEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) 
            	        	        {
            	        	            all_key370_last = all_key370.tree.get();
            	        	            stream_all_key.add(all_key370.tree);
            	        	        }

            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_cell_assignment_in_model_rules_element5222);
            cell_assignment371=cell_assignment();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemodel_rules_elementEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                cell_assignment371_last = cell_assignment371.tree.get();
                stream_cell_assignment.add(cell_assignment371.tree);
            }

            // OracleDML.g:545:17: ( order_by_clause )?
            {
                ANTLR_UINT32 alt129=2;
                switch ( this->LA(1) )
                {
                    case SQL92_RESERVED_ORDER:
                    	{
                    		alt129=1;
                    	}
                        break;
                }

                switch (alt129)
                {
            	case 1:
            	    // OracleDML.g:545:17: order_by_clause
            	    {
            	        this->followPush(FOLLOW_order_by_clause_in_model_rules_element5240);
            	        order_by_clause372=order_by_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemodel_rules_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            order_by_clause372_last = order_by_clause372.tree.get();
            	            stream_order_by_clause.add(order_by_clause372.tree);
            	        }

            	    }
            	    break;

                }
            }

            EQUALS_OP373 =  this->matchToken(EQUALS_OP, &FOLLOW_EQUALS_OP_in_model_rules_element5255);
            if  (this->hasException())
            {
                goto rulemodel_rules_elementEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_EQUALS_OP.add(EQUALS_OP373);


            this->followPush(FOLLOW_expression_in_model_rules_element5257);
            expression374=expression();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemodel_rules_elementEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                expression374_last = expression374.tree.get();
                stream_expression.add(expression374.tree);
            }

            // AST REWRITE
            // elements: upsert_key, expression, all_key, order_by_clause, update_key, cell_assignment
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 547:9: -> ^( MODEL_RULE ^( ASSIGN[$EQUALS_OP] cell_assignment ^( EXPR expression ) ) ( update_key )? ( upsert_key )? ( all_key )? ( order_by_clause )? )
            {
            	// OracleDML.g:547:12: ^( MODEL_RULE ^( ASSIGN[$EQUALS_OP] cell_assignment ^( EXPR expression ) ) ( update_key )? ( upsert_key )? ( all_key )? ( order_by_clause )? )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(MODEL_RULE, "MODEL_RULE"), root_1);
            	// OracleDML.g:547:25: ^( ASSIGN[$EQUALS_OP] cell_assignment ^( EXPR expression ) )
            	{
            	ImplTraits::TreeTypePtr root_2 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_2 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(ASSIGN, EQUALS_OP373), root_2);
            	get_psrstate()->get_treeAdaptor()->addChild(root_2, stream_cell_assignment.nextTree());
            	// OracleDML.g:547:62: ^( EXPR expression )
            	{
            	ImplTraits::TreeTypePtr root_3 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_3 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(EXPR, "EXPR"), root_3);
            	get_psrstate()->get_treeAdaptor()->addChild(root_3, stream_expression.nextTree());
            	get_psrstate()->get_treeAdaptor()->addChild(root_2, root_3);
            	}
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, root_2);
            	}
            	// OracleDML.g:547:82: ( update_key )?
            	if ( stream_update_key.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_update_key.nextTree());
            	}
            	stream_update_key.reset();

            	// OracleDML.g:547:94: ( upsert_key )?
            	if ( stream_upsert_key.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_upsert_key.nextTree());
            	}
            	stream_upsert_key.reset();

            	// OracleDML.g:547:106: ( all_key )?
            	if ( stream_all_key.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_all_key.nextTree());
            	}
            	stream_all_key.reset();

            	// OracleDML.g:547:115: ( order_by_clause )?
            	if ( stream_order_by_clause.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_order_by_clause.nextTree());
            	}
            	stream_order_by_clause.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulemodel_rules_elementEx; /* Prevent compiler warnings */
    rulemodel_rules_elementEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end model_rules_element */

/**
 * $ANTLR start cell_assignment
 * OracleDML.g:550:1: cell_assignment : model_expression ;
 */
OracleDML::cell_assignment_return
OracleDML::cell_assignment()
{
    OracleDML::cell_assignment_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML::model_expression_return model_expression375;
    ImplTraits::TreeTypePtr::pointer model_expression375_last = NULL;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:551:5: ( model_expression )
        // OracleDML.g:551:10: model_expression
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            this->followPush(FOLLOW_model_expression_in_cell_assignment5316);
            model_expression375=model_expression();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecell_assignmentEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, model_expression375.tree);


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulecell_assignmentEx; /* Prevent compiler warnings */
    rulecell_assignmentEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end cell_assignment */

/**
 * $ANTLR start model_iterate_clause
 * OracleDML.g:554:1: model_iterate_clause : iterate_key LEFT_PAREN expression RIGHT_PAREN ( until_part )? -> ^( iterate_key ^( EXPR expression ) ( until_part )? ) ;
 */
OracleDML::model_iterate_clause_return
OracleDML::model_iterate_clause()
{
    OracleDML::model_iterate_clause_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* LEFT_PAREN377 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN379 = NULL;
    OracleDML_OracleDMLKeys::iterate_key_return iterate_key376;
    ImplTraits::TreeTypePtr::pointer iterate_key376_last = NULL;
    OracleDML::expression_return expression378;
    ImplTraits::TreeTypePtr::pointer expression378_last = NULL;
    OracleDML::until_part_return until_part380;
    ImplTraits::TreeTypePtr::pointer until_part380_last = NULL;
    ImplTraits::TreeTypePtr LEFT_PAREN377_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN379_tree;
    RewriteRuleTokenStream<ImplTraits> stream_LEFT_PAREN(get_psrstate()->get_treeAdaptor(), "token LEFT_PAREN");
    RewriteRuleTokenStream<ImplTraits> stream_RIGHT_PAREN(get_psrstate()->get_treeAdaptor(), "token RIGHT_PAREN");
    RewriteRuleSubtreeStream<ImplTraits> stream_iterate_key(get_psrstate()->get_treeAdaptor(), "rule iterate_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_expression(get_psrstate()->get_treeAdaptor(), "rule expression");
    RewriteRuleSubtreeStream<ImplTraits> stream_until_part(get_psrstate()->get_treeAdaptor(), "rule until_part");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:555:5: ( iterate_key LEFT_PAREN expression RIGHT_PAREN ( until_part )? -> ^( iterate_key ^( EXPR expression ) ( until_part )? ) )
        // OracleDML.g:555:10: iterate_key LEFT_PAREN expression RIGHT_PAREN ( until_part )?
        {
            this->followPush(FOLLOW_iterate_key_in_model_iterate_clause5336);
            iterate_key376=iterate_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemodel_iterate_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                iterate_key376_last = iterate_key376.tree.get();
                stream_iterate_key.add(iterate_key376.tree);
            }

            LEFT_PAREN377 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_model_iterate_clause5338);
            if  (this->hasException())
            {
                goto rulemodel_iterate_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_LEFT_PAREN.add(LEFT_PAREN377);


            this->followPush(FOLLOW_expression_in_model_iterate_clause5340);
            expression378=expression();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemodel_iterate_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                expression378_last = expression378.tree.get();
                stream_expression.add(expression378.tree);
            }

            RIGHT_PAREN379 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_model_iterate_clause5342);
            if  (this->hasException())
            {
                goto rulemodel_iterate_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN379);


            // OracleDML.g:555:56: ( until_part )?
            {
                ANTLR_UINT32 alt130=2;
                {
                    ANTLR_UINT32 LA130_0 = this->LA(1);
                    if ( (LA130_0 == REGULAR_ID) && ((toUpper(LT(1)->getText()) == "UNTIL")))
                    {
                        alt130=1;
                    }
                }
                switch (alt130)
                {
            	case 1:
            	    // OracleDML.g:555:56: until_part
            	    {
            	        this->followPush(FOLLOW_until_part_in_model_iterate_clause5344);
            	        until_part380=until_part();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemodel_iterate_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            until_part380_last = until_part380.tree.get();
            	            stream_until_part.add(until_part380.tree);
            	        }

            	    }
            	    break;

                }
            }

            // AST REWRITE
            // elements: until_part, expression, iterate_key
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 556:9: -> ^( iterate_key ^( EXPR expression ) ( until_part )? )
            {
            	// OracleDML.g:556:11: ^( iterate_key ^( EXPR expression ) ( until_part )? )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(stream_iterate_key.nextNode(), root_1);
            	// OracleDML.g:556:25: ^( EXPR expression )
            	{
            	ImplTraits::TreeTypePtr root_2 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_2 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(EXPR, "EXPR"), root_2);
            	get_psrstate()->get_treeAdaptor()->addChild(root_2, stream_expression.nextTree());
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, root_2);
            	}
            	// OracleDML.g:556:44: ( until_part )?
            	if ( stream_until_part.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_until_part.nextTree());
            	}
            	stream_until_part.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulemodel_iterate_clauseEx; /* Prevent compiler warnings */
    rulemodel_iterate_clauseEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end model_iterate_clause */

/**
 * $ANTLR start until_part
 * OracleDML.g:559:1: until_part : until_key LEFT_PAREN condition RIGHT_PAREN -> ^( until_key ^( LOGIC_EXPR condition ) ) ;
 */
OracleDML::until_part_return
OracleDML::until_part()
{
    OracleDML::until_part_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* LEFT_PAREN382 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN384 = NULL;
    OracleDML_OracleDMLKeys::until_key_return until_key381;
    ImplTraits::TreeTypePtr::pointer until_key381_last = NULL;
    OracleDML::condition_return condition383;
    ImplTraits::TreeTypePtr::pointer condition383_last = NULL;
    ImplTraits::TreeTypePtr LEFT_PAREN382_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN384_tree;
    RewriteRuleTokenStream<ImplTraits> stream_LEFT_PAREN(get_psrstate()->get_treeAdaptor(), "token LEFT_PAREN");
    RewriteRuleTokenStream<ImplTraits> stream_RIGHT_PAREN(get_psrstate()->get_treeAdaptor(), "token RIGHT_PAREN");
    RewriteRuleSubtreeStream<ImplTraits> stream_until_key(get_psrstate()->get_treeAdaptor(), "rule until_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_condition(get_psrstate()->get_treeAdaptor(), "rule condition");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:560:5: ( until_key LEFT_PAREN condition RIGHT_PAREN -> ^( until_key ^( LOGIC_EXPR condition ) ) )
        // OracleDML.g:560:10: until_key LEFT_PAREN condition RIGHT_PAREN
        {
            this->followPush(FOLLOW_until_key_in_until_part5387);
            until_key381=until_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleuntil_partEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                until_key381_last = until_key381.tree.get();
                stream_until_key.add(until_key381.tree);
            }

            LEFT_PAREN382 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_until_part5389);
            if  (this->hasException())
            {
                goto ruleuntil_partEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_LEFT_PAREN.add(LEFT_PAREN382);


            this->followPush(FOLLOW_condition_in_until_part5391);
            condition383=condition();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleuntil_partEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                condition383_last = condition383.tree.get();
                stream_condition.add(condition383.tree);
            }

            RIGHT_PAREN384 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_until_part5393);
            if  (this->hasException())
            {
                goto ruleuntil_partEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN384);


            // AST REWRITE
            // elements: condition, until_key
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 561:9: -> ^( until_key ^( LOGIC_EXPR condition ) )
            {
            	// OracleDML.g:561:12: ^( until_key ^( LOGIC_EXPR condition ) )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(stream_until_key.nextNode(), root_1);
            	// OracleDML.g:561:24: ^( LOGIC_EXPR condition )
            	{
            	ImplTraits::TreeTypePtr root_2 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_2 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(LOGIC_EXPR, "LOGIC_EXPR"), root_2);
            	get_psrstate()->get_treeAdaptor()->addChild(root_2, stream_condition.nextTree());
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, root_2);
            	}
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleuntil_partEx; /* Prevent compiler warnings */
    ruleuntil_partEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end until_part */

/**
 * $ANTLR start order_by_clause
 * OracleDML.g:564:1: order_by_clause : order_key ( siblings_key )? by_key order_by_elements ( COMMA order_by_elements )* ( row_limiting_clause )? -> ^( order_key ( siblings_key )? ^( ORDER_BY_ELEMENTS ( order_by_elements )+ ) ( row_limiting_clause )? ) ;
 */
OracleDML::order_by_clause_return
OracleDML::order_by_clause()
{
    OracleDML::order_by_clause_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* COMMA389 = NULL;
    OracleDML_OracleDMLKeys::order_key_return order_key385;
    ImplTraits::TreeTypePtr::pointer order_key385_last = NULL;
    OracleDML_OracleDMLKeys::siblings_key_return siblings_key386;
    ImplTraits::TreeTypePtr::pointer siblings_key386_last = NULL;
    OracleDML_OracleDMLKeys::by_key_return by_key387;
    ImplTraits::TreeTypePtr::pointer by_key387_last = NULL;
    OracleDML::order_by_elements_return order_by_elements388;
    ImplTraits::TreeTypePtr::pointer order_by_elements388_last = NULL;
    OracleDML::order_by_elements_return order_by_elements390;
    ImplTraits::TreeTypePtr::pointer order_by_elements390_last = NULL;
    OracleDML::row_limiting_clause_return row_limiting_clause391;
    ImplTraits::TreeTypePtr::pointer row_limiting_clause391_last = NULL;
    ImplTraits::TreeTypePtr COMMA389_tree;
    RewriteRuleTokenStream<ImplTraits> stream_COMMA(get_psrstate()->get_treeAdaptor(), "token COMMA");
    RewriteRuleSubtreeStream<ImplTraits> stream_order_key(get_psrstate()->get_treeAdaptor(), "rule order_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_by_key(get_psrstate()->get_treeAdaptor(), "rule by_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_row_limiting_clause(get_psrstate()->get_treeAdaptor(), "rule row_limiting_clause");
    RewriteRuleSubtreeStream<ImplTraits> stream_siblings_key(get_psrstate()->get_treeAdaptor(), "rule siblings_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_order_by_elements(get_psrstate()->get_treeAdaptor(), "rule order_by_elements");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:565:5: ( order_key ( siblings_key )? by_key order_by_elements ( COMMA order_by_elements )* ( row_limiting_clause )? -> ^( order_key ( siblings_key )? ^( ORDER_BY_ELEMENTS ( order_by_elements )+ ) ( row_limiting_clause )? ) )
        // OracleDML.g:565:10: order_key ( siblings_key )? by_key order_by_elements ( COMMA order_by_elements )* ( row_limiting_clause )?
        {
            this->followPush(FOLLOW_order_key_in_order_by_clause5433);
            order_key385=order_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleorder_by_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                order_key385_last = order_key385.tree.get();
                stream_order_key.add(order_key385.tree);
            }

            // OracleDML.g:565:20: ( siblings_key )?
            {
                ANTLR_UINT32 alt131=2;
                {
                    ANTLR_UINT32 LA131_0 = this->LA(1);
                    if ( (LA131_0 == REGULAR_ID) && ((toUpper(LT(1)->getText()) == "SIBLINGS")))
                    {
                        alt131=1;
                    }
                }
                switch (alt131)
                {
            	case 1:
            	    // OracleDML.g:565:20: siblings_key
            	    {
            	        this->followPush(FOLLOW_siblings_key_in_order_by_clause5435);
            	        siblings_key386=siblings_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleorder_by_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            siblings_key386_last = siblings_key386.tree.get();
            	            stream_siblings_key.add(siblings_key386.tree);
            	        }

            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_by_key_in_order_by_clause5438);
            by_key387=by_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleorder_by_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                by_key387_last = by_key387.tree.get();
                stream_by_key.add(by_key387.tree);
            }

            this->followPush(FOLLOW_order_by_elements_in_order_by_clause5440);
            order_by_elements388=order_by_elements();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleorder_by_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                order_by_elements388_last = order_by_elements388.tree.get();
                stream_order_by_elements.add(order_by_elements388.tree);
            }

            // OracleDML.g:565:59: ( COMMA order_by_elements )*

            for (;;)
            {
                ANTLR_UINT32 alt132=2;
                switch ( this->LA(1) )
                {
                case COMMA:
                	{
                		alt132=1;
                	}
                    break;

                }

                switch (alt132)
                {
            	case 1:
            	    // OracleDML.g:565:60: COMMA order_by_elements
            	    {
            	        COMMA389 =  this->matchToken(COMMA, &FOLLOW_COMMA_in_order_by_clause5443);
            	        if  (this->hasException())
            	        {
            	            goto ruleorder_by_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( this->get_backtracking()==0 ) stream_COMMA.add(COMMA389);


            	        this->followPush(FOLLOW_order_by_elements_in_order_by_clause5445);
            	        order_by_elements390=order_by_elements();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleorder_by_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            order_by_elements390_last = order_by_elements390.tree.get();
            	            stream_order_by_elements.add(order_by_elements390.tree);
            	        }

            	    }
            	    break;

            	default:
            	    goto loop132;	/* break out of the loop */
            	    break;
                }
            }
            loop132: ; /* Jump out to here if this rule does not match */


            // OracleDML.g:565:86: ( row_limiting_clause )?
            {
                ANTLR_UINT32 alt133=2;
                {
                    ANTLR_UINT32 LA133_0 = this->LA(1);
                    if ( (LA133_0 == SQL92_RESERVED_FETCH || LA133_0 == SQL_ISO_RESERVED_OFFSET))
                    {
                        alt133=1;
                    }
                    else if ( (LA133_0 == RIGHT_PAREN))
                    {
                        alt133=1;
                    }
                    else if ( (LA133_0 == EOF_TOKEN || LA133_0 == SEMICOLON))
                    {
                        alt133=1;
                    }
                    else if ( (LA133_0 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "RANGE"))||((toUpper(LT(1)->getText()) == "ROWS"))||((toUpper(LT(1)->getText()) == "LOG")))))
                    {
                        {
                            ANTLR_UINT32 LA133_4 = this->LA(2);
                            if ( ((((toUpper(LT(1)->getText()) == "RANGE"))||((toUpper(LT(1)->getText()) == "ROWS"))||((toUpper(LT(1)->getText()) == "LOG")))))
                            {
                                alt133=1;
                            }
                        }
                    }
                    else if ( (LA133_0 == SQL92_RESERVED_WITH))
                    {
                        alt133=1;
                    }
                    else if ( (LA133_0 == SQL92_RESERVED_FOR))
                    {
                        alt133=1;
                    }
                    else if ( (LA133_0 == SQL92_RESERVED_ORDER))
                    {
                        alt133=1;
                    }
                    else if ( (LA133_0 == EQUALS_OP))
                    {
                        alt133=1;
                    }
                }
                switch (alt133)
                {
            	case 1:
            	    // OracleDML.g:565:86: row_limiting_clause
            	    {
            	        this->followPush(FOLLOW_row_limiting_clause_in_order_by_clause5449);
            	        row_limiting_clause391=row_limiting_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleorder_by_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            row_limiting_clause391_last = row_limiting_clause391.tree.get();
            	            stream_row_limiting_clause.add(row_limiting_clause391.tree);
            	        }

            	    }
            	    break;

                }
            }

            // AST REWRITE
            // elements: order_key, row_limiting_clause, order_by_elements, siblings_key
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 566:9: -> ^( order_key ( siblings_key )? ^( ORDER_BY_ELEMENTS ( order_by_elements )+ ) ( row_limiting_clause )? )
            {
            	// OracleDML.g:566:12: ^( order_key ( siblings_key )? ^( ORDER_BY_ELEMENTS ( order_by_elements )+ ) ( row_limiting_clause )? )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(stream_order_key.nextNode(), root_1);
            	// OracleDML.g:566:24: ( siblings_key )?
            	if ( stream_siblings_key.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_siblings_key.nextTree());
            	}
            	stream_siblings_key.reset();

            	// OracleDML.g:566:38: ^( ORDER_BY_ELEMENTS ( order_by_elements )+ )
            	{
            	ImplTraits::TreeTypePtr root_2 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_2 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(ORDER_BY_ELEMENTS, "ORDER_BY_ELEMENTS"), root_2);
            	if ( !(stream_order_by_elements.hasNext()) ) {
            		ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, REWRITE_EARLY_EXCEPTION, StreamType>( this->get_rec(), "order_by_elements empty" );
            		goto ruleorder_by_clauseEx;
            	}
            	while ( stream_order_by_elements.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_2, stream_order_by_elements.nextTree());
            	}
            	stream_order_by_elements.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_1, root_2);
            	}
            	// OracleDML.g:566:78: ( row_limiting_clause )?
            	if ( stream_row_limiting_clause.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_row_limiting_clause.nextTree());
            	}
            	stream_row_limiting_clause.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleorder_by_clauseEx; /* Prevent compiler warnings */
    ruleorder_by_clauseEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end order_by_clause */

/**
 * $ANTLR start order_by_elements
 * OracleDML.g:569:1: order_by_elements : expression ( asc_key | desc_key )? ( nulls_key ( first_key | last_key ) )? -> ^( ORDER_BY_ELEMENT ^( EXPR expression ) ( asc_key )? ( desc_key )? ( nulls_key )? ( first_key )? ( last_key )? ) ;
 */
OracleDML::order_by_elements_return
OracleDML::order_by_elements()
{
    OracleDML::order_by_elements_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML::expression_return expression392;
    ImplTraits::TreeTypePtr::pointer expression392_last = NULL;
    OracleDML_OracleDMLKeys::asc_key_return asc_key393;
    ImplTraits::TreeTypePtr::pointer asc_key393_last = NULL;
    OracleDML_OracleDMLKeys::desc_key_return desc_key394;
    ImplTraits::TreeTypePtr::pointer desc_key394_last = NULL;
    OracleDML_OracleDMLKeys::nulls_key_return nulls_key395;
    ImplTraits::TreeTypePtr::pointer nulls_key395_last = NULL;
    OracleDML_OracleDMLKeys::first_key_return first_key396;
    ImplTraits::TreeTypePtr::pointer first_key396_last = NULL;
    OracleDML_OracleDMLKeys::last_key_return last_key397;
    ImplTraits::TreeTypePtr::pointer last_key397_last = NULL;
    RewriteRuleSubtreeStream<ImplTraits> stream_expression(get_psrstate()->get_treeAdaptor(), "rule expression");
    RewriteRuleSubtreeStream<ImplTraits> stream_desc_key(get_psrstate()->get_treeAdaptor(), "rule desc_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_nulls_key(get_psrstate()->get_treeAdaptor(), "rule nulls_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_last_key(get_psrstate()->get_treeAdaptor(), "rule last_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_asc_key(get_psrstate()->get_treeAdaptor(), "rule asc_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_first_key(get_psrstate()->get_treeAdaptor(), "rule first_key");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:570:5: ( expression ( asc_key | desc_key )? ( nulls_key ( first_key | last_key ) )? -> ^( ORDER_BY_ELEMENT ^( EXPR expression ) ( asc_key )? ( desc_key )? ( nulls_key )? ( first_key )? ( last_key )? ) )
        // OracleDML.g:570:10: expression ( asc_key | desc_key )? ( nulls_key ( first_key | last_key ) )?
        {
            this->followPush(FOLLOW_expression_in_order_by_elements5497);
            expression392=expression();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleorder_by_elementsEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                expression392_last = expression392.tree.get();
                stream_expression.add(expression392.tree);
            }

            // OracleDML.g:570:21: ( asc_key | desc_key )?
            {
                ANTLR_UINT32 alt134=3;
                switch ( this->LA(1) )
                {
                    case SQL92_RESERVED_ASC:
                    	{
                    		alt134=1;
                    	}
                        break;
                    case SQL92_RESERVED_DESC:
                    	{
                    		alt134=2;
                    	}
                        break;
                }

                switch (alt134)
                {
            	case 1:
            	    // OracleDML.g:570:22: asc_key
            	    {
            	        this->followPush(FOLLOW_asc_key_in_order_by_elements5500);
            	        asc_key393=asc_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleorder_by_elementsEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            asc_key393_last = asc_key393.tree.get();
            	            stream_asc_key.add(asc_key393.tree);
            	        }

            	    }
            	    break;
            	case 2:
            	    // OracleDML.g:570:30: desc_key
            	    {
            	        this->followPush(FOLLOW_desc_key_in_order_by_elements5502);
            	        desc_key394=desc_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleorder_by_elementsEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            desc_key394_last = desc_key394.tree.get();
            	            stream_desc_key.add(desc_key394.tree);
            	        }

            	    }
            	    break;

                }
            }

            // OracleDML.g:570:41: ( nulls_key ( first_key | last_key ) )?
            {
                ANTLR_UINT32 alt136=2;
                {
                    ANTLR_UINT32 LA136_0 = this->LA(1);
                    if ( (LA136_0 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "RANGE"))||((toUpper(LT(1)->getText()) == "ROWS"))||((toUpper(LT(1)->getText()) == "LOG"))||((toUpper(LT(1)->getText()) == "NULLS")))))
                    {
                        {
                            ANTLR_UINT32 LA136_1 = this->LA(2);
                            if ( (LA136_1 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "RANGE"))||((toUpper(LT(1)->getText()) == "ROWS"))||((toUpper(LT(1)->getText()) == "LOG"))||((toUpper(LT(1)->getText()) == "NULLS")))))
                            {
                                {
                                    ANTLR_UINT32 LA136_3 = this->LA(3);
                                    if ( ((toUpper(LT(1)->getText()) == "NULLS")))
                                    {
                                        alt136=1;
                                    }
                                }
                            }
                        }
                    }
                }
                switch (alt136)
                {
            	case 1:
            	    // OracleDML.g:570:42: nulls_key ( first_key | last_key )
            	    {
            	        this->followPush(FOLLOW_nulls_key_in_order_by_elements5507);
            	        nulls_key395=nulls_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleorder_by_elementsEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            nulls_key395_last = nulls_key395.tree.get();
            	            stream_nulls_key.add(nulls_key395.tree);
            	        }

            	        // OracleDML.g:570:52: ( first_key | last_key )
            	        {
            	            ANTLR_UINT32 alt135=2;
            	            {
            	                ANTLR_UINT32 LA135_0 = this->LA(1);
            	                if ( (LA135_0 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "FIRST"))||((toUpper(LT(1)->getText()) == "LAST")))))
            	                {
            	                    {
            	                        ANTLR_UINT32 LA135_1 = this->LA(2);
            	                        if ( ((toUpper(LT(1)->getText()) == "FIRST")))
            	                        {
            	                            alt135=1;
            	                        }
            	                        else if ( ((toUpper(LT(1)->getText()) == "LAST")))
            	                        {
            	                            alt135=2;
            	                        }
            	                        else
            	                        {
            	                            if (this->get_backtracking()>0)
            	                            {
            	                                this->set_failedflag( true );
            	                                return retval;
            	                            }


            	                            ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                            ex->set_decisionNum( 135 );
            	                            ex->set_state( 1 );


            	                            goto ruleorder_by_elementsEx;

            	                        }
            	                    }
            	                }
            	                else
            	                {
            	                    if (this->get_backtracking()>0)
            	                    {
            	                        this->set_failedflag( true );
            	                        return retval;
            	                    }


            	                    ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                    ex->set_decisionNum( 135 );
            	                    ex->set_state( 0 );


            	                    goto ruleorder_by_elementsEx;

            	                }
            	            }
            	            switch (alt135)
            	            {
            	        	case 1:
            	        	    // OracleDML.g:570:53: first_key
            	        	    {
            	        	        this->followPush(FOLLOW_first_key_in_order_by_elements5510);
            	        	        first_key396=first_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleorder_by_elementsEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) 
            	        	        {
            	        	            first_key396_last = first_key396.tree.get();
            	        	            stream_first_key.add(first_key396.tree);
            	        	        }

            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // OracleDML.g:570:63: last_key
            	        	    {
            	        	        this->followPush(FOLLOW_last_key_in_order_by_elements5512);
            	        	        last_key397=last_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleorder_by_elementsEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) 
            	        	        {
            	        	            last_key397_last = last_key397.tree.get();
            	        	            stream_last_key.add(last_key397.tree);
            	        	        }

            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

                }
            }

            // AST REWRITE
            // elements: nulls_key, first_key, desc_key, asc_key, last_key, expression
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 571:9: -> ^( ORDER_BY_ELEMENT ^( EXPR expression ) ( asc_key )? ( desc_key )? ( nulls_key )? ( first_key )? ( last_key )? )
            {
            	// OracleDML.g:571:12: ^( ORDER_BY_ELEMENT ^( EXPR expression ) ( asc_key )? ( desc_key )? ( nulls_key )? ( first_key )? ( last_key )? )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(ORDER_BY_ELEMENT, "ORDER_BY_ELEMENT"), root_1);
            	// OracleDML.g:571:31: ^( EXPR expression )
            	{
            	ImplTraits::TreeTypePtr root_2 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_2 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(EXPR, "EXPR"), root_2);
            	get_psrstate()->get_treeAdaptor()->addChild(root_2, stream_expression.nextTree());
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, root_2);
            	}
            	// OracleDML.g:571:50: ( asc_key )?
            	if ( stream_asc_key.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_asc_key.nextTree());
            	}
            	stream_asc_key.reset();

            	// OracleDML.g:571:59: ( desc_key )?
            	if ( stream_desc_key.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_desc_key.nextTree());
            	}
            	stream_desc_key.reset();

            	// OracleDML.g:571:69: ( nulls_key )?
            	if ( stream_nulls_key.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_nulls_key.nextTree());
            	}
            	stream_nulls_key.reset();

            	// OracleDML.g:571:80: ( first_key )?
            	if ( stream_first_key.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_first_key.nextTree());
            	}
            	stream_first_key.reset();

            	// OracleDML.g:571:91: ( last_key )?
            	if ( stream_last_key.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_last_key.nextTree());
            	}
            	stream_last_key.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleorder_by_elementsEx; /* Prevent compiler warnings */
    ruleorder_by_elementsEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end order_by_elements */

/**
 * $ANTLR start row_limiting_clause
 * OracleDML.g:574:1: row_limiting_clause : ( offset_key expression ( row_key | rows_key )? )? ( fetch_key ( first_key | next_key ) ( expression ( percent_key )? )? ( row_key | rows_key ) ( only_key | with_key ties_key ) )? ;
 */
OracleDML::row_limiting_clause_return
OracleDML::row_limiting_clause()
{
    OracleDML::row_limiting_clause_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML_OracleDMLKeys::offset_key_return offset_key398;
    ImplTraits::TreeTypePtr::pointer offset_key398_last = NULL;
    OracleDML::expression_return expression399;
    ImplTraits::TreeTypePtr::pointer expression399_last = NULL;
    OracleDML_OracleDMLKeys::row_key_return row_key400;
    ImplTraits::TreeTypePtr::pointer row_key400_last = NULL;
    OracleDML_OracleDMLKeys::rows_key_return rows_key401;
    ImplTraits::TreeTypePtr::pointer rows_key401_last = NULL;
    OracleDML_OracleDMLKeys::fetch_key_return fetch_key402;
    ImplTraits::TreeTypePtr::pointer fetch_key402_last = NULL;
    OracleDML_OracleDMLKeys::first_key_return first_key403;
    ImplTraits::TreeTypePtr::pointer first_key403_last = NULL;
    OracleDML_OracleDMLKeys::next_key_return next_key404;
    ImplTraits::TreeTypePtr::pointer next_key404_last = NULL;
    OracleDML::expression_return expression405;
    ImplTraits::TreeTypePtr::pointer expression405_last = NULL;
    OracleDML_OracleDMLKeys::percent_key_return percent_key406;
    ImplTraits::TreeTypePtr::pointer percent_key406_last = NULL;
    OracleDML_OracleDMLKeys::row_key_return row_key407;
    ImplTraits::TreeTypePtr::pointer row_key407_last = NULL;
    OracleDML_OracleDMLKeys::rows_key_return rows_key408;
    ImplTraits::TreeTypePtr::pointer rows_key408_last = NULL;
    OracleDML_OracleDMLKeys::only_key_return only_key409;
    ImplTraits::TreeTypePtr::pointer only_key409_last = NULL;
    OracleDML_OracleDMLKeys::with_key_return with_key410;
    ImplTraits::TreeTypePtr::pointer with_key410_last = NULL;
    OracleDML_OracleDMLKeys::ties_key_return ties_key411;
    ImplTraits::TreeTypePtr::pointer ties_key411_last = NULL;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:575:5: ( ( offset_key expression ( row_key | rows_key )? )? ( fetch_key ( first_key | next_key ) ( expression ( percent_key )? )? ( row_key | rows_key ) ( only_key | with_key ties_key ) )? )
        // OracleDML.g:575:10: ( offset_key expression ( row_key | rows_key )? )? ( fetch_key ( first_key | next_key ) ( expression ( percent_key )? )? ( row_key | rows_key ) ( only_key | with_key ties_key ) )?
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            // OracleDML.g:575:10: ( offset_key expression ( row_key | rows_key )? )?
            {
                ANTLR_UINT32 alt138=2;
                switch ( this->LA(1) )
                {
                    case SQL_ISO_RESERVED_OFFSET:
                    	{
                    		alt138=1;
                    	}
                        break;
                }

                switch (alt138)
                {
            	case 1:
            	    // OracleDML.g:575:11: offset_key expression ( row_key | rows_key )?
            	    {
            	        this->followPush(FOLLOW_offset_key_in_row_limiting_clause5571);
            	        offset_key398=offset_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulerow_limiting_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, offset_key398.tree);


            	        this->followPush(FOLLOW_expression_in_row_limiting_clause5573);
            	        expression399=expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulerow_limiting_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, expression399.tree);


            	        // OracleDML.g:575:34: ( row_key | rows_key )?
            	        {
            	            ANTLR_UINT32 alt137=3;
            	            switch ( this->LA(1) )
            	            {
            	                case REGULAR_ID:
            	                	{
            	                		{
            	                		    ANTLR_UINT32 LA137_1 = this->LA(2);
            	                		    if ( ((toUpper(LT(1)->getText()) == "ROW")))
            	                		    {
            	                		        alt137=1;
            	                		    }
            	                		    else if ( ((toUpper(LT(1)->getText()) == "ROWS")))
            	                		    {
            	                		        alt137=2;
            	                		    }
            	                		}
            	                	}
            	                    break;
            	            }

            	            switch (alt137)
            	            {
            	        	case 1:
            	        	    // OracleDML.g:575:35: row_key
            	        	    {
            	        	        this->followPush(FOLLOW_row_key_in_row_limiting_clause5577);
            	        	        row_key400=row_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulerow_limiting_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, row_key400.tree);


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // OracleDML.g:575:43: rows_key
            	        	    {
            	        	        this->followPush(FOLLOW_rows_key_in_row_limiting_clause5579);
            	        	        rows_key401=rows_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulerow_limiting_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, rows_key401.tree);


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

                }
            }

            // OracleDML.g:576:10: ( fetch_key ( first_key | next_key ) ( expression ( percent_key )? )? ( row_key | rows_key ) ( only_key | with_key ties_key ) )?
            {
                ANTLR_UINT32 alt144=2;
                switch ( this->LA(1) )
                {
                    case SQL92_RESERVED_FETCH:
                    	{
                    		alt144=1;
                    	}
                        break;
                }

                switch (alt144)
                {
            	case 1:
            	    // OracleDML.g:576:11: fetch_key ( first_key | next_key ) ( expression ( percent_key )? )? ( row_key | rows_key ) ( only_key | with_key ties_key )
            	    {
            	        this->followPush(FOLLOW_fetch_key_in_row_limiting_clause5596);
            	        fetch_key402=fetch_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulerow_limiting_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, fetch_key402.tree);


            	        // OracleDML.g:576:21: ( first_key | next_key )
            	        {
            	            ANTLR_UINT32 alt139=2;
            	            switch ( this->LA(1) )
            	            {
            	            case REGULAR_ID:
            	            	{
            	            		{
            	            		    ANTLR_UINT32 LA139_1 = this->LA(2);
            	            		    if ( ((toUpper(LT(1)->getText()) == "FIRST")))
            	            		    {
            	            		        alt139=1;
            	            		    }
            	            		    else if ( ((toUpper(LT(1)->getText()) == "NEXT")))
            	            		    {
            	            		        alt139=2;
            	            		    }
            	            		    else
            	            		    {
            	            		        if (this->get_backtracking()>0)
            	            		        {
            	            		            this->set_failedflag( true );
            	            		            return retval;
            	            		        }


            	            		        ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	            		        ex->set_decisionNum( 139 );
            	            		        ex->set_state( 1 );


            	            		        goto rulerow_limiting_clauseEx;

            	            		    }
            	            		}
            	            	}
            	                break;

            	            default:
            	                if (this->get_backtracking()>0)
            	                {
            	                    this->set_failedflag( true );
            	                    return retval;
            	                }

            	                ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                ex->set_decisionNum( 139 );
            	                ex->set_state( 0 );


            	                goto rulerow_limiting_clauseEx;

            	            }

            	            switch (alt139)
            	            {
            	        	case 1:
            	        	    // OracleDML.g:576:22: first_key
            	        	    {
            	        	        this->followPush(FOLLOW_first_key_in_row_limiting_clause5599);
            	        	        first_key403=first_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulerow_limiting_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, first_key403.tree);


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // OracleDML.g:576:32: next_key
            	        	    {
            	        	        this->followPush(FOLLOW_next_key_in_row_limiting_clause5601);
            	        	        next_key404=next_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulerow_limiting_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, next_key404.tree);


            	        	    }
            	        	    break;

            	            }
            	        }

            	        // OracleDML.g:576:42: ( expression ( percent_key )? )?
            	        {
            	            ANTLR_UINT32 alt141=2;
            	            switch ( this->LA(1) )
            	            {
            	                case APPROXIMATE_NUM_LIT:
            	                case BINDVAR:
            	                case CHAR_STRING:
            	                case CHAR_STRING_PERL:
            	                case COLON:
            	                case DELIMITED_ID:
            	                case EXACT_NUM_LIT:
            	                case INTRODUCER:
            	                case LEFT_PAREN:
            	                case MINUS_SIGN:
            	                case NATIONAL_CHAR_STRING_LIT:
            	                case PLSQL_NON_RESERVED_CAST:
            	                case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
            	                case PLUS_SIGN:
            	                case SQL92_RESERVED_ALL:
            	                case SQL92_RESERVED_ANY:
            	                case SQL92_RESERVED_CASE:
            	                case SQL92_RESERVED_CURSOR:
            	                case SQL92_RESERVED_DATE:
            	                case SQL92_RESERVED_DEFAULT:
            	                case SQL92_RESERVED_DISTINCT:
            	                case SQL92_RESERVED_EXISTS:
            	                case SQL92_RESERVED_FALSE:
            	                case SQL92_RESERVED_NOT:
            	                case SQL92_RESERVED_NULL:
            	                case SQL92_RESERVED_PRIOR:
            	                case SQL92_RESERVED_TRUE:
            	                case UNSIGNED_INTEGER:
            	                	{
            	                		alt141=1;
            	                	}
            	                    break;
            	                case REGULAR_ID:
            	                	{
            	                		{
            	                		    ANTLR_UINT32 LA141_7 = this->LA(2);
            	                		    if ( (!( ((((toUpper(LT(1)->getText()) == "ROWS"))||((toUpper(LT(1)->getText()) == "ROW")))) )))
            	                		    {
            	                		        alt141=1;
            	                		    }
            	                		}
            	                	}
            	                    break;
            	            }

            	            switch (alt141)
            	            {
            	        	case 1:
            	        	    // OracleDML.g:576:43: expression ( percent_key )?
            	        	    {
            	        	        this->followPush(FOLLOW_expression_in_row_limiting_clause5605);
            	        	        expression405=expression();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulerow_limiting_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, expression405.tree);


            	        	        // OracleDML.g:576:54: ( percent_key )?
            	        	        {
            	        	            ANTLR_UINT32 alt140=2;
            	        	            switch ( this->LA(1) )
            	        	            {
            	        	                case REGULAR_ID:
            	        	                	{
            	        	                		switch ( this->LA(2) )
            	        	                		{
            	        	                		    case REGULAR_ID:
            	        	                		    	{
            	        	                		    		switch ( this->LA(3) )
            	        	                		    		{
            	        	                		    		    case REGULAR_ID:
            	        	                		    		    	{
            	        	                		    		    		switch ( this->LA(4) )
            	        	                		    		    		{
            	        	                		    		    		    case EOF_TOKEN:
            	        	                		    		    		    case EQUALS_OP:
            	        	                		    		    		    case RIGHT_PAREN:
            	        	                		    		    		    case SEMICOLON:
            	        	                		    		    		    case SQL92_RESERVED_FOR:
            	        	                		    		    		    case SQL92_RESERVED_ORDER:
            	        	                		    		    		    case SQL92_RESERVED_WITH:
            	        	                		    		    		    	{
            	        	                		    		    		    		alt140=1;
            	        	                		    		    		    	}
            	        	                		    		    		        break;
            	        	                		    		    		    case REGULAR_ID:
            	        	                		    		    		    	{
            	        	                		    		    		    		{
            	        	                		    		    		    		    ANTLR_UINT32 LA140_7 = this->LA(5);
            	        	                		    		    		    		    if ( ((toUpper(LT(1)->getText()) == "PERCENT")))
            	        	                		    		    		    		    {
            	        	                		    		    		    		        alt140=1;
            	        	                		    		    		    		    }
            	        	                		    		    		    		}
            	        	                		    		    		    	}
            	        	                		    		    		        break;
            	        	                		    		    		}

            	        	                		    		    	}
            	        	                		    		        break;
            	        	                		    		    case SQL92_RESERVED_WITH:
            	        	                		    		    	{
            	        	                		    		    		switch ( this->LA(4) )
            	        	                		    		    		{
            	        	                		    		    		    case REGULAR_ID:
            	        	                		    		    		    	{
            	        	                		    		    		    		switch ( this->LA(5) )
            	        	                		    		    		    		{
            	        	                		    		    		    		    case EOF_TOKEN:
            	        	                		    		    		    		    case EQUALS_OP:
            	        	                		    		    		    		    case RIGHT_PAREN:
            	        	                		    		    		    		    case SEMICOLON:
            	        	                		    		    		    		    case SQL92_RESERVED_FOR:
            	        	                		    		    		    		    case SQL92_RESERVED_ORDER:
            	        	                		    		    		    		    case SQL92_RESERVED_WITH:
            	        	                		    		    		    		    	{
            	        	                		    		    		    		    		alt140=1;
            	        	                		    		    		    		    	}
            	        	                		    		    		    		        break;
            	        	                		    		    		    		    case REGULAR_ID:
            	        	                		    		    		    		    	{
            	        	                		    		    		    		    		switch ( this->LA(6) )
            	        	                		    		    		    		    		{
            	        	                		    		    		    		    		    case APPROXIMATE_NUM_LIT:
            	        	                		    		    		    		    		    case BINDVAR:
            	        	                		    		    		    		    		    case CHAR_STRING:
            	        	                		    		    		    		    		    case CHAR_STRING_PERL:
            	        	                		    		    		    		    		    case COLON:
            	        	                		    		    		    		    		    case DELIMITED_ID:
            	        	                		    		    		    		    		    case EXACT_NUM_LIT:
            	        	                		    		    		    		    		    case INTRODUCER:
            	        	                		    		    		    		    		    case LEFT_PAREN:
            	        	                		    		    		    		    		    case MINUS_SIGN:
            	        	                		    		    		    		    		    case NATIONAL_CHAR_STRING_LIT:
            	        	                		    		    		    		    		    case PLSQL_NON_RESERVED_CAST:
            	        	                		    		    		    		    		    case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
            	        	                		    		    		    		    		    case PLUS_SIGN:
            	        	                		    		    		    		    		    case REGULAR_ID:
            	        	                		    		    		    		    		    case SQL92_RESERVED_ALL:
            	        	                		    		    		    		    		    case SQL92_RESERVED_ANY:
            	        	                		    		    		    		    		    case SQL92_RESERVED_BETWEEN:
            	        	                		    		    		    		    		    case SQL92_RESERVED_CASE:
            	        	                		    		    		    		    		    case SQL92_RESERVED_CURRENT:
            	        	                		    		    		    		    		    case SQL92_RESERVED_DATE:
            	        	                		    		    		    		    		    case SQL92_RESERVED_DEFAULT:
            	        	                		    		    		    		    		    case SQL92_RESERVED_DISTINCT:
            	        	                		    		    		    		    		    case SQL92_RESERVED_EXISTS:
            	        	                		    		    		    		    		    case SQL92_RESERVED_FALSE:
            	        	                		    		    		    		    		    case SQL92_RESERVED_NULL:
            	        	                		    		    		    		    		    case SQL92_RESERVED_PRIOR:
            	        	                		    		    		    		    		    case SQL92_RESERVED_TRUE:
            	        	                		    		    		    		    		    case UNSIGNED_INTEGER:
            	        	                		    		    		    		    		    	{
            	        	                		    		    		    		    		    		alt140=1;
            	        	                		    		    		    		    		    	}
            	        	                		    		    		    		    		        break;
            	        	                		    		    		    		    		}

            	        	                		    		    		    		    	}
            	        	                		    		    		    		        break;
            	        	                		    		    		    		}

            	        	                		    		    		    	}
            	        	                		    		    		        break;
            	        	                		    		    		}

            	        	                		    		    	}
            	        	                		    		        break;
            	        	                		    		}

            	        	                		    	}
            	        	                		        break;
            	        	                		}

            	        	                	}
            	        	                    break;
            	        	            }

            	        	            switch (alt140)
            	        	            {
            	        	        	case 1:
            	        	        	    // OracleDML.g:576:54: percent_key
            	        	        	    {
            	        	        	        this->followPush(FOLLOW_percent_key_in_row_limiting_clause5607);
            	        	        	        percent_key406=percent_key();

            	        	        	        this->followPop();
            	        	        	        if  (this->hasException())
            	        	        	        {
            	        	        	            goto rulerow_limiting_clauseEx;
            	        	        	        }
            	        	        	        if (this->hasFailed())
            	        	        	        {
            	        	        	            return retval;
            	        	        	        }

            	        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, percent_key406.tree);


            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	    }
            	        	    break;

            	            }
            	        }

            	        // OracleDML.g:576:69: ( row_key | rows_key )
            	        {
            	            ANTLR_UINT32 alt142=2;
            	            switch ( this->LA(1) )
            	            {
            	            case REGULAR_ID:
            	            	{
            	            		{
            	            		    ANTLR_UINT32 LA142_1 = this->LA(2);
            	            		    if ( ((toUpper(LT(1)->getText()) == "ROW")))
            	            		    {
            	            		        alt142=1;
            	            		    }
            	            		    else if ( ((toUpper(LT(1)->getText()) == "ROWS")))
            	            		    {
            	            		        alt142=2;
            	            		    }
            	            		    else
            	            		    {
            	            		        if (this->get_backtracking()>0)
            	            		        {
            	            		            this->set_failedflag( true );
            	            		            return retval;
            	            		        }


            	            		        ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	            		        ex->set_decisionNum( 142 );
            	            		        ex->set_state( 1 );


            	            		        goto rulerow_limiting_clauseEx;

            	            		    }
            	            		}
            	            	}
            	                break;

            	            default:
            	                if (this->get_backtracking()>0)
            	                {
            	                    this->set_failedflag( true );
            	                    return retval;
            	                }

            	                ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                ex->set_decisionNum( 142 );
            	                ex->set_state( 0 );


            	                goto rulerow_limiting_clauseEx;

            	            }

            	            switch (alt142)
            	            {
            	        	case 1:
            	        	    // OracleDML.g:576:70: row_key
            	        	    {
            	        	        this->followPush(FOLLOW_row_key_in_row_limiting_clause5613);
            	        	        row_key407=row_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulerow_limiting_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, row_key407.tree);


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // OracleDML.g:576:78: rows_key
            	        	    {
            	        	        this->followPush(FOLLOW_rows_key_in_row_limiting_clause5615);
            	        	        rows_key408=rows_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulerow_limiting_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, rows_key408.tree);


            	        	    }
            	        	    break;

            	            }
            	        }

            	        // OracleDML.g:576:88: ( only_key | with_key ties_key )
            	        {
            	            ANTLR_UINT32 alt143=2;
            	            switch ( this->LA(1) )
            	            {
            	            case REGULAR_ID:
            	            	{
            	            		alt143=1;
            	            	}
            	                break;
            	            case SQL92_RESERVED_WITH:
            	            	{
            	            		alt143=2;
            	            	}
            	                break;

            	            default:
            	                if (this->get_backtracking()>0)
            	                {
            	                    this->set_failedflag( true );
            	                    return retval;
            	                }

            	                ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                ex->set_decisionNum( 143 );
            	                ex->set_state( 0 );


            	                goto rulerow_limiting_clauseEx;

            	            }

            	            switch (alt143)
            	            {
            	        	case 1:
            	        	    // OracleDML.g:576:89: only_key
            	        	    {
            	        	        this->followPush(FOLLOW_only_key_in_row_limiting_clause5619);
            	        	        only_key409=only_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulerow_limiting_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, only_key409.tree);


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // OracleDML.g:576:98: with_key ties_key
            	        	    {
            	        	        this->followPush(FOLLOW_with_key_in_row_limiting_clause5621);
            	        	        with_key410=with_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulerow_limiting_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, with_key410.tree);


            	        	        this->followPush(FOLLOW_ties_key_in_row_limiting_clause5623);
            	        	        ties_key411=ties_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulerow_limiting_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, ties_key411.tree);


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

                }
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulerow_limiting_clauseEx; /* Prevent compiler warnings */
    rulerow_limiting_clauseEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end row_limiting_clause */

/**
 * $ANTLR start for_update_clause
 * OracleDML.g:579:1: for_update_clause : for_key update_key ( for_update_of_part )? ( for_update_options )? -> ^( for_key update_key ( for_update_of_part )? ( for_update_options )? ) ;
 */
OracleDML::for_update_clause_return
OracleDML::for_update_clause()
{
    OracleDML::for_update_clause_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML_OracleDMLKeys::for_key_return for_key412;
    ImplTraits::TreeTypePtr::pointer for_key412_last = NULL;
    OracleDML_OracleDMLKeys::update_key_return update_key413;
    ImplTraits::TreeTypePtr::pointer update_key413_last = NULL;
    OracleDML::for_update_of_part_return for_update_of_part414;
    ImplTraits::TreeTypePtr::pointer for_update_of_part414_last = NULL;
    OracleDML::for_update_options_return for_update_options415;
    ImplTraits::TreeTypePtr::pointer for_update_options415_last = NULL;
    RewriteRuleSubtreeStream<ImplTraits> stream_for_update_of_part(get_psrstate()->get_treeAdaptor(), "rule for_update_of_part");
    RewriteRuleSubtreeStream<ImplTraits> stream_for_update_options(get_psrstate()->get_treeAdaptor(), "rule for_update_options");
    RewriteRuleSubtreeStream<ImplTraits> stream_update_key(get_psrstate()->get_treeAdaptor(), "rule update_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_for_key(get_psrstate()->get_treeAdaptor(), "rule for_key");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:580:5: ( for_key update_key ( for_update_of_part )? ( for_update_options )? -> ^( for_key update_key ( for_update_of_part )? ( for_update_options )? ) )
        // OracleDML.g:580:10: for_key update_key ( for_update_of_part )? ( for_update_options )?
        {
            this->followPush(FOLLOW_for_key_in_for_update_clause5671);
            for_key412=for_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulefor_update_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                for_key412_last = for_key412.tree.get();
                stream_for_key.add(for_key412.tree);
            }

            this->followPush(FOLLOW_update_key_in_for_update_clause5673);
            update_key413=update_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulefor_update_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                update_key413_last = update_key413.tree.get();
                stream_update_key.add(update_key413.tree);
            }

            // OracleDML.g:580:29: ( for_update_of_part )?
            {
                ANTLR_UINT32 alt145=2;
                switch ( this->LA(1) )
                {
                    case SQL92_RESERVED_OF:
                    	{
                    		alt145=1;
                    	}
                        break;
                }

                switch (alt145)
                {
            	case 1:
            	    // OracleDML.g:580:29: for_update_of_part
            	    {
            	        this->followPush(FOLLOW_for_update_of_part_in_for_update_clause5675);
            	        for_update_of_part414=for_update_of_part();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulefor_update_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            for_update_of_part414_last = for_update_of_part414.tree.get();
            	            stream_for_update_of_part.add(for_update_of_part414.tree);
            	        }

            	    }
            	    break;

                }
            }

            // OracleDML.g:580:49: ( for_update_options )?
            {
                ANTLR_UINT32 alt146=2;
                {
                    ANTLR_UINT32 LA146_0 = this->LA(1);
                    if ( (LA146_0 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SKIP"))||((toUpper(LT(1)->getText()) == "WAIT"))||((toUpper(LT(1)->getText()) == "LOG")))))
                    {
                        {
                            ANTLR_UINT32 LA146_1 = this->LA(2);
                            if ( (LA146_1 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SKIP"))||((toUpper(LT(1)->getText()) == "WAIT"))||((toUpper(LT(1)->getText()) == "LOG")))))
                            {
                                {
                                    ANTLR_UINT32 LA146_4 = this->LA(3);
                                    if ( ((((toUpper(LT(1)->getText()) == "SKIP"))||((toUpper(LT(1)->getText()) == "WAIT")))))
                                    {
                                        alt146=1;
                                    }
                                }
                            }
                            else if ( (LA146_1 == APPROXIMATE_NUM_LIT || LA146_1 == BINDVAR || ((LA146_1 >= CHAR_STRING) && (LA146_1 <= CHAR_STRING_PERL)) || LA146_1 == COLON || LA146_1 == DELIMITED_ID || LA146_1 == EXACT_NUM_LIT || LA146_1 == INTRODUCER || LA146_1 == LEFT_PAREN || LA146_1 == MINUS_SIGN || LA146_1 == NATIONAL_CHAR_STRING_LIT || ((LA146_1 >= PLSQL_NON_RESERVED_CAST) && (LA146_1 <= PLSQL_NON_RESERVED_CONNECT_BY_ROOT)) || LA146_1 == PLUS_SIGN || LA146_1 == SQL92_RESERVED_ALL || LA146_1 == SQL92_RESERVED_ANY || LA146_1 == SQL92_RESERVED_CASE || ((LA146_1 >= SQL92_RESERVED_CURSOR) && (LA146_1 <= SQL92_RESERVED_DATE)) || LA146_1 == SQL92_RESERVED_DEFAULT || LA146_1 == SQL92_RESERVED_DISTINCT || ((LA146_1 >= SQL92_RESERVED_EXISTS) && (LA146_1 <= SQL92_RESERVED_FALSE)) || ((LA146_1 >= SQL92_RESERVED_NOT) && (LA146_1 <= SQL92_RESERVED_NULL)) || LA146_1 == SQL92_RESERVED_PRIOR || LA146_1 == SQL92_RESERVED_TRUE || LA146_1 == UNSIGNED_INTEGER) && ((toUpper(LT(1)->getText()) == "WAIT")))
                            {
                                alt146=1;
                            }
                        }
                    }
                    else if ( (LA146_0 == PLSQL_RESERVED_NOWAIT))
                    {
                        alt146=1;
                    }
                }
                switch (alt146)
                {
            	case 1:
            	    // OracleDML.g:580:49: for_update_options
            	    {
            	        this->followPush(FOLLOW_for_update_options_in_for_update_clause5678);
            	        for_update_options415=for_update_options();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulefor_update_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            for_update_options415_last = for_update_options415.tree.get();
            	            stream_for_update_options.add(for_update_options415.tree);
            	        }

            	    }
            	    break;

                }
            }

            // AST REWRITE
            // elements: for_update_of_part, update_key, for_update_options, for_key
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 581:9: -> ^( for_key update_key ( for_update_of_part )? ( for_update_options )? )
            {
            	// OracleDML.g:581:12: ^( for_key update_key ( for_update_of_part )? ( for_update_options )? )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(stream_for_key.nextNode(), root_1);
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_update_key.nextTree());
            	// OracleDML.g:581:33: ( for_update_of_part )?
            	if ( stream_for_update_of_part.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_for_update_of_part.nextTree());
            	}
            	stream_for_update_of_part.reset();

            	// OracleDML.g:581:53: ( for_update_options )?
            	if ( stream_for_update_options.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_for_update_options.nextTree());
            	}
            	stream_for_update_options.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulefor_update_clauseEx; /* Prevent compiler warnings */
    rulefor_update_clauseEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end for_update_clause */

/**
 * $ANTLR start for_update_of_part
 * OracleDML.g:584:1: for_update_of_part : of_key ^ column_name ( COMMA ! column_name )* ;
 */
OracleDML::for_update_of_part_return
OracleDML::for_update_of_part()
{
    OracleDML::for_update_of_part_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* COMMA418 = NULL;
    OracleDML_OracleDMLKeys::of_key_return of_key416;
    ImplTraits::TreeTypePtr::pointer of_key416_last = NULL;
    OracleDML_OracleDMLCommons::column_name_return column_name417;
    ImplTraits::TreeTypePtr::pointer column_name417_last = NULL;
    OracleDML_OracleDMLCommons::column_name_return column_name419;
    ImplTraits::TreeTypePtr::pointer column_name419_last = NULL;
    ImplTraits::TreeTypePtr COMMA418_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:585:5: ( of_key ^ column_name ( COMMA ! column_name )* )
        // OracleDML.g:585:10: of_key ^ column_name ( COMMA ! column_name )*
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            this->followPush(FOLLOW_of_key_in_for_update_of_part5721);
            of_key416=of_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulefor_update_of_partEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(of_key416.tree, root_0);

            this->followPush(FOLLOW_column_name_in_for_update_of_part5724);
            column_name417=column_name();

            this->followPop();
            if  (this->hasException())
            {
                goto rulefor_update_of_partEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, column_name417.tree);


            // OracleDML.g:585:30: ( COMMA ! column_name )*

            for (;;)
            {
                ANTLR_UINT32 alt147=2;
                switch ( this->LA(1) )
                {
                case COMMA:
                	{
                		alt147=1;
                	}
                    break;

                }

                switch (alt147)
                {
            	case 1:
            	    // OracleDML.g:585:31: COMMA ! column_name
            	    {
            	        COMMA418 =  this->matchToken(COMMA, &FOLLOW_COMMA_in_for_update_of_part5727);
            	        if  (this->hasException())
            	        {
            	            goto rulefor_update_of_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }


            	        this->followPush(FOLLOW_column_name_in_for_update_of_part5730);
            	        column_name419=column_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulefor_update_of_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, column_name419.tree);


            	    }
            	    break;

            	default:
            	    goto loop147;	/* break out of the loop */
            	    break;
                }
            }
            loop147: ; /* Jump out to here if this rule does not match */


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulefor_update_of_partEx; /* Prevent compiler warnings */
    rulefor_update_of_partEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end for_update_of_part */

/**
 * $ANTLR start for_update_options
 * OracleDML.g:588:1: for_update_options : ( skip_key locked_key !| nowait_key | wait_key expression -> ^( wait_key ^( EXPR expression ) ) );
 */
OracleDML::for_update_options_return
OracleDML::for_update_options()
{
    OracleDML::for_update_options_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML_OracleDMLKeys::skip_key_return skip_key420;
    ImplTraits::TreeTypePtr::pointer skip_key420_last = NULL;
    OracleDML_OracleDMLKeys::locked_key_return locked_key421;
    ImplTraits::TreeTypePtr::pointer locked_key421_last = NULL;
    OracleDML_OracleDMLKeys::nowait_key_return nowait_key422;
    ImplTraits::TreeTypePtr::pointer nowait_key422_last = NULL;
    OracleDML_OracleDMLKeys::wait_key_return wait_key423;
    ImplTraits::TreeTypePtr::pointer wait_key423_last = NULL;
    OracleDML::expression_return expression424;
    ImplTraits::TreeTypePtr::pointer expression424_last = NULL;
    RewriteRuleSubtreeStream<ImplTraits> stream_expression(get_psrstate()->get_treeAdaptor(), "rule expression");
    RewriteRuleSubtreeStream<ImplTraits> stream_wait_key(get_psrstate()->get_treeAdaptor(), "rule wait_key");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        {
            //  OracleDML.g:589:5: ( skip_key locked_key !| nowait_key | wait_key expression -> ^( wait_key ^( EXPR expression ) ) )

            ANTLR_UINT32 alt148;

            alt148=3;

            {
                ANTLR_UINT32 LA148_0 = this->LA(1);
                if ( (LA148_0 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SKIP"))||((toUpper(LT(1)->getText()) == "WAIT")))))
                {
                    {
                        ANTLR_UINT32 LA148_1 = this->LA(2);
                        if ( (LA148_1 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SKIP"))||((toUpper(LT(1)->getText()) == "WAIT")))))
                        {
                            {
                                ANTLR_UINT32 LA148_3 = this->LA(3);
                                if ( ((toUpper(LT(1)->getText()) == "SKIP")))
                                {
                                    alt148=1;
                                }
                                else if ( ((toUpper(LT(1)->getText()) == "WAIT")))
                                {
                                    alt148=3;
                                }
                                else
                                {
                                    if (this->get_backtracking()>0)
                                    {
                                        this->set_failedflag( true );
                                        return retval;
                                    }


                                    ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                    ex->set_decisionNum( 148 );
                                    ex->set_state( 3 );


                                    goto rulefor_update_optionsEx;

                                }
                            }
                        }
                        else if ( (LA148_1 == APPROXIMATE_NUM_LIT || LA148_1 == BINDVAR || ((LA148_1 >= CHAR_STRING) && (LA148_1 <= CHAR_STRING_PERL)) || LA148_1 == COLON || LA148_1 == DELIMITED_ID || LA148_1 == EXACT_NUM_LIT || LA148_1 == INTRODUCER || LA148_1 == LEFT_PAREN || LA148_1 == MINUS_SIGN || LA148_1 == NATIONAL_CHAR_STRING_LIT || ((LA148_1 >= PLSQL_NON_RESERVED_CAST) && (LA148_1 <= PLSQL_NON_RESERVED_CONNECT_BY_ROOT)) || LA148_1 == PLUS_SIGN || LA148_1 == SQL92_RESERVED_ALL || LA148_1 == SQL92_RESERVED_ANY || LA148_1 == SQL92_RESERVED_CASE || ((LA148_1 >= SQL92_RESERVED_CURSOR) && (LA148_1 <= SQL92_RESERVED_DATE)) || LA148_1 == SQL92_RESERVED_DEFAULT || LA148_1 == SQL92_RESERVED_DISTINCT || ((LA148_1 >= SQL92_RESERVED_EXISTS) && (LA148_1 <= SQL92_RESERVED_FALSE)) || ((LA148_1 >= SQL92_RESERVED_NOT) && (LA148_1 <= SQL92_RESERVED_NULL)) || LA148_1 == SQL92_RESERVED_PRIOR || LA148_1 == SQL92_RESERVED_TRUE || LA148_1 == UNSIGNED_INTEGER) && ((toUpper(LT(1)->getText()) == "WAIT")))
                        {
                            alt148=3;
                        }
                        else
                        {
                            if (this->get_backtracking()>0)
                            {
                                this->set_failedflag( true );
                                return retval;
                            }


                            ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                            ex->set_decisionNum( 148 );
                            ex->set_state( 1 );


                            goto rulefor_update_optionsEx;

                        }
                    }
                }
                else if ( (LA148_0 == PLSQL_RESERVED_NOWAIT))
                {
                    alt148=2;
                }
                else
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return retval;
                    }


                    ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 148 );
                    ex->set_state( 0 );


                    goto rulefor_update_optionsEx;

                }
            }
            switch (alt148)
            {
        	case 1:
        	    // OracleDML.g:589:10: skip_key locked_key !
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_skip_key_in_for_update_options5752);
        	        skip_key420=skip_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulefor_update_optionsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, skip_key420.tree);


        	        this->followPush(FOLLOW_locked_key_in_for_update_options5754);
        	        locked_key421=locked_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulefor_update_optionsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }


        	    }
        	    break;
        	case 2:
        	    // OracleDML.g:590:10: nowait_key
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_nowait_key_in_for_update_options5766);
        	        nowait_key422=nowait_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulefor_update_optionsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, nowait_key422.tree);


        	    }
        	    break;
        	case 3:
        	    // OracleDML.g:591:10: wait_key expression
        	    {
        	        this->followPush(FOLLOW_wait_key_in_for_update_options5777);
        	        wait_key423=wait_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulefor_update_optionsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) 
        	        {
        	            wait_key423_last = wait_key423.tree.get();
        	            stream_wait_key.add(wait_key423.tree);
        	        }

        	        this->followPush(FOLLOW_expression_in_for_update_options5779);
        	        expression424=expression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulefor_update_optionsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) 
        	        {
        	            expression424_last = expression424.tree.get();
        	            stream_expression.add(expression424.tree);
        	        }

        	        // AST REWRITE
        	        // elements: wait_key, expression
        	        // token labels: 
        	        // rule labels: retval
        	        // token list labels: 
        	        // rule list labels: 
        	        // wildcard labels: 
        	        if ( this->get_backtracking()==0 ) {
        	        retval.tree = std::move(root_0);
        	        RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
        	        // 591:30: -> ^( wait_key ^( EXPR expression ) )
        	        {
        	        	// OracleDML.g:591:33: ^( wait_key ^( EXPR expression ) )
        	        	{
        	        	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
        	        	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(stream_wait_key.nextNode(), root_1);
        	        	// OracleDML.g:591:44: ^( EXPR expression )
        	        	{
        	        	ImplTraits::TreeTypePtr root_2 = get_psrstate()->get_treeAdaptor()->nilNode();
        	        	root_2 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(EXPR, "EXPR"), root_2);
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_2, stream_expression.nextTree());
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_1, root_2);
        	        	}
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
        	        	}
        	        }


        	        //retval.tree = std::move(root_0);
        	        }

        	    }
        	    break;

            }
        }
    }//...
    // This is where rules clean up and exit
    //
    goto rulefor_update_optionsEx; /* Prevent compiler warnings */
    rulefor_update_optionsEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end for_update_options */

/**
 * $ANTLR start update_statement
 * OracleDML.g:596:1: update_statement : update_key ^ general_table_ref update_set_clause ( where_clause )? ( static_returning_clause )? ( error_logging_clause )? ;
 */
OracleDML::update_statement_return
OracleDML::update_statement()
{
    OracleDML::update_statement_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML_OracleDMLKeys::update_key_return update_key425;
    ImplTraits::TreeTypePtr::pointer update_key425_last = NULL;
    OracleDML::general_table_ref_return general_table_ref426;
    ImplTraits::TreeTypePtr::pointer general_table_ref426_last = NULL;
    OracleDML::update_set_clause_return update_set_clause427;
    ImplTraits::TreeTypePtr::pointer update_set_clause427_last = NULL;
    OracleDML_OracleDMLCommons::where_clause_return where_clause428;
    ImplTraits::TreeTypePtr::pointer where_clause428_last = NULL;
    OracleDML::static_returning_clause_return static_returning_clause429;
    ImplTraits::TreeTypePtr::pointer static_returning_clause429_last = NULL;
    OracleDML::error_logging_clause_return error_logging_clause430;
    ImplTraits::TreeTypePtr::pointer error_logging_clause430_last = NULL;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:597:5: ( update_key ^ general_table_ref update_set_clause ( where_clause )? ( static_returning_clause )? ( error_logging_clause )? )
        // OracleDML.g:597:10: update_key ^ general_table_ref update_set_clause ( where_clause )? ( static_returning_clause )? ( error_logging_clause )?
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            this->followPush(FOLLOW_update_key_in_update_statement5813);
            update_key425=update_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleupdate_statementEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(update_key425.tree, root_0);

            this->followPush(FOLLOW_general_table_ref_in_update_statement5816);
            general_table_ref426=general_table_ref();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleupdate_statementEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, general_table_ref426.tree);


            this->followPush(FOLLOW_update_set_clause_in_update_statement5826);
            update_set_clause427=update_set_clause();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleupdate_statementEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, update_set_clause427.tree);


            // OracleDML.g:599:9: ( where_clause )?
            {
                ANTLR_UINT32 alt149=2;
                switch ( this->LA(1) )
                {
                    case SQL92_RESERVED_WHERE:
                    	{
                    		alt149=1;
                    	}
                        break;
                }

                switch (alt149)
                {
            	case 1:
            	    // OracleDML.g:599:9: where_clause
            	    {
            	        this->followPush(FOLLOW_where_clause_in_update_statement5836);
            	        where_clause428=where_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleupdate_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, where_clause428.tree);


            	    }
            	    break;

                }
            }

            // OracleDML.g:599:23: ( static_returning_clause )?
            {
                ANTLR_UINT32 alt150=2;
                switch ( this->LA(1) )
                {
                    case REGULAR_ID:
                    	{
                    		{
                    		    ANTLR_UINT32 LA150_1 = this->LA(2);
                    		    if ( ((((toUpper(LT(1)->getText()) == "RETURN"))||((toUpper(LT(1)->getText()) == "RETURNING")))))
                    		    {
                    		        alt150=1;
                    		    }
                    		}
                    	}
                        break;
                }

                switch (alt150)
                {
            	case 1:
            	    // OracleDML.g:599:23: static_returning_clause
            	    {
            	        this->followPush(FOLLOW_static_returning_clause_in_update_statement5839);
            	        static_returning_clause429=static_returning_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleupdate_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, static_returning_clause429.tree);


            	    }
            	    break;

                }
            }

            // OracleDML.g:599:48: ( error_logging_clause )?
            {
                ANTLR_UINT32 alt151=2;
                {
                    ANTLR_UINT32 LA151_0 = this->LA(1);
                    if ( (LA151_0 == REGULAR_ID) && ((toUpper(LT(1)->getText()) == "LOG")))
                    {
                        alt151=1;
                    }
                }
                switch (alt151)
                {
            	case 1:
            	    // OracleDML.g:599:48: error_logging_clause
            	    {
            	        this->followPush(FOLLOW_error_logging_clause_in_update_statement5842);
            	        error_logging_clause430=error_logging_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleupdate_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, error_logging_clause430.tree);


            	    }
            	    break;

                }
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleupdate_statementEx; /* Prevent compiler warnings */
    ruleupdate_statementEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end update_statement */

/**
 * $ANTLR start update_set_clause
 * OracleDML.g:603:1: update_set_clause : set_key ( column_based_update_set_clause ( COMMA column_based_update_set_clause )* | value_key LEFT_PAREN id[T_UNKNOWN,T_USE] RIGHT_PAREN EQUALS_OP expression ) -> {mode == 1}? ^( set_key ( column_based_update_set_clause )+ ) -> ^( set_key ^( value_key id ^( EXPR expression ) ) ) ;
 */
OracleDML::update_set_clause_return
OracleDML::update_set_clause()
{
    OracleDML::update_set_clause_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* COMMA433 = NULL;
    ImplTraits::CommonTokenType const* LEFT_PAREN436 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN438 = NULL;
    ImplTraits::CommonTokenType const* EQUALS_OP439 = NULL;
    OracleDML_OracleDMLKeys::set_key_return set_key431;
    ImplTraits::TreeTypePtr::pointer set_key431_last = NULL;
    OracleDML::column_based_update_set_clause_return column_based_update_set_clause432;
    ImplTraits::TreeTypePtr::pointer column_based_update_set_clause432_last = NULL;
    OracleDML::column_based_update_set_clause_return column_based_update_set_clause434;
    ImplTraits::TreeTypePtr::pointer column_based_update_set_clause434_last = NULL;
    OracleDML_OracleDMLKeys::value_key_return value_key435;
    ImplTraits::TreeTypePtr::pointer value_key435_last = NULL;
    OracleDML_OracleDMLCommons::id_return id437;
    ImplTraits::TreeTypePtr::pointer id437_last = NULL;
    OracleDML::expression_return expression440;
    ImplTraits::TreeTypePtr::pointer expression440_last = NULL;
    ImplTraits::TreeTypePtr COMMA433_tree;
    ImplTraits::TreeTypePtr LEFT_PAREN436_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN438_tree;
    ImplTraits::TreeTypePtr EQUALS_OP439_tree;
    RewriteRuleTokenStream<ImplTraits> stream_LEFT_PAREN(get_psrstate()->get_treeAdaptor(), "token LEFT_PAREN");
    RewriteRuleTokenStream<ImplTraits> stream_RIGHT_PAREN(get_psrstate()->get_treeAdaptor(), "token RIGHT_PAREN");
    RewriteRuleTokenStream<ImplTraits> stream_COMMA(get_psrstate()->get_treeAdaptor(), "token COMMA");
    RewriteRuleTokenStream<ImplTraits> stream_EQUALS_OP(get_psrstate()->get_treeAdaptor(), "token EQUALS_OP");
    RewriteRuleSubtreeStream<ImplTraits> stream_id(get_psrstate()->get_treeAdaptor(), "rule id");
    RewriteRuleSubtreeStream<ImplTraits> stream_expression(get_psrstate()->get_treeAdaptor(), "rule expression");
    RewriteRuleSubtreeStream<ImplTraits> stream_value_key(get_psrstate()->get_treeAdaptor(), "rule value_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_column_based_update_set_clause(get_psrstate()->get_treeAdaptor(), "rule column_based_update_set_clause");
    RewriteRuleSubtreeStream<ImplTraits> stream_set_key(get_psrstate()->get_treeAdaptor(), "rule set_key");

    /* Initialize rule variables
     */

        int mode = 1;    
    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:605:5: ( set_key ( column_based_update_set_clause ( COMMA column_based_update_set_clause )* | value_key LEFT_PAREN id[T_UNKNOWN,T_USE] RIGHT_PAREN EQUALS_OP expression ) -> {mode == 1}? ^( set_key ( column_based_update_set_clause )+ ) -> ^( set_key ^( value_key id ^( EXPR expression ) ) ) )
        // OracleDML.g:605:10: set_key ( column_based_update_set_clause ( COMMA column_based_update_set_clause )* | value_key LEFT_PAREN id[T_UNKNOWN,T_USE] RIGHT_PAREN EQUALS_OP expression )
        {
            this->followPush(FOLLOW_set_key_in_update_set_clause5872);
            set_key431=set_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleupdate_set_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                set_key431_last = set_key431.tree.get();
                stream_set_key.add(set_key431.tree);
            }

            // OracleDML.g:606:5: ( column_based_update_set_clause ( COMMA column_based_update_set_clause )* | value_key LEFT_PAREN id[T_UNKNOWN,T_USE] RIGHT_PAREN EQUALS_OP expression )
            {
                ANTLR_UINT32 alt153=2;
                switch ( this->LA(1) )
                {
                case DELIMITED_ID:
                case INTRODUCER:
                case LEFT_PAREN:
                	{
                		alt153=1;
                	}
                    break;
                case REGULAR_ID:
                	{
                		switch ( this->LA(2) )
                		{
                		case EQUALS_OP:
                		case PERIOD:
                			{
                				alt153=1;
                			}
                		    break;
                		case LEFT_PAREN:
                			{
                				alt153=2;
                			}
                		    break;

                		default:
                		    if (this->get_backtracking()>0)
                		    {
                		        this->set_failedflag( true );
                		        return retval;
                		    }

                		    ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		    ex->set_decisionNum( 153 );
                		    ex->set_state( 2 );


                		    goto ruleupdate_set_clauseEx;

                		}

                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return retval;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 153 );
                    ex->set_state( 0 );


                    goto ruleupdate_set_clauseEx;

                }

                switch (alt153)
                {
            	case 1:
            	    // OracleDML.g:606:10: column_based_update_set_clause ( COMMA column_based_update_set_clause )*
            	    {
            	        this->followPush(FOLLOW_column_based_update_set_clause_in_update_set_clause5883);
            	        column_based_update_set_clause432=column_based_update_set_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleupdate_set_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            column_based_update_set_clause432_last = column_based_update_set_clause432.tree.get();
            	            stream_column_based_update_set_clause.add(column_based_update_set_clause432.tree);
            	        }

            	        // OracleDML.g:606:41: ( COMMA column_based_update_set_clause )*

            	        for (;;)
            	        {
            	            ANTLR_UINT32 alt152=2;
            	            switch ( this->LA(1) )
            	            {
            	            case COMMA:
            	            	{
            	            		alt152=1;
            	            	}
            	                break;

            	            }

            	            switch (alt152)
            	            {
            	        	case 1:
            	        	    // OracleDML.g:606:42: COMMA column_based_update_set_clause
            	        	    {
            	        	        COMMA433 =  this->matchToken(COMMA, &FOLLOW_COMMA_in_update_set_clause5886);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleupdate_set_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }
            	        	         
            	        	        if ( this->get_backtracking()==0 ) stream_COMMA.add(COMMA433);


            	        	        this->followPush(FOLLOW_column_based_update_set_clause_in_update_set_clause5888);
            	        	        column_based_update_set_clause434=column_based_update_set_clause();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleupdate_set_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) 
            	        	        {
            	        	            column_based_update_set_clause434_last = column_based_update_set_clause434.tree.get();
            	        	            stream_column_based_update_set_clause.add(column_based_update_set_clause434.tree);
            	        	        }

            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop152;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop152: ; /* Jump out to here if this rule does not match */


            	    }
            	    break;
            	case 2:
            	    // OracleDML.g:607:10: value_key LEFT_PAREN id[T_UNKNOWN,T_USE] RIGHT_PAREN EQUALS_OP expression
            	    {
            	        this->followPush(FOLLOW_value_key_in_update_set_clause5901);
            	        value_key435=value_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleupdate_set_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            value_key435_last = value_key435.tree.get();
            	            stream_value_key.add(value_key435.tree);
            	        }

            	        LEFT_PAREN436 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_update_set_clause5903);
            	        if  (this->hasException())
            	        {
            	            goto ruleupdate_set_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( this->get_backtracking()==0 ) stream_LEFT_PAREN.add(LEFT_PAREN436);


            	        this->followPush(FOLLOW_id_in_update_set_clause5905);
            	        id437=id(T_UNKNOWN, T_USE);

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleupdate_set_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            id437_last = id437.tree.get();
            	            stream_id.add(id437.tree);
            	        }

            	        RIGHT_PAREN438 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_update_set_clause5908);
            	        if  (this->hasException())
            	        {
            	            goto ruleupdate_set_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( this->get_backtracking()==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN438);


            	        EQUALS_OP439 =  this->matchToken(EQUALS_OP, &FOLLOW_EQUALS_OP_in_update_set_clause5910);
            	        if  (this->hasException())
            	        {
            	            goto ruleupdate_set_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( this->get_backtracking()==0 ) stream_EQUALS_OP.add(EQUALS_OP439);


            	        this->followPush(FOLLOW_expression_in_update_set_clause5912);
            	        expression440=expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleupdate_set_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            expression440_last = expression440.tree.get();
            	            stream_expression.add(expression440.tree);
            	        }

            	        if ( this->get_backtracking()==0 )
            	        {
            	            mode = 0;
            	        }


            	    }
            	    break;

                }
            }

            // AST REWRITE
            // elements: expression, set_key, set_key, column_based_update_set_clause, id, value_key
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 609:9: -> {mode == 1}? ^( set_key ( column_based_update_set_clause )+ )
            if (mode == 1) {
            	// OracleDML.g:609:24: ^( set_key ( column_based_update_set_clause )+ )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(stream_set_key.nextNode(), root_1);
            	if ( !(stream_column_based_update_set_clause.hasNext()) ) {
            		ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, REWRITE_EARLY_EXCEPTION, StreamType>( this->get_rec(), "column_based_update_set_clause empty" );
            		goto ruleupdate_set_clauseEx;
            	}
            	while ( stream_column_based_update_set_clause.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_column_based_update_set_clause.nextTree());
            	}
            	stream_column_based_update_set_clause.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }

            else // 610:9: -> ^( set_key ^( value_key id ^( EXPR expression ) ) )
            {
            	// OracleDML.g:610:12: ^( set_key ^( value_key id ^( EXPR expression ) ) )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(stream_set_key.nextNode(), root_1);
            	// OracleDML.g:610:22: ^( value_key id ^( EXPR expression ) )
            	{
            	ImplTraits::TreeTypePtr root_2 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_2 = get_psrstate()->get_treeAdaptor()->becomeRoot(stream_value_key.nextNode(), root_2);
            	get_psrstate()->get_treeAdaptor()->addChild(root_2, stream_id.nextTree());
            	// OracleDML.g:610:37: ^( EXPR expression )
            	{
            	ImplTraits::TreeTypePtr root_3 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_3 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(EXPR, "EXPR"), root_3);
            	get_psrstate()->get_treeAdaptor()->addChild(root_3, stream_expression.nextTree());
            	get_psrstate()->get_treeAdaptor()->addChild(root_2, root_3);
            	}
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, root_2);
            	}
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleupdate_set_clauseEx; /* Prevent compiler warnings */
    ruleupdate_set_clauseEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end update_set_clause */

/**
 * $ANTLR start column_based_update_set_clause
 * OracleDML.g:613:1: column_based_update_set_clause : ( column_name EQUALS_OP expression -> ^( ASSIGN[$EQUALS_OP] column_name ^( EXPR expression ) ) | LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN EQUALS_OP subquery -> ^( ASSIGN[$EQUALS_OP] ( column_name )+ subquery ) );
 */
OracleDML::column_based_update_set_clause_return
OracleDML::column_based_update_set_clause()
{
    OracleDML::column_based_update_set_clause_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* EQUALS_OP442 = NULL;
    ImplTraits::CommonTokenType const* LEFT_PAREN444 = NULL;
    ImplTraits::CommonTokenType const* COMMA446 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN448 = NULL;
    ImplTraits::CommonTokenType const* EQUALS_OP449 = NULL;
    OracleDML_OracleDMLCommons::column_name_return column_name441;
    ImplTraits::TreeTypePtr::pointer column_name441_last = NULL;
    OracleDML::expression_return expression443;
    ImplTraits::TreeTypePtr::pointer expression443_last = NULL;
    OracleDML_OracleDMLCommons::column_name_return column_name445;
    ImplTraits::TreeTypePtr::pointer column_name445_last = NULL;
    OracleDML_OracleDMLCommons::column_name_return column_name447;
    ImplTraits::TreeTypePtr::pointer column_name447_last = NULL;
    OracleDML::subquery_return subquery450;
    ImplTraits::TreeTypePtr::pointer subquery450_last = NULL;
    ImplTraits::TreeTypePtr EQUALS_OP442_tree;
    ImplTraits::TreeTypePtr LEFT_PAREN444_tree;
    ImplTraits::TreeTypePtr COMMA446_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN448_tree;
    ImplTraits::TreeTypePtr EQUALS_OP449_tree;
    RewriteRuleTokenStream<ImplTraits> stream_LEFT_PAREN(get_psrstate()->get_treeAdaptor(), "token LEFT_PAREN");
    RewriteRuleTokenStream<ImplTraits> stream_RIGHT_PAREN(get_psrstate()->get_treeAdaptor(), "token RIGHT_PAREN");
    RewriteRuleTokenStream<ImplTraits> stream_COMMA(get_psrstate()->get_treeAdaptor(), "token COMMA");
    RewriteRuleTokenStream<ImplTraits> stream_EQUALS_OP(get_psrstate()->get_treeAdaptor(), "token EQUALS_OP");
    RewriteRuleSubtreeStream<ImplTraits> stream_expression(get_psrstate()->get_treeAdaptor(), "rule expression");
    RewriteRuleSubtreeStream<ImplTraits> stream_column_name(get_psrstate()->get_treeAdaptor(), "rule column_name");
    RewriteRuleSubtreeStream<ImplTraits> stream_subquery(get_psrstate()->get_treeAdaptor(), "rule subquery");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        {
            //  OracleDML.g:614:5: ( column_name EQUALS_OP expression -> ^( ASSIGN[$EQUALS_OP] column_name ^( EXPR expression ) ) | LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN EQUALS_OP subquery -> ^( ASSIGN[$EQUALS_OP] ( column_name )+ subquery ) )

            ANTLR_UINT32 alt155;

            alt155=2;

            switch ( this->LA(1) )
            {
            case DELIMITED_ID:
            case INTRODUCER:
            case REGULAR_ID:
            	{
            		alt155=1;
            	}
                break;
            case LEFT_PAREN:
            	{
            		alt155=2;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 155 );
                ex->set_state( 0 );


                goto rulecolumn_based_update_set_clauseEx;

            }

            switch (alt155)
            {
        	case 1:
        	    // OracleDML.g:614:10: column_name EQUALS_OP expression
        	    {
        	        this->followPush(FOLLOW_column_name_in_column_based_update_set_clause5984);
        	        column_name441=column_name();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulecolumn_based_update_set_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) 
        	        {
        	            column_name441_last = column_name441.tree.get();
        	            stream_column_name.add(column_name441.tree);
        	        }

        	        EQUALS_OP442 =  this->matchToken(EQUALS_OP, &FOLLOW_EQUALS_OP_in_column_based_update_set_clause5986);
        	        if  (this->hasException())
        	        {
        	            goto rulecolumn_based_update_set_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }
        	         
        	        if ( this->get_backtracking()==0 ) stream_EQUALS_OP.add(EQUALS_OP442);


        	        this->followPush(FOLLOW_expression_in_column_based_update_set_clause5988);
        	        expression443=expression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulecolumn_based_update_set_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) 
        	        {
        	            expression443_last = expression443.tree.get();
        	            stream_expression.add(expression443.tree);
        	        }

        	        // AST REWRITE
        	        // elements: column_name, expression
        	        // token labels: 
        	        // rule labels: retval
        	        // token list labels: 
        	        // rule list labels: 
        	        // wildcard labels: 
        	        if ( this->get_backtracking()==0 ) {
        	        retval.tree = std::move(root_0);
        	        RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
        	        // 614:43: -> ^( ASSIGN[$EQUALS_OP] column_name ^( EXPR expression ) )
        	        {
        	        	// OracleDML.g:614:46: ^( ASSIGN[$EQUALS_OP] column_name ^( EXPR expression ) )
        	        	{
        	        	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
        	        	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(ASSIGN, EQUALS_OP442), root_1);
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_column_name.nextTree());
        	        	// OracleDML.g:614:79: ^( EXPR expression )
        	        	{
        	        	ImplTraits::TreeTypePtr root_2 = get_psrstate()->get_treeAdaptor()->nilNode();
        	        	root_2 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(EXPR, "EXPR"), root_2);
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_2, stream_expression.nextTree());
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_1, root_2);
        	        	}
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
        	        	}
        	        }


        	        //retval.tree = std::move(root_0);
        	        }

        	    }
        	    break;
        	case 2:
        	    // OracleDML.g:615:10: LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN EQUALS_OP subquery
        	    {
        	        LEFT_PAREN444 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_column_based_update_set_clause6014);
        	        if  (this->hasException())
        	        {
        	            goto rulecolumn_based_update_set_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }
        	         
        	        if ( this->get_backtracking()==0 ) stream_LEFT_PAREN.add(LEFT_PAREN444);


        	        this->followPush(FOLLOW_column_name_in_column_based_update_set_clause6016);
        	        column_name445=column_name();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulecolumn_based_update_set_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) 
        	        {
        	            column_name445_last = column_name445.tree.get();
        	            stream_column_name.add(column_name445.tree);
        	        }

        	        // OracleDML.g:615:33: ( COMMA column_name )*

        	        for (;;)
        	        {
        	            ANTLR_UINT32 alt154=2;
        	            switch ( this->LA(1) )
        	            {
        	            case COMMA:
        	            	{
        	            		alt154=1;
        	            	}
        	                break;

        	            }

        	            switch (alt154)
        	            {
        	        	case 1:
        	        	    // OracleDML.g:615:34: COMMA column_name
        	        	    {
        	        	        COMMA446 =  this->matchToken(COMMA, &FOLLOW_COMMA_in_column_based_update_set_clause6019);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulecolumn_based_update_set_clauseEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }
        	        	         
        	        	        if ( this->get_backtracking()==0 ) stream_COMMA.add(COMMA446);


        	        	        this->followPush(FOLLOW_column_name_in_column_based_update_set_clause6021);
        	        	        column_name447=column_name();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulecolumn_based_update_set_clauseEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) 
        	        	        {
        	        	            column_name447_last = column_name447.tree.get();
        	        	            stream_column_name.add(column_name447.tree);
        	        	        }

        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop154;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop154: ; /* Jump out to here if this rule does not match */


        	        RIGHT_PAREN448 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_column_based_update_set_clause6025);
        	        if  (this->hasException())
        	        {
        	            goto rulecolumn_based_update_set_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }
        	         
        	        if ( this->get_backtracking()==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN448);


        	        EQUALS_OP449 =  this->matchToken(EQUALS_OP, &FOLLOW_EQUALS_OP_in_column_based_update_set_clause6027);
        	        if  (this->hasException())
        	        {
        	            goto rulecolumn_based_update_set_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }
        	         
        	        if ( this->get_backtracking()==0 ) stream_EQUALS_OP.add(EQUALS_OP449);


        	        this->followPush(FOLLOW_subquery_in_column_based_update_set_clause6029);
        	        subquery450=subquery();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulecolumn_based_update_set_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) 
        	        {
        	            subquery450_last = subquery450.tree.get();
        	            stream_subquery.add(subquery450.tree);
        	        }

        	        // AST REWRITE
        	        // elements: column_name, subquery
        	        // token labels: 
        	        // rule labels: retval
        	        // token list labels: 
        	        // rule list labels: 
        	        // wildcard labels: 
        	        if ( this->get_backtracking()==0 ) {
        	        retval.tree = std::move(root_0);
        	        RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
        	        // 615:85: -> ^( ASSIGN[$EQUALS_OP] ( column_name )+ subquery )
        	        {
        	        	// OracleDML.g:615:88: ^( ASSIGN[$EQUALS_OP] ( column_name )+ subquery )
        	        	{
        	        	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
        	        	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(ASSIGN, EQUALS_OP449), root_1);
        	        	if ( !(stream_column_name.hasNext()) ) {
        	        		ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, REWRITE_EARLY_EXCEPTION, StreamType>( this->get_rec(), "column_name empty" );
        	        		goto rulecolumn_based_update_set_clauseEx;
        	        	}
        	        	while ( stream_column_name.hasNext() ) {
        	        		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_column_name.nextTree());
        	        	}
        	        	stream_column_name.reset();

        	        	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_subquery.nextTree());
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
        	        	}
        	        }


        	        //retval.tree = std::move(root_0);
        	        }

        	    }
        	    break;

            }
        }
    }//...
    // This is where rules clean up and exit
    //
    goto rulecolumn_based_update_set_clauseEx; /* Prevent compiler warnings */
    rulecolumn_based_update_set_clauseEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end column_based_update_set_clause */

/**
 * $ANTLR start delete_statement
 * OracleDML.g:620:1: delete_statement : delete_key ^ ( from_key !)? general_table_ref ( where_clause )? ( static_returning_clause )? ( error_logging_clause )? ;
 */
OracleDML::delete_statement_return
OracleDML::delete_statement()
{
    OracleDML::delete_statement_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML_OracleDMLKeys::delete_key_return delete_key451;
    ImplTraits::TreeTypePtr::pointer delete_key451_last = NULL;
    OracleDML_OracleDMLKeys::from_key_return from_key452;
    ImplTraits::TreeTypePtr::pointer from_key452_last = NULL;
    OracleDML::general_table_ref_return general_table_ref453;
    ImplTraits::TreeTypePtr::pointer general_table_ref453_last = NULL;
    OracleDML_OracleDMLCommons::where_clause_return where_clause454;
    ImplTraits::TreeTypePtr::pointer where_clause454_last = NULL;
    OracleDML::static_returning_clause_return static_returning_clause455;
    ImplTraits::TreeTypePtr::pointer static_returning_clause455_last = NULL;
    OracleDML::error_logging_clause_return error_logging_clause456;
    ImplTraits::TreeTypePtr::pointer error_logging_clause456_last = NULL;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:621:5: ( delete_key ^ ( from_key !)? general_table_ref ( where_clause )? ( static_returning_clause )? ( error_logging_clause )? )
        // OracleDML.g:621:10: delete_key ^ ( from_key !)? general_table_ref ( where_clause )? ( static_returning_clause )? ( error_logging_clause )?
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            this->followPush(FOLLOW_delete_key_in_delete_statement6063);
            delete_key451=delete_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruledelete_statementEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(delete_key451.tree, root_0);

            // OracleDML.g:621:30: ( from_key !)?
            {
                ANTLR_UINT32 alt156=2;
                switch ( this->LA(1) )
                {
                    case SQL92_RESERVED_FROM:
                    	{
                    		alt156=1;
                    	}
                        break;
                }

                switch (alt156)
                {
            	case 1:
            	    // OracleDML.g:621:30: from_key !
            	    {
            	        this->followPush(FOLLOW_from_key_in_delete_statement6066);
            	        from_key452=from_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruledelete_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_general_table_ref_in_delete_statement6078);
            general_table_ref453=general_table_ref();

            this->followPop();
            if  (this->hasException())
            {
                goto ruledelete_statementEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, general_table_ref453.tree);


            // OracleDML.g:623:9: ( where_clause )?
            {
                ANTLR_UINT32 alt157=2;
                switch ( this->LA(1) )
                {
                    case SQL92_RESERVED_WHERE:
                    	{
                    		alt157=1;
                    	}
                        break;
                }

                switch (alt157)
                {
            	case 1:
            	    // OracleDML.g:623:9: where_clause
            	    {
            	        this->followPush(FOLLOW_where_clause_in_delete_statement6088);
            	        where_clause454=where_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruledelete_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, where_clause454.tree);


            	    }
            	    break;

                }
            }

            // OracleDML.g:623:23: ( static_returning_clause )?
            {
                ANTLR_UINT32 alt158=2;
                switch ( this->LA(1) )
                {
                    case REGULAR_ID:
                    	{
                    		{
                    		    ANTLR_UINT32 LA158_1 = this->LA(2);
                    		    if ( ((((toUpper(LT(1)->getText()) == "RETURN"))||((toUpper(LT(1)->getText()) == "RETURNING")))))
                    		    {
                    		        alt158=1;
                    		    }
                    		}
                    	}
                        break;
                }

                switch (alt158)
                {
            	case 1:
            	    // OracleDML.g:623:23: static_returning_clause
            	    {
            	        this->followPush(FOLLOW_static_returning_clause_in_delete_statement6091);
            	        static_returning_clause455=static_returning_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruledelete_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, static_returning_clause455.tree);


            	    }
            	    break;

                }
            }

            // OracleDML.g:623:48: ( error_logging_clause )?
            {
                ANTLR_UINT32 alt159=2;
                {
                    ANTLR_UINT32 LA159_0 = this->LA(1);
                    if ( (LA159_0 == REGULAR_ID) && ((toUpper(LT(1)->getText()) == "LOG")))
                    {
                        alt159=1;
                    }
                }
                switch (alt159)
                {
            	case 1:
            	    // OracleDML.g:623:48: error_logging_clause
            	    {
            	        this->followPush(FOLLOW_error_logging_clause_in_delete_statement6094);
            	        error_logging_clause456=error_logging_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruledelete_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, error_logging_clause456.tree);


            	    }
            	    break;

                }
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruledelete_statementEx; /* Prevent compiler warnings */
    ruledelete_statementEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end delete_statement */

/**
 * $ANTLR start insert_statement
 * OracleDML.g:626:1: insert_statement : insert_key ^ ( single_table_insert | multi_table_insert ) ;
 */
OracleDML::insert_statement_return
OracleDML::insert_statement()
{
    OracleDML::insert_statement_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML_OracleDMLKeys::insert_key_return insert_key457;
    ImplTraits::TreeTypePtr::pointer insert_key457_last = NULL;
    OracleDML::single_table_insert_return single_table_insert458;
    ImplTraits::TreeTypePtr::pointer single_table_insert458_last = NULL;
    OracleDML::multi_table_insert_return multi_table_insert459;
    ImplTraits::TreeTypePtr::pointer multi_table_insert459_last = NULL;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:627:5: ( insert_key ^ ( single_table_insert | multi_table_insert ) )
        // OracleDML.g:627:10: insert_key ^ ( single_table_insert | multi_table_insert )
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            this->followPush(FOLLOW_insert_key_in_insert_statement6115);
            insert_key457=insert_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleinsert_statementEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(insert_key457.tree, root_0);

            // OracleDML.g:628:5: ( single_table_insert | multi_table_insert )
            {
                ANTLR_UINT32 alt160=2;
                {
                    ANTLR_UINT32 LA160_0 = this->LA(1);
                    if ( (LA160_0 == SQL92_RESERVED_INTO))
                    {
                        alt160=1;
                    }
                    else if ( (LA160_0 == SQL92_RESERVED_ALL))
                    {
                        alt160=2;
                    }
                    else if ( (LA160_0 == REGULAR_ID) && ((toUpper(LT(1)->getText()) == "FIRST")))
                    {
                        alt160=2;
                    }
                    else if ( (LA160_0 == SQL92_RESERVED_WHEN))
                    {
                        alt160=2;
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return retval;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 160 );
                        ex->set_state( 0 );


                        goto ruleinsert_statementEx;

                    }
                }
                switch (alt160)
                {
            	case 1:
            	    // OracleDML.g:628:10: single_table_insert
            	    {
            	        this->followPush(FOLLOW_single_table_insert_in_insert_statement6127);
            	        single_table_insert458=single_table_insert();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleinsert_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, single_table_insert458.tree);


            	    }
            	    break;
            	case 2:
            	    // OracleDML.g:629:10: multi_table_insert
            	    {
            	        this->followPush(FOLLOW_multi_table_insert_in_insert_statement6138);
            	        multi_table_insert459=multi_table_insert();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleinsert_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, multi_table_insert459.tree);


            	    }
            	    break;

                }
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleinsert_statementEx; /* Prevent compiler warnings */
    ruleinsert_statementEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end insert_statement */

/**
 * $ANTLR start single_table_insert
 * OracleDML.g:635:1: single_table_insert : insert_into_clause ( values_clause ( static_returning_clause )? | select_statement ) ( error_logging_clause )? -> ^( SINGLE_TABLE_MODE insert_into_clause ( values_clause )? ( static_returning_clause )? ( select_statement )? ( error_logging_clause )? ) ;
 */
OracleDML::single_table_insert_return
OracleDML::single_table_insert()
{
    OracleDML::single_table_insert_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML::insert_into_clause_return insert_into_clause460;
    ImplTraits::TreeTypePtr::pointer insert_into_clause460_last = NULL;
    OracleDML::values_clause_return values_clause461;
    ImplTraits::TreeTypePtr::pointer values_clause461_last = NULL;
    OracleDML::static_returning_clause_return static_returning_clause462;
    ImplTraits::TreeTypePtr::pointer static_returning_clause462_last = NULL;
    OracleDML::select_statement_return select_statement463;
    ImplTraits::TreeTypePtr::pointer select_statement463_last = NULL;
    OracleDML::error_logging_clause_return error_logging_clause464;
    ImplTraits::TreeTypePtr::pointer error_logging_clause464_last = NULL;
    RewriteRuleSubtreeStream<ImplTraits> stream_static_returning_clause(get_psrstate()->get_treeAdaptor(), "rule static_returning_clause");
    RewriteRuleSubtreeStream<ImplTraits> stream_values_clause(get_psrstate()->get_treeAdaptor(), "rule values_clause");
    RewriteRuleSubtreeStream<ImplTraits> stream_insert_into_clause(get_psrstate()->get_treeAdaptor(), "rule insert_into_clause");
    RewriteRuleSubtreeStream<ImplTraits> stream_error_logging_clause(get_psrstate()->get_treeAdaptor(), "rule error_logging_clause");
    RewriteRuleSubtreeStream<ImplTraits> stream_select_statement(get_psrstate()->get_treeAdaptor(), "rule select_statement");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:636:5: ( insert_into_clause ( values_clause ( static_returning_clause )? | select_statement ) ( error_logging_clause )? -> ^( SINGLE_TABLE_MODE insert_into_clause ( values_clause )? ( static_returning_clause )? ( select_statement )? ( error_logging_clause )? ) )
        // OracleDML.g:636:10: insert_into_clause ( values_clause ( static_returning_clause )? | select_statement ) ( error_logging_clause )?
        {
            this->followPush(FOLLOW_insert_into_clause_in_single_table_insert6166);
            insert_into_clause460=insert_into_clause();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesingle_table_insertEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                insert_into_clause460_last = insert_into_clause460.tree.get();
                stream_insert_into_clause.add(insert_into_clause460.tree);
            }

            // OracleDML.g:637:5: ( values_clause ( static_returning_clause )? | select_statement )
            {
                ANTLR_UINT32 alt162=2;
                switch ( this->LA(1) )
                {
                case SQL92_RESERVED_VALUES:
                	{
                		alt162=1;
                	}
                    break;
                case LEFT_PAREN:
                case SQL92_RESERVED_SELECT:
                case SQL92_RESERVED_WITH:
                	{
                		alt162=2;
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return retval;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 162 );
                    ex->set_state( 0 );


                    goto rulesingle_table_insertEx;

                }

                switch (alt162)
                {
            	case 1:
            	    // OracleDML.g:637:10: values_clause ( static_returning_clause )?
            	    {
            	        this->followPush(FOLLOW_values_clause_in_single_table_insert6177);
            	        values_clause461=values_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesingle_table_insertEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            values_clause461_last = values_clause461.tree.get();
            	            stream_values_clause.add(values_clause461.tree);
            	        }

            	        // OracleDML.g:637:24: ( static_returning_clause )?
            	        {
            	            ANTLR_UINT32 alt161=2;
            	            switch ( this->LA(1) )
            	            {
            	                case REGULAR_ID:
            	                	{
            	                		{
            	                		    ANTLR_UINT32 LA161_1 = this->LA(2);
            	                		    if ( ((((toUpper(LT(1)->getText()) == "RETURN"))||((toUpper(LT(1)->getText()) == "RETURNING")))))
            	                		    {
            	                		        alt161=1;
            	                		    }
            	                		}
            	                	}
            	                    break;
            	            }

            	            switch (alt161)
            	            {
            	        	case 1:
            	        	    // OracleDML.g:637:24: static_returning_clause
            	        	    {
            	        	        this->followPush(FOLLOW_static_returning_clause_in_single_table_insert6179);
            	        	        static_returning_clause462=static_returning_clause();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulesingle_table_insertEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) 
            	        	        {
            	        	            static_returning_clause462_last = static_returning_clause462.tree.get();
            	        	            stream_static_returning_clause.add(static_returning_clause462.tree);
            	        	        }

            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;
            	case 2:
            	    // OracleDML.g:638:10: select_statement
            	    {
            	        this->followPush(FOLLOW_select_statement_in_single_table_insert6191);
            	        select_statement463=select_statement();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesingle_table_insertEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            select_statement463_last = select_statement463.tree.get();
            	            stream_select_statement.add(select_statement463.tree);
            	        }

            	    }
            	    break;

                }
            }

            // OracleDML.g:640:9: ( error_logging_clause )?
            {
                ANTLR_UINT32 alt163=2;
                {
                    ANTLR_UINT32 LA163_0 = this->LA(1);
                    if ( (LA163_0 == REGULAR_ID) && ((toUpper(LT(1)->getText()) == "LOG")))
                    {
                        alt163=1;
                    }
                }
                switch (alt163)
                {
            	case 1:
            	    // OracleDML.g:640:9: error_logging_clause
            	    {
            	        this->followPush(FOLLOW_error_logging_clause_in_single_table_insert6207);
            	        error_logging_clause464=error_logging_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesingle_table_insertEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            error_logging_clause464_last = error_logging_clause464.tree.get();
            	            stream_error_logging_clause.add(error_logging_clause464.tree);
            	        }

            	    }
            	    break;

                }
            }

            // AST REWRITE
            // elements: static_returning_clause, values_clause, insert_into_clause, error_logging_clause, select_statement
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 641:9: -> ^( SINGLE_TABLE_MODE insert_into_clause ( values_clause )? ( static_returning_clause )? ( select_statement )? ( error_logging_clause )? )
            {
            	// OracleDML.g:641:12: ^( SINGLE_TABLE_MODE insert_into_clause ( values_clause )? ( static_returning_clause )? ( select_statement )? ( error_logging_clause )? )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(SINGLE_TABLE_MODE, "SINGLE_TABLE_MODE"), root_1);
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_insert_into_clause.nextTree());
            	// OracleDML.g:641:51: ( values_clause )?
            	if ( stream_values_clause.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_values_clause.nextTree());
            	}
            	stream_values_clause.reset();

            	// OracleDML.g:641:66: ( static_returning_clause )?
            	if ( stream_static_returning_clause.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_static_returning_clause.nextTree());
            	}
            	stream_static_returning_clause.reset();

            	// OracleDML.g:641:91: ( select_statement )?
            	if ( stream_select_statement.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_select_statement.nextTree());
            	}
            	stream_select_statement.reset();

            	// OracleDML.g:641:109: ( error_logging_clause )?
            	if ( stream_error_logging_clause.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_error_logging_clause.nextTree());
            	}
            	stream_error_logging_clause.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulesingle_table_insertEx; /* Prevent compiler warnings */
    rulesingle_table_insertEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end single_table_insert */

/**
 * $ANTLR start multi_table_insert
 * OracleDML.g:644:1: multi_table_insert : ( all_key ( multi_table_element )+ | conditional_insert_clause ) select_statement -> ^( MULTI_TABLE_MODE ( multi_table_element )* ( conditional_insert_clause )? select_statement ) ;
 */
OracleDML::multi_table_insert_return
OracleDML::multi_table_insert()
{
    OracleDML::multi_table_insert_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML_OracleDMLKeys::all_key_return all_key465;
    ImplTraits::TreeTypePtr::pointer all_key465_last = NULL;
    OracleDML::multi_table_element_return multi_table_element466;
    ImplTraits::TreeTypePtr::pointer multi_table_element466_last = NULL;
    OracleDML::conditional_insert_clause_return conditional_insert_clause467;
    ImplTraits::TreeTypePtr::pointer conditional_insert_clause467_last = NULL;
    OracleDML::select_statement_return select_statement468;
    ImplTraits::TreeTypePtr::pointer select_statement468_last = NULL;
    RewriteRuleSubtreeStream<ImplTraits> stream_all_key(get_psrstate()->get_treeAdaptor(), "rule all_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_multi_table_element(get_psrstate()->get_treeAdaptor(), "rule multi_table_element");
    RewriteRuleSubtreeStream<ImplTraits> stream_conditional_insert_clause(get_psrstate()->get_treeAdaptor(), "rule conditional_insert_clause");
    RewriteRuleSubtreeStream<ImplTraits> stream_select_statement(get_psrstate()->get_treeAdaptor(), "rule select_statement");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:645:5: ( ( all_key ( multi_table_element )+ | conditional_insert_clause ) select_statement -> ^( MULTI_TABLE_MODE ( multi_table_element )* ( conditional_insert_clause )? select_statement ) )
        // OracleDML.g:646:5: ( all_key ( multi_table_element )+ | conditional_insert_clause ) select_statement
        {
            // OracleDML.g:646:5: ( all_key ( multi_table_element )+ | conditional_insert_clause )
            {
                ANTLR_UINT32 alt165=2;
                {
                    ANTLR_UINT32 LA165_0 = this->LA(1);
                    if ( (LA165_0 == SQL92_RESERVED_ALL))
                    {
                        switch ( this->LA(2) )
                        {
                        case SQL92_RESERVED_INTO:
                        	{
                        		alt165=1;
                        	}
                            break;
                        case SQL92_RESERVED_WHEN:
                        	{
                        		alt165=2;
                        	}
                            break;

                        default:
                            if (this->get_backtracking()>0)
                            {
                                this->set_failedflag( true );
                                return retval;
                            }

                            ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                            ex->set_decisionNum( 165 );
                            ex->set_state( 1 );


                            goto rulemulti_table_insertEx;

                        }

                    }
                    else if ( (LA165_0 == REGULAR_ID) && ((toUpper(LT(1)->getText()) == "FIRST")))
                    {
                        alt165=2;
                    }
                    else if ( (LA165_0 == SQL92_RESERVED_WHEN))
                    {
                        alt165=2;
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return retval;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 165 );
                        ex->set_state( 0 );


                        goto rulemulti_table_insertEx;

                    }
                }
                switch (alt165)
                {
            	case 1:
            	    // OracleDML.g:646:10: all_key ( multi_table_element )+
            	    {
            	        this->followPush(FOLLOW_all_key_in_multi_table_insert6266);
            	        all_key465=all_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemulti_table_insertEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            all_key465_last = all_key465.tree.get();
            	            stream_all_key.add(all_key465.tree);
            	        }

            	        // OracleDML.g:646:18: ( multi_table_element )+
            	        {
            	            int cnt164=0;

            	            for (;;)
            	            {
            	                ANTLR_UINT32 alt164=2;
            	        	switch ( this->LA(1) )
            	        	{
            	        	case SQL92_RESERVED_INTO:
            	        		{
            	        			alt164=1;
            	        		}
            	        	    break;

            	        	}

            	        	switch (alt164)
            	        	{
            	        	    case 1:
            	        	        // OracleDML.g:646:18: multi_table_element
            	        	        {
            	        	            this->followPush(FOLLOW_multi_table_element_in_multi_table_insert6268);
            	        	            multi_table_element466=multi_table_element();

            	        	            this->followPop();
            	        	            if  (this->hasException())
            	        	            {
            	        	                goto rulemulti_table_insertEx;
            	        	            }
            	        	            if (this->hasFailed())
            	        	            {
            	        	                return retval;
            	        	            }

            	        	            if ( this->get_backtracking()==0 ) 
            	        	            {
            	        	                multi_table_element466_last = multi_table_element466.tree.get();
            	        	                stream_multi_table_element.add(multi_table_element466.tree);
            	        	            }

            	        	        }
            	        	        break;

            	        	    default:

            	        		if ( cnt164 >= 1 )
            	        		{
            	        		    goto loop164;
            	        		}
            	        		if (this->get_backtracking()>0)
            	        		{
            	        		    this->set_failedflag( true );
            	        		    return retval;
            	        		}

            	        		/* mismatchedSetEx()
            	        		 */
            	        		new ANTLR_Exception< OracleDMLImplTraits, EARLY_EXIT_EXCEPTION, StreamType>( this->get_rec(), "" );


            	        		goto rulemulti_table_insertEx;
            	        	}
            	        	cnt164++;
            	            }
            	            loop164: ;	/* Jump to here if this rule does not match */
            	        }

            	    }
            	    break;
            	case 2:
            	    // OracleDML.g:647:10: conditional_insert_clause
            	    {
            	        this->followPush(FOLLOW_conditional_insert_clause_in_multi_table_insert6280);
            	        conditional_insert_clause467=conditional_insert_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemulti_table_insertEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            conditional_insert_clause467_last = conditional_insert_clause467.tree.get();
            	            stream_conditional_insert_clause.add(conditional_insert_clause467.tree);
            	        }

            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_select_statement_in_multi_table_insert6296);
            select_statement468=select_statement();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemulti_table_insertEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                select_statement468_last = select_statement468.tree.get();
                stream_select_statement.add(select_statement468.tree);
            }

            // AST REWRITE
            // elements: multi_table_element, conditional_insert_clause, select_statement
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 650:9: -> ^( MULTI_TABLE_MODE ( multi_table_element )* ( conditional_insert_clause )? select_statement )
            {
            	// OracleDML.g:650:12: ^( MULTI_TABLE_MODE ( multi_table_element )* ( conditional_insert_clause )? select_statement )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(MULTI_TABLE_MODE, "MULTI_TABLE_MODE"), root_1);
            	// OracleDML.g:650:31: ( multi_table_element )*
            	while ( stream_multi_table_element.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_multi_table_element.nextTree());
            	}
            	stream_multi_table_element.reset();

            	// OracleDML.g:650:52: ( conditional_insert_clause )?
            	if ( stream_conditional_insert_clause.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_conditional_insert_clause.nextTree());
            	}
            	stream_conditional_insert_clause.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_select_statement.nextTree());
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulemulti_table_insertEx; /* Prevent compiler warnings */
    rulemulti_table_insertEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end multi_table_insert */

/**
 * $ANTLR start multi_table_element
 * OracleDML.g:653:1: multi_table_element : insert_into_clause ( values_clause )? ( error_logging_clause )? -> ^( TABLE_ELEMENT insert_into_clause ( values_clause )? ( error_logging_clause )? ) ;
 */
OracleDML::multi_table_element_return
OracleDML::multi_table_element()
{
    OracleDML::multi_table_element_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML::insert_into_clause_return insert_into_clause469;
    ImplTraits::TreeTypePtr::pointer insert_into_clause469_last = NULL;
    OracleDML::values_clause_return values_clause470;
    ImplTraits::TreeTypePtr::pointer values_clause470_last = NULL;
    OracleDML::error_logging_clause_return error_logging_clause471;
    ImplTraits::TreeTypePtr::pointer error_logging_clause471_last = NULL;
    RewriteRuleSubtreeStream<ImplTraits> stream_values_clause(get_psrstate()->get_treeAdaptor(), "rule values_clause");
    RewriteRuleSubtreeStream<ImplTraits> stream_insert_into_clause(get_psrstate()->get_treeAdaptor(), "rule insert_into_clause");
    RewriteRuleSubtreeStream<ImplTraits> stream_error_logging_clause(get_psrstate()->get_treeAdaptor(), "rule error_logging_clause");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:654:5: ( insert_into_clause ( values_clause )? ( error_logging_clause )? -> ^( TABLE_ELEMENT insert_into_clause ( values_clause )? ( error_logging_clause )? ) )
        // OracleDML.g:654:10: insert_into_clause ( values_clause )? ( error_logging_clause )?
        {
            this->followPush(FOLLOW_insert_into_clause_in_multi_table_element6338);
            insert_into_clause469=insert_into_clause();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemulti_table_elementEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                insert_into_clause469_last = insert_into_clause469.tree.get();
                stream_insert_into_clause.add(insert_into_clause469.tree);
            }

            // OracleDML.g:654:29: ( values_clause )?
            {
                ANTLR_UINT32 alt166=2;
                switch ( this->LA(1) )
                {
                    case SQL92_RESERVED_VALUES:
                    	{
                    		alt166=1;
                    	}
                        break;
                }

                switch (alt166)
                {
            	case 1:
            	    // OracleDML.g:654:29: values_clause
            	    {
            	        this->followPush(FOLLOW_values_clause_in_multi_table_element6340);
            	        values_clause470=values_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemulti_table_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            values_clause470_last = values_clause470.tree.get();
            	            stream_values_clause.add(values_clause470.tree);
            	        }

            	    }
            	    break;

                }
            }

            // OracleDML.g:654:44: ( error_logging_clause )?
            {
                ANTLR_UINT32 alt167=2;
                {
                    ANTLR_UINT32 LA167_0 = this->LA(1);
                    if ( (LA167_0 == REGULAR_ID) && ((toUpper(LT(1)->getText()) == "LOG")))
                    {
                        alt167=1;
                    }
                }
                switch (alt167)
                {
            	case 1:
            	    // OracleDML.g:654:44: error_logging_clause
            	    {
            	        this->followPush(FOLLOW_error_logging_clause_in_multi_table_element6343);
            	        error_logging_clause471=error_logging_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemulti_table_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            error_logging_clause471_last = error_logging_clause471.tree.get();
            	            stream_error_logging_clause.add(error_logging_clause471.tree);
            	        }

            	    }
            	    break;

                }
            }

            // AST REWRITE
            // elements: values_clause, insert_into_clause, error_logging_clause
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 655:9: -> ^( TABLE_ELEMENT insert_into_clause ( values_clause )? ( error_logging_clause )? )
            {
            	// OracleDML.g:655:12: ^( TABLE_ELEMENT insert_into_clause ( values_clause )? ( error_logging_clause )? )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(TABLE_ELEMENT, "TABLE_ELEMENT"), root_1);
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_insert_into_clause.nextTree());
            	// OracleDML.g:655:47: ( values_clause )?
            	if ( stream_values_clause.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_values_clause.nextTree());
            	}
            	stream_values_clause.reset();

            	// OracleDML.g:655:62: ( error_logging_clause )?
            	if ( stream_error_logging_clause.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_error_logging_clause.nextTree());
            	}
            	stream_error_logging_clause.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulemulti_table_elementEx; /* Prevent compiler warnings */
    rulemulti_table_elementEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end multi_table_element */

/**
 * $ANTLR start conditional_insert_clause
 * OracleDML.g:658:1: conditional_insert_clause : ( all_key | first_key )? ( conditional_insert_when_part )+ ( conditional_insert_else_part )? -> ^( CONDITIONAL_INSERT ( all_key )? ( first_key )? ( conditional_insert_when_part )+ ( conditional_insert_else_part )? ) ;
 */
OracleDML::conditional_insert_clause_return
OracleDML::conditional_insert_clause()
{
    OracleDML::conditional_insert_clause_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML_OracleDMLKeys::all_key_return all_key472;
    ImplTraits::TreeTypePtr::pointer all_key472_last = NULL;
    OracleDML_OracleDMLKeys::first_key_return first_key473;
    ImplTraits::TreeTypePtr::pointer first_key473_last = NULL;
    OracleDML::conditional_insert_when_part_return conditional_insert_when_part474;
    ImplTraits::TreeTypePtr::pointer conditional_insert_when_part474_last = NULL;
    OracleDML::conditional_insert_else_part_return conditional_insert_else_part475;
    ImplTraits::TreeTypePtr::pointer conditional_insert_else_part475_last = NULL;
    RewriteRuleSubtreeStream<ImplTraits> stream_all_key(get_psrstate()->get_treeAdaptor(), "rule all_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_conditional_insert_when_part(get_psrstate()->get_treeAdaptor(), "rule conditional_insert_when_part");
    RewriteRuleSubtreeStream<ImplTraits> stream_conditional_insert_else_part(get_psrstate()->get_treeAdaptor(), "rule conditional_insert_else_part");
    RewriteRuleSubtreeStream<ImplTraits> stream_first_key(get_psrstate()->get_treeAdaptor(), "rule first_key");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:659:5: ( ( all_key | first_key )? ( conditional_insert_when_part )+ ( conditional_insert_else_part )? -> ^( CONDITIONAL_INSERT ( all_key )? ( first_key )? ( conditional_insert_when_part )+ ( conditional_insert_else_part )? ) )
        // OracleDML.g:659:10: ( all_key | first_key )? ( conditional_insert_when_part )+ ( conditional_insert_else_part )?
        {
            // OracleDML.g:659:10: ( all_key | first_key )?
            {
                ANTLR_UINT32 alt168=3;
                {
                    ANTLR_UINT32 LA168_0 = this->LA(1);
                    if ( (LA168_0 == SQL92_RESERVED_ALL))
                    {
                        alt168=1;
                    }
                    else if ( (LA168_0 == REGULAR_ID) && ((toUpper(LT(1)->getText()) == "FIRST")))
                    {
                        alt168=2;
                    }
                }
                switch (alt168)
                {
            	case 1:
            	    // OracleDML.g:659:11: all_key
            	    {
            	        this->followPush(FOLLOW_all_key_in_conditional_insert_clause6387);
            	        all_key472=all_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleconditional_insert_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            all_key472_last = all_key472.tree.get();
            	            stream_all_key.add(all_key472.tree);
            	        }

            	    }
            	    break;
            	case 2:
            	    // OracleDML.g:659:19: first_key
            	    {
            	        this->followPush(FOLLOW_first_key_in_conditional_insert_clause6389);
            	        first_key473=first_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleconditional_insert_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            first_key473_last = first_key473.tree.get();
            	            stream_first_key.add(first_key473.tree);
            	        }

            	    }
            	    break;

                }
            }

            // OracleDML.g:660:9: ( conditional_insert_when_part )+
            {
                int cnt169=0;

                for (;;)
                {
                    ANTLR_UINT32 alt169=2;
            	switch ( this->LA(1) )
            	{
            	case SQL92_RESERVED_WHEN:
            		{
            			alt169=1;
            		}
            	    break;

            	}

            	switch (alt169)
            	{
            	    case 1:
            	        // OracleDML.g:660:9: conditional_insert_when_part
            	        {
            	            this->followPush(FOLLOW_conditional_insert_when_part_in_conditional_insert_clause6401);
            	            conditional_insert_when_part474=conditional_insert_when_part();

            	            this->followPop();
            	            if  (this->hasException())
            	            {
            	                goto ruleconditional_insert_clauseEx;
            	            }
            	            if (this->hasFailed())
            	            {
            	                return retval;
            	            }

            	            if ( this->get_backtracking()==0 ) 
            	            {
            	                conditional_insert_when_part474_last = conditional_insert_when_part474.tree.get();
            	                stream_conditional_insert_when_part.add(conditional_insert_when_part474.tree);
            	            }

            	        }
            	        break;

            	    default:

            		if ( cnt169 >= 1 )
            		{
            		    goto loop169;
            		}
            		if (this->get_backtracking()>0)
            		{
            		    this->set_failedflag( true );
            		    return retval;
            		}

            		/* mismatchedSetEx()
            		 */
            		new ANTLR_Exception< OracleDMLImplTraits, EARLY_EXIT_EXCEPTION, StreamType>( this->get_rec(), "" );


            		goto ruleconditional_insert_clauseEx;
            	}
            	cnt169++;
                }
                loop169: ;	/* Jump to here if this rule does not match */
            }

            // OracleDML.g:660:39: ( conditional_insert_else_part )?
            {
                ANTLR_UINT32 alt170=2;
                switch ( this->LA(1) )
                {
                    case SQL92_RESERVED_ELSE:
                    	{
                    		alt170=1;
                    	}
                        break;
                }

                switch (alt170)
                {
            	case 1:
            	    // OracleDML.g:660:39: conditional_insert_else_part
            	    {
            	        this->followPush(FOLLOW_conditional_insert_else_part_in_conditional_insert_clause6404);
            	        conditional_insert_else_part475=conditional_insert_else_part();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleconditional_insert_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            conditional_insert_else_part475_last = conditional_insert_else_part475.tree.get();
            	            stream_conditional_insert_else_part.add(conditional_insert_else_part475.tree);
            	        }

            	    }
            	    break;

                }
            }

            // AST REWRITE
            // elements: first_key, conditional_insert_else_part, all_key, conditional_insert_when_part
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 661:9: -> ^( CONDITIONAL_INSERT ( all_key )? ( first_key )? ( conditional_insert_when_part )+ ( conditional_insert_else_part )? )
            {
            	// OracleDML.g:661:12: ^( CONDITIONAL_INSERT ( all_key )? ( first_key )? ( conditional_insert_when_part )+ ( conditional_insert_else_part )? )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(CONDITIONAL_INSERT, "CONDITIONAL_INSERT"), root_1);
            	// OracleDML.g:661:33: ( all_key )?
            	if ( stream_all_key.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_all_key.nextTree());
            	}
            	stream_all_key.reset();

            	// OracleDML.g:661:42: ( first_key )?
            	if ( stream_first_key.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_first_key.nextTree());
            	}
            	stream_first_key.reset();

            	if ( !(stream_conditional_insert_when_part.hasNext()) ) {
            		ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, REWRITE_EARLY_EXCEPTION, StreamType>( this->get_rec(), "conditional_insert_when_part empty" );
            		goto ruleconditional_insert_clauseEx;
            	}
            	while ( stream_conditional_insert_when_part.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_conditional_insert_when_part.nextTree());
            	}
            	stream_conditional_insert_when_part.reset();

            	// OracleDML.g:661:83: ( conditional_insert_else_part )?
            	if ( stream_conditional_insert_else_part.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_conditional_insert_else_part.nextTree());
            	}
            	stream_conditional_insert_else_part.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleconditional_insert_clauseEx; /* Prevent compiler warnings */
    ruleconditional_insert_clauseEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end conditional_insert_clause */

/**
 * $ANTLR start conditional_insert_when_part
 * OracleDML.g:664:1: conditional_insert_when_part : when_key condition then_key ( multi_table_element )+ -> ^( when_key ^( LOGIC_EXPR condition ) ( multi_table_element )+ ) ;
 */
OracleDML::conditional_insert_when_part_return
OracleDML::conditional_insert_when_part()
{
    OracleDML::conditional_insert_when_part_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML_OracleDMLKeys::when_key_return when_key476;
    ImplTraits::TreeTypePtr::pointer when_key476_last = NULL;
    OracleDML::condition_return condition477;
    ImplTraits::TreeTypePtr::pointer condition477_last = NULL;
    OracleDML_OracleDMLKeys::then_key_return then_key478;
    ImplTraits::TreeTypePtr::pointer then_key478_last = NULL;
    OracleDML::multi_table_element_return multi_table_element479;
    ImplTraits::TreeTypePtr::pointer multi_table_element479_last = NULL;
    RewriteRuleSubtreeStream<ImplTraits> stream_then_key(get_psrstate()->get_treeAdaptor(), "rule then_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_condition(get_psrstate()->get_treeAdaptor(), "rule condition");
    RewriteRuleSubtreeStream<ImplTraits> stream_multi_table_element(get_psrstate()->get_treeAdaptor(), "rule multi_table_element");
    RewriteRuleSubtreeStream<ImplTraits> stream_when_key(get_psrstate()->get_treeAdaptor(), "rule when_key");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:665:5: ( when_key condition then_key ( multi_table_element )+ -> ^( when_key ^( LOGIC_EXPR condition ) ( multi_table_element )+ ) )
        // OracleDML.g:665:10: when_key condition then_key ( multi_table_element )+
        {
            this->followPush(FOLLOW_when_key_in_conditional_insert_when_part6452);
            when_key476=when_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleconditional_insert_when_partEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                when_key476_last = when_key476.tree.get();
                stream_when_key.add(when_key476.tree);
            }

            this->followPush(FOLLOW_condition_in_conditional_insert_when_part6454);
            condition477=condition();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleconditional_insert_when_partEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                condition477_last = condition477.tree.get();
                stream_condition.add(condition477.tree);
            }

            this->followPush(FOLLOW_then_key_in_conditional_insert_when_part6456);
            then_key478=then_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleconditional_insert_when_partEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                then_key478_last = then_key478.tree.get();
                stream_then_key.add(then_key478.tree);
            }

            // OracleDML.g:665:38: ( multi_table_element )+
            {
                int cnt171=0;

                for (;;)
                {
                    ANTLR_UINT32 alt171=2;
            	switch ( this->LA(1) )
            	{
            	case SQL92_RESERVED_INTO:
            		{
            			alt171=1;
            		}
            	    break;

            	}

            	switch (alt171)
            	{
            	    case 1:
            	        // OracleDML.g:665:38: multi_table_element
            	        {
            	            this->followPush(FOLLOW_multi_table_element_in_conditional_insert_when_part6458);
            	            multi_table_element479=multi_table_element();

            	            this->followPop();
            	            if  (this->hasException())
            	            {
            	                goto ruleconditional_insert_when_partEx;
            	            }
            	            if (this->hasFailed())
            	            {
            	                return retval;
            	            }

            	            if ( this->get_backtracking()==0 ) 
            	            {
            	                multi_table_element479_last = multi_table_element479.tree.get();
            	                stream_multi_table_element.add(multi_table_element479.tree);
            	            }

            	        }
            	        break;

            	    default:

            		if ( cnt171 >= 1 )
            		{
            		    goto loop171;
            		}
            		if (this->get_backtracking()>0)
            		{
            		    this->set_failedflag( true );
            		    return retval;
            		}

            		/* mismatchedSetEx()
            		 */
            		new ANTLR_Exception< OracleDMLImplTraits, EARLY_EXIT_EXCEPTION, StreamType>( this->get_rec(), "" );


            		goto ruleconditional_insert_when_partEx;
            	}
            	cnt171++;
                }
                loop171: ;	/* Jump to here if this rule does not match */
            }

            // AST REWRITE
            // elements: multi_table_element, when_key, condition
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 666:9: -> ^( when_key ^( LOGIC_EXPR condition ) ( multi_table_element )+ )
            {
            	// OracleDML.g:666:12: ^( when_key ^( LOGIC_EXPR condition ) ( multi_table_element )+ )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(stream_when_key.nextNode(), root_1);
            	// OracleDML.g:666:23: ^( LOGIC_EXPR condition )
            	{
            	ImplTraits::TreeTypePtr root_2 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_2 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(LOGIC_EXPR, "LOGIC_EXPR"), root_2);
            	get_psrstate()->get_treeAdaptor()->addChild(root_2, stream_condition.nextTree());
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, root_2);
            	}
            	if ( !(stream_multi_table_element.hasNext()) ) {
            		ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, REWRITE_EARLY_EXCEPTION, StreamType>( this->get_rec(), "multi_table_element empty" );
            		goto ruleconditional_insert_when_partEx;
            	}
            	while ( stream_multi_table_element.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_multi_table_element.nextTree());
            	}
            	stream_multi_table_element.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleconditional_insert_when_partEx; /* Prevent compiler warnings */
    ruleconditional_insert_when_partEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end conditional_insert_when_part */

/**
 * $ANTLR start conditional_insert_else_part
 * OracleDML.g:669:1: conditional_insert_else_part : else_key ^ ( multi_table_element )+ ;
 */
OracleDML::conditional_insert_else_part_return
OracleDML::conditional_insert_else_part()
{
    OracleDML::conditional_insert_else_part_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML_OracleDMLKeys::else_key_return else_key480;
    ImplTraits::TreeTypePtr::pointer else_key480_last = NULL;
    OracleDML::multi_table_element_return multi_table_element481;
    ImplTraits::TreeTypePtr::pointer multi_table_element481_last = NULL;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:670:5: ( else_key ^ ( multi_table_element )+ )
        // OracleDML.g:670:10: else_key ^ ( multi_table_element )+
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            this->followPush(FOLLOW_else_key_in_conditional_insert_else_part6502);
            else_key480=else_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleconditional_insert_else_partEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(else_key480.tree, root_0);

            // OracleDML.g:670:20: ( multi_table_element )+
            {
                int cnt172=0;

                for (;;)
                {
                    ANTLR_UINT32 alt172=2;
            	switch ( this->LA(1) )
            	{
            	case SQL92_RESERVED_INTO:
            		{
            			alt172=1;
            		}
            	    break;

            	}

            	switch (alt172)
            	{
            	    case 1:
            	        // OracleDML.g:670:20: multi_table_element
            	        {
            	            this->followPush(FOLLOW_multi_table_element_in_conditional_insert_else_part6505);
            	            multi_table_element481=multi_table_element();

            	            this->followPop();
            	            if  (this->hasException())
            	            {
            	                goto ruleconditional_insert_else_partEx;
            	            }
            	            if (this->hasFailed())
            	            {
            	                return retval;
            	            }

            	            if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, multi_table_element481.tree);


            	        }
            	        break;

            	    default:

            		if ( cnt172 >= 1 )
            		{
            		    goto loop172;
            		}
            		if (this->get_backtracking()>0)
            		{
            		    this->set_failedflag( true );
            		    return retval;
            		}

            		/* mismatchedSetEx()
            		 */
            		new ANTLR_Exception< OracleDMLImplTraits, EARLY_EXIT_EXCEPTION, StreamType>( this->get_rec(), "" );


            		goto ruleconditional_insert_else_partEx;
            	}
            	cnt172++;
                }
                loop172: ;	/* Jump to here if this rule does not match */
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleconditional_insert_else_partEx; /* Prevent compiler warnings */
    ruleconditional_insert_else_partEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end conditional_insert_else_part */

/**
 * $ANTLR start insert_into_clause
 * OracleDML.g:673:1: insert_into_clause : into_key general_table_ref ( LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN )? -> ^( into_key general_table_ref ^( COLUMNS ( column_name )* ) ) ;
 */
OracleDML::insert_into_clause_return
OracleDML::insert_into_clause()
{
    OracleDML::insert_into_clause_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* LEFT_PAREN484 = NULL;
    ImplTraits::CommonTokenType const* COMMA486 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN488 = NULL;
    OracleDML_OracleDMLKeys::into_key_return into_key482;
    ImplTraits::TreeTypePtr::pointer into_key482_last = NULL;
    OracleDML::general_table_ref_return general_table_ref483;
    ImplTraits::TreeTypePtr::pointer general_table_ref483_last = NULL;
    OracleDML_OracleDMLCommons::column_name_return column_name485;
    ImplTraits::TreeTypePtr::pointer column_name485_last = NULL;
    OracleDML_OracleDMLCommons::column_name_return column_name487;
    ImplTraits::TreeTypePtr::pointer column_name487_last = NULL;
    ImplTraits::TreeTypePtr LEFT_PAREN484_tree;
    ImplTraits::TreeTypePtr COMMA486_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN488_tree;
    RewriteRuleTokenStream<ImplTraits> stream_LEFT_PAREN(get_psrstate()->get_treeAdaptor(), "token LEFT_PAREN");
    RewriteRuleTokenStream<ImplTraits> stream_RIGHT_PAREN(get_psrstate()->get_treeAdaptor(), "token RIGHT_PAREN");
    RewriteRuleTokenStream<ImplTraits> stream_COMMA(get_psrstate()->get_treeAdaptor(), "token COMMA");
    RewriteRuleSubtreeStream<ImplTraits> stream_general_table_ref(get_psrstate()->get_treeAdaptor(), "rule general_table_ref");
    RewriteRuleSubtreeStream<ImplTraits> stream_into_key(get_psrstate()->get_treeAdaptor(), "rule into_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_column_name(get_psrstate()->get_treeAdaptor(), "rule column_name");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:674:5: ( into_key general_table_ref ( LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN )? -> ^( into_key general_table_ref ^( COLUMNS ( column_name )* ) ) )
        // OracleDML.g:674:10: into_key general_table_ref ( LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN )?
        {
            this->followPush(FOLLOW_into_key_in_insert_into_clause6526);
            into_key482=into_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleinsert_into_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                into_key482_last = into_key482.tree.get();
                stream_into_key.add(into_key482.tree);
            }

            this->followPush(FOLLOW_general_table_ref_in_insert_into_clause6528);
            general_table_ref483=general_table_ref();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleinsert_into_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                general_table_ref483_last = general_table_ref483.tree.get();
                stream_general_table_ref.add(general_table_ref483.tree);
            }

            // OracleDML.g:675:9: ( LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN )?
            {
                ANTLR_UINT32 alt174=2;
                switch ( this->LA(1) )
                {
                    case LEFT_PAREN:
                    	{
                    		switch ( this->LA(2) )
                    		{
                    		    case DELIMITED_ID:
                    		    case INTRODUCER:
                    		    case REGULAR_ID:
                    		    	{
                    		    		alt174=1;
                    		    	}
                    		        break;
                    		}

                    	}
                        break;
                }

                switch (alt174)
                {
            	case 1:
            	    // OracleDML.g:675:10: LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN
            	    {
            	        LEFT_PAREN484 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_insert_into_clause6540);
            	        if  (this->hasException())
            	        {
            	            goto ruleinsert_into_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( this->get_backtracking()==0 ) stream_LEFT_PAREN.add(LEFT_PAREN484);


            	        this->followPush(FOLLOW_column_name_in_insert_into_clause6542);
            	        column_name485=column_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleinsert_into_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            column_name485_last = column_name485.tree.get();
            	            stream_column_name.add(column_name485.tree);
            	        }

            	        // OracleDML.g:675:33: ( COMMA column_name )*

            	        for (;;)
            	        {
            	            ANTLR_UINT32 alt173=2;
            	            switch ( this->LA(1) )
            	            {
            	            case COMMA:
            	            	{
            	            		alt173=1;
            	            	}
            	                break;

            	            }

            	            switch (alt173)
            	            {
            	        	case 1:
            	        	    // OracleDML.g:675:34: COMMA column_name
            	        	    {
            	        	        COMMA486 =  this->matchToken(COMMA, &FOLLOW_COMMA_in_insert_into_clause6545);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleinsert_into_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }
            	        	         
            	        	        if ( this->get_backtracking()==0 ) stream_COMMA.add(COMMA486);


            	        	        this->followPush(FOLLOW_column_name_in_insert_into_clause6547);
            	        	        column_name487=column_name();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleinsert_into_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) 
            	        	        {
            	        	            column_name487_last = column_name487.tree.get();
            	        	            stream_column_name.add(column_name487.tree);
            	        	        }

            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop173;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop173: ; /* Jump out to here if this rule does not match */


            	        RIGHT_PAREN488 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_insert_into_clause6551);
            	        if  (this->hasException())
            	        {
            	            goto ruleinsert_into_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( this->get_backtracking()==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN488);


            	    }
            	    break;

                }
            }

            // AST REWRITE
            // elements: column_name, into_key, general_table_ref
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 676:9: -> ^( into_key general_table_ref ^( COLUMNS ( column_name )* ) )
            {
            	// OracleDML.g:676:12: ^( into_key general_table_ref ^( COLUMNS ( column_name )* ) )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(stream_into_key.nextNode(), root_1);
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_general_table_ref.nextTree());
            	// OracleDML.g:676:41: ^( COLUMNS ( column_name )* )
            	{
            	ImplTraits::TreeTypePtr root_2 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_2 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(COLUMNS, "COLUMNS"), root_2);
            	// OracleDML.g:676:51: ( column_name )*
            	while ( stream_column_name.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_2, stream_column_name.nextTree());
            	}
            	stream_column_name.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_1, root_2);
            	}
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleinsert_into_clauseEx; /* Prevent compiler warnings */
    ruleinsert_into_clauseEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end insert_into_clause */

/**
 * $ANTLR start values_clause
 * OracleDML.g:679:1: values_clause : values_key ^ ( expression_list | record_name ) ;
 */
OracleDML::values_clause_return
OracleDML::values_clause()
{
    OracleDML::values_clause_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML_OracleDMLKeys::values_key_return values_key489;
    ImplTraits::TreeTypePtr::pointer values_key489_last = NULL;
    OracleDML::expression_list_return expression_list490;
    ImplTraits::TreeTypePtr::pointer expression_list490_last = NULL;
    OracleDML_OracleDMLCommons::record_name_return record_name491;
    ImplTraits::TreeTypePtr::pointer record_name491_last = NULL;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:680:5: ( values_key ^ ( expression_list | record_name ) )
        // OracleDML.g:680:10: values_key ^ ( expression_list | record_name )
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            this->followPush(FOLLOW_values_key_in_values_clause6596);
            values_key489=values_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulevalues_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(values_key489.tree, root_0);

            // OracleDML.g:680:22: ( expression_list | record_name )
            {
                ANTLR_UINT32 alt175=2;
                switch ( this->LA(1) )
                {
                case LEFT_PAREN:
                	{
                		alt175=1;
                	}
                    break;
                case BINDVAR:
                case COLON:
                case DELIMITED_ID:
                case INTRODUCER:
                case REGULAR_ID:
                	{
                		alt175=2;
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return retval;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 175 );
                    ex->set_state( 0 );


                    goto rulevalues_clauseEx;

                }

                switch (alt175)
                {
            	case 1:
            	    // OracleDML.g:680:23: expression_list
            	    {
            	        this->followPush(FOLLOW_expression_list_in_values_clause6600);
            	        expression_list490=expression_list();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulevalues_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, expression_list490.tree);


            	    }
            	    break;
            	case 2:
            	    // OracleDML.g:680:41: record_name
            	    {
            	        this->followPush(FOLLOW_record_name_in_values_clause6604);
            	        record_name491=record_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulevalues_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, record_name491.tree);


            	    }
            	    break;

                }
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulevalues_clauseEx; /* Prevent compiler warnings */
    rulevalues_clauseEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end values_clause */

/**
 * $ANTLR start merge_statement
 * OracleDML.g:684:1: merge_statement : merge_key into_key tableview_name ( table_alias )? using_key selected_tableview on_key LEFT_PAREN condition RIGHT_PAREN ( ( when_key matched_key )=> merge_update_insert_seq | ( when_key not_key matched_key )=> merge_insert_update_seq )? ( error_logging_clause )? -> ^( merge_key tableview_name ( table_alias )? ^( using_key selected_tableview ^( LOGIC_EXPR condition ) ) ( merge_update_insert_seq )? ( merge_insert_update_seq )? ( error_logging_clause )? ) ;
 */
OracleDML::merge_statement_return
OracleDML::merge_statement()
{
    OracleDML::merge_statement_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* LEFT_PAREN499 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN501 = NULL;
    OracleDML_OracleDMLKeys::merge_key_return merge_key492;
    ImplTraits::TreeTypePtr::pointer merge_key492_last = NULL;
    OracleDML_OracleDMLKeys::into_key_return into_key493;
    ImplTraits::TreeTypePtr::pointer into_key493_last = NULL;
    OracleDML_OracleDMLCommons::tableview_name_return tableview_name494;
    ImplTraits::TreeTypePtr::pointer tableview_name494_last = NULL;
    OracleDML_OracleDMLCommons::table_alias_return table_alias495;
    ImplTraits::TreeTypePtr::pointer table_alias495_last = NULL;
    OracleDML_OracleDMLKeys::using_key_return using_key496;
    ImplTraits::TreeTypePtr::pointer using_key496_last = NULL;
    OracleDML::selected_tableview_return selected_tableview497;
    ImplTraits::TreeTypePtr::pointer selected_tableview497_last = NULL;
    OracleDML_OracleDMLKeys::on_key_return on_key498;
    ImplTraits::TreeTypePtr::pointer on_key498_last = NULL;
    OracleDML::condition_return condition500;
    ImplTraits::TreeTypePtr::pointer condition500_last = NULL;
    OracleDML::merge_update_insert_seq_return merge_update_insert_seq502;
    ImplTraits::TreeTypePtr::pointer merge_update_insert_seq502_last = NULL;
    OracleDML::merge_insert_update_seq_return merge_insert_update_seq503;
    ImplTraits::TreeTypePtr::pointer merge_insert_update_seq503_last = NULL;
    OracleDML::error_logging_clause_return error_logging_clause504;
    ImplTraits::TreeTypePtr::pointer error_logging_clause504_last = NULL;
    ImplTraits::TreeTypePtr LEFT_PAREN499_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN501_tree;
    RewriteRuleTokenStream<ImplTraits> stream_LEFT_PAREN(get_psrstate()->get_treeAdaptor(), "token LEFT_PAREN");
    RewriteRuleTokenStream<ImplTraits> stream_RIGHT_PAREN(get_psrstate()->get_treeAdaptor(), "token RIGHT_PAREN");
    RewriteRuleSubtreeStream<ImplTraits> stream_using_key(get_psrstate()->get_treeAdaptor(), "rule using_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_into_key(get_psrstate()->get_treeAdaptor(), "rule into_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_merge_insert_update_seq(get_psrstate()->get_treeAdaptor(), "rule merge_insert_update_seq");
    RewriteRuleSubtreeStream<ImplTraits> stream_merge_key(get_psrstate()->get_treeAdaptor(), "rule merge_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_error_logging_clause(get_psrstate()->get_treeAdaptor(), "rule error_logging_clause");
    RewriteRuleSubtreeStream<ImplTraits> stream_condition(get_psrstate()->get_treeAdaptor(), "rule condition");
    RewriteRuleSubtreeStream<ImplTraits> stream_table_alias(get_psrstate()->get_treeAdaptor(), "rule table_alias");
    RewriteRuleSubtreeStream<ImplTraits> stream_selected_tableview(get_psrstate()->get_treeAdaptor(), "rule selected_tableview");
    RewriteRuleSubtreeStream<ImplTraits> stream_on_key(get_psrstate()->get_treeAdaptor(), "rule on_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_tableview_name(get_psrstate()->get_treeAdaptor(), "rule tableview_name");
    RewriteRuleSubtreeStream<ImplTraits> stream_merge_update_insert_seq(get_psrstate()->get_treeAdaptor(), "rule merge_update_insert_seq");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:685:5: ( merge_key into_key tableview_name ( table_alias )? using_key selected_tableview on_key LEFT_PAREN condition RIGHT_PAREN ( ( when_key matched_key )=> merge_update_insert_seq | ( when_key not_key matched_key )=> merge_insert_update_seq )? ( error_logging_clause )? -> ^( merge_key tableview_name ( table_alias )? ^( using_key selected_tableview ^( LOGIC_EXPR condition ) ) ( merge_update_insert_seq )? ( merge_insert_update_seq )? ( error_logging_clause )? ) )
        // OracleDML.g:685:10: merge_key into_key tableview_name ( table_alias )? using_key selected_tableview on_key LEFT_PAREN condition RIGHT_PAREN ( ( when_key matched_key )=> merge_update_insert_seq | ( when_key not_key matched_key )=> merge_insert_update_seq )? ( error_logging_clause )?
        {
            this->followPush(FOLLOW_merge_key_in_merge_statement6626);
            merge_key492=merge_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemerge_statementEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                merge_key492_last = merge_key492.tree.get();
                stream_merge_key.add(merge_key492.tree);
            }

            this->followPush(FOLLOW_into_key_in_merge_statement6628);
            into_key493=into_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemerge_statementEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                into_key493_last = into_key493.tree.get();
                stream_into_key.add(into_key493.tree);
            }

            this->followPush(FOLLOW_tableview_name_in_merge_statement6630);
            tableview_name494=tableview_name();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemerge_statementEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                tableview_name494_last = tableview_name494.tree.get();
                stream_tableview_name.add(tableview_name494.tree);
            }

            // OracleDML.g:685:44: ( table_alias )?
            {
                ANTLR_UINT32 alt176=2;
                switch ( this->LA(1) )
                {
                    case CHAR_STRING:
                    case CHAR_STRING_PERL:
                    case DELIMITED_ID:
                    case INTRODUCER:
                    case NATIONAL_CHAR_STRING_LIT:
                    case REGULAR_ID:
                    	{
                    		alt176=1;
                    	}
                        break;
                }

                switch (alt176)
                {
            	case 1:
            	    // OracleDML.g:685:44: table_alias
            	    {
            	        this->followPush(FOLLOW_table_alias_in_merge_statement6632);
            	        table_alias495=table_alias();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemerge_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            table_alias495_last = table_alias495.tree.get();
            	            stream_table_alias.add(table_alias495.tree);
            	        }

            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_using_key_in_merge_statement6643);
            using_key496=using_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemerge_statementEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                using_key496_last = using_key496.tree.get();
                stream_using_key.add(using_key496.tree);
            }

            this->followPush(FOLLOW_selected_tableview_in_merge_statement6645);
            selected_tableview497=selected_tableview();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemerge_statementEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                selected_tableview497_last = selected_tableview497.tree.get();
                stream_selected_tableview.add(selected_tableview497.tree);
            }

            this->followPush(FOLLOW_on_key_in_merge_statement6647);
            on_key498=on_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemerge_statementEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                on_key498_last = on_key498.tree.get();
                stream_on_key.add(on_key498.tree);
            }

            LEFT_PAREN499 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_merge_statement6649);
            if  (this->hasException())
            {
                goto rulemerge_statementEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_LEFT_PAREN.add(LEFT_PAREN499);


            this->followPush(FOLLOW_condition_in_merge_statement6651);
            condition500=condition();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemerge_statementEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                condition500_last = condition500.tree.get();
                stream_condition.add(condition500.tree);
            }

            RIGHT_PAREN501 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_merge_statement6653);
            if  (this->hasException())
            {
                goto rulemerge_statementEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN501);


            // OracleDML.g:687:9: ( ( when_key matched_key )=> merge_update_insert_seq | ( when_key not_key matched_key )=> merge_insert_update_seq )?
            {
                ANTLR_UINT32 alt177=3;
                switch ( this->LA(1) )
                {
                    case SQL92_RESERVED_WHEN:
                    	{
                    		{
                    		    ANTLR_UINT32 LA177_1 = this->LA(2);
                    		    if ( (LA177_1 == REGULAR_ID) && (this->msynpred( antlr3::ClassForwarder<synpred23_OracleDML>() )))
                    		    {
                    		        alt177=1;
                    		    }
                    		    else if ( (LA177_1 == SQL92_RESERVED_NOT) && (this->msynpred( antlr3::ClassForwarder<synpred24_OracleDML>() )))
                    		    {
                    		        alt177=2;
                    		    }
                    		}
                    	}
                        break;
                }

                switch (alt177)
                {
            	case 1:
            	    // OracleDML.g:688:13: ( when_key matched_key )=> merge_update_insert_seq
            	    {
            	        this->followPush(FOLLOW_merge_update_insert_seq_in_merge_statement6685);
            	        merge_update_insert_seq502=merge_update_insert_seq();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemerge_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            merge_update_insert_seq502_last = merge_update_insert_seq502.tree.get();
            	            stream_merge_update_insert_seq.add(merge_update_insert_seq502.tree);
            	        }

            	    }
            	    break;
            	case 2:
            	    // OracleDML.g:690:13: ( when_key not_key matched_key )=> merge_insert_update_seq
            	    {
            	        this->followPush(FOLLOW_merge_insert_update_seq_in_merge_statement6719);
            	        merge_insert_update_seq503=merge_insert_update_seq();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemerge_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            merge_insert_update_seq503_last = merge_insert_update_seq503.tree.get();
            	            stream_merge_insert_update_seq.add(merge_insert_update_seq503.tree);
            	        }

            	    }
            	    break;

                }
            }

            // OracleDML.g:692:9: ( error_logging_clause )?
            {
                ANTLR_UINT32 alt178=2;
                {
                    ANTLR_UINT32 LA178_0 = this->LA(1);
                    if ( (LA178_0 == REGULAR_ID) && ((toUpper(LT(1)->getText()) == "LOG")))
                    {
                        alt178=1;
                    }
                }
                switch (alt178)
                {
            	case 1:
            	    // OracleDML.g:692:9: error_logging_clause
            	    {
            	        this->followPush(FOLLOW_error_logging_clause_in_merge_statement6740);
            	        error_logging_clause504=error_logging_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemerge_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            error_logging_clause504_last = error_logging_clause504.tree.get();
            	            stream_error_logging_clause.add(error_logging_clause504.tree);
            	        }

            	    }
            	    break;

                }
            }

            // AST REWRITE
            // elements: merge_update_insert_seq, merge_key, selected_tableview, using_key, merge_insert_update_seq, table_alias, tableview_name, error_logging_clause, condition
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 693:9: -> ^( merge_key tableview_name ( table_alias )? ^( using_key selected_tableview ^( LOGIC_EXPR condition ) ) ( merge_update_insert_seq )? ( merge_insert_update_seq )? ( error_logging_clause )? )
            {
            	// OracleDML.g:693:12: ^( merge_key tableview_name ( table_alias )? ^( using_key selected_tableview ^( LOGIC_EXPR condition ) ) ( merge_update_insert_seq )? ( merge_insert_update_seq )? ( error_logging_clause )? )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(stream_merge_key.nextNode(), root_1);
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_tableview_name.nextTree());
            	// OracleDML.g:693:39: ( table_alias )?
            	if ( stream_table_alias.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_table_alias.nextTree());
            	}
            	stream_table_alias.reset();

            	// OracleDML.g:693:52: ^( using_key selected_tableview ^( LOGIC_EXPR condition ) )
            	{
            	ImplTraits::TreeTypePtr root_2 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_2 = get_psrstate()->get_treeAdaptor()->becomeRoot(stream_using_key.nextNode(), root_2);
            	get_psrstate()->get_treeAdaptor()->addChild(root_2, stream_selected_tableview.nextTree());
            	// OracleDML.g:693:83: ^( LOGIC_EXPR condition )
            	{
            	ImplTraits::TreeTypePtr root_3 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_3 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(LOGIC_EXPR, "LOGIC_EXPR"), root_3);
            	get_psrstate()->get_treeAdaptor()->addChild(root_3, stream_condition.nextTree());
            	get_psrstate()->get_treeAdaptor()->addChild(root_2, root_3);
            	}
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, root_2);
            	}
            	// OracleDML.g:694:13: ( merge_update_insert_seq )?
            	if ( stream_merge_update_insert_seq.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_merge_update_insert_seq.nextTree());
            	}
            	stream_merge_update_insert_seq.reset();

            	// OracleDML.g:694:38: ( merge_insert_update_seq )?
            	if ( stream_merge_insert_update_seq.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_merge_insert_update_seq.nextTree());
            	}
            	stream_merge_insert_update_seq.reset();

            	// OracleDML.g:695:13: ( error_logging_clause )?
            	if ( stream_error_logging_clause.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_error_logging_clause.nextTree());
            	}
            	stream_error_logging_clause.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulemerge_statementEx; /* Prevent compiler warnings */
    rulemerge_statementEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end merge_statement */

/**
 * $ANTLR start merge_update_insert_seq
 * OracleDML.g:699:1: merge_update_insert_seq : merge_update_clause ( merge_insert_clause )? ;
 */
OracleDML::merge_update_insert_seq_return
OracleDML::merge_update_insert_seq()
{
    OracleDML::merge_update_insert_seq_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML::merge_update_clause_return merge_update_clause505;
    ImplTraits::TreeTypePtr::pointer merge_update_clause505_last = NULL;
    OracleDML::merge_insert_clause_return merge_insert_clause506;
    ImplTraits::TreeTypePtr::pointer merge_insert_clause506_last = NULL;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:700:5: ( merge_update_clause ( merge_insert_clause )? )
        // OracleDML.g:700:7: merge_update_clause ( merge_insert_clause )?
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            this->followPush(FOLLOW_merge_update_clause_in_merge_update_insert_seq6823);
            merge_update_clause505=merge_update_clause();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemerge_update_insert_seqEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, merge_update_clause505.tree);


            // OracleDML.g:700:27: ( merge_insert_clause )?
            {
                ANTLR_UINT32 alt179=2;
                switch ( this->LA(1) )
                {
                    case SQL92_RESERVED_WHEN:
                    	{
                    		alt179=1;
                    	}
                        break;
                }

                switch (alt179)
                {
            	case 1:
            	    // OracleDML.g:700:27: merge_insert_clause
            	    {
            	        this->followPush(FOLLOW_merge_insert_clause_in_merge_update_insert_seq6825);
            	        merge_insert_clause506=merge_insert_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemerge_update_insert_seqEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, merge_insert_clause506.tree);


            	    }
            	    break;

                }
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulemerge_update_insert_seqEx; /* Prevent compiler warnings */
    rulemerge_update_insert_seqEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end merge_update_insert_seq */

/**
 * $ANTLR start merge_insert_update_seq
 * OracleDML.g:703:1: merge_insert_update_seq : merge_insert_clause ( merge_update_clause )? ;
 */
OracleDML::merge_insert_update_seq_return
OracleDML::merge_insert_update_seq()
{
    OracleDML::merge_insert_update_seq_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML::merge_insert_clause_return merge_insert_clause507;
    ImplTraits::TreeTypePtr::pointer merge_insert_clause507_last = NULL;
    OracleDML::merge_update_clause_return merge_update_clause508;
    ImplTraits::TreeTypePtr::pointer merge_update_clause508_last = NULL;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:704:5: ( merge_insert_clause ( merge_update_clause )? )
        // OracleDML.g:704:7: merge_insert_clause ( merge_update_clause )?
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            this->followPush(FOLLOW_merge_insert_clause_in_merge_insert_update_seq6843);
            merge_insert_clause507=merge_insert_clause();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemerge_insert_update_seqEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, merge_insert_clause507.tree);


            // OracleDML.g:704:27: ( merge_update_clause )?
            {
                ANTLR_UINT32 alt180=2;
                switch ( this->LA(1) )
                {
                    case SQL92_RESERVED_WHEN:
                    	{
                    		alt180=1;
                    	}
                        break;
                }

                switch (alt180)
                {
            	case 1:
            	    // OracleDML.g:704:27: merge_update_clause
            	    {
            	        this->followPush(FOLLOW_merge_update_clause_in_merge_insert_update_seq6845);
            	        merge_update_clause508=merge_update_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemerge_insert_update_seqEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, merge_update_clause508.tree);


            	    }
            	    break;

                }
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulemerge_insert_update_seqEx; /* Prevent compiler warnings */
    rulemerge_insert_update_seqEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end merge_insert_update_seq */

/**
 * $ANTLR start merge_update_clause
 * OracleDML.g:707:1: merge_update_clause : when_key matched_key then_key update_key set_key merge_element ( COMMA merge_element )* ( where_clause )? ( merge_update_delete_part )? -> ^( MERGE_UPDATE[$when_key.start] matched_key then_key update_key set_key ( merge_element )+ ( where_clause )? ( merge_update_delete_part )? ) ;
 */
OracleDML::merge_update_clause_return
OracleDML::merge_update_clause()
{
    OracleDML::merge_update_clause_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* COMMA515 = NULL;
    OracleDML_OracleDMLKeys::when_key_return when_key509;
    ImplTraits::TreeTypePtr::pointer when_key509_last = NULL;
    OracleDML_OracleDMLKeys::matched_key_return matched_key510;
    ImplTraits::TreeTypePtr::pointer matched_key510_last = NULL;
    OracleDML_OracleDMLKeys::then_key_return then_key511;
    ImplTraits::TreeTypePtr::pointer then_key511_last = NULL;
    OracleDML_OracleDMLKeys::update_key_return update_key512;
    ImplTraits::TreeTypePtr::pointer update_key512_last = NULL;
    OracleDML_OracleDMLKeys::set_key_return set_key513;
    ImplTraits::TreeTypePtr::pointer set_key513_last = NULL;
    OracleDML::merge_element_return merge_element514;
    ImplTraits::TreeTypePtr::pointer merge_element514_last = NULL;
    OracleDML::merge_element_return merge_element516;
    ImplTraits::TreeTypePtr::pointer merge_element516_last = NULL;
    OracleDML_OracleDMLCommons::where_clause_return where_clause517;
    ImplTraits::TreeTypePtr::pointer where_clause517_last = NULL;
    OracleDML::merge_update_delete_part_return merge_update_delete_part518;
    ImplTraits::TreeTypePtr::pointer merge_update_delete_part518_last = NULL;
    ImplTraits::TreeTypePtr COMMA515_tree;
    RewriteRuleTokenStream<ImplTraits> stream_COMMA(get_psrstate()->get_treeAdaptor(), "token COMMA");
    RewriteRuleSubtreeStream<ImplTraits> stream_then_key(get_psrstate()->get_treeAdaptor(), "rule then_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_merge_update_delete_part(get_psrstate()->get_treeAdaptor(), "rule merge_update_delete_part");
    RewriteRuleSubtreeStream<ImplTraits> stream_merge_element(get_psrstate()->get_treeAdaptor(), "rule merge_element");
    RewriteRuleSubtreeStream<ImplTraits> stream_where_clause(get_psrstate()->get_treeAdaptor(), "rule where_clause");
    RewriteRuleSubtreeStream<ImplTraits> stream_set_key(get_psrstate()->get_treeAdaptor(), "rule set_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_update_key(get_psrstate()->get_treeAdaptor(), "rule update_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_when_key(get_psrstate()->get_treeAdaptor(), "rule when_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_matched_key(get_psrstate()->get_treeAdaptor(), "rule matched_key");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:708:5: ( when_key matched_key then_key update_key set_key merge_element ( COMMA merge_element )* ( where_clause )? ( merge_update_delete_part )? -> ^( MERGE_UPDATE[$when_key.start] matched_key then_key update_key set_key ( merge_element )+ ( where_clause )? ( merge_update_delete_part )? ) )
        // OracleDML.g:708:10: when_key matched_key then_key update_key set_key merge_element ( COMMA merge_element )* ( where_clause )? ( merge_update_delete_part )?
        {
            this->followPush(FOLLOW_when_key_in_merge_update_clause6866);
            when_key509=when_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemerge_update_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                when_key509_last = when_key509.tree.get();
                stream_when_key.add(when_key509.tree);
            }

            this->followPush(FOLLOW_matched_key_in_merge_update_clause6868);
            matched_key510=matched_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemerge_update_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                matched_key510_last = matched_key510.tree.get();
                stream_matched_key.add(matched_key510.tree);
            }

            this->followPush(FOLLOW_then_key_in_merge_update_clause6870);
            then_key511=then_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemerge_update_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                then_key511_last = then_key511.tree.get();
                stream_then_key.add(then_key511.tree);
            }

            this->followPush(FOLLOW_update_key_in_merge_update_clause6872);
            update_key512=update_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemerge_update_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                update_key512_last = update_key512.tree.get();
                stream_update_key.add(update_key512.tree);
            }

            this->followPush(FOLLOW_set_key_in_merge_update_clause6874);
            set_key513=set_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemerge_update_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                set_key513_last = set_key513.tree.get();
                stream_set_key.add(set_key513.tree);
            }

            this->followPush(FOLLOW_merge_element_in_merge_update_clause6885);
            merge_element514=merge_element();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemerge_update_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                merge_element514_last = merge_element514.tree.get();
                stream_merge_element.add(merge_element514.tree);
            }

            // OracleDML.g:709:23: ( COMMA merge_element )*

            for (;;)
            {
                ANTLR_UINT32 alt181=2;
                switch ( this->LA(1) )
                {
                case COMMA:
                	{
                		alt181=1;
                	}
                    break;

                }

                switch (alt181)
                {
            	case 1:
            	    // OracleDML.g:709:24: COMMA merge_element
            	    {
            	        COMMA515 =  this->matchToken(COMMA, &FOLLOW_COMMA_in_merge_update_clause6888);
            	        if  (this->hasException())
            	        {
            	            goto rulemerge_update_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( this->get_backtracking()==0 ) stream_COMMA.add(COMMA515);


            	        this->followPush(FOLLOW_merge_element_in_merge_update_clause6890);
            	        merge_element516=merge_element();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemerge_update_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            merge_element516_last = merge_element516.tree.get();
            	            stream_merge_element.add(merge_element516.tree);
            	        }

            	    }
            	    break;

            	default:
            	    goto loop181;	/* break out of the loop */
            	    break;
                }
            }
            loop181: ; /* Jump out to here if this rule does not match */


            // OracleDML.g:710:9: ( where_clause )?
            {
                ANTLR_UINT32 alt182=2;
                switch ( this->LA(1) )
                {
                    case SQL92_RESERVED_WHERE:
                    	{
                    		alt182=1;
                    	}
                        break;
                }

                switch (alt182)
                {
            	case 1:
            	    // OracleDML.g:710:9: where_clause
            	    {
            	        this->followPush(FOLLOW_where_clause_in_merge_update_clause6902);
            	        where_clause517=where_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemerge_update_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            where_clause517_last = where_clause517.tree.get();
            	            stream_where_clause.add(where_clause517.tree);
            	        }

            	    }
            	    break;

                }
            }

            // OracleDML.g:710:23: ( merge_update_delete_part )?
            {
                ANTLR_UINT32 alt183=2;
                switch ( this->LA(1) )
                {
                    case SQL92_RESERVED_DELETE:
                    	{
                    		alt183=1;
                    	}
                        break;
                }

                switch (alt183)
                {
            	case 1:
            	    // OracleDML.g:710:23: merge_update_delete_part
            	    {
            	        this->followPush(FOLLOW_merge_update_delete_part_in_merge_update_clause6905);
            	        merge_update_delete_part518=merge_update_delete_part();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemerge_update_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            merge_update_delete_part518_last = merge_update_delete_part518.tree.get();
            	            stream_merge_update_delete_part.add(merge_update_delete_part518.tree);
            	        }

            	    }
            	    break;

                }
            }

            // AST REWRITE
            // elements: where_clause, matched_key, set_key, update_key, merge_update_delete_part, merge_element, then_key
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 711:9: -> ^( MERGE_UPDATE[$when_key.start] matched_key then_key update_key set_key ( merge_element )+ ( where_clause )? ( merge_update_delete_part )? )
            {
            	// OracleDML.g:711:11: ^( MERGE_UPDATE[$when_key.start] matched_key then_key update_key set_key ( merge_element )+ ( where_clause )? ( merge_update_delete_part )? )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(MERGE_UPDATE, (when_key509.start)), root_1);
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_matched_key.nextTree());
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_then_key.nextTree());
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_update_key.nextTree());
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_set_key.nextTree());
            	if ( !(stream_merge_element.hasNext()) ) {
            		ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, REWRITE_EARLY_EXCEPTION, StreamType>( this->get_rec(), "merge_element empty" );
            		goto rulemerge_update_clauseEx;
            	}
            	while ( stream_merge_element.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_merge_element.nextTree());
            	}
            	stream_merge_element.reset();

            	// OracleDML.g:711:98: ( where_clause )?
            	if ( stream_where_clause.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_where_clause.nextTree());
            	}
            	stream_where_clause.reset();

            	// OracleDML.g:711:112: ( merge_update_delete_part )?
            	if ( stream_merge_update_delete_part.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_merge_update_delete_part.nextTree());
            	}
            	stream_merge_update_delete_part.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulemerge_update_clauseEx; /* Prevent compiler warnings */
    rulemerge_update_clauseEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end merge_update_clause */

/**
 * $ANTLR start merge_element
 * OracleDML.g:714:1: merge_element : column_name EQUALS_OP expression -> ^( ASSIGN[$EQUALS_OP] column_name ^( EXPR expression ) ) ;
 */
OracleDML::merge_element_return
OracleDML::merge_element()
{
    OracleDML::merge_element_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* EQUALS_OP520 = NULL;
    OracleDML_OracleDMLCommons::column_name_return column_name519;
    ImplTraits::TreeTypePtr::pointer column_name519_last = NULL;
    OracleDML::expression_return expression521;
    ImplTraits::TreeTypePtr::pointer expression521_last = NULL;
    ImplTraits::TreeTypePtr EQUALS_OP520_tree;
    RewriteRuleTokenStream<ImplTraits> stream_EQUALS_OP(get_psrstate()->get_treeAdaptor(), "token EQUALS_OP");
    RewriteRuleSubtreeStream<ImplTraits> stream_expression(get_psrstate()->get_treeAdaptor(), "rule expression");
    RewriteRuleSubtreeStream<ImplTraits> stream_column_name(get_psrstate()->get_treeAdaptor(), "rule column_name");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:715:5: ( column_name EQUALS_OP expression -> ^( ASSIGN[$EQUALS_OP] column_name ^( EXPR expression ) ) )
        // OracleDML.g:715:10: column_name EQUALS_OP expression
        {
            this->followPush(FOLLOW_column_name_in_merge_element6957);
            column_name519=column_name();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemerge_elementEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                column_name519_last = column_name519.tree.get();
                stream_column_name.add(column_name519.tree);
            }

            EQUALS_OP520 =  this->matchToken(EQUALS_OP, &FOLLOW_EQUALS_OP_in_merge_element6959);
            if  (this->hasException())
            {
                goto rulemerge_elementEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_EQUALS_OP.add(EQUALS_OP520);


            this->followPush(FOLLOW_expression_in_merge_element6961);
            expression521=expression();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemerge_elementEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                expression521_last = expression521.tree.get();
                stream_expression.add(expression521.tree);
            }

            // AST REWRITE
            // elements: column_name, expression
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 716:9: -> ^( ASSIGN[$EQUALS_OP] column_name ^( EXPR expression ) )
            {
            	// OracleDML.g:716:12: ^( ASSIGN[$EQUALS_OP] column_name ^( EXPR expression ) )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(ASSIGN, EQUALS_OP520), root_1);
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_column_name.nextTree());
            	// OracleDML.g:716:45: ^( EXPR expression )
            	{
            	ImplTraits::TreeTypePtr root_2 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_2 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(EXPR, "EXPR"), root_2);
            	get_psrstate()->get_treeAdaptor()->addChild(root_2, stream_expression.nextTree());
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, root_2);
            	}
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulemerge_elementEx; /* Prevent compiler warnings */
    rulemerge_elementEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end merge_element */

/**
 * $ANTLR start merge_update_delete_part
 * OracleDML.g:719:1: merge_update_delete_part : delete_key ^ where_clause ;
 */
OracleDML::merge_update_delete_part_return
OracleDML::merge_update_delete_part()
{
    OracleDML::merge_update_delete_part_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML_OracleDMLKeys::delete_key_return delete_key522;
    ImplTraits::TreeTypePtr::pointer delete_key522_last = NULL;
    OracleDML_OracleDMLCommons::where_clause_return where_clause523;
    ImplTraits::TreeTypePtr::pointer where_clause523_last = NULL;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:720:5: ( delete_key ^ where_clause )
        // OracleDML.g:720:10: delete_key ^ where_clause
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            this->followPush(FOLLOW_delete_key_in_merge_update_delete_part7004);
            delete_key522=delete_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemerge_update_delete_partEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(delete_key522.tree, root_0);

            this->followPush(FOLLOW_where_clause_in_merge_update_delete_part7007);
            where_clause523=where_clause();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemerge_update_delete_partEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, where_clause523.tree);


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulemerge_update_delete_partEx; /* Prevent compiler warnings */
    rulemerge_update_delete_partEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end merge_update_delete_part */

/**
 * $ANTLR start merge_insert_clause
 * OracleDML.g:723:1: merge_insert_clause : when_key not_key matched_key then_key insert_key ( LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN )? values_key expression_list ( where_clause )? -> ^( MERGE_INSERT[$when_key.start] not_key matched_key then_key insert_key ^( COLUMNS ( column_name )* ) values_key expression_list ( where_clause )? ) ;
 */
OracleDML::merge_insert_clause_return
OracleDML::merge_insert_clause()
{
    OracleDML::merge_insert_clause_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* LEFT_PAREN529 = NULL;
    ImplTraits::CommonTokenType const* COMMA531 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN533 = NULL;
    OracleDML_OracleDMLKeys::when_key_return when_key524;
    ImplTraits::TreeTypePtr::pointer when_key524_last = NULL;
    OracleDML_OracleDMLKeys::not_key_return not_key525;
    ImplTraits::TreeTypePtr::pointer not_key525_last = NULL;
    OracleDML_OracleDMLKeys::matched_key_return matched_key526;
    ImplTraits::TreeTypePtr::pointer matched_key526_last = NULL;
    OracleDML_OracleDMLKeys::then_key_return then_key527;
    ImplTraits::TreeTypePtr::pointer then_key527_last = NULL;
    OracleDML_OracleDMLKeys::insert_key_return insert_key528;
    ImplTraits::TreeTypePtr::pointer insert_key528_last = NULL;
    OracleDML_OracleDMLCommons::column_name_return column_name530;
    ImplTraits::TreeTypePtr::pointer column_name530_last = NULL;
    OracleDML_OracleDMLCommons::column_name_return column_name532;
    ImplTraits::TreeTypePtr::pointer column_name532_last = NULL;
    OracleDML_OracleDMLKeys::values_key_return values_key534;
    ImplTraits::TreeTypePtr::pointer values_key534_last = NULL;
    OracleDML::expression_list_return expression_list535;
    ImplTraits::TreeTypePtr::pointer expression_list535_last = NULL;
    OracleDML_OracleDMLCommons::where_clause_return where_clause536;
    ImplTraits::TreeTypePtr::pointer where_clause536_last = NULL;
    ImplTraits::TreeTypePtr LEFT_PAREN529_tree;
    ImplTraits::TreeTypePtr COMMA531_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN533_tree;
    RewriteRuleTokenStream<ImplTraits> stream_LEFT_PAREN(get_psrstate()->get_treeAdaptor(), "token LEFT_PAREN");
    RewriteRuleTokenStream<ImplTraits> stream_RIGHT_PAREN(get_psrstate()->get_treeAdaptor(), "token RIGHT_PAREN");
    RewriteRuleTokenStream<ImplTraits> stream_COMMA(get_psrstate()->get_treeAdaptor(), "token COMMA");
    RewriteRuleSubtreeStream<ImplTraits> stream_then_key(get_psrstate()->get_treeAdaptor(), "rule then_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_expression_list(get_psrstate()->get_treeAdaptor(), "rule expression_list");
    RewriteRuleSubtreeStream<ImplTraits> stream_insert_key(get_psrstate()->get_treeAdaptor(), "rule insert_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_values_key(get_psrstate()->get_treeAdaptor(), "rule values_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_where_clause(get_psrstate()->get_treeAdaptor(), "rule where_clause");
    RewriteRuleSubtreeStream<ImplTraits> stream_not_key(get_psrstate()->get_treeAdaptor(), "rule not_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_column_name(get_psrstate()->get_treeAdaptor(), "rule column_name");
    RewriteRuleSubtreeStream<ImplTraits> stream_when_key(get_psrstate()->get_treeAdaptor(), "rule when_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_matched_key(get_psrstate()->get_treeAdaptor(), "rule matched_key");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:724:5: ( when_key not_key matched_key then_key insert_key ( LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN )? values_key expression_list ( where_clause )? -> ^( MERGE_INSERT[$when_key.start] not_key matched_key then_key insert_key ^( COLUMNS ( column_name )* ) values_key expression_list ( where_clause )? ) )
        // OracleDML.g:724:10: when_key not_key matched_key then_key insert_key ( LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN )? values_key expression_list ( where_clause )?
        {
            this->followPush(FOLLOW_when_key_in_merge_insert_clause7027);
            when_key524=when_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemerge_insert_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                when_key524_last = when_key524.tree.get();
                stream_when_key.add(when_key524.tree);
            }

            this->followPush(FOLLOW_not_key_in_merge_insert_clause7029);
            not_key525=not_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemerge_insert_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                not_key525_last = not_key525.tree.get();
                stream_not_key.add(not_key525.tree);
            }

            this->followPush(FOLLOW_matched_key_in_merge_insert_clause7031);
            matched_key526=matched_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemerge_insert_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                matched_key526_last = matched_key526.tree.get();
                stream_matched_key.add(matched_key526.tree);
            }

            this->followPush(FOLLOW_then_key_in_merge_insert_clause7033);
            then_key527=then_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemerge_insert_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                then_key527_last = then_key527.tree.get();
                stream_then_key.add(then_key527.tree);
            }

            this->followPush(FOLLOW_insert_key_in_merge_insert_clause7035);
            insert_key528=insert_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemerge_insert_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                insert_key528_last = insert_key528.tree.get();
                stream_insert_key.add(insert_key528.tree);
            }

            // OracleDML.g:725:9: ( LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN )?
            {
                ANTLR_UINT32 alt185=2;
                switch ( this->LA(1) )
                {
                    case LEFT_PAREN:
                    	{
                    		alt185=1;
                    	}
                        break;
                }

                switch (alt185)
                {
            	case 1:
            	    // OracleDML.g:725:10: LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN
            	    {
            	        LEFT_PAREN529 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_merge_insert_clause7047);
            	        if  (this->hasException())
            	        {
            	            goto rulemerge_insert_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( this->get_backtracking()==0 ) stream_LEFT_PAREN.add(LEFT_PAREN529);


            	        this->followPush(FOLLOW_column_name_in_merge_insert_clause7049);
            	        column_name530=column_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemerge_insert_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            column_name530_last = column_name530.tree.get();
            	            stream_column_name.add(column_name530.tree);
            	        }

            	        // OracleDML.g:725:33: ( COMMA column_name )*

            	        for (;;)
            	        {
            	            ANTLR_UINT32 alt184=2;
            	            switch ( this->LA(1) )
            	            {
            	            case COMMA:
            	            	{
            	            		alt184=1;
            	            	}
            	                break;

            	            }

            	            switch (alt184)
            	            {
            	        	case 1:
            	        	    // OracleDML.g:725:34: COMMA column_name
            	        	    {
            	        	        COMMA531 =  this->matchToken(COMMA, &FOLLOW_COMMA_in_merge_insert_clause7052);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulemerge_insert_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }
            	        	         
            	        	        if ( this->get_backtracking()==0 ) stream_COMMA.add(COMMA531);


            	        	        this->followPush(FOLLOW_column_name_in_merge_insert_clause7054);
            	        	        column_name532=column_name();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulemerge_insert_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) 
            	        	        {
            	        	            column_name532_last = column_name532.tree.get();
            	        	            stream_column_name.add(column_name532.tree);
            	        	        }

            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop184;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop184: ; /* Jump out to here if this rule does not match */


            	        RIGHT_PAREN533 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_merge_insert_clause7058);
            	        if  (this->hasException())
            	        {
            	            goto rulemerge_insert_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( this->get_backtracking()==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN533);


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_values_key_in_merge_insert_clause7070);
            values_key534=values_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemerge_insert_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                values_key534_last = values_key534.tree.get();
                stream_values_key.add(values_key534.tree);
            }

            this->followPush(FOLLOW_expression_list_in_merge_insert_clause7072);
            expression_list535=expression_list();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemerge_insert_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                expression_list535_last = expression_list535.tree.get();
                stream_expression_list.add(expression_list535.tree);
            }

            // OracleDML.g:726:36: ( where_clause )?
            {
                ANTLR_UINT32 alt186=2;
                switch ( this->LA(1) )
                {
                    case SQL92_RESERVED_WHERE:
                    	{
                    		alt186=1;
                    	}
                        break;
                }

                switch (alt186)
                {
            	case 1:
            	    // OracleDML.g:726:36: where_clause
            	    {
            	        this->followPush(FOLLOW_where_clause_in_merge_insert_clause7074);
            	        where_clause536=where_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemerge_insert_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            where_clause536_last = where_clause536.tree.get();
            	            stream_where_clause.add(where_clause536.tree);
            	        }

            	    }
            	    break;

                }
            }

            // AST REWRITE
            // elements: values_key, expression_list, column_name, matched_key, then_key, where_clause, insert_key, not_key
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 727:9: -> ^( MERGE_INSERT[$when_key.start] not_key matched_key then_key insert_key ^( COLUMNS ( column_name )* ) values_key expression_list ( where_clause )? )
            {
            	// OracleDML.g:727:12: ^( MERGE_INSERT[$when_key.start] not_key matched_key then_key insert_key ^( COLUMNS ( column_name )* ) values_key expression_list ( where_clause )? )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(MERGE_INSERT, (when_key524.start)), root_1);
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_not_key.nextTree());
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_matched_key.nextTree());
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_then_key.nextTree());
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_insert_key.nextTree());
            	// OracleDML.g:727:84: ^( COLUMNS ( column_name )* )
            	{
            	ImplTraits::TreeTypePtr root_2 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_2 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(COLUMNS, "COLUMNS"), root_2);
            	// OracleDML.g:727:94: ( column_name )*
            	while ( stream_column_name.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_2, stream_column_name.nextTree());
            	}
            	stream_column_name.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_1, root_2);
            	}
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_values_key.nextTree());
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_expression_list.nextTree());
            	// OracleDML.g:727:135: ( where_clause )?
            	if ( stream_where_clause.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_where_clause.nextTree());
            	}
            	stream_where_clause.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulemerge_insert_clauseEx; /* Prevent compiler warnings */
    rulemerge_insert_clauseEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end merge_insert_clause */

/**
 * $ANTLR start selected_tableview
 * OracleDML.g:730:1: selected_tableview : ( tableview_name | LEFT_PAREN select_statement RIGHT_PAREN ) ( table_alias )? -> ^( SELECTED_TABLEVIEW ( tableview_name )? ( select_statement )? ( table_alias )? ) ;
 */
OracleDML::selected_tableview_return
OracleDML::selected_tableview()
{
    OracleDML::selected_tableview_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* LEFT_PAREN538 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN540 = NULL;
    OracleDML_OracleDMLCommons::tableview_name_return tableview_name537;
    ImplTraits::TreeTypePtr::pointer tableview_name537_last = NULL;
    OracleDML::select_statement_return select_statement539;
    ImplTraits::TreeTypePtr::pointer select_statement539_last = NULL;
    OracleDML_OracleDMLCommons::table_alias_return table_alias541;
    ImplTraits::TreeTypePtr::pointer table_alias541_last = NULL;
    ImplTraits::TreeTypePtr LEFT_PAREN538_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN540_tree;
    RewriteRuleTokenStream<ImplTraits> stream_LEFT_PAREN(get_psrstate()->get_treeAdaptor(), "token LEFT_PAREN");
    RewriteRuleTokenStream<ImplTraits> stream_RIGHT_PAREN(get_psrstate()->get_treeAdaptor(), "token RIGHT_PAREN");
    RewriteRuleSubtreeStream<ImplTraits> stream_table_alias(get_psrstate()->get_treeAdaptor(), "rule table_alias");
    RewriteRuleSubtreeStream<ImplTraits> stream_select_statement(get_psrstate()->get_treeAdaptor(), "rule select_statement");
    RewriteRuleSubtreeStream<ImplTraits> stream_tableview_name(get_psrstate()->get_treeAdaptor(), "rule tableview_name");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:731:5: ( ( tableview_name | LEFT_PAREN select_statement RIGHT_PAREN ) ( table_alias )? -> ^( SELECTED_TABLEVIEW ( tableview_name )? ( select_statement )? ( table_alias )? ) )
        // OracleDML.g:731:10: ( tableview_name | LEFT_PAREN select_statement RIGHT_PAREN ) ( table_alias )?
        {
            // OracleDML.g:731:10: ( tableview_name | LEFT_PAREN select_statement RIGHT_PAREN )
            {
                ANTLR_UINT32 alt187=2;
                switch ( this->LA(1) )
                {
                case DELIMITED_ID:
                case INTRODUCER:
                case REGULAR_ID:
                	{
                		alt187=1;
                	}
                    break;
                case LEFT_PAREN:
                	{
                		alt187=2;
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return retval;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 187 );
                    ex->set_state( 0 );


                    goto ruleselected_tableviewEx;

                }

                switch (alt187)
                {
            	case 1:
            	    // OracleDML.g:731:12: tableview_name
            	    {
            	        this->followPush(FOLLOW_tableview_name_in_selected_tableview7135);
            	        tableview_name537=tableview_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleselected_tableviewEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            tableview_name537_last = tableview_name537.tree.get();
            	            stream_tableview_name.add(tableview_name537.tree);
            	        }

            	    }
            	    break;
            	case 2:
            	    // OracleDML.g:731:29: LEFT_PAREN select_statement RIGHT_PAREN
            	    {
            	        LEFT_PAREN538 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_selected_tableview7139);
            	        if  (this->hasException())
            	        {
            	            goto ruleselected_tableviewEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( this->get_backtracking()==0 ) stream_LEFT_PAREN.add(LEFT_PAREN538);


            	        this->followPush(FOLLOW_select_statement_in_selected_tableview7141);
            	        select_statement539=select_statement();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleselected_tableviewEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            select_statement539_last = select_statement539.tree.get();
            	            stream_select_statement.add(select_statement539.tree);
            	        }

            	        RIGHT_PAREN540 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_selected_tableview7143);
            	        if  (this->hasException())
            	        {
            	            goto ruleselected_tableviewEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( this->get_backtracking()==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN540);


            	    }
            	    break;

                }
            }

            // OracleDML.g:731:70: ( table_alias )?
            {
                ANTLR_UINT32 alt188=2;
                switch ( this->LA(1) )
                {
                    case CHAR_STRING:
                    case CHAR_STRING_PERL:
                    case DELIMITED_ID:
                    case INTRODUCER:
                    case NATIONAL_CHAR_STRING_LIT:
                    case REGULAR_ID:
                    	{
                    		alt188=1;
                    	}
                        break;
                }

                switch (alt188)
                {
            	case 1:
            	    // OracleDML.g:731:70: table_alias
            	    {
            	        this->followPush(FOLLOW_table_alias_in_selected_tableview7146);
            	        table_alias541=table_alias();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleselected_tableviewEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            table_alias541_last = table_alias541.tree.get();
            	            stream_table_alias.add(table_alias541.tree);
            	        }

            	    }
            	    break;

                }
            }

            // AST REWRITE
            // elements: select_statement, table_alias, tableview_name
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 732:9: -> ^( SELECTED_TABLEVIEW ( tableview_name )? ( select_statement )? ( table_alias )? )
            {
            	// OracleDML.g:732:12: ^( SELECTED_TABLEVIEW ( tableview_name )? ( select_statement )? ( table_alias )? )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(SELECTED_TABLEVIEW, "SELECTED_TABLEVIEW"), root_1);
            	// OracleDML.g:732:33: ( tableview_name )?
            	if ( stream_tableview_name.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_tableview_name.nextTree());
            	}
            	stream_tableview_name.reset();

            	// OracleDML.g:732:49: ( select_statement )?
            	if ( stream_select_statement.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_select_statement.nextTree());
            	}
            	stream_select_statement.reset();

            	// OracleDML.g:732:67: ( table_alias )?
            	if ( stream_table_alias.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_table_alias.nextTree());
            	}
            	stream_table_alias.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleselected_tableviewEx; /* Prevent compiler warnings */
    ruleselected_tableviewEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end selected_tableview */

/**
 * $ANTLR start lock_table_statement
 * OracleDML.g:737:1: lock_table_statement : lock_key table_key lock_table_element ( COMMA lock_table_element )* in_key lock_mode mode_key ( wait_nowait_part )? -> ^( lock_key ( lock_table_element )+ lock_mode ( wait_nowait_part )? ) ;
 */
OracleDML::lock_table_statement_return
OracleDML::lock_table_statement()
{
    OracleDML::lock_table_statement_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* COMMA545 = NULL;
    OracleDML_OracleDMLKeys::lock_key_return lock_key542;
    ImplTraits::TreeTypePtr::pointer lock_key542_last = NULL;
    OracleDML_OracleDMLKeys::table_key_return table_key543;
    ImplTraits::TreeTypePtr::pointer table_key543_last = NULL;
    OracleDML::lock_table_element_return lock_table_element544;
    ImplTraits::TreeTypePtr::pointer lock_table_element544_last = NULL;
    OracleDML::lock_table_element_return lock_table_element546;
    ImplTraits::TreeTypePtr::pointer lock_table_element546_last = NULL;
    OracleDML_OracleDMLKeys::in_key_return in_key547;
    ImplTraits::TreeTypePtr::pointer in_key547_last = NULL;
    OracleDML::lock_mode_return lock_mode548;
    ImplTraits::TreeTypePtr::pointer lock_mode548_last = NULL;
    OracleDML_OracleDMLKeys::mode_key_return mode_key549;
    ImplTraits::TreeTypePtr::pointer mode_key549_last = NULL;
    OracleDML::wait_nowait_part_return wait_nowait_part550;
    ImplTraits::TreeTypePtr::pointer wait_nowait_part550_last = NULL;
    ImplTraits::TreeTypePtr COMMA545_tree;
    RewriteRuleTokenStream<ImplTraits> stream_COMMA(get_psrstate()->get_treeAdaptor(), "token COMMA");
    RewriteRuleSubtreeStream<ImplTraits> stream_lock_table_element(get_psrstate()->get_treeAdaptor(), "rule lock_table_element");
    RewriteRuleSubtreeStream<ImplTraits> stream_mode_key(get_psrstate()->get_treeAdaptor(), "rule mode_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_table_key(get_psrstate()->get_treeAdaptor(), "rule table_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_lock_mode(get_psrstate()->get_treeAdaptor(), "rule lock_mode");
    RewriteRuleSubtreeStream<ImplTraits> stream_wait_nowait_part(get_psrstate()->get_treeAdaptor(), "rule wait_nowait_part");
    RewriteRuleSubtreeStream<ImplTraits> stream_lock_key(get_psrstate()->get_treeAdaptor(), "rule lock_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_in_key(get_psrstate()->get_treeAdaptor(), "rule in_key");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:738:5: ( lock_key table_key lock_table_element ( COMMA lock_table_element )* in_key lock_mode mode_key ( wait_nowait_part )? -> ^( lock_key ( lock_table_element )+ lock_mode ( wait_nowait_part )? ) )
        // OracleDML.g:738:10: lock_key table_key lock_table_element ( COMMA lock_table_element )* in_key lock_mode mode_key ( wait_nowait_part )?
        {
            this->followPush(FOLLOW_lock_key_in_lock_table_statement7192);
            lock_key542=lock_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulelock_table_statementEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                lock_key542_last = lock_key542.tree.get();
                stream_lock_key.add(lock_key542.tree);
            }

            this->followPush(FOLLOW_table_key_in_lock_table_statement7194);
            table_key543=table_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulelock_table_statementEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                table_key543_last = table_key543.tree.get();
                stream_table_key.add(table_key543.tree);
            }

            this->followPush(FOLLOW_lock_table_element_in_lock_table_statement7205);
            lock_table_element544=lock_table_element();

            this->followPop();
            if  (this->hasException())
            {
                goto rulelock_table_statementEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                lock_table_element544_last = lock_table_element544.tree.get();
                stream_lock_table_element.add(lock_table_element544.tree);
            }

            // OracleDML.g:739:28: ( COMMA lock_table_element )*

            for (;;)
            {
                ANTLR_UINT32 alt189=2;
                switch ( this->LA(1) )
                {
                case COMMA:
                	{
                		alt189=1;
                	}
                    break;

                }

                switch (alt189)
                {
            	case 1:
            	    // OracleDML.g:739:29: COMMA lock_table_element
            	    {
            	        COMMA545 =  this->matchToken(COMMA, &FOLLOW_COMMA_in_lock_table_statement7208);
            	        if  (this->hasException())
            	        {
            	            goto rulelock_table_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( this->get_backtracking()==0 ) stream_COMMA.add(COMMA545);


            	        this->followPush(FOLLOW_lock_table_element_in_lock_table_statement7210);
            	        lock_table_element546=lock_table_element();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulelock_table_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            lock_table_element546_last = lock_table_element546.tree.get();
            	            stream_lock_table_element.add(lock_table_element546.tree);
            	        }

            	    }
            	    break;

            	default:
            	    goto loop189;	/* break out of the loop */
            	    break;
                }
            }
            loop189: ; /* Jump out to here if this rule does not match */


            this->followPush(FOLLOW_in_key_in_lock_table_statement7223);
            in_key547=in_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulelock_table_statementEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                in_key547_last = in_key547.tree.get();
                stream_in_key.add(in_key547.tree);
            }

            this->followPush(FOLLOW_lock_mode_in_lock_table_statement7225);
            lock_mode548=lock_mode();

            this->followPop();
            if  (this->hasException())
            {
                goto rulelock_table_statementEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                lock_mode548_last = lock_mode548.tree.get();
                stream_lock_mode.add(lock_mode548.tree);
            }

            this->followPush(FOLLOW_mode_key_in_lock_table_statement7227);
            mode_key549=mode_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulelock_table_statementEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                mode_key549_last = mode_key549.tree.get();
                stream_mode_key.add(mode_key549.tree);
            }

            // OracleDML.g:740:35: ( wait_nowait_part )?
            {
                ANTLR_UINT32 alt190=2;
                {
                    ANTLR_UINT32 LA190_0 = this->LA(1);
                    if ( (LA190_0 == REGULAR_ID) && ((toUpper(LT(1)->getText()) == "WAIT")))
                    {
                        alt190=1;
                    }
                    else if ( (LA190_0 == PLSQL_RESERVED_NOWAIT))
                    {
                        alt190=1;
                    }
                }
                switch (alt190)
                {
            	case 1:
            	    // OracleDML.g:740:35: wait_nowait_part
            	    {
            	        this->followPush(FOLLOW_wait_nowait_part_in_lock_table_statement7229);
            	        wait_nowait_part550=wait_nowait_part();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulelock_table_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            wait_nowait_part550_last = wait_nowait_part550.tree.get();
            	            stream_wait_nowait_part.add(wait_nowait_part550.tree);
            	        }

            	    }
            	    break;

                }
            }

            // AST REWRITE
            // elements: lock_key, lock_table_element, lock_mode, wait_nowait_part
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 741:9: -> ^( lock_key ( lock_table_element )+ lock_mode ( wait_nowait_part )? )
            {
            	// OracleDML.g:741:12: ^( lock_key ( lock_table_element )+ lock_mode ( wait_nowait_part )? )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(stream_lock_key.nextNode(), root_1);
            	if ( !(stream_lock_table_element.hasNext()) ) {
            		ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, REWRITE_EARLY_EXCEPTION, StreamType>( this->get_rec(), "lock_table_element empty" );
            		goto rulelock_table_statementEx;
            	}
            	while ( stream_lock_table_element.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_lock_table_element.nextTree());
            	}
            	stream_lock_table_element.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_lock_mode.nextTree());
            	// OracleDML.g:741:53: ( wait_nowait_part )?
            	if ( stream_wait_nowait_part.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_wait_nowait_part.nextTree());
            	}
            	stream_wait_nowait_part.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulelock_table_statementEx; /* Prevent compiler warnings */
    rulelock_table_statementEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end lock_table_statement */

/**
 * $ANTLR start wait_nowait_part
 * OracleDML.g:744:1: wait_nowait_part : ( wait_key expression -> ^( wait_key ^( EXPR expression ) ) | nowait_key );
 */
OracleDML::wait_nowait_part_return
OracleDML::wait_nowait_part()
{
    OracleDML::wait_nowait_part_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML_OracleDMLKeys::wait_key_return wait_key551;
    ImplTraits::TreeTypePtr::pointer wait_key551_last = NULL;
    OracleDML::expression_return expression552;
    ImplTraits::TreeTypePtr::pointer expression552_last = NULL;
    OracleDML_OracleDMLKeys::nowait_key_return nowait_key553;
    ImplTraits::TreeTypePtr::pointer nowait_key553_last = NULL;
    RewriteRuleSubtreeStream<ImplTraits> stream_expression(get_psrstate()->get_treeAdaptor(), "rule expression");
    RewriteRuleSubtreeStream<ImplTraits> stream_wait_key(get_psrstate()->get_treeAdaptor(), "rule wait_key");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        {
            //  OracleDML.g:745:5: ( wait_key expression -> ^( wait_key ^( EXPR expression ) ) | nowait_key )

            ANTLR_UINT32 alt191;

            alt191=2;

            {
                ANTLR_UINT32 LA191_0 = this->LA(1);
                if ( (LA191_0 == REGULAR_ID) && ((toUpper(LT(1)->getText()) == "WAIT")))
                {
                    alt191=1;
                }
                else if ( (LA191_0 == PLSQL_RESERVED_NOWAIT))
                {
                    alt191=2;
                }
                else
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return retval;
                    }


                    ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 191 );
                    ex->set_state( 0 );


                    goto rulewait_nowait_partEx;

                }
            }
            switch (alt191)
            {
        	case 1:
        	    // OracleDML.g:745:10: wait_key expression
        	    {
        	        this->followPush(FOLLOW_wait_key_in_wait_nowait_part7272);
        	        wait_key551=wait_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulewait_nowait_partEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) 
        	        {
        	            wait_key551_last = wait_key551.tree.get();
        	            stream_wait_key.add(wait_key551.tree);
        	        }

        	        this->followPush(FOLLOW_expression_in_wait_nowait_part7274);
        	        expression552=expression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulewait_nowait_partEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) 
        	        {
        	            expression552_last = expression552.tree.get();
        	            stream_expression.add(expression552.tree);
        	        }

        	        // AST REWRITE
        	        // elements: expression, wait_key
        	        // token labels: 
        	        // rule labels: retval
        	        // token list labels: 
        	        // rule list labels: 
        	        // wildcard labels: 
        	        if ( this->get_backtracking()==0 ) {
        	        retval.tree = std::move(root_0);
        	        RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
        	        // 745:30: -> ^( wait_key ^( EXPR expression ) )
        	        {
        	        	// OracleDML.g:745:33: ^( wait_key ^( EXPR expression ) )
        	        	{
        	        	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
        	        	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(stream_wait_key.nextNode(), root_1);
        	        	// OracleDML.g:745:44: ^( EXPR expression )
        	        	{
        	        	ImplTraits::TreeTypePtr root_2 = get_psrstate()->get_treeAdaptor()->nilNode();
        	        	root_2 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(EXPR, "EXPR"), root_2);
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_2, stream_expression.nextTree());
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_1, root_2);
        	        	}
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
        	        	}
        	        }


        	        //retval.tree = std::move(root_0);
        	        }

        	    }
        	    break;
        	case 2:
        	    // OracleDML.g:746:10: nowait_key
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_nowait_key_in_wait_nowait_part7297);
        	        nowait_key553=nowait_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulewait_nowait_partEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, nowait_key553.tree);


        	    }
        	    break;

            }
        }
    }//...
    // This is where rules clean up and exit
    //
    goto rulewait_nowait_partEx; /* Prevent compiler warnings */
    rulewait_nowait_partEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end wait_nowait_part */

/**
 * $ANTLR start lock_table_element
 * OracleDML.g:751:1: lock_table_element : tableview_name ( partition_extension_clause )? -> ^( LOCK_TABLE_ELEMENT tableview_name ( partition_extension_clause )? ) ;
 */
OracleDML::lock_table_element_return
OracleDML::lock_table_element()
{
    OracleDML::lock_table_element_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML_OracleDMLCommons::tableview_name_return tableview_name554;
    ImplTraits::TreeTypePtr::pointer tableview_name554_last = NULL;
    OracleDML_OracleDMLCommons::partition_extension_clause_return partition_extension_clause555;
    ImplTraits::TreeTypePtr::pointer partition_extension_clause555_last = NULL;
    RewriteRuleSubtreeStream<ImplTraits> stream_partition_extension_clause(get_psrstate()->get_treeAdaptor(), "rule partition_extension_clause");
    RewriteRuleSubtreeStream<ImplTraits> stream_tableview_name(get_psrstate()->get_treeAdaptor(), "rule tableview_name");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:752:5: ( tableview_name ( partition_extension_clause )? -> ^( LOCK_TABLE_ELEMENT tableview_name ( partition_extension_clause )? ) )
        // OracleDML.g:752:10: tableview_name ( partition_extension_clause )?
        {
            this->followPush(FOLLOW_tableview_name_in_lock_table_element7319);
            tableview_name554=tableview_name();

            this->followPop();
            if  (this->hasException())
            {
                goto rulelock_table_elementEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                tableview_name554_last = tableview_name554.tree.get();
                stream_tableview_name.add(tableview_name554.tree);
            }

            // OracleDML.g:752:25: ( partition_extension_clause )?
            {
                ANTLR_UINT32 alt192=2;
                {
                    ANTLR_UINT32 LA192_0 = this->LA(1);
                    if ( (LA192_0 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "PARTITION"))||((toUpper(LT(1)->getText()) == "SUBPARTITION")))))
                    {
                        alt192=1;
                    }
                }
                switch (alt192)
                {
            	case 1:
            	    // OracleDML.g:752:25: partition_extension_clause
            	    {
            	        this->followPush(FOLLOW_partition_extension_clause_in_lock_table_element7321);
            	        partition_extension_clause555=partition_extension_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulelock_table_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            partition_extension_clause555_last = partition_extension_clause555.tree.get();
            	            stream_partition_extension_clause.add(partition_extension_clause555.tree);
            	        }

            	    }
            	    break;

                }
            }

            // AST REWRITE
            // elements: tableview_name, partition_extension_clause
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 753:9: -> ^( LOCK_TABLE_ELEMENT tableview_name ( partition_extension_clause )? )
            {
            	// OracleDML.g:753:12: ^( LOCK_TABLE_ELEMENT tableview_name ( partition_extension_clause )? )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(LOCK_TABLE_ELEMENT, "LOCK_TABLE_ELEMENT"), root_1);
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_tableview_name.nextTree());
            	// OracleDML.g:753:48: ( partition_extension_clause )?
            	if ( stream_partition_extension_clause.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_partition_extension_clause.nextTree());
            	}
            	stream_partition_extension_clause.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulelock_table_elementEx; /* Prevent compiler warnings */
    rulelock_table_elementEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end lock_table_element */

/**
 * $ANTLR start lock_mode
 * OracleDML.g:756:1: lock_mode : ( row_key share_key | row_key exclusive_key | share_key ( update_key )? | share_key row_key exclusive_key | exclusive_key );
 */
OracleDML::lock_mode_return
OracleDML::lock_mode()
{
    OracleDML::lock_mode_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML_OracleDMLKeys::row_key_return row_key556;
    ImplTraits::TreeTypePtr::pointer row_key556_last = NULL;
    OracleDML_OracleDMLKeys::share_key_return share_key557;
    ImplTraits::TreeTypePtr::pointer share_key557_last = NULL;
    OracleDML_OracleDMLKeys::row_key_return row_key558;
    ImplTraits::TreeTypePtr::pointer row_key558_last = NULL;
    OracleDML_OracleDMLKeys::exclusive_key_return exclusive_key559;
    ImplTraits::TreeTypePtr::pointer exclusive_key559_last = NULL;
    OracleDML_OracleDMLKeys::share_key_return share_key560;
    ImplTraits::TreeTypePtr::pointer share_key560_last = NULL;
    OracleDML_OracleDMLKeys::update_key_return update_key561;
    ImplTraits::TreeTypePtr::pointer update_key561_last = NULL;
    OracleDML_OracleDMLKeys::share_key_return share_key562;
    ImplTraits::TreeTypePtr::pointer share_key562_last = NULL;
    OracleDML_OracleDMLKeys::row_key_return row_key563;
    ImplTraits::TreeTypePtr::pointer row_key563_last = NULL;
    OracleDML_OracleDMLKeys::exclusive_key_return exclusive_key564;
    ImplTraits::TreeTypePtr::pointer exclusive_key564_last = NULL;
    OracleDML_OracleDMLKeys::exclusive_key_return exclusive_key565;
    ImplTraits::TreeTypePtr::pointer exclusive_key565_last = NULL;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        {
            //  OracleDML.g:757:5: ( row_key share_key | row_key exclusive_key | share_key ( update_key )? | share_key row_key exclusive_key | exclusive_key )

            ANTLR_UINT32 alt194;

            alt194=5;

            switch ( this->LA(1) )
            {
            case REGULAR_ID:
            	{
            		switch ( this->LA(2) )
            		{
            		case PLSQL_RESERVED_SHARE:
            			{
            				alt194=1;
            			}
            		    break;
            		case PLSQL_RESERVED_EXCLUSIVE:
            			{
            				alt194=2;
            			}
            		    break;

            		default:
            		    if (this->get_backtracking()>0)
            		    {
            		        this->set_failedflag( true );
            		        return retval;
            		    }

            		    ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		    ex->set_decisionNum( 194 );
            		    ex->set_state( 1 );


            		    goto rulelock_modeEx;

            		}

            	}
                break;
            case PLSQL_RESERVED_SHARE:
            	{
            		switch ( this->LA(2) )
            		{
            		case PLSQL_RESERVED_MODE:
            		case SQL92_RESERVED_UPDATE:
            			{
            				alt194=3;
            			}
            		    break;
            		case REGULAR_ID:
            			{
            				alt194=4;
            			}
            		    break;

            		default:
            		    if (this->get_backtracking()>0)
            		    {
            		        this->set_failedflag( true );
            		        return retval;
            		    }

            		    ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		    ex->set_decisionNum( 194 );
            		    ex->set_state( 2 );


            		    goto rulelock_modeEx;

            		}

            	}
                break;
            case PLSQL_RESERVED_EXCLUSIVE:
            	{
            		alt194=5;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 194 );
                ex->set_state( 0 );


                goto rulelock_modeEx;

            }

            switch (alt194)
            {
        	case 1:
        	    // OracleDML.g:757:10: row_key share_key
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_row_key_in_lock_mode7361);
        	        row_key556=row_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulelock_modeEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, row_key556.tree);


        	        this->followPush(FOLLOW_share_key_in_lock_mode7363);
        	        share_key557=share_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulelock_modeEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, share_key557.tree);


        	    }
        	    break;
        	case 2:
        	    // OracleDML.g:758:10: row_key exclusive_key
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_row_key_in_lock_mode7374);
        	        row_key558=row_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulelock_modeEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, row_key558.tree);


        	        this->followPush(FOLLOW_exclusive_key_in_lock_mode7376);
        	        exclusive_key559=exclusive_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulelock_modeEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, exclusive_key559.tree);


        	    }
        	    break;
        	case 3:
        	    // OracleDML.g:759:10: share_key ( update_key )?
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_share_key_in_lock_mode7387);
        	        share_key560=share_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulelock_modeEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, share_key560.tree);


        	        // OracleDML.g:759:20: ( update_key )?
        	        {
        	            ANTLR_UINT32 alt193=2;
        	            switch ( this->LA(1) )
        	            {
        	                case SQL92_RESERVED_UPDATE:
        	                	{
        	                		alt193=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt193)
        	            {
        	        	case 1:
        	        	    // OracleDML.g:759:20: update_key
        	        	    {
        	        	        this->followPush(FOLLOW_update_key_in_lock_mode7389);
        	        	        update_key561=update_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulelock_modeEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, update_key561.tree);


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 4:
        	    // OracleDML.g:760:10: share_key row_key exclusive_key
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_share_key_in_lock_mode7401);
        	        share_key562=share_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulelock_modeEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, share_key562.tree);


        	        this->followPush(FOLLOW_row_key_in_lock_mode7403);
        	        row_key563=row_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulelock_modeEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, row_key563.tree);


        	        this->followPush(FOLLOW_exclusive_key_in_lock_mode7405);
        	        exclusive_key564=exclusive_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulelock_modeEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, exclusive_key564.tree);


        	    }
        	    break;
        	case 5:
        	    // OracleDML.g:761:10: exclusive_key
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_exclusive_key_in_lock_mode7416);
        	        exclusive_key565=exclusive_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulelock_modeEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, exclusive_key565.tree);


        	    }
        	    break;

            }
        }
    }//...
    // This is where rules clean up and exit
    //
    goto rulelock_modeEx; /* Prevent compiler warnings */
    rulelock_modeEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end lock_mode */

/**
 * $ANTLR start general_table_ref
 * OracleDML.g:767:1: general_table_ref : ( dml_table_expression_clause | only_key LEFT_PAREN dml_table_expression_clause RIGHT_PAREN ) ( table_alias )? -> ^( TABLE_REF ( table_alias )? dml_table_expression_clause ( only_key )? ) ;
 */
OracleDML::general_table_ref_return
OracleDML::general_table_ref()
{
    OracleDML::general_table_ref_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* LEFT_PAREN568 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN570 = NULL;
    OracleDML::dml_table_expression_clause_return dml_table_expression_clause566;
    ImplTraits::TreeTypePtr::pointer dml_table_expression_clause566_last = NULL;
    OracleDML_OracleDMLKeys::only_key_return only_key567;
    ImplTraits::TreeTypePtr::pointer only_key567_last = NULL;
    OracleDML::dml_table_expression_clause_return dml_table_expression_clause569;
    ImplTraits::TreeTypePtr::pointer dml_table_expression_clause569_last = NULL;
    OracleDML_OracleDMLCommons::table_alias_return table_alias571;
    ImplTraits::TreeTypePtr::pointer table_alias571_last = NULL;
    ImplTraits::TreeTypePtr LEFT_PAREN568_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN570_tree;
    RewriteRuleTokenStream<ImplTraits> stream_LEFT_PAREN(get_psrstate()->get_treeAdaptor(), "token LEFT_PAREN");
    RewriteRuleTokenStream<ImplTraits> stream_RIGHT_PAREN(get_psrstate()->get_treeAdaptor(), "token RIGHT_PAREN");
    RewriteRuleSubtreeStream<ImplTraits> stream_dml_table_expression_clause(get_psrstate()->get_treeAdaptor(), "rule dml_table_expression_clause");
    RewriteRuleSubtreeStream<ImplTraits> stream_table_alias(get_psrstate()->get_treeAdaptor(), "rule table_alias");
    RewriteRuleSubtreeStream<ImplTraits> stream_only_key(get_psrstate()->get_treeAdaptor(), "rule only_key");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:768:5: ( ( dml_table_expression_clause | only_key LEFT_PAREN dml_table_expression_clause RIGHT_PAREN ) ( table_alias )? -> ^( TABLE_REF ( table_alias )? dml_table_expression_clause ( only_key )? ) )
        // OracleDML.g:768:10: ( dml_table_expression_clause | only_key LEFT_PAREN dml_table_expression_clause RIGHT_PAREN ) ( table_alias )?
        {
            // OracleDML.g:768:10: ( dml_table_expression_clause | only_key LEFT_PAREN dml_table_expression_clause RIGHT_PAREN )
            {
                ANTLR_UINT32 alt195=2;
                switch ( this->LA(1) )
                {
                case DELIMITED_ID:
                case INTRODUCER:
                case LEFT_PAREN:
                case SQL92_RESERVED_TABLE:
                case SQL92_RESERVED_THE:
                	{
                		alt195=1;
                	}
                    break;
                case REGULAR_ID:
                	{
                		{
                		    ANTLR_UINT32 LA195_5 = this->LA(2);
                		    if ( (!( ((toUpper(LT(1)->getText()) == "ONLY")) )))
                		    {
                		        alt195=1;
                		    }
                		    else if ( ((toUpper(LT(1)->getText()) == "ONLY")))
                		    {
                		        alt195=2;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return retval;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 195 );
                		        ex->set_state( 5 );


                		        goto rulegeneral_table_refEx;

                		    }
                		}
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return retval;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 195 );
                    ex->set_state( 0 );


                    goto rulegeneral_table_refEx;

                }

                switch (alt195)
                {
            	case 1:
            	    // OracleDML.g:768:15: dml_table_expression_clause
            	    {
            	        this->followPush(FOLLOW_dml_table_expression_clause_in_general_table_ref7444);
            	        dml_table_expression_clause566=dml_table_expression_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulegeneral_table_refEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            dml_table_expression_clause566_last = dml_table_expression_clause566.tree.get();
            	            stream_dml_table_expression_clause.add(dml_table_expression_clause566.tree);
            	        }

            	    }
            	    break;
            	case 2:
            	    // OracleDML.g:769:14: only_key LEFT_PAREN dml_table_expression_clause RIGHT_PAREN
            	    {
            	        this->followPush(FOLLOW_only_key_in_general_table_ref7459);
            	        only_key567=only_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulegeneral_table_refEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            only_key567_last = only_key567.tree.get();
            	            stream_only_key.add(only_key567.tree);
            	        }

            	        LEFT_PAREN568 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_general_table_ref7461);
            	        if  (this->hasException())
            	        {
            	            goto rulegeneral_table_refEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( this->get_backtracking()==0 ) stream_LEFT_PAREN.add(LEFT_PAREN568);


            	        this->followPush(FOLLOW_dml_table_expression_clause_in_general_table_ref7463);
            	        dml_table_expression_clause569=dml_table_expression_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulegeneral_table_refEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            dml_table_expression_clause569_last = dml_table_expression_clause569.tree.get();
            	            stream_dml_table_expression_clause.add(dml_table_expression_clause569.tree);
            	        }

            	        RIGHT_PAREN570 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_general_table_ref7465);
            	        if  (this->hasException())
            	        {
            	            goto rulegeneral_table_refEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( this->get_backtracking()==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN570);


            	    }
            	    break;

                }
            }

            // OracleDML.g:770:14: ( table_alias )?
            {
                ANTLR_UINT32 alt196=2;
                switch ( this->LA(1) )
                {
                    case CHAR_STRING:
                    case CHAR_STRING_PERL:
                    case DELIMITED_ID:
                    case INTRODUCER:
                    case NATIONAL_CHAR_STRING_LIT:
                    	{
                    		alt196=1;
                    	}
                        break;
                    case REGULAR_ID:
                    	{
                    		{
                    		    ANTLR_UINT32 LA196_2 = this->LA(2);
                    		    if ( (!( ((((toUpper(LT(1)->getText()) == "RETURN"))||((toUpper(LT(1)->getText()) == "SET"))||((toUpper(LT(1)->getText()) == "LOG"))||((toUpper(LT(1)->getText()) == "RETURNING")))) )))
                    		    {
                    		        alt196=1;
                    		    }
                    		}
                    	}
                        break;
                }

                switch (alt196)
                {
            	case 1:
            	    // OracleDML.g:770:14: table_alias
            	    {
            	        this->followPush(FOLLOW_table_alias_in_general_table_ref7480);
            	        table_alias571=table_alias();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulegeneral_table_refEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            table_alias571_last = table_alias571.tree.get();
            	            stream_table_alias.add(table_alias571.tree);
            	        }

            	    }
            	    break;

                }
            }

            // AST REWRITE
            // elements: table_alias, only_key, dml_table_expression_clause
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 771:9: -> ^( TABLE_REF ( table_alias )? dml_table_expression_clause ( only_key )? )
            {
            	// OracleDML.g:771:12: ^( TABLE_REF ( table_alias )? dml_table_expression_clause ( only_key )? )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(TABLE_REF, "TABLE_REF"), root_1);
            	// OracleDML.g:771:24: ( table_alias )?
            	if ( stream_table_alias.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_table_alias.nextTree());
            	}
            	stream_table_alias.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_dml_table_expression_clause.nextTree());
            	// OracleDML.g:771:65: ( only_key )?
            	if ( stream_only_key.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_only_key.nextTree());
            	}
            	stream_only_key.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulegeneral_table_refEx; /* Prevent compiler warnings */
    rulegeneral_table_refEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end general_table_ref */

/**
 * $ANTLR start static_returning_clause
 * OracleDML.g:774:1: static_returning_clause : ( returning_key | return_key ) expression ( COMMA expression )* into_clause -> ^( STATIC_RETURNING ( ^( EXPR expression ) )+ into_clause ) ;
 */
OracleDML::static_returning_clause_return
OracleDML::static_returning_clause()
{
    OracleDML::static_returning_clause_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* COMMA575 = NULL;
    OracleDML_OracleDMLKeys::returning_key_return returning_key572;
    ImplTraits::TreeTypePtr::pointer returning_key572_last = NULL;
    OracleDML_OracleDMLKeys::return_key_return return_key573;
    ImplTraits::TreeTypePtr::pointer return_key573_last = NULL;
    OracleDML::expression_return expression574;
    ImplTraits::TreeTypePtr::pointer expression574_last = NULL;
    OracleDML::expression_return expression576;
    ImplTraits::TreeTypePtr::pointer expression576_last = NULL;
    OracleDML_OracleDMLCommons::into_clause_return into_clause577;
    ImplTraits::TreeTypePtr::pointer into_clause577_last = NULL;
    ImplTraits::TreeTypePtr COMMA575_tree;
    RewriteRuleTokenStream<ImplTraits> stream_COMMA(get_psrstate()->get_treeAdaptor(), "token COMMA");
    RewriteRuleSubtreeStream<ImplTraits> stream_returning_key(get_psrstate()->get_treeAdaptor(), "rule returning_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_expression(get_psrstate()->get_treeAdaptor(), "rule expression");
    RewriteRuleSubtreeStream<ImplTraits> stream_return_key(get_psrstate()->get_treeAdaptor(), "rule return_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_into_clause(get_psrstate()->get_treeAdaptor(), "rule into_clause");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:775:5: ( ( returning_key | return_key ) expression ( COMMA expression )* into_clause -> ^( STATIC_RETURNING ( ^( EXPR expression ) )+ into_clause ) )
        // OracleDML.g:775:10: ( returning_key | return_key ) expression ( COMMA expression )* into_clause
        {
            // OracleDML.g:775:10: ( returning_key | return_key )
            {
                ANTLR_UINT32 alt197=2;
                switch ( this->LA(1) )
                {
                case REGULAR_ID:
                	{
                		{
                		    ANTLR_UINT32 LA197_1 = this->LA(2);
                		    if ( ((toUpper(LT(1)->getText()) == "RETURNING")))
                		    {
                		        alt197=1;
                		    }
                		    else if ( ((toUpper(LT(1)->getText()) == "RETURN")))
                		    {
                		        alt197=2;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return retval;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 197 );
                		        ex->set_state( 1 );


                		        goto rulestatic_returning_clauseEx;

                		    }
                		}
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return retval;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 197 );
                    ex->set_state( 0 );


                    goto rulestatic_returning_clauseEx;

                }

                switch (alt197)
                {
            	case 1:
            	    // OracleDML.g:775:11: returning_key
            	    {
            	        this->followPush(FOLLOW_returning_key_in_static_returning_clause7524);
            	        returning_key572=returning_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulestatic_returning_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            returning_key572_last = returning_key572.tree.get();
            	            stream_returning_key.add(returning_key572.tree);
            	        }

            	    }
            	    break;
            	case 2:
            	    // OracleDML.g:775:25: return_key
            	    {
            	        this->followPush(FOLLOW_return_key_in_static_returning_clause7526);
            	        return_key573=return_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulestatic_returning_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            return_key573_last = return_key573.tree.get();
            	            stream_return_key.add(return_key573.tree);
            	        }

            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_expression_in_static_returning_clause7529);
            expression574=expression();

            this->followPop();
            if  (this->hasException())
            {
                goto rulestatic_returning_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                expression574_last = expression574.tree.get();
                stream_expression.add(expression574.tree);
            }

            // OracleDML.g:775:48: ( COMMA expression )*

            for (;;)
            {
                ANTLR_UINT32 alt198=2;
                switch ( this->LA(1) )
                {
                case COMMA:
                	{
                		alt198=1;
                	}
                    break;

                }

                switch (alt198)
                {
            	case 1:
            	    // OracleDML.g:775:49: COMMA expression
            	    {
            	        COMMA575 =  this->matchToken(COMMA, &FOLLOW_COMMA_in_static_returning_clause7532);
            	        if  (this->hasException())
            	        {
            	            goto rulestatic_returning_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( this->get_backtracking()==0 ) stream_COMMA.add(COMMA575);


            	        this->followPush(FOLLOW_expression_in_static_returning_clause7534);
            	        expression576=expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulestatic_returning_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            expression576_last = expression576.tree.get();
            	            stream_expression.add(expression576.tree);
            	        }

            	    }
            	    break;

            	default:
            	    goto loop198;	/* break out of the loop */
            	    break;
                }
            }
            loop198: ; /* Jump out to here if this rule does not match */


            this->followPush(FOLLOW_into_clause_in_static_returning_clause7547);
            into_clause577=into_clause();

            this->followPop();
            if  (this->hasException())
            {
                goto rulestatic_returning_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                into_clause577_last = into_clause577.tree.get();
                stream_into_clause.add(into_clause577.tree);
            }

            // AST REWRITE
            // elements: into_clause, expression
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 777:9: -> ^( STATIC_RETURNING ( ^( EXPR expression ) )+ into_clause )
            {
            	// OracleDML.g:777:12: ^( STATIC_RETURNING ( ^( EXPR expression ) )+ into_clause )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(STATIC_RETURNING, "STATIC_RETURNING"), root_1);
            	if ( !(stream_expression.hasNext()) ) {
            		ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, REWRITE_EARLY_EXCEPTION, StreamType>( this->get_rec(), "expression empty" );
            		goto rulestatic_returning_clauseEx;
            	}
            	while ( stream_expression.hasNext() ) {
            		// OracleDML.g:777:31: ^( EXPR expression )
            		{
            		ImplTraits::TreeTypePtr root_2 = get_psrstate()->get_treeAdaptor()->nilNode();
            		root_2 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(EXPR, "EXPR"), root_2);
            		get_psrstate()->get_treeAdaptor()->addChild(root_2, stream_expression.nextTree());
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, root_2);
            		}
            	}
            	stream_expression.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_into_clause.nextTree());
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulestatic_returning_clauseEx; /* Prevent compiler warnings */
    rulestatic_returning_clauseEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end static_returning_clause */

/**
 * $ANTLR start error_logging_clause
 * OracleDML.g:780:1: error_logging_clause : log_key errors_key ( error_logging_into_part )? ( ( LEFT_PAREN )=> expression_wrapper )? ( error_logging_reject_part )? -> ^( log_key ( error_logging_into_part )? ( expression_wrapper )? ( error_logging_reject_part )? ) ;
 */
OracleDML::error_logging_clause_return
OracleDML::error_logging_clause()
{
    OracleDML::error_logging_clause_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML_OracleDMLKeys::log_key_return log_key578;
    ImplTraits::TreeTypePtr::pointer log_key578_last = NULL;
    OracleDML_OracleDMLKeys::errors_key_return errors_key579;
    ImplTraits::TreeTypePtr::pointer errors_key579_last = NULL;
    OracleDML::error_logging_into_part_return error_logging_into_part580;
    ImplTraits::TreeTypePtr::pointer error_logging_into_part580_last = NULL;
    OracleDML::expression_wrapper_return expression_wrapper581;
    ImplTraits::TreeTypePtr::pointer expression_wrapper581_last = NULL;
    OracleDML::error_logging_reject_part_return error_logging_reject_part582;
    ImplTraits::TreeTypePtr::pointer error_logging_reject_part582_last = NULL;
    RewriteRuleSubtreeStream<ImplTraits> stream_error_logging_reject_part(get_psrstate()->get_treeAdaptor(), "rule error_logging_reject_part");
    RewriteRuleSubtreeStream<ImplTraits> stream_expression_wrapper(get_psrstate()->get_treeAdaptor(), "rule expression_wrapper");
    RewriteRuleSubtreeStream<ImplTraits> stream_errors_key(get_psrstate()->get_treeAdaptor(), "rule errors_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_error_logging_into_part(get_psrstate()->get_treeAdaptor(), "rule error_logging_into_part");
    RewriteRuleSubtreeStream<ImplTraits> stream_log_key(get_psrstate()->get_treeAdaptor(), "rule log_key");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:781:5: ( log_key errors_key ( error_logging_into_part )? ( ( LEFT_PAREN )=> expression_wrapper )? ( error_logging_reject_part )? -> ^( log_key ( error_logging_into_part )? ( expression_wrapper )? ( error_logging_reject_part )? ) )
        // OracleDML.g:781:10: log_key errors_key ( error_logging_into_part )? ( ( LEFT_PAREN )=> expression_wrapper )? ( error_logging_reject_part )?
        {
            this->followPush(FOLLOW_log_key_in_error_logging_clause7590);
            log_key578=log_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleerror_logging_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                log_key578_last = log_key578.tree.get();
                stream_log_key.add(log_key578.tree);
            }

            this->followPush(FOLLOW_errors_key_in_error_logging_clause7592);
            errors_key579=errors_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleerror_logging_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                errors_key579_last = errors_key579.tree.get();
                stream_errors_key.add(errors_key579.tree);
            }

            // OracleDML.g:782:9: ( error_logging_into_part )?
            {
                ANTLR_UINT32 alt199=2;
                alt199 = cdfa199.predict(this, this->get_rec(), this->get_istream(), cdfa199 );
                if  (this->hasException())
                {
                    goto ruleerror_logging_clauseEx;
                }
                if (this->hasFailed())
                {
                    return retval;
                }

                switch (alt199)
                {
            	case 1:
            	    // OracleDML.g:782:9: error_logging_into_part
            	    {
            	        this->followPush(FOLLOW_error_logging_into_part_in_error_logging_clause7603);
            	        error_logging_into_part580=error_logging_into_part();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleerror_logging_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            error_logging_into_part580_last = error_logging_into_part580.tree.get();
            	            stream_error_logging_into_part.add(error_logging_into_part580.tree);
            	        }

            	    }
            	    break;

                }
            }

            // OracleDML.g:783:9: ( ( LEFT_PAREN )=> expression_wrapper )?
            {
                ANTLR_UINT32 alt200=2;
                {
                    ANTLR_UINT32 LA200_0 = this->LA(1);
                    if ( (LA200_0 == SQL92_RESERVED_CURSOR) && (this->msynpred( antlr3::ClassForwarder<synpred25_OracleDML>() )))
                    {
                        alt200=1;
                    }
                    else if ( (LA200_0 == SQL92_RESERVED_NOT) && (this->msynpred( antlr3::ClassForwarder<synpred25_OracleDML>() )))
                    {
                        alt200=1;
                    }
                    else if ( (LA200_0 == MINUS_SIGN) && (this->msynpred( antlr3::ClassForwarder<synpred25_OracleDML>() )))
                    {
                        alt200=1;
                    }
                    else if ( (LA200_0 == PLUS_SIGN) && (this->msynpred( antlr3::ClassForwarder<synpred25_OracleDML>() )))
                    {
                        alt200=1;
                    }
                    else if ( (LA200_0 == SQL92_RESERVED_PRIOR) && (this->msynpred( antlr3::ClassForwarder<synpred25_OracleDML>() )))
                    {
                        alt200=1;
                    }
                    else if ( (LA200_0 == PLSQL_NON_RESERVED_CONNECT_BY_ROOT) && (this->msynpred( antlr3::ClassForwarder<synpred25_OracleDML>() )))
                    {
                        alt200=1;
                    }
                    else if ( (LA200_0 == REGULAR_ID) && ((toUpper(LT(1)->getText()) == "REJECT")))
                    {
                        {
                            ANTLR_UINT32 LA200_7 = this->LA(2);
                            if ( (this->msynpred( antlr3::ClassForwarder<synpred25_OracleDML>() )))
                            {
                                alt200=1;
                            }
                        }
                    }
                    else if ( (LA200_0 == SQL92_RESERVED_DISTINCT) && (this->msynpred( antlr3::ClassForwarder<synpred25_OracleDML>() )))
                    {
                        alt200=1;
                    }
                    else if ( (LA200_0 == SQL92_RESERVED_ALL) && (this->msynpred( antlr3::ClassForwarder<synpred25_OracleDML>() )))
                    {
                        alt200=1;
                    }
                    else if ( (LA200_0 == DELIMITED_ID) && (this->msynpred( antlr3::ClassForwarder<synpred25_OracleDML>() )))
                    {
                        alt200=1;
                    }
                    else if ( (LA200_0 == SQL92_RESERVED_CASE) && (this->msynpred( antlr3::ClassForwarder<synpred25_OracleDML>() )))
                    {
                        alt200=1;
                    }
                    else if ( (LA200_0 == SQL92_RESERVED_EXISTS) && (this->msynpred( antlr3::ClassForwarder<synpred25_OracleDML>() )))
                    {
                        alt200=1;
                    }
                    else if ( (LA200_0 == SQL92_RESERVED_ANY) && (this->msynpred( antlr3::ClassForwarder<synpred25_OracleDML>() )))
                    {
                        alt200=1;
                    }
                    else if ( (LA200_0 == PLSQL_NON_RESERVED_CAST) && (this->msynpred( antlr3::ClassForwarder<synpred25_OracleDML>() )))
                    {
                        alt200=1;
                    }
                    else if ( (LA200_0 == INTRODUCER) && (this->msynpred( antlr3::ClassForwarder<synpred25_OracleDML>() )))
                    {
                        alt200=1;
                    }
                    else if ( (LA200_0 == BINDVAR) && (this->msynpred( antlr3::ClassForwarder<synpred25_OracleDML>() )))
                    {
                        alt200=1;
                    }
                    else if ( (LA200_0 == COLON) && (this->msynpred( antlr3::ClassForwarder<synpred25_OracleDML>() )))
                    {
                        alt200=1;
                    }
                    else if ( (LA200_0 == APPROXIMATE_NUM_LIT || LA200_0 == EXACT_NUM_LIT || LA200_0 == UNSIGNED_INTEGER) && (this->msynpred( antlr3::ClassForwarder<synpred25_OracleDML>() )))
                    {
                        alt200=1;
                    }
                    else if ( (LA200_0 == SQL92_RESERVED_DATE) && (this->msynpred( antlr3::ClassForwarder<synpred25_OracleDML>() )))
                    {
                        alt200=1;
                    }
                    else if ( (((LA200_0 >= CHAR_STRING) && (LA200_0 <= CHAR_STRING_PERL)) || LA200_0 == NATIONAL_CHAR_STRING_LIT) && (this->msynpred( antlr3::ClassForwarder<synpred25_OracleDML>() )))
                    {
                        alt200=1;
                    }
                    else if ( (LA200_0 == SQL92_RESERVED_NULL) && (this->msynpred( antlr3::ClassForwarder<synpred25_OracleDML>() )))
                    {
                        alt200=1;
                    }
                    else if ( (LA200_0 == SQL92_RESERVED_TRUE) && (this->msynpred( antlr3::ClassForwarder<synpred25_OracleDML>() )))
                    {
                        alt200=1;
                    }
                    else if ( (LA200_0 == SQL92_RESERVED_FALSE) && (this->msynpred( antlr3::ClassForwarder<synpred25_OracleDML>() )))
                    {
                        alt200=1;
                    }
                    else if ( (LA200_0 == SQL92_RESERVED_DEFAULT) && (this->msynpred( antlr3::ClassForwarder<synpred25_OracleDML>() )))
                    {
                        alt200=1;
                    }
                    else if ( (LA200_0 == LEFT_PAREN))
                    {
                        {
                            ANTLR_UINT32 LA200_25 = this->LA(2);
                            if ( (this->msynpred( antlr3::ClassForwarder<synpred25_OracleDML>() )))
                            {
                                alt200=1;
                            }
                        }
                    }
                }
                switch (alt200)
                {
            	case 1:
            	    // OracleDML.g:783:10: ( LEFT_PAREN )=> expression_wrapper
            	    {
            	        this->followPush(FOLLOW_expression_wrapper_in_error_logging_clause7620);
            	        expression_wrapper581=expression_wrapper();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleerror_logging_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            expression_wrapper581_last = expression_wrapper581.tree.get();
            	            stream_expression_wrapper.add(expression_wrapper581.tree);
            	        }

            	    }
            	    break;

                }
            }

            // OracleDML.g:784:9: ( error_logging_reject_part )?
            {
                ANTLR_UINT32 alt201=2;
                {
                    ANTLR_UINT32 LA201_0 = this->LA(1);
                    if ( (LA201_0 == REGULAR_ID) && ((toUpper(LT(1)->getText()) == "REJECT")))
                    {
                        alt201=1;
                    }
                }
                switch (alt201)
                {
            	case 1:
            	    // OracleDML.g:784:9: error_logging_reject_part
            	    {
            	        this->followPush(FOLLOW_error_logging_reject_part_in_error_logging_clause7632);
            	        error_logging_reject_part582=error_logging_reject_part();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleerror_logging_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            error_logging_reject_part582_last = error_logging_reject_part582.tree.get();
            	            stream_error_logging_reject_part.add(error_logging_reject_part582.tree);
            	        }

            	    }
            	    break;

                }
            }

            // AST REWRITE
            // elements: error_logging_reject_part, expression_wrapper, log_key, error_logging_into_part
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 785:9: -> ^( log_key ( error_logging_into_part )? ( expression_wrapper )? ( error_logging_reject_part )? )
            {
            	// OracleDML.g:785:12: ^( log_key ( error_logging_into_part )? ( expression_wrapper )? ( error_logging_reject_part )? )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(stream_log_key.nextNode(), root_1);
            	// OracleDML.g:785:22: ( error_logging_into_part )?
            	if ( stream_error_logging_into_part.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_error_logging_into_part.nextTree());
            	}
            	stream_error_logging_into_part.reset();

            	// OracleDML.g:785:47: ( expression_wrapper )?
            	if ( stream_expression_wrapper.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_expression_wrapper.nextTree());
            	}
            	stream_expression_wrapper.reset();

            	// OracleDML.g:785:67: ( error_logging_reject_part )?
            	if ( stream_error_logging_reject_part.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_error_logging_reject_part.nextTree());
            	}
            	stream_error_logging_reject_part.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleerror_logging_clauseEx; /* Prevent compiler warnings */
    ruleerror_logging_clauseEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end error_logging_clause */

/**
 * $ANTLR start error_logging_into_part
 * OracleDML.g:788:1: error_logging_into_part : into_key ^ tableview_name ;
 */
OracleDML::error_logging_into_part_return
OracleDML::error_logging_into_part()
{
    OracleDML::error_logging_into_part_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML_OracleDMLKeys::into_key_return into_key583;
    ImplTraits::TreeTypePtr::pointer into_key583_last = NULL;
    OracleDML_OracleDMLCommons::tableview_name_return tableview_name584;
    ImplTraits::TreeTypePtr::pointer tableview_name584_last = NULL;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:789:5: ( into_key ^ tableview_name )
        // OracleDML.g:789:10: into_key ^ tableview_name
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            this->followPush(FOLLOW_into_key_in_error_logging_into_part7676);
            into_key583=into_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleerror_logging_into_partEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(into_key583.tree, root_0);

            this->followPush(FOLLOW_tableview_name_in_error_logging_into_part7679);
            tableview_name584=tableview_name();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleerror_logging_into_partEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, tableview_name584.tree);


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleerror_logging_into_partEx; /* Prevent compiler warnings */
    ruleerror_logging_into_partEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end error_logging_into_part */

/**
 * $ANTLR start error_logging_reject_part
 * OracleDML.g:792:1: error_logging_reject_part : reject_key ^ limit_key ! ( ( unlimited_key )=> unlimited_key | expression_wrapper ) ;
 */
OracleDML::error_logging_reject_part_return
OracleDML::error_logging_reject_part()
{
    OracleDML::error_logging_reject_part_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML_OracleDMLKeys::reject_key_return reject_key585;
    ImplTraits::TreeTypePtr::pointer reject_key585_last = NULL;
    OracleDML_OracleDMLKeys::limit_key_return limit_key586;
    ImplTraits::TreeTypePtr::pointer limit_key586_last = NULL;
    OracleDML_OracleDMLKeys::unlimited_key_return unlimited_key587;
    ImplTraits::TreeTypePtr::pointer unlimited_key587_last = NULL;
    OracleDML::expression_wrapper_return expression_wrapper588;
    ImplTraits::TreeTypePtr::pointer expression_wrapper588_last = NULL;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:793:5: ( reject_key ^ limit_key ! ( ( unlimited_key )=> unlimited_key | expression_wrapper ) )
        // OracleDML.g:793:10: reject_key ^ limit_key ! ( ( unlimited_key )=> unlimited_key | expression_wrapper )
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            this->followPush(FOLLOW_reject_key_in_error_logging_reject_part7699);
            reject_key585=reject_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleerror_logging_reject_partEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(reject_key585.tree, root_0);

            this->followPush(FOLLOW_limit_key_in_error_logging_reject_part7702);
            limit_key586=limit_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleerror_logging_reject_partEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }


            // OracleDML.g:793:33: ( ( unlimited_key )=> unlimited_key | expression_wrapper )
            {
                ANTLR_UINT32 alt202=2;
                switch ( this->LA(1) )
                {
                case REGULAR_ID:
                	{
                		{
                		    ANTLR_UINT32 LA202_1 = this->LA(2);
                		    if ( (( ((toUpper(LT(1)->getText()) == "UNLIMITED")) && (this->msynpred( antlr3::ClassForwarder<synpred26_OracleDML>() )) )))
                		    {
                		        alt202=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt202=2;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return retval;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 202 );
                		        ex->set_state( 1 );


                		        goto ruleerror_logging_reject_partEx;

                		    }
                		}
                	}
                    break;
                case APPROXIMATE_NUM_LIT:
                case BINDVAR:
                case CHAR_STRING:
                case CHAR_STRING_PERL:
                case COLON:
                case DELIMITED_ID:
                case EXACT_NUM_LIT:
                case INTRODUCER:
                case LEFT_PAREN:
                case MINUS_SIGN:
                case NATIONAL_CHAR_STRING_LIT:
                case PLSQL_NON_RESERVED_CAST:
                case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
                case PLUS_SIGN:
                case SQL92_RESERVED_ALL:
                case SQL92_RESERVED_ANY:
                case SQL92_RESERVED_CASE:
                case SQL92_RESERVED_CURSOR:
                case SQL92_RESERVED_DATE:
                case SQL92_RESERVED_DEFAULT:
                case SQL92_RESERVED_DISTINCT:
                case SQL92_RESERVED_EXISTS:
                case SQL92_RESERVED_FALSE:
                case SQL92_RESERVED_NOT:
                case SQL92_RESERVED_NULL:
                case SQL92_RESERVED_PRIOR:
                case SQL92_RESERVED_TRUE:
                case UNSIGNED_INTEGER:
                	{
                		alt202=2;
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return retval;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 202 );
                    ex->set_state( 0 );


                    goto ruleerror_logging_reject_partEx;

                }

                switch (alt202)
                {
            	case 1:
            	    // OracleDML.g:793:34: ( unlimited_key )=> unlimited_key
            	    {
            	        this->followPush(FOLLOW_unlimited_key_in_error_logging_reject_part7710);
            	        unlimited_key587=unlimited_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleerror_logging_reject_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, unlimited_key587.tree);


            	    }
            	    break;
            	case 2:
            	    // OracleDML.g:793:65: expression_wrapper
            	    {
            	        this->followPush(FOLLOW_expression_wrapper_in_error_logging_reject_part7712);
            	        expression_wrapper588=expression_wrapper();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleerror_logging_reject_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, expression_wrapper588.tree);


            	    }
            	    break;

                }
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleerror_logging_reject_partEx; /* Prevent compiler warnings */
    ruleerror_logging_reject_partEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end error_logging_reject_part */

/**
 * $ANTLR start dml_table_expression_clause
 * OracleDML.g:796:1: dml_table_expression_clause : ( table_collection_expression -> ^( TABLE_EXPRESSION ^( COLLECTION_MODE table_collection_expression ) ) | LEFT_PAREN select_statement ( subquery_restriction_clause )? RIGHT_PAREN -> ^( TABLE_EXPRESSION ^( NESTED_SUBQUERY[$LEFT_PAREN] ^( SELECT_MODE select_statement ( subquery_restriction_clause )? ) RIGHT_PAREN ) ) | tableview_name ( sample_clause )? -> ^( TABLE_EXPRESSION ^( DIRECT_MODE tableview_name ( sample_clause )? ) ) );
 */
OracleDML::dml_table_expression_clause_return
OracleDML::dml_table_expression_clause()
{
    OracleDML::dml_table_expression_clause_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* LEFT_PAREN590 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN593 = NULL;
    OracleDML::table_collection_expression_return table_collection_expression589;
    ImplTraits::TreeTypePtr::pointer table_collection_expression589_last = NULL;
    OracleDML::select_statement_return select_statement591;
    ImplTraits::TreeTypePtr::pointer select_statement591_last = NULL;
    OracleDML::subquery_restriction_clause_return subquery_restriction_clause592;
    ImplTraits::TreeTypePtr::pointer subquery_restriction_clause592_last = NULL;
    OracleDML_OracleDMLCommons::tableview_name_return tableview_name594;
    ImplTraits::TreeTypePtr::pointer tableview_name594_last = NULL;
    OracleDML::sample_clause_return sample_clause595;
    ImplTraits::TreeTypePtr::pointer sample_clause595_last = NULL;
    ImplTraits::TreeTypePtr LEFT_PAREN590_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN593_tree;
    RewriteRuleTokenStream<ImplTraits> stream_LEFT_PAREN(get_psrstate()->get_treeAdaptor(), "token LEFT_PAREN");
    RewriteRuleTokenStream<ImplTraits> stream_RIGHT_PAREN(get_psrstate()->get_treeAdaptor(), "token RIGHT_PAREN");
    RewriteRuleSubtreeStream<ImplTraits> stream_sample_clause(get_psrstate()->get_treeAdaptor(), "rule sample_clause");
    RewriteRuleSubtreeStream<ImplTraits> stream_select_statement(get_psrstate()->get_treeAdaptor(), "rule select_statement");
    RewriteRuleSubtreeStream<ImplTraits> stream_table_collection_expression(get_psrstate()->get_treeAdaptor(), "rule table_collection_expression");
    RewriteRuleSubtreeStream<ImplTraits> stream_tableview_name(get_psrstate()->get_treeAdaptor(), "rule tableview_name");
    RewriteRuleSubtreeStream<ImplTraits> stream_subquery_restriction_clause(get_psrstate()->get_treeAdaptor(), "rule subquery_restriction_clause");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        {
            //  OracleDML.g:797:5: ( table_collection_expression -> ^( TABLE_EXPRESSION ^( COLLECTION_MODE table_collection_expression ) ) | LEFT_PAREN select_statement ( subquery_restriction_clause )? RIGHT_PAREN -> ^( TABLE_EXPRESSION ^( NESTED_SUBQUERY[$LEFT_PAREN] ^( SELECT_MODE select_statement ( subquery_restriction_clause )? ) RIGHT_PAREN ) ) | tableview_name ( sample_clause )? -> ^( TABLE_EXPRESSION ^( DIRECT_MODE tableview_name ( sample_clause )? ) ) )

            ANTLR_UINT32 alt205;

            alt205=3;

            switch ( this->LA(1) )
            {
            case SQL92_RESERVED_TABLE:
            case SQL92_RESERVED_THE:
            	{
            		alt205=1;
            	}
                break;
            case LEFT_PAREN:
            	{
            		alt205=2;
            	}
                break;
            case DELIMITED_ID:
            case INTRODUCER:
            case REGULAR_ID:
            	{
            		alt205=3;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 205 );
                ex->set_state( 0 );


                goto ruledml_table_expression_clauseEx;

            }

            switch (alt205)
            {
        	case 1:
        	    // OracleDML.g:797:10: table_collection_expression
        	    {
        	        this->followPush(FOLLOW_table_collection_expression_in_dml_table_expression_clause7733);
        	        table_collection_expression589=table_collection_expression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruledml_table_expression_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) 
        	        {
        	            table_collection_expression589_last = table_collection_expression589.tree.get();
        	            stream_table_collection_expression.add(table_collection_expression589.tree);
        	        }

        	        // AST REWRITE
        	        // elements: table_collection_expression
        	        // token labels: 
        	        // rule labels: retval
        	        // token list labels: 
        	        // rule list labels: 
        	        // wildcard labels: 
        	        if ( this->get_backtracking()==0 ) {
        	        retval.tree = std::move(root_0);
        	        RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
        	        // 797:38: -> ^( TABLE_EXPRESSION ^( COLLECTION_MODE table_collection_expression ) )
        	        {
        	        	// OracleDML.g:797:41: ^( TABLE_EXPRESSION ^( COLLECTION_MODE table_collection_expression ) )
        	        	{
        	        	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
        	        	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(TABLE_EXPRESSION, "TABLE_EXPRESSION"), root_1);
        	        	// OracleDML.g:797:60: ^( COLLECTION_MODE table_collection_expression )
        	        	{
        	        	ImplTraits::TreeTypePtr root_2 = get_psrstate()->get_treeAdaptor()->nilNode();
        	        	root_2 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(COLLECTION_MODE, "COLLECTION_MODE"), root_2);
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_2, stream_table_collection_expression.nextTree());
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_1, root_2);
        	        	}
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
        	        	}
        	        }


        	        //retval.tree = std::move(root_0);
        	        }

        	    }
        	    break;
        	case 2:
        	    // OracleDML.g:798:10: LEFT_PAREN select_statement ( subquery_restriction_clause )? RIGHT_PAREN
        	    {
        	        LEFT_PAREN590 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_dml_table_expression_clause7756);
        	        if  (this->hasException())
        	        {
        	            goto ruledml_table_expression_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }
        	         
        	        if ( this->get_backtracking()==0 ) stream_LEFT_PAREN.add(LEFT_PAREN590);


        	        this->followPush(FOLLOW_select_statement_in_dml_table_expression_clause7758);
        	        select_statement591=select_statement();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruledml_table_expression_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) 
        	        {
        	            select_statement591_last = select_statement591.tree.get();
        	            stream_select_statement.add(select_statement591.tree);
        	        }

        	        // OracleDML.g:798:38: ( subquery_restriction_clause )?
        	        {
        	            ANTLR_UINT32 alt203=2;
        	            switch ( this->LA(1) )
        	            {
        	                case SQL92_RESERVED_WITH:
        	                	{
        	                		alt203=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt203)
        	            {
        	        	case 1:
        	        	    // OracleDML.g:798:38: subquery_restriction_clause
        	        	    {
        	        	        this->followPush(FOLLOW_subquery_restriction_clause_in_dml_table_expression_clause7760);
        	        	        subquery_restriction_clause592=subquery_restriction_clause();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruledml_table_expression_clauseEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) 
        	        	        {
        	        	            subquery_restriction_clause592_last = subquery_restriction_clause592.tree.get();
        	        	            stream_subquery_restriction_clause.add(subquery_restriction_clause592.tree);
        	        	        }

        	        	    }
        	        	    break;

        	            }
        	        }

        	        RIGHT_PAREN593 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_dml_table_expression_clause7763);
        	        if  (this->hasException())
        	        {
        	            goto ruledml_table_expression_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }
        	         
        	        if ( this->get_backtracking()==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN593);


        	        // AST REWRITE
        	        // elements: RIGHT_PAREN, subquery_restriction_clause, select_statement
        	        // token labels: 
        	        // rule labels: retval
        	        // token list labels: 
        	        // rule list labels: 
        	        // wildcard labels: 
        	        if ( this->get_backtracking()==0 ) {
        	        retval.tree = std::move(root_0);
        	        RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
        	        // 799:10: -> ^( TABLE_EXPRESSION ^( NESTED_SUBQUERY[$LEFT_PAREN] ^( SELECT_MODE select_statement ( subquery_restriction_clause )? ) RIGHT_PAREN ) )
        	        {
        	        	// OracleDML.g:799:13: ^( TABLE_EXPRESSION ^( NESTED_SUBQUERY[$LEFT_PAREN] ^( SELECT_MODE select_statement ( subquery_restriction_clause )? ) RIGHT_PAREN ) )
        	        	{
        	        	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
        	        	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(TABLE_EXPRESSION, "TABLE_EXPRESSION"), root_1);
        	        	// OracleDML.g:799:32: ^( NESTED_SUBQUERY[$LEFT_PAREN] ^( SELECT_MODE select_statement ( subquery_restriction_clause )? ) RIGHT_PAREN )
        	        	{
        	        	ImplTraits::TreeTypePtr root_2 = get_psrstate()->get_treeAdaptor()->nilNode();
        	        	root_2 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(NESTED_SUBQUERY, LEFT_PAREN590), root_2);
        	        	// OracleDML.g:799:63: ^( SELECT_MODE select_statement ( subquery_restriction_clause )? )
        	        	{
        	        	ImplTraits::TreeTypePtr root_3 = get_psrstate()->get_treeAdaptor()->nilNode();
        	        	root_3 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(SELECT_MODE, "SELECT_MODE"), root_3);
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_3, stream_select_statement.nextTree());
        	        	// OracleDML.g:799:94: ( subquery_restriction_clause )?
        	        	if ( stream_subquery_restriction_clause.hasNext() ) {
        	        		get_psrstate()->get_treeAdaptor()->addChild(root_3, stream_subquery_restriction_clause.nextTree());
        	        	}
        	        	stream_subquery_restriction_clause.reset();

        	        	get_psrstate()->get_treeAdaptor()->addChild(root_2, root_3);
        	        	}
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_2, stream_RIGHT_PAREN.nextNode());
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_1, root_2);
        	        	}
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
        	        	}
        	        }


        	        //retval.tree = std::move(root_0);
        	        }

        	    }
        	    break;
        	case 3:
        	    // OracleDML.g:800:10: tableview_name ( sample_clause )?
        	    {
        	        this->followPush(FOLLOW_tableview_name_in_dml_table_expression_clause7805);
        	        tableview_name594=tableview_name();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruledml_table_expression_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) 
        	        {
        	            tableview_name594_last = tableview_name594.tree.get();
        	            stream_tableview_name.add(tableview_name594.tree);
        	        }

        	        // OracleDML.g:800:25: ( sample_clause )?
        	        {
        	            ANTLR_UINT32 alt204=2;
        	            switch ( this->LA(1) )
        	            {
        	                case REGULAR_ID:
        	                	{
        	                		{
        	                		    ANTLR_UINT32 LA204_1 = this->LA(2);
        	                		    if ( ((toUpper(LT(1)->getText()) == "SAMPLE")))
        	                		    {
        	                		        alt204=1;
        	                		    }
        	                		}
        	                	}
        	                    break;
        	            }

        	            switch (alt204)
        	            {
        	        	case 1:
        	        	    // OracleDML.g:800:25: sample_clause
        	        	    {
        	        	        this->followPush(FOLLOW_sample_clause_in_dml_table_expression_clause7807);
        	        	        sample_clause595=sample_clause();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruledml_table_expression_clauseEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) 
        	        	        {
        	        	            sample_clause595_last = sample_clause595.tree.get();
        	        	            stream_sample_clause.add(sample_clause595.tree);
        	        	        }

        	        	    }
        	        	    break;

        	            }
        	        }

        	        // AST REWRITE
        	        // elements: sample_clause, tableview_name
        	        // token labels: 
        	        // rule labels: retval
        	        // token list labels: 
        	        // rule list labels: 
        	        // wildcard labels: 
        	        if ( this->get_backtracking()==0 ) {
        	        retval.tree = std::move(root_0);
        	        RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
        	        // 800:40: -> ^( TABLE_EXPRESSION ^( DIRECT_MODE tableview_name ( sample_clause )? ) )
        	        {
        	        	// OracleDML.g:800:43: ^( TABLE_EXPRESSION ^( DIRECT_MODE tableview_name ( sample_clause )? ) )
        	        	{
        	        	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
        	        	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(TABLE_EXPRESSION, "TABLE_EXPRESSION"), root_1);
        	        	// OracleDML.g:800:62: ^( DIRECT_MODE tableview_name ( sample_clause )? )
        	        	{
        	        	ImplTraits::TreeTypePtr root_2 = get_psrstate()->get_treeAdaptor()->nilNode();
        	        	root_2 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(DIRECT_MODE, "DIRECT_MODE"), root_2);
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_2, stream_tableview_name.nextTree());
        	        	// OracleDML.g:800:91: ( sample_clause )?
        	        	if ( stream_sample_clause.hasNext() ) {
        	        		get_psrstate()->get_treeAdaptor()->addChild(root_2, stream_sample_clause.nextTree());
        	        	}
        	        	stream_sample_clause.reset();

        	        	get_psrstate()->get_treeAdaptor()->addChild(root_1, root_2);
        	        	}
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
        	        	}
        	        }


        	        //retval.tree = std::move(root_0);
        	        }

        	    }
        	    break;

            }
        }
    }//...
    // This is where rules clean up and exit
    //
    goto ruledml_table_expression_clauseEx; /* Prevent compiler warnings */
    ruledml_table_expression_clauseEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end dml_table_expression_clause */

/**
 * $ANTLR start table_collection_expression
 * OracleDML.g:803:1: table_collection_expression : ( table_key | the_key ) ( ( LEFT_PAREN ( select_key | with_key ) )=> LEFT_PAREN subquery RIGHT_PAREN | LEFT_PAREN expression RIGHT_PAREN ) -> ^( EXPR ( subquery )? ( expression )? ) ;
 */
OracleDML::table_collection_expression_return
OracleDML::table_collection_expression()
{
    OracleDML::table_collection_expression_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* LEFT_PAREN598 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN600 = NULL;
    ImplTraits::CommonTokenType const* LEFT_PAREN601 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN603 = NULL;
    OracleDML_OracleDMLKeys::table_key_return table_key596;
    ImplTraits::TreeTypePtr::pointer table_key596_last = NULL;
    OracleDML_OracleDMLKeys::the_key_return the_key597;
    ImplTraits::TreeTypePtr::pointer the_key597_last = NULL;
    OracleDML::subquery_return subquery599;
    ImplTraits::TreeTypePtr::pointer subquery599_last = NULL;
    OracleDML::expression_return expression602;
    ImplTraits::TreeTypePtr::pointer expression602_last = NULL;
    ImplTraits::TreeTypePtr LEFT_PAREN598_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN600_tree;
    ImplTraits::TreeTypePtr LEFT_PAREN601_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN603_tree;
    RewriteRuleTokenStream<ImplTraits> stream_LEFT_PAREN(get_psrstate()->get_treeAdaptor(), "token LEFT_PAREN");
    RewriteRuleTokenStream<ImplTraits> stream_RIGHT_PAREN(get_psrstate()->get_treeAdaptor(), "token RIGHT_PAREN");
    RewriteRuleSubtreeStream<ImplTraits> stream_expression(get_psrstate()->get_treeAdaptor(), "rule expression");
    RewriteRuleSubtreeStream<ImplTraits> stream_table_key(get_psrstate()->get_treeAdaptor(), "rule table_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_the_key(get_psrstate()->get_treeAdaptor(), "rule the_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_subquery(get_psrstate()->get_treeAdaptor(), "rule subquery");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:804:5: ( ( table_key | the_key ) ( ( LEFT_PAREN ( select_key | with_key ) )=> LEFT_PAREN subquery RIGHT_PAREN | LEFT_PAREN expression RIGHT_PAREN ) -> ^( EXPR ( subquery )? ( expression )? ) )
        // OracleDML.g:804:10: ( table_key | the_key ) ( ( LEFT_PAREN ( select_key | with_key ) )=> LEFT_PAREN subquery RIGHT_PAREN | LEFT_PAREN expression RIGHT_PAREN )
        {
            // OracleDML.g:804:10: ( table_key | the_key )
            {
                ANTLR_UINT32 alt206=2;
                switch ( this->LA(1) )
                {
                case SQL92_RESERVED_TABLE:
                	{
                		alt206=1;
                	}
                    break;
                case SQL92_RESERVED_THE:
                	{
                		alt206=2;
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return retval;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 206 );
                    ex->set_state( 0 );


                    goto ruletable_collection_expressionEx;

                }

                switch (alt206)
                {
            	case 1:
            	    // OracleDML.g:804:12: table_key
            	    {
            	        this->followPush(FOLLOW_table_key_in_table_collection_expression7845);
            	        table_key596=table_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletable_collection_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            table_key596_last = table_key596.tree.get();
            	            stream_table_key.add(table_key596.tree);
            	        }

            	    }
            	    break;
            	case 2:
            	    // OracleDML.g:804:24: the_key
            	    {
            	        this->followPush(FOLLOW_the_key_in_table_collection_expression7849);
            	        the_key597=the_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletable_collection_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            the_key597_last = the_key597.tree.get();
            	            stream_the_key.add(the_key597.tree);
            	        }

            	    }
            	    break;

                }
            }

            // OracleDML.g:805:10: ( ( LEFT_PAREN ( select_key | with_key ) )=> LEFT_PAREN subquery RIGHT_PAREN | LEFT_PAREN expression RIGHT_PAREN )
            {
                ANTLR_UINT32 alt207=2;
                switch ( this->LA(1) )
                {
                case LEFT_PAREN:
                	{
                		{
                		    ANTLR_UINT32 LA207_1 = this->LA(2);
                		    if ( (this->msynpred( antlr3::ClassForwarder<synpred27_OracleDML>() )))
                		    {
                		        alt207=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt207=2;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return retval;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 207 );
                		        ex->set_state( 1 );


                		        goto ruletable_collection_expressionEx;

                		    }
                		}
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return retval;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 207 );
                    ex->set_state( 0 );


                    goto ruletable_collection_expressionEx;

                }

                switch (alt207)
                {
            	case 1:
            	    // OracleDML.g:805:12: ( LEFT_PAREN ( select_key | with_key ) )=> LEFT_PAREN subquery RIGHT_PAREN
            	    {
            	        LEFT_PAREN598 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_table_collection_expression7877);
            	        if  (this->hasException())
            	        {
            	            goto ruletable_collection_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( this->get_backtracking()==0 ) stream_LEFT_PAREN.add(LEFT_PAREN598);


            	        this->followPush(FOLLOW_subquery_in_table_collection_expression7879);
            	        subquery599=subquery();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletable_collection_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            subquery599_last = subquery599.tree.get();
            	            stream_subquery.add(subquery599.tree);
            	        }

            	        RIGHT_PAREN600 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_table_collection_expression7881);
            	        if  (this->hasException())
            	        {
            	            goto ruletable_collection_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( this->get_backtracking()==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN600);


            	    }
            	    break;
            	case 2:
            	    // OracleDML.g:806:12: LEFT_PAREN expression RIGHT_PAREN
            	    {
            	        LEFT_PAREN601 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_table_collection_expression7894);
            	        if  (this->hasException())
            	        {
            	            goto ruletable_collection_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( this->get_backtracking()==0 ) stream_LEFT_PAREN.add(LEFT_PAREN601);


            	        this->followPush(FOLLOW_expression_in_table_collection_expression7896);
            	        expression602=expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletable_collection_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            expression602_last = expression602.tree.get();
            	            stream_expression.add(expression602.tree);
            	        }

            	        RIGHT_PAREN603 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_table_collection_expression7898);
            	        if  (this->hasException())
            	        {
            	            goto ruletable_collection_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( this->get_backtracking()==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN603);


            	    }
            	    break;

                }
            }

            // AST REWRITE
            // elements: expression, subquery
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 808:9: -> ^( EXPR ( subquery )? ( expression )? )
            {
            	// OracleDML.g:808:12: ^( EXPR ( subquery )? ( expression )? )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(EXPR, "EXPR"), root_1);
            	// OracleDML.g:808:19: ( subquery )?
            	if ( stream_subquery.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_subquery.nextTree());
            	}
            	stream_subquery.reset();

            	// OracleDML.g:808:29: ( expression )?
            	if ( stream_expression.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_expression.nextTree());
            	}
            	stream_expression.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruletable_collection_expressionEx; /* Prevent compiler warnings */
    ruletable_collection_expressionEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end table_collection_expression */

/**
 * $ANTLR start subquery_restriction_clause
 * OracleDML.g:811:1: subquery_restriction_clause : with_key ( read_key only_key | check_key option_key ( constraint_key constraint_name )? ) -> ^( with_key ( read_key )? ( check_key )? ( constraint_name )? ) ;
 */
OracleDML::subquery_restriction_clause_return
OracleDML::subquery_restriction_clause()
{
    OracleDML::subquery_restriction_clause_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML_OracleDMLKeys::with_key_return with_key604;
    ImplTraits::TreeTypePtr::pointer with_key604_last = NULL;
    OracleDML_OracleDMLKeys::read_key_return read_key605;
    ImplTraits::TreeTypePtr::pointer read_key605_last = NULL;
    OracleDML_OracleDMLKeys::only_key_return only_key606;
    ImplTraits::TreeTypePtr::pointer only_key606_last = NULL;
    OracleDML_OracleDMLKeys::check_key_return check_key607;
    ImplTraits::TreeTypePtr::pointer check_key607_last = NULL;
    OracleDML_OracleDMLKeys::option_key_return option_key608;
    ImplTraits::TreeTypePtr::pointer option_key608_last = NULL;
    OracleDML_OracleDMLKeys::constraint_key_return constraint_key609;
    ImplTraits::TreeTypePtr::pointer constraint_key609_last = NULL;
    OracleDML_OracleDMLCommons::constraint_name_return constraint_name610;
    ImplTraits::TreeTypePtr::pointer constraint_name610_last = NULL;
    RewriteRuleSubtreeStream<ImplTraits> stream_with_key(get_psrstate()->get_treeAdaptor(), "rule with_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_constraint_key(get_psrstate()->get_treeAdaptor(), "rule constraint_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_check_key(get_psrstate()->get_treeAdaptor(), "rule check_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_option_key(get_psrstate()->get_treeAdaptor(), "rule option_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_constraint_name(get_psrstate()->get_treeAdaptor(), "rule constraint_name");
    RewriteRuleSubtreeStream<ImplTraits> stream_read_key(get_psrstate()->get_treeAdaptor(), "rule read_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_only_key(get_psrstate()->get_treeAdaptor(), "rule only_key");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:812:5: ( with_key ( read_key only_key | check_key option_key ( constraint_key constraint_name )? ) -> ^( with_key ( read_key )? ( check_key )? ( constraint_name )? ) )
        // OracleDML.g:812:10: with_key ( read_key only_key | check_key option_key ( constraint_key constraint_name )? )
        {
            this->followPush(FOLLOW_with_key_in_subquery_restriction_clause7951);
            with_key604=with_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesubquery_restriction_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                with_key604_last = with_key604.tree.get();
                stream_with_key.add(with_key604.tree);
            }

            // OracleDML.g:813:5: ( read_key only_key | check_key option_key ( constraint_key constraint_name )? )
            {
                ANTLR_UINT32 alt209=2;
                {
                    ANTLR_UINT32 LA209_0 = this->LA(1);
                    if ( (LA209_0 == REGULAR_ID) && ((toUpper(LT(1)->getText()) == "READ")))
                    {
                        alt209=1;
                    }
                    else if ( (LA209_0 == SQL92_RESERVED_CHECK))
                    {
                        alt209=2;
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return retval;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 209 );
                        ex->set_state( 0 );


                        goto rulesubquery_restriction_clauseEx;

                    }
                }
                switch (alt209)
                {
            	case 1:
            	    // OracleDML.g:813:10: read_key only_key
            	    {
            	        this->followPush(FOLLOW_read_key_in_subquery_restriction_clause7962);
            	        read_key605=read_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesubquery_restriction_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            read_key605_last = read_key605.tree.get();
            	            stream_read_key.add(read_key605.tree);
            	        }

            	        this->followPush(FOLLOW_only_key_in_subquery_restriction_clause7964);
            	        only_key606=only_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesubquery_restriction_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            only_key606_last = only_key606.tree.get();
            	            stream_only_key.add(only_key606.tree);
            	        }

            	    }
            	    break;
            	case 2:
            	    // OracleDML.g:814:10: check_key option_key ( constraint_key constraint_name )?
            	    {
            	        this->followPush(FOLLOW_check_key_in_subquery_restriction_clause7975);
            	        check_key607=check_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesubquery_restriction_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            check_key607_last = check_key607.tree.get();
            	            stream_check_key.add(check_key607.tree);
            	        }

            	        this->followPush(FOLLOW_option_key_in_subquery_restriction_clause7977);
            	        option_key608=option_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesubquery_restriction_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            option_key608_last = option_key608.tree.get();
            	            stream_option_key.add(option_key608.tree);
            	        }

            	        // OracleDML.g:814:31: ( constraint_key constraint_name )?
            	        {
            	            ANTLR_UINT32 alt208=2;
            	            {
            	                ANTLR_UINT32 LA208_0 = this->LA(1);
            	                if ( (LA208_0 == REGULAR_ID) && ((toUpper(LT(1)->getText()) == "CONSTRAINT")))
            	                {
            	                    alt208=1;
            	                }
            	            }
            	            switch (alt208)
            	            {
            	        	case 1:
            	        	    // OracleDML.g:814:32: constraint_key constraint_name
            	        	    {
            	        	        this->followPush(FOLLOW_constraint_key_in_subquery_restriction_clause7980);
            	        	        constraint_key609=constraint_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulesubquery_restriction_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) 
            	        	        {
            	        	            constraint_key609_last = constraint_key609.tree.get();
            	        	            stream_constraint_key.add(constraint_key609.tree);
            	        	        }

            	        	        this->followPush(FOLLOW_constraint_name_in_subquery_restriction_clause7982);
            	        	        constraint_name610=constraint_name();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulesubquery_restriction_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) 
            	        	        {
            	        	            constraint_name610_last = constraint_name610.tree.get();
            	        	            stream_constraint_name.add(constraint_name610.tree);
            	        	        }

            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

                }
            }

            // AST REWRITE
            // elements: with_key, check_key, read_key, constraint_name
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 816:9: -> ^( with_key ( read_key )? ( check_key )? ( constraint_name )? )
            {
            	// OracleDML.g:816:12: ^( with_key ( read_key )? ( check_key )? ( constraint_name )? )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(stream_with_key.nextNode(), root_1);
            	// OracleDML.g:816:23: ( read_key )?
            	if ( stream_read_key.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_read_key.nextTree());
            	}
            	stream_read_key.reset();

            	// OracleDML.g:816:33: ( check_key )?
            	if ( stream_check_key.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_check_key.nextTree());
            	}
            	stream_check_key.reset();

            	// OracleDML.g:816:44: ( constraint_name )?
            	if ( stream_constraint_name.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_constraint_name.nextTree());
            	}
            	stream_constraint_name.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulesubquery_restriction_clauseEx; /* Prevent compiler warnings */
    rulesubquery_restriction_clauseEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end subquery_restriction_clause */

/**
 * $ANTLR start sample_clause
 * OracleDML.g:819:1: sample_clause : sample_key ( block_key )? LEFT_PAREN e1= expression ( COMMA e2= expression )? RIGHT_PAREN ( seed_part )? -> ^( sample_key ( block_key )? ^( EXPR $e1) ( ^( EXPR $e2) )? ( seed_part )? ) ;
 */
OracleDML::sample_clause_return
OracleDML::sample_clause()
{
    OracleDML::sample_clause_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* LEFT_PAREN613 = NULL;
    ImplTraits::CommonTokenType const* COMMA614 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN615 = NULL;
    OracleDML::expression_return e1;
    ImplTraits::TreeTypePtr::pointer e1_last = NULL;
    OracleDML::expression_return e2;
    ImplTraits::TreeTypePtr::pointer e2_last = NULL;
    OracleDML_OracleDMLKeys::sample_key_return sample_key611;
    ImplTraits::TreeTypePtr::pointer sample_key611_last = NULL;
    OracleDML_OracleDMLKeys::block_key_return block_key612;
    ImplTraits::TreeTypePtr::pointer block_key612_last = NULL;
    OracleDML::seed_part_return seed_part616;
    ImplTraits::TreeTypePtr::pointer seed_part616_last = NULL;
    ImplTraits::TreeTypePtr LEFT_PAREN613_tree;
    ImplTraits::TreeTypePtr COMMA614_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN615_tree;
    RewriteRuleTokenStream<ImplTraits> stream_LEFT_PAREN(get_psrstate()->get_treeAdaptor(), "token LEFT_PAREN");
    RewriteRuleTokenStream<ImplTraits> stream_RIGHT_PAREN(get_psrstate()->get_treeAdaptor(), "token RIGHT_PAREN");
    RewriteRuleTokenStream<ImplTraits> stream_COMMA(get_psrstate()->get_treeAdaptor(), "token COMMA");
    RewriteRuleSubtreeStream<ImplTraits> stream_expression(get_psrstate()->get_treeAdaptor(), "rule expression");
    RewriteRuleSubtreeStream<ImplTraits> stream_seed_part(get_psrstate()->get_treeAdaptor(), "rule seed_part");
    RewriteRuleSubtreeStream<ImplTraits> stream_sample_key(get_psrstate()->get_treeAdaptor(), "rule sample_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_block_key(get_psrstate()->get_treeAdaptor(), "rule block_key");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:820:5: ( sample_key ( block_key )? LEFT_PAREN e1= expression ( COMMA e2= expression )? RIGHT_PAREN ( seed_part )? -> ^( sample_key ( block_key )? ^( EXPR $e1) ( ^( EXPR $e2) )? ( seed_part )? ) )
        // OracleDML.g:820:10: sample_key ( block_key )? LEFT_PAREN e1= expression ( COMMA e2= expression )? RIGHT_PAREN ( seed_part )?
        {
            this->followPush(FOLLOW_sample_key_in_sample_clause8033);
            sample_key611=sample_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesample_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                sample_key611_last = sample_key611.tree.get();
                stream_sample_key.add(sample_key611.tree);
            }

            // OracleDML.g:820:21: ( block_key )?
            {
                ANTLR_UINT32 alt210=2;
                {
                    ANTLR_UINT32 LA210_0 = this->LA(1);
                    if ( (LA210_0 == REGULAR_ID) && ((toUpper(LT(1)->getText()) == "BLOCK")))
                    {
                        alt210=1;
                    }
                }
                switch (alt210)
                {
            	case 1:
            	    // OracleDML.g:820:21: block_key
            	    {
            	        this->followPush(FOLLOW_block_key_in_sample_clause8035);
            	        block_key612=block_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesample_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            block_key612_last = block_key612.tree.get();
            	            stream_block_key.add(block_key612.tree);
            	        }

            	    }
            	    break;

                }
            }

            LEFT_PAREN613 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_sample_clause8047);
            if  (this->hasException())
            {
                goto rulesample_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_LEFT_PAREN.add(LEFT_PAREN613);


            this->followPush(FOLLOW_expression_in_sample_clause8051);
            e1=expression();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesample_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                e1_last = e1.tree.get();
                stream_expression.add(e1.tree);
            }

            // OracleDML.g:821:34: ( COMMA e2= expression )?
            {
                ANTLR_UINT32 alt211=2;
                switch ( this->LA(1) )
                {
                    case COMMA:
                    	{
                    		alt211=1;
                    	}
                        break;
                }

                switch (alt211)
                {
            	case 1:
            	    // OracleDML.g:821:35: COMMA e2= expression
            	    {
            	        COMMA614 =  this->matchToken(COMMA, &FOLLOW_COMMA_in_sample_clause8054);
            	        if  (this->hasException())
            	        {
            	            goto rulesample_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( this->get_backtracking()==0 ) stream_COMMA.add(COMMA614);


            	        this->followPush(FOLLOW_expression_in_sample_clause8058);
            	        e2=expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesample_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            e2_last = e2.tree.get();
            	            stream_expression.add(e2.tree);
            	        }

            	    }
            	    break;

                }
            }

            RIGHT_PAREN615 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_sample_clause8062);
            if  (this->hasException())
            {
                goto rulesample_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN615);


            // OracleDML.g:822:9: ( seed_part )?
            {
                ANTLR_UINT32 alt212=2;
                switch ( this->LA(1) )
                {
                    case REGULAR_ID:
                    	{
                    		{
                    		    ANTLR_UINT32 LA212_1 = this->LA(2);
                    		    if ( ((toUpper(LT(1)->getText()) == "SEED")))
                    		    {
                    		        alt212=1;
                    		    }
                    		}
                    	}
                        break;
                }

                switch (alt212)
                {
            	case 1:
            	    // OracleDML.g:822:9: seed_part
            	    {
            	        this->followPush(FOLLOW_seed_part_in_sample_clause8072);
            	        seed_part616=seed_part();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesample_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            seed_part616_last = seed_part616.tree.get();
            	            stream_seed_part.add(seed_part616.tree);
            	        }

            	    }
            	    break;

                }
            }

            // AST REWRITE
            // elements: seed_part, sample_key, e1, block_key, e2
            // token labels: 
            // rule labels: retval, e1, e2
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval
            RewriteRuleSubtreeStream<ImplTraits> stream_e1(get_psrstate()->get_treeAdaptor(), "rule e1",e1_last); // rewrite alias
            RewriteRuleSubtreeStream<ImplTraits> stream_e2(get_psrstate()->get_treeAdaptor(), "rule e2",e2_last); // rewrite alias

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 823:9: -> ^( sample_key ( block_key )? ^( EXPR $e1) ( ^( EXPR $e2) )? ( seed_part )? )
            {
            	// OracleDML.g:823:12: ^( sample_key ( block_key )? ^( EXPR $e1) ( ^( EXPR $e2) )? ( seed_part )? )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(stream_sample_key.nextNode(), root_1);
            	// OracleDML.g:823:25: ( block_key )?
            	if ( stream_block_key.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_block_key.nextTree());
            	}
            	stream_block_key.reset();

            	// OracleDML.g:823:36: ^( EXPR $e1)
            	{
            	ImplTraits::TreeTypePtr root_2 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_2 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(EXPR, "EXPR"), root_2);
            	get_psrstate()->get_treeAdaptor()->addChild(root_2, stream_e1.nextTree());
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, root_2);
            	}
            	// OracleDML.g:823:48: ( ^( EXPR $e2) )?
            	if ( stream_e2.hasNext() ) {
            		// OracleDML.g:823:48: ^( EXPR $e2)
            		{
            		ImplTraits::TreeTypePtr root_2 = get_psrstate()->get_treeAdaptor()->nilNode();
            		root_2 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(EXPR, "EXPR"), root_2);
            		get_psrstate()->get_treeAdaptor()->addChild(root_2, stream_e2.nextTree());
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, root_2);
            		}
            	}
            	stream_e2.reset();

            	// OracleDML.g:823:61: ( seed_part )?
            	if ( stream_seed_part.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_seed_part.nextTree());
            	}
            	stream_seed_part.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulesample_clauseEx; /* Prevent compiler warnings */
    rulesample_clauseEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end sample_clause */

/**
 * $ANTLR start seed_part
 * OracleDML.g:826:1: seed_part : seed_key LEFT_PAREN expression RIGHT_PAREN -> ^( seed_key LEFT_PAREN ^( EXPR expression ) RIGHT_PAREN ) ;
 */
OracleDML::seed_part_return
OracleDML::seed_part()
{
    OracleDML::seed_part_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* LEFT_PAREN618 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN620 = NULL;
    OracleDML_OracleDMLKeys::seed_key_return seed_key617;
    ImplTraits::TreeTypePtr::pointer seed_key617_last = NULL;
    OracleDML::expression_return expression619;
    ImplTraits::TreeTypePtr::pointer expression619_last = NULL;
    ImplTraits::TreeTypePtr LEFT_PAREN618_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN620_tree;
    RewriteRuleTokenStream<ImplTraits> stream_LEFT_PAREN(get_psrstate()->get_treeAdaptor(), "token LEFT_PAREN");
    RewriteRuleTokenStream<ImplTraits> stream_RIGHT_PAREN(get_psrstate()->get_treeAdaptor(), "token RIGHT_PAREN");
    RewriteRuleSubtreeStream<ImplTraits> stream_expression(get_psrstate()->get_treeAdaptor(), "rule expression");
    RewriteRuleSubtreeStream<ImplTraits> stream_seed_key(get_psrstate()->get_treeAdaptor(), "rule seed_key");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:827:5: ( seed_key LEFT_PAREN expression RIGHT_PAREN -> ^( seed_key LEFT_PAREN ^( EXPR expression ) RIGHT_PAREN ) )
        // OracleDML.g:827:10: seed_key LEFT_PAREN expression RIGHT_PAREN
        {
            this->followPush(FOLLOW_seed_key_in_seed_part8128);
            seed_key617=seed_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleseed_partEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                seed_key617_last = seed_key617.tree.get();
                stream_seed_key.add(seed_key617.tree);
            }

            LEFT_PAREN618 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_seed_part8130);
            if  (this->hasException())
            {
                goto ruleseed_partEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_LEFT_PAREN.add(LEFT_PAREN618);


            this->followPush(FOLLOW_expression_in_seed_part8132);
            expression619=expression();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleseed_partEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                expression619_last = expression619.tree.get();
                stream_expression.add(expression619.tree);
            }

            RIGHT_PAREN620 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_seed_part8134);
            if  (this->hasException())
            {
                goto ruleseed_partEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN620);


            // AST REWRITE
            // elements: LEFT_PAREN, RIGHT_PAREN, seed_key, expression
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 828:9: -> ^( seed_key LEFT_PAREN ^( EXPR expression ) RIGHT_PAREN )
            {
            	// OracleDML.g:828:12: ^( seed_key LEFT_PAREN ^( EXPR expression ) RIGHT_PAREN )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(stream_seed_key.nextNode(), root_1);
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_LEFT_PAREN.nextNode());
            	// OracleDML.g:828:34: ^( EXPR expression )
            	{
            	ImplTraits::TreeTypePtr root_2 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_2 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(EXPR, "EXPR"), root_2);
            	get_psrstate()->get_treeAdaptor()->addChild(root_2, stream_expression.nextTree());
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, root_2);
            	}
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_RIGHT_PAREN.nextNode());
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleseed_partEx; /* Prevent compiler warnings */
    ruleseed_partEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end seed_part */

/**
 * $ANTLR start cursor_expression
 * OracleDML.g:834:1: cursor_expression : cursor_key LEFT_PAREN subquery RIGHT_PAREN ;
 */
OracleDML::cursor_expression_return
OracleDML::cursor_expression()
{
    OracleDML::cursor_expression_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* LEFT_PAREN622 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN624 = NULL;
    OracleDML_OracleDMLKeys::cursor_key_return cursor_key621;
    ImplTraits::TreeTypePtr::pointer cursor_key621_last = NULL;
    OracleDML::subquery_return subquery623;
    ImplTraits::TreeTypePtr::pointer subquery623_last = NULL;
    ImplTraits::TreeTypePtr LEFT_PAREN622_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN624_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:835:5: ( cursor_key LEFT_PAREN subquery RIGHT_PAREN )
        // OracleDML.g:835:10: cursor_key LEFT_PAREN subquery RIGHT_PAREN
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            this->followPush(FOLLOW_cursor_key_in_cursor_expression8181);
            cursor_key621=cursor_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecursor_expressionEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, cursor_key621.tree);


            LEFT_PAREN622 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_cursor_expression8183);
            if  (this->hasException())
            {
                goto rulecursor_expressionEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            LEFT_PAREN622_tree = std::move(get_psrstate()->get_treeAdaptor()->create(LEFT_PAREN622));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, LEFT_PAREN622_tree);
            }


            this->followPush(FOLLOW_subquery_in_cursor_expression8185);
            subquery623=subquery();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecursor_expressionEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, subquery623.tree);


            RIGHT_PAREN624 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_cursor_expression8187);
            if  (this->hasException())
            {
                goto rulecursor_expressionEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            RIGHT_PAREN624_tree = std::move(get_psrstate()->get_treeAdaptor()->create(RIGHT_PAREN624));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, RIGHT_PAREN624_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulecursor_expressionEx; /* Prevent compiler warnings */
    rulecursor_expressionEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end cursor_expression */

/**
 * $ANTLR start expression_list
 * OracleDML.g:838:1: expression_list : LEFT_PAREN ( expression )? ( COMMA expression )* RIGHT_PAREN -> ^( EXPR_LIST[$LEFT_PAREN] ( ^( EXPR expression ) )* RIGHT_PAREN ) ;
 */
OracleDML::expression_list_return
OracleDML::expression_list()
{
    OracleDML::expression_list_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* LEFT_PAREN625 = NULL;
    ImplTraits::CommonTokenType const* COMMA627 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN629 = NULL;
    OracleDML::expression_return expression626;
    ImplTraits::TreeTypePtr::pointer expression626_last = NULL;
    OracleDML::expression_return expression628;
    ImplTraits::TreeTypePtr::pointer expression628_last = NULL;
    ImplTraits::TreeTypePtr LEFT_PAREN625_tree;
    ImplTraits::TreeTypePtr COMMA627_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN629_tree;
    RewriteRuleTokenStream<ImplTraits> stream_LEFT_PAREN(get_psrstate()->get_treeAdaptor(), "token LEFT_PAREN");
    RewriteRuleTokenStream<ImplTraits> stream_RIGHT_PAREN(get_psrstate()->get_treeAdaptor(), "token RIGHT_PAREN");
    RewriteRuleTokenStream<ImplTraits> stream_COMMA(get_psrstate()->get_treeAdaptor(), "token COMMA");
    RewriteRuleSubtreeStream<ImplTraits> stream_expression(get_psrstate()->get_treeAdaptor(), "rule expression");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:839:5: ( LEFT_PAREN ( expression )? ( COMMA expression )* RIGHT_PAREN -> ^( EXPR_LIST[$LEFT_PAREN] ( ^( EXPR expression ) )* RIGHT_PAREN ) )
        // OracleDML.g:839:10: LEFT_PAREN ( expression )? ( COMMA expression )* RIGHT_PAREN
        {
            LEFT_PAREN625 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_expression_list8207);
            if  (this->hasException())
            {
                goto ruleexpression_listEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_LEFT_PAREN.add(LEFT_PAREN625);


            // OracleDML.g:839:21: ( expression )?
            {
                ANTLR_UINT32 alt213=2;
                switch ( this->LA(1) )
                {
                    case APPROXIMATE_NUM_LIT:
                    case BINDVAR:
                    case CHAR_STRING:
                    case CHAR_STRING_PERL:
                    case COLON:
                    case DELIMITED_ID:
                    case EXACT_NUM_LIT:
                    case INTRODUCER:
                    case LEFT_PAREN:
                    case MINUS_SIGN:
                    case NATIONAL_CHAR_STRING_LIT:
                    case PLSQL_NON_RESERVED_CAST:
                    case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
                    case PLUS_SIGN:
                    case REGULAR_ID:
                    case SQL92_RESERVED_ALL:
                    case SQL92_RESERVED_ANY:
                    case SQL92_RESERVED_CASE:
                    case SQL92_RESERVED_CURSOR:
                    case SQL92_RESERVED_DATE:
                    case SQL92_RESERVED_DEFAULT:
                    case SQL92_RESERVED_DISTINCT:
                    case SQL92_RESERVED_EXISTS:
                    case SQL92_RESERVED_FALSE:
                    case SQL92_RESERVED_NOT:
                    case SQL92_RESERVED_NULL:
                    case SQL92_RESERVED_PRIOR:
                    case SQL92_RESERVED_TRUE:
                    case UNSIGNED_INTEGER:
                    	{
                    		alt213=1;
                    	}
                        break;
                }

                switch (alt213)
                {
            	case 1:
            	    // OracleDML.g:839:21: expression
            	    {
            	        this->followPush(FOLLOW_expression_in_expression_list8209);
            	        expression626=expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleexpression_listEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            expression626_last = expression626.tree.get();
            	            stream_expression.add(expression626.tree);
            	        }

            	    }
            	    break;

                }
            }

            // OracleDML.g:839:33: ( COMMA expression )*

            for (;;)
            {
                ANTLR_UINT32 alt214=2;
                switch ( this->LA(1) )
                {
                case COMMA:
                	{
                		alt214=1;
                	}
                    break;

                }

                switch (alt214)
                {
            	case 1:
            	    // OracleDML.g:839:34: COMMA expression
            	    {
            	        COMMA627 =  this->matchToken(COMMA, &FOLLOW_COMMA_in_expression_list8213);
            	        if  (this->hasException())
            	        {
            	            goto ruleexpression_listEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( this->get_backtracking()==0 ) stream_COMMA.add(COMMA627);


            	        this->followPush(FOLLOW_expression_in_expression_list8215);
            	        expression628=expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleexpression_listEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            expression628_last = expression628.tree.get();
            	            stream_expression.add(expression628.tree);
            	        }

            	    }
            	    break;

            	default:
            	    goto loop214;	/* break out of the loop */
            	    break;
                }
            }
            loop214: ; /* Jump out to here if this rule does not match */


            RIGHT_PAREN629 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_expression_list8219);
            if  (this->hasException())
            {
                goto ruleexpression_listEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN629);


            // AST REWRITE
            // elements: expression, RIGHT_PAREN
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 840:9: -> ^( EXPR_LIST[$LEFT_PAREN] ( ^( EXPR expression ) )* RIGHT_PAREN )
            {
            	// OracleDML.g:840:12: ^( EXPR_LIST[$LEFT_PAREN] ( ^( EXPR expression ) )* RIGHT_PAREN )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(EXPR_LIST, LEFT_PAREN625), root_1);
            	// OracleDML.g:840:37: ( ^( EXPR expression ) )*
            	while ( stream_expression.hasNext() ) {
            		// OracleDML.g:840:37: ^( EXPR expression )
            		{
            		ImplTraits::TreeTypePtr root_2 = get_psrstate()->get_treeAdaptor()->nilNode();
            		root_2 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(EXPR, "EXPR"), root_2);
            		get_psrstate()->get_treeAdaptor()->addChild(root_2, stream_expression.nextTree());
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, root_2);
            		}
            	}
            	stream_expression.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_RIGHT_PAREN.nextNode());
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleexpression_listEx; /* Prevent compiler warnings */
    ruleexpression_listEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end expression_list */

/**
 * $ANTLR start condition
 * OracleDML.g:843:1: condition : expression ;
 */
OracleDML::condition_return
OracleDML::condition()
{
    OracleDML::condition_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML::expression_return expression630;
    ImplTraits::TreeTypePtr::pointer expression630_last = NULL;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:844:5: ( expression )
        // OracleDML.g:844:11: expression
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            this->followPush(FOLLOW_expression_in_condition8264);
            expression630=expression();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleconditionEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, expression630.tree);


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleconditionEx; /* Prevent compiler warnings */
    ruleconditionEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end condition */

/**
 * $ANTLR start condition_wrapper
 * OracleDML.g:847:1: condition_wrapper : expression -> ^( LOGIC_EXPR expression ) ;
 */
OracleDML::condition_wrapper_return
OracleDML::condition_wrapper()
{
    OracleDML::condition_wrapper_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML::expression_return expression631;
    ImplTraits::TreeTypePtr::pointer expression631_last = NULL;
    RewriteRuleSubtreeStream<ImplTraits> stream_expression(get_psrstate()->get_treeAdaptor(), "rule expression");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:848:5: ( expression -> ^( LOGIC_EXPR expression ) )
        // OracleDML.g:848:10: expression
        {
            this->followPush(FOLLOW_expression_in_condition_wrapper8284);
            expression631=expression();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecondition_wrapperEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                expression631_last = expression631.tree.get();
                stream_expression.add(expression631.tree);
            }

            // AST REWRITE
            // elements: expression
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 849:9: -> ^( LOGIC_EXPR expression )
            {
            	// OracleDML.g:849:12: ^( LOGIC_EXPR expression )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(LOGIC_EXPR, "LOGIC_EXPR"), root_1);
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_expression.nextTree());
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulecondition_wrapperEx; /* Prevent compiler warnings */
    rulecondition_wrapperEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end condition_wrapper */

/**
 * $ANTLR start logical_or_expression_seq
 * OracleDML.g:852:1: logical_or_expression_seq : ( or_key ^ logical_and_expression ) ;
 */
OracleDML::logical_or_expression_seq_return
OracleDML::logical_or_expression_seq()
{
    OracleDML::logical_or_expression_seq_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML_OracleDMLKeys::or_key_return or_key632;
    ImplTraits::TreeTypePtr::pointer or_key632_last = NULL;
    OracleDML::logical_and_expression_return logical_and_expression633;
    ImplTraits::TreeTypePtr::pointer logical_and_expression633_last = NULL;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:853:2: ( ( or_key ^ logical_and_expression ) )
        // OracleDML.g:853:7: ( or_key ^ logical_and_expression )
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            // OracleDML.g:853:7: ( or_key ^ logical_and_expression )
            // OracleDML.g:853:8: or_key ^ logical_and_expression
            {
                this->followPush(FOLLOW_or_key_in_logical_or_expression_seq8318);
                or_key632=or_key();

                this->followPop();
                if  (this->hasException())
                {
                    goto rulelogical_or_expression_seqEx;
                }
                if (this->hasFailed())
                {
                    return retval;
                }

                if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(or_key632.tree, root_0);

                this->followPush(FOLLOW_logical_and_expression_in_logical_or_expression_seq8321);
                logical_and_expression633=logical_and_expression();

                this->followPop();
                if  (this->hasException())
                {
                    goto rulelogical_or_expression_seqEx;
                }
                if (this->hasFailed())
                {
                    return retval;
                }

                if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, logical_and_expression633.tree);


            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulelogical_or_expression_seqEx; /* Prevent compiler warnings */
    rulelogical_or_expression_seqEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end logical_or_expression_seq */

/**
 * $ANTLR start expression
 * OracleDML.g:856:1: expression : ( ( cursor_key LEFT_PAREN ( select_key | with_key ) )=> cursor_expression -> cursor_expression | logical_and_expression ( logical_or_expression_seq )* -> { mode == 1 }? ^( DISJUNCTION logical_and_expression ( logical_or_expression_seq )* ) -> logical_and_expression );
 */
OracleDML::expression_return
OracleDML::expression()
{
    OracleDML::expression_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML::cursor_expression_return cursor_expression634;
    ImplTraits::TreeTypePtr::pointer cursor_expression634_last = NULL;
    OracleDML::logical_and_expression_return logical_and_expression635;
    ImplTraits::TreeTypePtr::pointer logical_and_expression635_last = NULL;
    OracleDML::logical_or_expression_seq_return logical_or_expression_seq636;
    ImplTraits::TreeTypePtr::pointer logical_or_expression_seq636_last = NULL;
    RewriteRuleSubtreeStream<ImplTraits> stream_logical_or_expression_seq(get_psrstate()->get_treeAdaptor(), "rule logical_or_expression_seq");
    RewriteRuleSubtreeStream<ImplTraits> stream_logical_and_expression(get_psrstate()->get_treeAdaptor(), "rule logical_and_expression");
    RewriteRuleSubtreeStream<ImplTraits> stream_cursor_expression(get_psrstate()->get_treeAdaptor(), "rule cursor_expression");

    /* Initialize rule variables
     */

        int mode = 0;    
    retval.call_start_placeholder(this);


 
    {
        {
            //  OracleDML.g:858:5: ( ( cursor_key LEFT_PAREN ( select_key | with_key ) )=> cursor_expression -> cursor_expression | logical_and_expression ( logical_or_expression_seq )* -> { mode == 1 }? ^( DISJUNCTION logical_and_expression ( logical_or_expression_seq )* ) -> logical_and_expression )

            ANTLR_UINT32 alt216;

            alt216=2;

            {
                ANTLR_UINT32 LA216_0 = this->LA(1);
                if ( (LA216_0 == SQL92_RESERVED_CURSOR) && (this->msynpred( antlr3::ClassForwarder<synpred28_OracleDML>() )))
                {
                    alt216=1;
                }
                else if ( (LA216_0 == APPROXIMATE_NUM_LIT || LA216_0 == BINDVAR || ((LA216_0 >= CHAR_STRING) && (LA216_0 <= CHAR_STRING_PERL)) || LA216_0 == COLON || LA216_0 == DELIMITED_ID || LA216_0 == EXACT_NUM_LIT || LA216_0 == INTRODUCER || LA216_0 == LEFT_PAREN || LA216_0 == MINUS_SIGN || LA216_0 == NATIONAL_CHAR_STRING_LIT || ((LA216_0 >= PLSQL_NON_RESERVED_CAST) && (LA216_0 <= PLSQL_NON_RESERVED_CONNECT_BY_ROOT)) || LA216_0 == PLUS_SIGN || LA216_0 == REGULAR_ID || LA216_0 == SQL92_RESERVED_ALL || LA216_0 == SQL92_RESERVED_ANY || LA216_0 == SQL92_RESERVED_CASE || LA216_0 == SQL92_RESERVED_DATE || LA216_0 == SQL92_RESERVED_DEFAULT || LA216_0 == SQL92_RESERVED_DISTINCT || ((LA216_0 >= SQL92_RESERVED_EXISTS) && (LA216_0 <= SQL92_RESERVED_FALSE)) || ((LA216_0 >= SQL92_RESERVED_NOT) && (LA216_0 <= SQL92_RESERVED_NULL)) || LA216_0 == SQL92_RESERVED_PRIOR || LA216_0 == SQL92_RESERVED_TRUE || LA216_0 == UNSIGNED_INTEGER))
                {
                    alt216=2;
                }
                else
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return retval;
                    }


                    ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 216 );
                    ex->set_state( 0 );


                    goto ruleexpressionEx;

                }
            }
            switch (alt216)
            {
        	case 1:
        	    // OracleDML.g:858:10: ( cursor_key LEFT_PAREN ( select_key | with_key ) )=> cursor_expression
        	    {
        	        this->followPush(FOLLOW_cursor_expression_in_expression8364);
        	        cursor_expression634=cursor_expression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleexpressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) 
        	        {
        	            cursor_expression634_last = cursor_expression634.tree.get();
        	            stream_cursor_expression.add(cursor_expression634.tree);
        	        }

        	        // AST REWRITE
        	        // elements: cursor_expression
        	        // token labels: 
        	        // rule labels: retval
        	        // token list labels: 
        	        // rule list labels: 
        	        // wildcard labels: 
        	        if ( this->get_backtracking()==0 ) {
        	        retval.tree = std::move(root_0);
        	        RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
        	        // 858:77: -> cursor_expression
        	        {
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_0, stream_cursor_expression.nextTree());
        	        }


        	        //retval.tree = std::move(root_0);
        	        }

        	    }
        	    break;
        	case 2:
        	    // OracleDML.g:859:10: logical_and_expression ( logical_or_expression_seq )*
        	    {
        	        this->followPush(FOLLOW_logical_and_expression_in_expression8379);
        	        logical_and_expression635=logical_and_expression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleexpressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) 
        	        {
        	            logical_and_expression635_last = logical_and_expression635.tree.get();
        	            stream_logical_and_expression.add(logical_and_expression635.tree);
        	        }

        	        // OracleDML.g:859:33: ( logical_or_expression_seq )*

        	        for (;;)
        	        {
        	            ANTLR_UINT32 alt215=2;
        	            switch ( this->LA(1) )
        	            {
        	            case SQL92_RESERVED_OR:
        	            	{
        	            		alt215=1;
        	            	}
        	                break;

        	            }

        	            switch (alt215)
        	            {
        	        	case 1:
        	        	    // OracleDML.g:859:35: logical_or_expression_seq
        	        	    {
        	        	        this->followPush(FOLLOW_logical_or_expression_seq_in_expression8383);
        	        	        logical_or_expression_seq636=logical_or_expression_seq();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleexpressionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) 
        	        	        {
        	        	            logical_or_expression_seq636_last = logical_or_expression_seq636.tree.get();
        	        	            stream_logical_or_expression_seq.add(logical_or_expression_seq636.tree);
        	        	        }

        	        	        if ( this->get_backtracking()==0 )
        	        	        {
        	        	            mode = 1; 
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop215;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop215: ; /* Jump out to here if this rule does not match */


        	        // AST REWRITE
        	        // elements: logical_or_expression_seq, logical_and_expression, logical_and_expression
        	        // token labels: 
        	        // rule labels: retval
        	        // token list labels: 
        	        // rule list labels: 
        	        // wildcard labels: 
        	        if ( this->get_backtracking()==0 ) {
        	        retval.tree = std::move(root_0);
        	        RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
        	        // 860:9: -> { mode == 1 }? ^( DISJUNCTION logical_and_expression ( logical_or_expression_seq )* )
        	        if ( mode == 1 ) {
        	        	// OracleDML.g:860:27: ^( DISJUNCTION logical_and_expression ( logical_or_expression_seq )* )
        	        	{
        	        	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
        	        	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(DISJUNCTION, "DISJUNCTION"), root_1);
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_logical_and_expression.nextTree());
        	        	// OracleDML.g:860:64: ( logical_or_expression_seq )*
        	        	while ( stream_logical_or_expression_seq.hasNext() ) {
        	        		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_logical_or_expression_seq.nextTree());
        	        	}
        	        	stream_logical_or_expression_seq.reset();

        	        	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
        	        	}
        	        }

        	        else // 861:9: -> logical_and_expression
        	        {
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_0, stream_logical_and_expression.nextTree());
        	        }


        	        //retval.tree = std::move(root_0);
        	        }

        	    }
        	    break;

            }
        }
    }//...
    // This is where rules clean up and exit
    //
    goto ruleexpressionEx; /* Prevent compiler warnings */
    ruleexpressionEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end expression */

/**
 * $ANTLR start expression_wrapper
 * OracleDML.g:864:1: expression_wrapper : expression -> ^( EXPR expression ) ;
 */
OracleDML::expression_wrapper_return
OracleDML::expression_wrapper()
{
    OracleDML::expression_wrapper_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML::expression_return expression637;
    ImplTraits::TreeTypePtr::pointer expression637_last = NULL;
    RewriteRuleSubtreeStream<ImplTraits> stream_expression(get_psrstate()->get_treeAdaptor(), "rule expression");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:865:5: ( expression -> ^( EXPR expression ) )
        // OracleDML.g:865:10: expression
        {
            this->followPush(FOLLOW_expression_in_expression_wrapper8441);
            expression637=expression();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleexpression_wrapperEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                expression637_last = expression637.tree.get();
                stream_expression.add(expression637.tree);
            }

            // AST REWRITE
            // elements: expression
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 866:9: -> ^( EXPR expression )
            {
            	// OracleDML.g:866:12: ^( EXPR expression )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(EXPR, "EXPR"), root_1);
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_expression.nextTree());
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleexpression_wrapperEx; /* Prevent compiler warnings */
    ruleexpression_wrapperEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end expression_wrapper */

/**
 * $ANTLR start logical_and_expression_seq
 * OracleDML.g:869:1: logical_and_expression_seq : ( and_key ^ negated_expression ) ;
 */
OracleDML::logical_and_expression_seq_return
OracleDML::logical_and_expression_seq()
{
    OracleDML::logical_and_expression_seq_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML_OracleDMLKeys::and_key_return and_key638;
    ImplTraits::TreeTypePtr::pointer and_key638_last = NULL;
    OracleDML::negated_expression_return negated_expression639;
    ImplTraits::TreeTypePtr::pointer negated_expression639_last = NULL;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:870:5: ( ( and_key ^ negated_expression ) )
        // OracleDML.g:870:10: ( and_key ^ negated_expression )
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            // OracleDML.g:870:10: ( and_key ^ negated_expression )
            // OracleDML.g:870:11: and_key ^ negated_expression
            {
                this->followPush(FOLLOW_and_key_in_logical_and_expression_seq8478);
                and_key638=and_key();

                this->followPop();
                if  (this->hasException())
                {
                    goto rulelogical_and_expression_seqEx;
                }
                if (this->hasFailed())
                {
                    return retval;
                }

                if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(and_key638.tree, root_0);

                this->followPush(FOLLOW_negated_expression_in_logical_and_expression_seq8481);
                negated_expression639=negated_expression();

                this->followPop();
                if  (this->hasException())
                {
                    goto rulelogical_and_expression_seqEx;
                }
                if (this->hasFailed())
                {
                    return retval;
                }

                if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, negated_expression639.tree);


            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulelogical_and_expression_seqEx; /* Prevent compiler warnings */
    rulelogical_and_expression_seqEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end logical_and_expression_seq */

/**
 * $ANTLR start logical_and_expression
 * OracleDML.g:873:1: logical_and_expression : negated_expression ( logical_and_expression_seq )* -> { mode == 1 }? ^( CONJUNCTION negated_expression ( logical_and_expression_seq )* ) -> negated_expression ;
 */
OracleDML::logical_and_expression_return
OracleDML::logical_and_expression()
{
    OracleDML::logical_and_expression_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML::negated_expression_return negated_expression640;
    ImplTraits::TreeTypePtr::pointer negated_expression640_last = NULL;
    OracleDML::logical_and_expression_seq_return logical_and_expression_seq641;
    ImplTraits::TreeTypePtr::pointer logical_and_expression_seq641_last = NULL;
    RewriteRuleSubtreeStream<ImplTraits> stream_negated_expression(get_psrstate()->get_treeAdaptor(), "rule negated_expression");
    RewriteRuleSubtreeStream<ImplTraits> stream_logical_and_expression_seq(get_psrstate()->get_treeAdaptor(), "rule logical_and_expression_seq");

    /* Initialize rule variables
     */

        int mode = 0;    
    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:875:5: ( negated_expression ( logical_and_expression_seq )* -> { mode == 1 }? ^( CONJUNCTION negated_expression ( logical_and_expression_seq )* ) -> negated_expression )
        // OracleDML.g:875:10: negated_expression ( logical_and_expression_seq )*
        {
            this->followPush(FOLLOW_negated_expression_in_logical_and_expression8510);
            negated_expression640=negated_expression();

            this->followPop();
            if  (this->hasException())
            {
                goto rulelogical_and_expressionEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                negated_expression640_last = negated_expression640.tree.get();
                stream_negated_expression.add(negated_expression640.tree);
            }

            // OracleDML.g:875:29: ( logical_and_expression_seq )*

            for (;;)
            {
                ANTLR_UINT32 alt217=2;
                switch ( this->LA(1) )
                {
                case SQL92_RESERVED_AND:
                	{
                		alt217=1;
                	}
                    break;

                }

                switch (alt217)
                {
            	case 1:
            	    // OracleDML.g:875:30: logical_and_expression_seq
            	    {
            	        this->followPush(FOLLOW_logical_and_expression_seq_in_logical_and_expression8513);
            	        logical_and_expression_seq641=logical_and_expression_seq();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulelogical_and_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            logical_and_expression_seq641_last = logical_and_expression_seq641.tree.get();
            	            stream_logical_and_expression_seq.add(logical_and_expression_seq641.tree);
            	        }

            	        if ( this->get_backtracking()==0 )
            	        {
            	            mode = 1;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop217;	/* break out of the loop */
            	    break;
                }
            }
            loop217: ; /* Jump out to here if this rule does not match */


            // AST REWRITE
            // elements: logical_and_expression_seq, negated_expression, negated_expression
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 876:10: -> { mode == 1 }? ^( CONJUNCTION negated_expression ( logical_and_expression_seq )* )
            if ( mode == 1 ) {
            	// OracleDML.g:876:28: ^( CONJUNCTION negated_expression ( logical_and_expression_seq )* )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(CONJUNCTION, "CONJUNCTION"), root_1);
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_negated_expression.nextTree());
            	// OracleDML.g:876:61: ( logical_and_expression_seq )*
            	while ( stream_logical_and_expression_seq.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_logical_and_expression_seq.nextTree());
            	}
            	stream_logical_and_expression_seq.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }

            else // 877:10: -> negated_expression
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, stream_negated_expression.nextTree());
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulelogical_and_expressionEx; /* Prevent compiler warnings */
    rulelogical_and_expressionEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end logical_and_expression */

/**
 * $ANTLR start negated_expression
 * OracleDML.g:880:1: negated_expression : ( not_key ^ negated_expression | equality_expression );
 */
OracleDML::negated_expression_return
OracleDML::negated_expression()
{
    OracleDML::negated_expression_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML_OracleDMLKeys::not_key_return not_key642;
    ImplTraits::TreeTypePtr::pointer not_key642_last = NULL;
    OracleDML::negated_expression_return negated_expression643;
    ImplTraits::TreeTypePtr::pointer negated_expression643_last = NULL;
    OracleDML::equality_expression_return equality_expression644;
    ImplTraits::TreeTypePtr::pointer equality_expression644_last = NULL;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        {
            //  OracleDML.g:881:5: ( not_key ^ negated_expression | equality_expression )

            ANTLR_UINT32 alt218;

            alt218=2;

            switch ( this->LA(1) )
            {
            case SQL92_RESERVED_NOT:
            	{
            		alt218=1;
            	}
                break;
            case APPROXIMATE_NUM_LIT:
            case BINDVAR:
            case CHAR_STRING:
            case CHAR_STRING_PERL:
            case COLON:
            case DELIMITED_ID:
            case EXACT_NUM_LIT:
            case INTRODUCER:
            case LEFT_PAREN:
            case MINUS_SIGN:
            case NATIONAL_CHAR_STRING_LIT:
            case PLSQL_NON_RESERVED_CAST:
            case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
            case PLUS_SIGN:
            case REGULAR_ID:
            case SQL92_RESERVED_ALL:
            case SQL92_RESERVED_ANY:
            case SQL92_RESERVED_CASE:
            case SQL92_RESERVED_DATE:
            case SQL92_RESERVED_DEFAULT:
            case SQL92_RESERVED_DISTINCT:
            case SQL92_RESERVED_EXISTS:
            case SQL92_RESERVED_FALSE:
            case SQL92_RESERVED_NULL:
            case SQL92_RESERVED_PRIOR:
            case SQL92_RESERVED_TRUE:
            case UNSIGNED_INTEGER:
            	{
            		alt218=2;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 218 );
                ex->set_state( 0 );


                goto rulenegated_expressionEx;

            }

            switch (alt218)
            {
        	case 1:
        	    // OracleDML.g:881:10: not_key ^ negated_expression
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_not_key_in_negated_expression8573);
        	        not_key642=not_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenegated_expressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(not_key642.tree, root_0);

        	        this->followPush(FOLLOW_negated_expression_in_negated_expression8576);
        	        negated_expression643=negated_expression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenegated_expressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, negated_expression643.tree);


        	    }
        	    break;
        	case 2:
        	    // OracleDML.g:882:10: equality_expression
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_equality_expression_in_negated_expression8587);
        	        equality_expression644=equality_expression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenegated_expressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, equality_expression644.tree);


        	    }
        	    break;

            }
        }
    }//...
    // This is where rules clean up and exit
    //
    goto rulenegated_expressionEx; /* Prevent compiler warnings */
    rulenegated_expressionEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end negated_expression */

/**
 * $ANTLR start equality_expression
 * OracleDML.g:885:1: equality_expression : ( multiset_comparsion -> multiset_comparsion ) ( is_key ( not_key )? ( null_key -> {isNegated}? ^( IS_NOT_NULL $equality_expression) -> ^( IS_NULL $equality_expression) | nan_key -> {isNegated}? ^( IS_NOT_NAN $equality_expression) -> ^( IS_NAN $equality_expression) | present_key -> {isNegated}? ^( IS_NOT_PRESENT $equality_expression) -> ^( IS_PRESENT $equality_expression) | infinite_key -> {isNegated}? ^( IS_NOT_INFINITE $equality_expression) -> ^( IS_INFINITE $equality_expression) | a_key set_key -> {isNegated}? ^( IS_NOT_A_SET $equality_expression) -> ^( IS_A_SET $equality_expression) | empty_key -> {isNegated}? ^( IS_NOT_EMPTY $equality_expression) -> ^( IS_EMPTY $equality_expression) | of_key ( type_key )? LEFT_PAREN ( only_key )? type_spec ( COMMA type_spec )* RIGHT_PAREN -> {isNegated}? ^( IS_NOT_OF_TYPE $equality_expression ( type_spec )+ ) -> ^( IS_OF_TYPE $equality_expression ( type_spec )+ ) ) )? ;
 */
OracleDML::equality_expression_return
OracleDML::equality_expression()
{
    OracleDML::equality_expression_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* LEFT_PAREN657 = NULL;
    ImplTraits::CommonTokenType const* COMMA660 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN662 = NULL;
    OracleDML::multiset_comparsion_return multiset_comparsion645;
    ImplTraits::TreeTypePtr::pointer multiset_comparsion645_last = NULL;
    OracleDML_OracleDMLKeys::is_key_return is_key646;
    ImplTraits::TreeTypePtr::pointer is_key646_last = NULL;
    OracleDML_OracleDMLKeys::not_key_return not_key647;
    ImplTraits::TreeTypePtr::pointer not_key647_last = NULL;
    OracleDML_OracleDMLKeys::null_key_return null_key648;
    ImplTraits::TreeTypePtr::pointer null_key648_last = NULL;
    OracleDML_OracleDMLKeys::nan_key_return nan_key649;
    ImplTraits::TreeTypePtr::pointer nan_key649_last = NULL;
    OracleDML_OracleDMLKeys::present_key_return present_key650;
    ImplTraits::TreeTypePtr::pointer present_key650_last = NULL;
    OracleDML_OracleDMLKeys::infinite_key_return infinite_key651;
    ImplTraits::TreeTypePtr::pointer infinite_key651_last = NULL;
    OracleDML_OracleDMLKeys::a_key_return a_key652;
    ImplTraits::TreeTypePtr::pointer a_key652_last = NULL;
    OracleDML_OracleDMLKeys::set_key_return set_key653;
    ImplTraits::TreeTypePtr::pointer set_key653_last = NULL;
    OracleDML_OracleDMLKeys::empty_key_return empty_key654;
    ImplTraits::TreeTypePtr::pointer empty_key654_last = NULL;
    OracleDML_OracleDMLKeys::of_key_return of_key655;
    ImplTraits::TreeTypePtr::pointer of_key655_last = NULL;
    OracleDML_OracleDMLKeys::type_key_return type_key656;
    ImplTraits::TreeTypePtr::pointer type_key656_last = NULL;
    OracleDML_OracleDMLKeys::only_key_return only_key658;
    ImplTraits::TreeTypePtr::pointer only_key658_last = NULL;
    OracleDML_OracleDMLCommons::type_spec_return type_spec659;
    ImplTraits::TreeTypePtr::pointer type_spec659_last = NULL;
    OracleDML_OracleDMLCommons::type_spec_return type_spec661;
    ImplTraits::TreeTypePtr::pointer type_spec661_last = NULL;
    ImplTraits::TreeTypePtr LEFT_PAREN657_tree;
    ImplTraits::TreeTypePtr COMMA660_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN662_tree;
    RewriteRuleTokenStream<ImplTraits> stream_LEFT_PAREN(get_psrstate()->get_treeAdaptor(), "token LEFT_PAREN");
    RewriteRuleTokenStream<ImplTraits> stream_RIGHT_PAREN(get_psrstate()->get_treeAdaptor(), "token RIGHT_PAREN");
    RewriteRuleTokenStream<ImplTraits> stream_COMMA(get_psrstate()->get_treeAdaptor(), "token COMMA");
    RewriteRuleSubtreeStream<ImplTraits> stream_multiset_comparsion(get_psrstate()->get_treeAdaptor(), "rule multiset_comparsion");
    RewriteRuleSubtreeStream<ImplTraits> stream_type_spec(get_psrstate()->get_treeAdaptor(), "rule type_spec");
    RewriteRuleSubtreeStream<ImplTraits> stream_is_key(get_psrstate()->get_treeAdaptor(), "rule is_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_present_key(get_psrstate()->get_treeAdaptor(), "rule present_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_null_key(get_psrstate()->get_treeAdaptor(), "rule null_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_nan_key(get_psrstate()->get_treeAdaptor(), "rule nan_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_a_key(get_psrstate()->get_treeAdaptor(), "rule a_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_empty_key(get_psrstate()->get_treeAdaptor(), "rule empty_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_not_key(get_psrstate()->get_treeAdaptor(), "rule not_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_set_key(get_psrstate()->get_treeAdaptor(), "rule set_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_infinite_key(get_psrstate()->get_treeAdaptor(), "rule infinite_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_of_key(get_psrstate()->get_treeAdaptor(), "rule of_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_only_key(get_psrstate()->get_treeAdaptor(), "rule only_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_type_key(get_psrstate()->get_treeAdaptor(), "rule type_key");

    /* Initialize rule variables
     */

        int isNegated = false;    
    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:887:5: ( ( multiset_comparsion -> multiset_comparsion ) ( is_key ( not_key )? ( null_key -> {isNegated}? ^( IS_NOT_NULL $equality_expression) -> ^( IS_NULL $equality_expression) | nan_key -> {isNegated}? ^( IS_NOT_NAN $equality_expression) -> ^( IS_NAN $equality_expression) | present_key -> {isNegated}? ^( IS_NOT_PRESENT $equality_expression) -> ^( IS_PRESENT $equality_expression) | infinite_key -> {isNegated}? ^( IS_NOT_INFINITE $equality_expression) -> ^( IS_INFINITE $equality_expression) | a_key set_key -> {isNegated}? ^( IS_NOT_A_SET $equality_expression) -> ^( IS_A_SET $equality_expression) | empty_key -> {isNegated}? ^( IS_NOT_EMPTY $equality_expression) -> ^( IS_EMPTY $equality_expression) | of_key ( type_key )? LEFT_PAREN ( only_key )? type_spec ( COMMA type_spec )* RIGHT_PAREN -> {isNegated}? ^( IS_NOT_OF_TYPE $equality_expression ( type_spec )+ ) -> ^( IS_OF_TYPE $equality_expression ( type_spec )+ ) ) )? )
        // OracleDML.g:887:10: ( multiset_comparsion -> multiset_comparsion ) ( is_key ( not_key )? ( null_key -> {isNegated}? ^( IS_NOT_NULL $equality_expression) -> ^( IS_NULL $equality_expression) | nan_key -> {isNegated}? ^( IS_NOT_NAN $equality_expression) -> ^( IS_NAN $equality_expression) | present_key -> {isNegated}? ^( IS_NOT_PRESENT $equality_expression) -> ^( IS_PRESENT $equality_expression) | infinite_key -> {isNegated}? ^( IS_NOT_INFINITE $equality_expression) -> ^( IS_INFINITE $equality_expression) | a_key set_key -> {isNegated}? ^( IS_NOT_A_SET $equality_expression) -> ^( IS_A_SET $equality_expression) | empty_key -> {isNegated}? ^( IS_NOT_EMPTY $equality_expression) -> ^( IS_EMPTY $equality_expression) | of_key ( type_key )? LEFT_PAREN ( only_key )? type_spec ( COMMA type_spec )* RIGHT_PAREN -> {isNegated}? ^( IS_NOT_OF_TYPE $equality_expression ( type_spec )+ ) -> ^( IS_OF_TYPE $equality_expression ( type_spec )+ ) ) )?
        {
            // OracleDML.g:887:10: ( multiset_comparsion -> multiset_comparsion )
            // OracleDML.g:887:11: multiset_comparsion
            {
                this->followPush(FOLLOW_multiset_comparsion_in_equality_expression8616);
                multiset_comparsion645=multiset_comparsion();

                this->followPop();
                if  (this->hasException())
                {
                    goto ruleequality_expressionEx;
                }
                if (this->hasFailed())
                {
                    return retval;
                }

                if ( this->get_backtracking()==0 ) 
                {
                    multiset_comparsion645_last = multiset_comparsion645.tree.get();
                    stream_multiset_comparsion.add(multiset_comparsion645.tree);
                }

                // AST REWRITE
                // elements: multiset_comparsion
                // token labels: 
                // rule labels: retval
                // token list labels: 
                // rule list labels: 
                // wildcard labels: 
                if ( this->get_backtracking()==0 ) {
                retval.tree = std::move(root_0);
                RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

                root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
                // 887:31: -> multiset_comparsion
                {
                	get_psrstate()->get_treeAdaptor()->addChild(root_0, stream_multiset_comparsion.nextTree());
                }


                //retval.tree = std::move(root_0);
                }

            }


            // OracleDML.g:888:5: ( is_key ( not_key )? ( null_key -> {isNegated}? ^( IS_NOT_NULL $equality_expression) -> ^( IS_NULL $equality_expression) | nan_key -> {isNegated}? ^( IS_NOT_NAN $equality_expression) -> ^( IS_NAN $equality_expression) | present_key -> {isNegated}? ^( IS_NOT_PRESENT $equality_expression) -> ^( IS_PRESENT $equality_expression) | infinite_key -> {isNegated}? ^( IS_NOT_INFINITE $equality_expression) -> ^( IS_INFINITE $equality_expression) | a_key set_key -> {isNegated}? ^( IS_NOT_A_SET $equality_expression) -> ^( IS_A_SET $equality_expression) | empty_key -> {isNegated}? ^( IS_NOT_EMPTY $equality_expression) -> ^( IS_EMPTY $equality_expression) | of_key ( type_key )? LEFT_PAREN ( only_key )? type_spec ( COMMA type_spec )* RIGHT_PAREN -> {isNegated}? ^( IS_NOT_OF_TYPE $equality_expression ( type_spec )+ ) -> ^( IS_OF_TYPE $equality_expression ( type_spec )+ ) ) )?
            {
                ANTLR_UINT32 alt224=2;
                switch ( this->LA(1) )
                {
                    case SQL92_RESERVED_IS:
                    	{
                    		alt224=1;
                    	}
                        break;
                }

                switch (alt224)
                {
            	case 1:
            	    // OracleDML.g:888:10: is_key ( not_key )? ( null_key -> {isNegated}? ^( IS_NOT_NULL $equality_expression) -> ^( IS_NULL $equality_expression) | nan_key -> {isNegated}? ^( IS_NOT_NAN $equality_expression) -> ^( IS_NAN $equality_expression) | present_key -> {isNegated}? ^( IS_NOT_PRESENT $equality_expression) -> ^( IS_PRESENT $equality_expression) | infinite_key -> {isNegated}? ^( IS_NOT_INFINITE $equality_expression) -> ^( IS_INFINITE $equality_expression) | a_key set_key -> {isNegated}? ^( IS_NOT_A_SET $equality_expression) -> ^( IS_A_SET $equality_expression) | empty_key -> {isNegated}? ^( IS_NOT_EMPTY $equality_expression) -> ^( IS_EMPTY $equality_expression) | of_key ( type_key )? LEFT_PAREN ( only_key )? type_spec ( COMMA type_spec )* RIGHT_PAREN -> {isNegated}? ^( IS_NOT_OF_TYPE $equality_expression ( type_spec )+ ) -> ^( IS_OF_TYPE $equality_expression ( type_spec )+ ) )
            	    {
            	        this->followPush(FOLLOW_is_key_in_equality_expression8632);
            	        is_key646=is_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleequality_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            is_key646_last = is_key646.tree.get();
            	            stream_is_key.add(is_key646.tree);
            	        }

            	        // OracleDML.g:888:17: ( not_key )?
            	        {
            	            ANTLR_UINT32 alt219=2;
            	            switch ( this->LA(1) )
            	            {
            	                case SQL92_RESERVED_NOT:
            	                	{
            	                		alt219=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt219)
            	            {
            	        	case 1:
            	        	    // OracleDML.g:888:18: not_key
            	        	    {
            	        	        this->followPush(FOLLOW_not_key_in_equality_expression8635);
            	        	        not_key647=not_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleequality_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) 
            	        	        {
            	        	            not_key647_last = not_key647.tree.get();
            	        	            stream_not_key.add(not_key647.tree);
            	        	        }

            	        	        if ( this->get_backtracking()==0 )
            	        	        {
            	        	            isNegated = true;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	        // OracleDML.g:889:9: ( null_key -> {isNegated}? ^( IS_NOT_NULL $equality_expression) -> ^( IS_NULL $equality_expression) | nan_key -> {isNegated}? ^( IS_NOT_NAN $equality_expression) -> ^( IS_NAN $equality_expression) | present_key -> {isNegated}? ^( IS_NOT_PRESENT $equality_expression) -> ^( IS_PRESENT $equality_expression) | infinite_key -> {isNegated}? ^( IS_NOT_INFINITE $equality_expression) -> ^( IS_INFINITE $equality_expression) | a_key set_key -> {isNegated}? ^( IS_NOT_A_SET $equality_expression) -> ^( IS_A_SET $equality_expression) | empty_key -> {isNegated}? ^( IS_NOT_EMPTY $equality_expression) -> ^( IS_EMPTY $equality_expression) | of_key ( type_key )? LEFT_PAREN ( only_key )? type_spec ( COMMA type_spec )* RIGHT_PAREN -> {isNegated}? ^( IS_NOT_OF_TYPE $equality_expression ( type_spec )+ ) -> ^( IS_OF_TYPE $equality_expression ( type_spec )+ ) )
            	        {
            	            ANTLR_UINT32 alt223=7;
            	            {
            	                ANTLR_UINT32 LA223_0 = this->LA(1);
            	                if ( (LA223_0 == SQL92_RESERVED_NULL))
            	                {
            	                    alt223=1;
            	                }
            	                else if ( (LA223_0 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "EMPTY"))||((toUpper(LT(1)->getText()) == "PRESENT"))||((toUpper(LT(1)->getText()) == "INFINITE"))||((toUpper(LT(1)->getText()) == "A"))||((toUpper(LT(1)->getText()) == "NAN")))))
            	                {
            	                    {
            	                        ANTLR_UINT32 LA223_2 = this->LA(2);
            	                        if ( (LA223_2 == REGULAR_ID) && ((toUpper(LT(1)->getText()) == "A")))
            	                        {
            	                            alt223=5;
            	                        }
            	                        else if ( ((toUpper(LT(1)->getText()) == "NAN")))
            	                        {
            	                            alt223=2;
            	                        }
            	                        else if ( ((toUpper(LT(1)->getText()) == "PRESENT")))
            	                        {
            	                            alt223=3;
            	                        }
            	                        else if ( ((toUpper(LT(1)->getText()) == "INFINITE")))
            	                        {
            	                            alt223=4;
            	                        }
            	                        else if ( ((toUpper(LT(1)->getText()) == "EMPTY")))
            	                        {
            	                            alt223=6;
            	                        }
            	                        else
            	                        {
            	                            if (this->get_backtracking()>0)
            	                            {
            	                                this->set_failedflag( true );
            	                                return retval;
            	                            }


            	                            ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                            ex->set_decisionNum( 223 );
            	                            ex->set_state( 2 );


            	                            goto ruleequality_expressionEx;

            	                        }
            	                    }
            	                }
            	                else if ( (LA223_0 == SQL92_RESERVED_OF))
            	                {
            	                    alt223=7;
            	                }
            	                else
            	                {
            	                    if (this->get_backtracking()>0)
            	                    {
            	                        this->set_failedflag( true );
            	                        return retval;
            	                    }


            	                    ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                    ex->set_decisionNum( 223 );
            	                    ex->set_state( 0 );


            	                    goto ruleequality_expressionEx;

            	                }
            	            }
            	            switch (alt223)
            	            {
            	        	case 1:
            	        	    // OracleDML.g:889:14: null_key
            	        	    {
            	        	        this->followPush(FOLLOW_null_key_in_equality_expression8654);
            	        	        null_key648=null_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleequality_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) 
            	        	        {
            	        	            null_key648_last = null_key648.tree.get();
            	        	            stream_null_key.add(null_key648.tree);
            	        	        }

            	        	        // AST REWRITE
            	        	        // elements: equality_expression, equality_expression
            	        	        // token labels: 
            	        	        // rule labels: retval
            	        	        // token list labels: 
            	        	        // rule list labels: 
            	        	        // wildcard labels: 
            	        	        if ( this->get_backtracking()==0 ) {
            	        	        retval.tree = std::move(root_0);
            	        	        RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            	        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            	        	        // 890:17: -> {isNegated}? ^( IS_NOT_NULL $equality_expression)
            	        	        if (isNegated) {
            	        	        	// OracleDML.g:890:33: ^( IS_NOT_NULL $equality_expression)
            	        	        	{
            	        	        	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	        	        	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(IS_NOT_NULL, "IS_NOT_NULL"), root_1);
            	        	        	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_retval.nextTree());
            	        	        	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	        	        	}
            	        	        }

            	        	        else // 891:17: -> ^( IS_NULL $equality_expression)
            	        	        {
            	        	        	// OracleDML.g:891:20: ^( IS_NULL $equality_expression)
            	        	        	{
            	        	        	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	        	        	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(IS_NULL, "IS_NULL"), root_1);
            	        	        	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_retval.nextTree());
            	        	        	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	        	        	}
            	        	        }


            	        	        //retval.tree = std::move(root_0);
            	        	        }

            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // OracleDML.g:892:14: nan_key
            	        	    {
            	        	        this->followPush(FOLLOW_nan_key_in_equality_expression8721);
            	        	        nan_key649=nan_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleequality_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) 
            	        	        {
            	        	            nan_key649_last = nan_key649.tree.get();
            	        	            stream_nan_key.add(nan_key649.tree);
            	        	        }

            	        	        // AST REWRITE
            	        	        // elements: equality_expression, equality_expression
            	        	        // token labels: 
            	        	        // rule labels: retval
            	        	        // token list labels: 
            	        	        // rule list labels: 
            	        	        // wildcard labels: 
            	        	        if ( this->get_backtracking()==0 ) {
            	        	        retval.tree = std::move(root_0);
            	        	        RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            	        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            	        	        // 893:17: -> {isNegated}? ^( IS_NOT_NAN $equality_expression)
            	        	        if (isNegated) {
            	        	        	// OracleDML.g:893:33: ^( IS_NOT_NAN $equality_expression)
            	        	        	{
            	        	        	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	        	        	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(IS_NOT_NAN, "IS_NOT_NAN"), root_1);
            	        	        	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_retval.nextTree());
            	        	        	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	        	        	}
            	        	        }

            	        	        else // 894:17: -> ^( IS_NAN $equality_expression)
            	        	        {
            	        	        	// OracleDML.g:894:20: ^( IS_NAN $equality_expression)
            	        	        	{
            	        	        	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	        	        	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(IS_NAN, "IS_NAN"), root_1);
            	        	        	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_retval.nextTree());
            	        	        	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	        	        	}
            	        	        }


            	        	        //retval.tree = std::move(root_0);
            	        	        }

            	        	    }
            	        	    break;
            	        	case 3:
            	        	    // OracleDML.g:895:14: present_key
            	        	    {
            	        	        this->followPush(FOLLOW_present_key_in_equality_expression8788);
            	        	        present_key650=present_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleequality_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) 
            	        	        {
            	        	            present_key650_last = present_key650.tree.get();
            	        	            stream_present_key.add(present_key650.tree);
            	        	        }

            	        	        // AST REWRITE
            	        	        // elements: equality_expression, equality_expression
            	        	        // token labels: 
            	        	        // rule labels: retval
            	        	        // token list labels: 
            	        	        // rule list labels: 
            	        	        // wildcard labels: 
            	        	        if ( this->get_backtracking()==0 ) {
            	        	        retval.tree = std::move(root_0);
            	        	        RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            	        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            	        	        // 896:17: -> {isNegated}? ^( IS_NOT_PRESENT $equality_expression)
            	        	        if (isNegated) {
            	        	        	// OracleDML.g:896:33: ^( IS_NOT_PRESENT $equality_expression)
            	        	        	{
            	        	        	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	        	        	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(IS_NOT_PRESENT, "IS_NOT_PRESENT"), root_1);
            	        	        	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_retval.nextTree());
            	        	        	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	        	        	}
            	        	        }

            	        	        else // 897:17: -> ^( IS_PRESENT $equality_expression)
            	        	        {
            	        	        	// OracleDML.g:897:20: ^( IS_PRESENT $equality_expression)
            	        	        	{
            	        	        	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	        	        	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(IS_PRESENT, "IS_PRESENT"), root_1);
            	        	        	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_retval.nextTree());
            	        	        	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	        	        	}
            	        	        }


            	        	        //retval.tree = std::move(root_0);
            	        	        }

            	        	    }
            	        	    break;
            	        	case 4:
            	        	    // OracleDML.g:898:14: infinite_key
            	        	    {
            	        	        this->followPush(FOLLOW_infinite_key_in_equality_expression8855);
            	        	        infinite_key651=infinite_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleequality_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) 
            	        	        {
            	        	            infinite_key651_last = infinite_key651.tree.get();
            	        	            stream_infinite_key.add(infinite_key651.tree);
            	        	        }

            	        	        // AST REWRITE
            	        	        // elements: equality_expression, equality_expression
            	        	        // token labels: 
            	        	        // rule labels: retval
            	        	        // token list labels: 
            	        	        // rule list labels: 
            	        	        // wildcard labels: 
            	        	        if ( this->get_backtracking()==0 ) {
            	        	        retval.tree = std::move(root_0);
            	        	        RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            	        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            	        	        // 899:17: -> {isNegated}? ^( IS_NOT_INFINITE $equality_expression)
            	        	        if (isNegated) {
            	        	        	// OracleDML.g:899:33: ^( IS_NOT_INFINITE $equality_expression)
            	        	        	{
            	        	        	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	        	        	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(IS_NOT_INFINITE, "IS_NOT_INFINITE"), root_1);
            	        	        	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_retval.nextTree());
            	        	        	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	        	        	}
            	        	        }

            	        	        else // 900:17: -> ^( IS_INFINITE $equality_expression)
            	        	        {
            	        	        	// OracleDML.g:900:20: ^( IS_INFINITE $equality_expression)
            	        	        	{
            	        	        	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	        	        	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(IS_INFINITE, "IS_INFINITE"), root_1);
            	        	        	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_retval.nextTree());
            	        	        	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	        	        	}
            	        	        }


            	        	        //retval.tree = std::move(root_0);
            	        	        }

            	        	    }
            	        	    break;
            	        	case 5:
            	        	    // OracleDML.g:901:14: a_key set_key
            	        	    {
            	        	        this->followPush(FOLLOW_a_key_in_equality_expression8922);
            	        	        a_key652=a_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleequality_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) 
            	        	        {
            	        	            a_key652_last = a_key652.tree.get();
            	        	            stream_a_key.add(a_key652.tree);
            	        	        }

            	        	        this->followPush(FOLLOW_set_key_in_equality_expression8924);
            	        	        set_key653=set_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleequality_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) 
            	        	        {
            	        	            set_key653_last = set_key653.tree.get();
            	        	            stream_set_key.add(set_key653.tree);
            	        	        }

            	        	        // AST REWRITE
            	        	        // elements: equality_expression, equality_expression
            	        	        // token labels: 
            	        	        // rule labels: retval
            	        	        // token list labels: 
            	        	        // rule list labels: 
            	        	        // wildcard labels: 
            	        	        if ( this->get_backtracking()==0 ) {
            	        	        retval.tree = std::move(root_0);
            	        	        RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            	        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            	        	        // 902:17: -> {isNegated}? ^( IS_NOT_A_SET $equality_expression)
            	        	        if (isNegated) {
            	        	        	// OracleDML.g:902:33: ^( IS_NOT_A_SET $equality_expression)
            	        	        	{
            	        	        	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	        	        	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(IS_NOT_A_SET, "IS_NOT_A_SET"), root_1);
            	        	        	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_retval.nextTree());
            	        	        	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	        	        	}
            	        	        }

            	        	        else // 903:17: -> ^( IS_A_SET $equality_expression)
            	        	        {
            	        	        	// OracleDML.g:903:20: ^( IS_A_SET $equality_expression)
            	        	        	{
            	        	        	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	        	        	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(IS_A_SET, "IS_A_SET"), root_1);
            	        	        	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_retval.nextTree());
            	        	        	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	        	        	}
            	        	        }


            	        	        //retval.tree = std::move(root_0);
            	        	        }

            	        	    }
            	        	    break;
            	        	case 6:
            	        	    // OracleDML.g:904:14: empty_key
            	        	    {
            	        	        this->followPush(FOLLOW_empty_key_in_equality_expression8991);
            	        	        empty_key654=empty_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleequality_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) 
            	        	        {
            	        	            empty_key654_last = empty_key654.tree.get();
            	        	            stream_empty_key.add(empty_key654.tree);
            	        	        }

            	        	        // AST REWRITE
            	        	        // elements: equality_expression, equality_expression
            	        	        // token labels: 
            	        	        // rule labels: retval
            	        	        // token list labels: 
            	        	        // rule list labels: 
            	        	        // wildcard labels: 
            	        	        if ( this->get_backtracking()==0 ) {
            	        	        retval.tree = std::move(root_0);
            	        	        RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            	        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            	        	        // 905:17: -> {isNegated}? ^( IS_NOT_EMPTY $equality_expression)
            	        	        if (isNegated) {
            	        	        	// OracleDML.g:905:33: ^( IS_NOT_EMPTY $equality_expression)
            	        	        	{
            	        	        	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	        	        	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(IS_NOT_EMPTY, "IS_NOT_EMPTY"), root_1);
            	        	        	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_retval.nextTree());
            	        	        	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	        	        	}
            	        	        }

            	        	        else // 906:17: -> ^( IS_EMPTY $equality_expression)
            	        	        {
            	        	        	// OracleDML.g:906:20: ^( IS_EMPTY $equality_expression)
            	        	        	{
            	        	        	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	        	        	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(IS_EMPTY, "IS_EMPTY"), root_1);
            	        	        	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_retval.nextTree());
            	        	        	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	        	        	}
            	        	        }


            	        	        //retval.tree = std::move(root_0);
            	        	        }

            	        	    }
            	        	    break;
            	        	case 7:
            	        	    // OracleDML.g:907:14: of_key ( type_key )? LEFT_PAREN ( only_key )? type_spec ( COMMA type_spec )* RIGHT_PAREN
            	        	    {
            	        	        this->followPush(FOLLOW_of_key_in_equality_expression9058);
            	        	        of_key655=of_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleequality_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) 
            	        	        {
            	        	            of_key655_last = of_key655.tree.get();
            	        	            stream_of_key.add(of_key655.tree);
            	        	        }

            	        	        // OracleDML.g:907:21: ( type_key )?
            	        	        {
            	        	            ANTLR_UINT32 alt220=2;
            	        	            {
            	        	                ANTLR_UINT32 LA220_0 = this->LA(1);
            	        	                if ( (LA220_0 == REGULAR_ID) && ((toUpper(LT(1)->getText()) == "TYPE")))
            	        	                {
            	        	                    alt220=1;
            	        	                }
            	        	            }
            	        	            switch (alt220)
            	        	            {
            	        	        	case 1:
            	        	        	    // OracleDML.g:907:21: type_key
            	        	        	    {
            	        	        	        this->followPush(FOLLOW_type_key_in_equality_expression9060);
            	        	        	        type_key656=type_key();

            	        	        	        this->followPop();
            	        	        	        if  (this->hasException())
            	        	        	        {
            	        	        	            goto ruleequality_expressionEx;
            	        	        	        }
            	        	        	        if (this->hasFailed())
            	        	        	        {
            	        	        	            return retval;
            	        	        	        }

            	        	        	        if ( this->get_backtracking()==0 ) 
            	        	        	        {
            	        	        	            type_key656_last = type_key656.tree.get();
            	        	        	            stream_type_key.add(type_key656.tree);
            	        	        	        }

            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	        LEFT_PAREN657 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_equality_expression9063);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleequality_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }
            	        	         
            	        	        if ( this->get_backtracking()==0 ) stream_LEFT_PAREN.add(LEFT_PAREN657);


            	        	        // OracleDML.g:907:42: ( only_key )?
            	        	        {
            	        	            ANTLR_UINT32 alt221=2;
            	        	            switch ( this->LA(1) )
            	        	            {
            	        	                case REGULAR_ID:
            	        	                	{
            	        	                		{
            	        	                		    ANTLR_UINT32 LA221_1 = this->LA(2);
            	        	                		    if ( ((toUpper(LT(1)->getText()) == "ONLY")))
            	        	                		    {
            	        	                		        alt221=1;
            	        	                		    }
            	        	                		}
            	        	                	}
            	        	                    break;
            	        	            }

            	        	            switch (alt221)
            	        	            {
            	        	        	case 1:
            	        	        	    // OracleDML.g:907:42: only_key
            	        	        	    {
            	        	        	        this->followPush(FOLLOW_only_key_in_equality_expression9065);
            	        	        	        only_key658=only_key();

            	        	        	        this->followPop();
            	        	        	        if  (this->hasException())
            	        	        	        {
            	        	        	            goto ruleequality_expressionEx;
            	        	        	        }
            	        	        	        if (this->hasFailed())
            	        	        	        {
            	        	        	            return retval;
            	        	        	        }

            	        	        	        if ( this->get_backtracking()==0 ) 
            	        	        	        {
            	        	        	            only_key658_last = only_key658.tree.get();
            	        	        	            stream_only_key.add(only_key658.tree);
            	        	        	        }

            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	        this->followPush(FOLLOW_type_spec_in_equality_expression9068);
            	        	        type_spec659=type_spec();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleequality_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) 
            	        	        {
            	        	            type_spec659_last = type_spec659.tree.get();
            	        	            stream_type_spec.add(type_spec659.tree);
            	        	        }

            	        	        // OracleDML.g:907:62: ( COMMA type_spec )*

            	        	        for (;;)
            	        	        {
            	        	            ANTLR_UINT32 alt222=2;
            	        	            switch ( this->LA(1) )
            	        	            {
            	        	            case COMMA:
            	        	            	{
            	        	            		alt222=1;
            	        	            	}
            	        	                break;

            	        	            }

            	        	            switch (alt222)
            	        	            {
            	        	        	case 1:
            	        	        	    // OracleDML.g:907:63: COMMA type_spec
            	        	        	    {
            	        	        	        COMMA660 =  this->matchToken(COMMA, &FOLLOW_COMMA_in_equality_expression9071);
            	        	        	        if  (this->hasException())
            	        	        	        {
            	        	        	            goto ruleequality_expressionEx;
            	        	        	        }
            	        	        	        if (this->hasFailed())
            	        	        	        {
            	        	        	            return retval;
            	        	        	        }
            	        	        	         
            	        	        	        if ( this->get_backtracking()==0 ) stream_COMMA.add(COMMA660);


            	        	        	        this->followPush(FOLLOW_type_spec_in_equality_expression9073);
            	        	        	        type_spec661=type_spec();

            	        	        	        this->followPop();
            	        	        	        if  (this->hasException())
            	        	        	        {
            	        	        	            goto ruleequality_expressionEx;
            	        	        	        }
            	        	        	        if (this->hasFailed())
            	        	        	        {
            	        	        	            return retval;
            	        	        	        }

            	        	        	        if ( this->get_backtracking()==0 ) 
            	        	        	        {
            	        	        	            type_spec661_last = type_spec661.tree.get();
            	        	        	            stream_type_spec.add(type_spec661.tree);
            	        	        	        }

            	        	        	    }
            	        	        	    break;

            	        	        	default:
            	        	        	    goto loop222;	/* break out of the loop */
            	        	        	    break;
            	        	            }
            	        	        }
            	        	        loop222: ; /* Jump out to here if this rule does not match */


            	        	        RIGHT_PAREN662 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_equality_expression9077);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleequality_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }
            	        	         
            	        	        if ( this->get_backtracking()==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN662);


            	        	        // AST REWRITE
            	        	        // elements: type_spec, type_spec, equality_expression, equality_expression
            	        	        // token labels: 
            	        	        // rule labels: retval
            	        	        // token list labels: 
            	        	        // rule list labels: 
            	        	        // wildcard labels: 
            	        	        if ( this->get_backtracking()==0 ) {
            	        	        retval.tree = std::move(root_0);
            	        	        RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            	        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            	        	        // 908:17: -> {isNegated}? ^( IS_NOT_OF_TYPE $equality_expression ( type_spec )+ )
            	        	        if (isNegated) {
            	        	        	// OracleDML.g:908:33: ^( IS_NOT_OF_TYPE $equality_expression ( type_spec )+ )
            	        	        	{
            	        	        	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	        	        	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(IS_NOT_OF_TYPE, "IS_NOT_OF_TYPE"), root_1);
            	        	        	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_retval.nextTree());
            	        	        	if ( !(stream_type_spec.hasNext()) ) {
            	        	        		ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, REWRITE_EARLY_EXCEPTION, StreamType>( this->get_rec(), "type_spec empty" );
            	        	        		goto ruleequality_expressionEx;
            	        	        	}
            	        	        	while ( stream_type_spec.hasNext() ) {
            	        	        		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_type_spec.nextTree());
            	        	        	}
            	        	        	stream_type_spec.reset();

            	        	        	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	        	        	}
            	        	        }

            	        	        else // 909:17: -> ^( IS_OF_TYPE $equality_expression ( type_spec )+ )
            	        	        {
            	        	        	// OracleDML.g:909:20: ^( IS_OF_TYPE $equality_expression ( type_spec )+ )
            	        	        	{
            	        	        	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	        	        	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(IS_OF_TYPE, "IS_OF_TYPE"), root_1);
            	        	        	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_retval.nextTree());
            	        	        	if ( !(stream_type_spec.hasNext()) ) {
            	        	        		ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, REWRITE_EARLY_EXCEPTION, StreamType>( this->get_rec(), "type_spec empty" );
            	        	        		goto ruleequality_expressionEx;
            	        	        	}
            	        	        	while ( stream_type_spec.hasNext() ) {
            	        	        		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_type_spec.nextTree());
            	        	        	}
            	        	        	stream_type_spec.reset();

            	        	        	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	        	        	}
            	        	        }


            	        	        //retval.tree = std::move(root_0);
            	        	        }

            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

                }
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleequality_expressionEx; /* Prevent compiler warnings */
    ruleequality_expressionEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end equality_expression */

/**
 * $ANTLR start multiset_comparsion
 * OracleDML.g:915:1: multiset_comparsion : ( relational_expression -> relational_expression ) ( multiset_type ( of_key )? concatenation -> ^( multiset_type $multiset_comparsion ^( EXPR concatenation ) ) )? ;
 */
OracleDML::multiset_comparsion_return
OracleDML::multiset_comparsion()
{
    OracleDML::multiset_comparsion_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML::relational_expression_return relational_expression663;
    ImplTraits::TreeTypePtr::pointer relational_expression663_last = NULL;
    OracleDML::multiset_type_return multiset_type664;
    ImplTraits::TreeTypePtr::pointer multiset_type664_last = NULL;
    OracleDML_OracleDMLKeys::of_key_return of_key665;
    ImplTraits::TreeTypePtr::pointer of_key665_last = NULL;
    OracleDML::concatenation_return concatenation666;
    ImplTraits::TreeTypePtr::pointer concatenation666_last = NULL;
    RewriteRuleSubtreeStream<ImplTraits> stream_multiset_type(get_psrstate()->get_treeAdaptor(), "rule multiset_type");
    RewriteRuleSubtreeStream<ImplTraits> stream_relational_expression(get_psrstate()->get_treeAdaptor(), "rule relational_expression");
    RewriteRuleSubtreeStream<ImplTraits> stream_of_key(get_psrstate()->get_treeAdaptor(), "rule of_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_concatenation(get_psrstate()->get_treeAdaptor(), "rule concatenation");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:916:5: ( ( relational_expression -> relational_expression ) ( multiset_type ( of_key )? concatenation -> ^( multiset_type $multiset_comparsion ^( EXPR concatenation ) ) )? )
        // OracleDML.g:916:10: ( relational_expression -> relational_expression ) ( multiset_type ( of_key )? concatenation -> ^( multiset_type $multiset_comparsion ^( EXPR concatenation ) ) )?
        {
            // OracleDML.g:916:10: ( relational_expression -> relational_expression )
            // OracleDML.g:916:11: relational_expression
            {
                this->followPush(FOLLOW_relational_expression_in_multiset_comparsion9174);
                relational_expression663=relational_expression();

                this->followPop();
                if  (this->hasException())
                {
                    goto rulemultiset_comparsionEx;
                }
                if (this->hasFailed())
                {
                    return retval;
                }

                if ( this->get_backtracking()==0 ) 
                {
                    relational_expression663_last = relational_expression663.tree.get();
                    stream_relational_expression.add(relational_expression663.tree);
                }

                // AST REWRITE
                // elements: relational_expression
                // token labels: 
                // rule labels: retval
                // token list labels: 
                // rule list labels: 
                // wildcard labels: 
                if ( this->get_backtracking()==0 ) {
                retval.tree = std::move(root_0);
                RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

                root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
                // 916:33: -> relational_expression
                {
                	get_psrstate()->get_treeAdaptor()->addChild(root_0, stream_relational_expression.nextTree());
                }


                //retval.tree = std::move(root_0);
                }

            }


            // OracleDML.g:917:5: ( multiset_type ( of_key )? concatenation -> ^( multiset_type $multiset_comparsion ^( EXPR concatenation ) ) )?
            {
                ANTLR_UINT32 alt226=2;
                switch ( this->LA(1) )
                {
                    case REGULAR_ID:
                    	{
                    		{
                    		    ANTLR_UINT32 LA226_1 = this->LA(2);
                    		    if ( ((((toUpper(LT(1)->getText()) == "SUBMULTISET"))||((toUpper(LT(1)->getText()) == "MEMBER")))))
                    		    {
                    		        alt226=1;
                    		    }
                    		}
                    	}
                        break;
                }

                switch (alt226)
                {
            	case 1:
            	    // OracleDML.g:917:10: multiset_type ( of_key )? concatenation
            	    {
            	        this->followPush(FOLLOW_multiset_type_in_multiset_comparsion9190);
            	        multiset_type664=multiset_type();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemultiset_comparsionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            multiset_type664_last = multiset_type664.tree.get();
            	            stream_multiset_type.add(multiset_type664.tree);
            	        }

            	        // OracleDML.g:917:24: ( of_key )?
            	        {
            	            ANTLR_UINT32 alt225=2;
            	            switch ( this->LA(1) )
            	            {
            	                case SQL92_RESERVED_OF:
            	                	{
            	                		alt225=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt225)
            	            {
            	        	case 1:
            	        	    // OracleDML.g:917:24: of_key
            	        	    {
            	        	        this->followPush(FOLLOW_of_key_in_multiset_comparsion9192);
            	        	        of_key665=of_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulemultiset_comparsionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) 
            	        	        {
            	        	            of_key665_last = of_key665.tree.get();
            	        	            stream_of_key.add(of_key665.tree);
            	        	        }

            	        	    }
            	        	    break;

            	            }
            	        }

            	        this->followPush(FOLLOW_concatenation_in_multiset_comparsion9195);
            	        concatenation666=concatenation();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemultiset_comparsionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            concatenation666_last = concatenation666.tree.get();
            	            stream_concatenation.add(concatenation666.tree);
            	        }

            	        // AST REWRITE
            	        // elements: multiset_type, concatenation, multiset_comparsion
            	        // token labels: 
            	        // rule labels: retval
            	        // token list labels: 
            	        // rule list labels: 
            	        // wildcard labels: 
            	        if ( this->get_backtracking()==0 ) {
            	        retval.tree = std::move(root_0);
            	        RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            	        // 918:9: -> ^( multiset_type $multiset_comparsion ^( EXPR concatenation ) )
            	        {
            	        	// OracleDML.g:918:12: ^( multiset_type $multiset_comparsion ^( EXPR concatenation ) )
            	        	{
            	        	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	        	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(stream_multiset_type.nextNode(), root_1);
            	        	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_retval.nextTree());
            	        	// OracleDML.g:918:49: ^( EXPR concatenation )
            	        	{
            	        	ImplTraits::TreeTypePtr root_2 = get_psrstate()->get_treeAdaptor()->nilNode();
            	        	root_2 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(EXPR, "EXPR"), root_2);
            	        	get_psrstate()->get_treeAdaptor()->addChild(root_2, stream_concatenation.nextTree());
            	        	get_psrstate()->get_treeAdaptor()->addChild(root_1, root_2);
            	        	}
            	        	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	        	}
            	        }


            	        //retval.tree = std::move(root_0);
            	        }

            	    }
            	    break;

                }
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulemultiset_comparsionEx; /* Prevent compiler warnings */
    rulemultiset_comparsionEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end multiset_comparsion */

/**
 * $ANTLR start multiset_type
 * OracleDML.g:921:1: multiset_type : ( member_key | submultiset_key );
 */
OracleDML::multiset_type_return
OracleDML::multiset_type()
{
    OracleDML::multiset_type_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML_OracleDMLKeys::member_key_return member_key667;
    ImplTraits::TreeTypePtr::pointer member_key667_last = NULL;
    OracleDML_OracleDMLKeys::submultiset_key_return submultiset_key668;
    ImplTraits::TreeTypePtr::pointer submultiset_key668_last = NULL;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        {
            //  OracleDML.g:922:5: ( member_key | submultiset_key )

            ANTLR_UINT32 alt227;

            alt227=2;

            {
                ANTLR_UINT32 LA227_0 = this->LA(1);
                if ( (LA227_0 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "SUBMULTISET"))||((toUpper(LT(1)->getText()) == "MEMBER")))))
                {
                    {
                        ANTLR_UINT32 LA227_1 = this->LA(2);
                        if ( ((toUpper(LT(1)->getText()) == "MEMBER")))
                        {
                            alt227=1;
                        }
                        else if ( ((toUpper(LT(1)->getText()) == "SUBMULTISET")))
                        {
                            alt227=2;
                        }
                        else
                        {
                            if (this->get_backtracking()>0)
                            {
                                this->set_failedflag( true );
                                return retval;
                            }


                            ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                            ex->set_decisionNum( 227 );
                            ex->set_state( 1 );


                            goto rulemultiset_typeEx;

                        }
                    }
                }
                else
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return retval;
                    }


                    ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 227 );
                    ex->set_state( 0 );


                    goto rulemultiset_typeEx;

                }
            }
            switch (alt227)
            {
        	case 1:
        	    // OracleDML.g:922:10: member_key
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_member_key_in_multiset_type9240);
        	        member_key667=member_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulemultiset_typeEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, member_key667.tree);


        	    }
        	    break;
        	case 2:
        	    // OracleDML.g:923:10: submultiset_key
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_submultiset_key_in_multiset_type9251);
        	        submultiset_key668=submultiset_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulemultiset_typeEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, submultiset_key668.tree);


        	    }
        	    break;

            }
        }
    }//...
    // This is where rules clean up and exit
    //
    goto rulemultiset_typeEx; /* Prevent compiler warnings */
    rulemultiset_typeEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end multiset_type */

/**
 * $ANTLR start relational_expression
 * OracleDML.g:926:1: relational_expression : compound_expression ( ( EQUALS_OP ^| not_equal_op ^| LESS_THAN_OP ^| GREATER_THAN_OP ^| less_than_or_equals_op ^| greater_than_or_equals_op ^) compound_expression )* ;
 */
OracleDML::relational_expression_return
OracleDML::relational_expression()
{
    OracleDML::relational_expression_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* EQUALS_OP670 = NULL;
    ImplTraits::CommonTokenType const* LESS_THAN_OP672 = NULL;
    ImplTraits::CommonTokenType const* GREATER_THAN_OP673 = NULL;
    OracleDML::compound_expression_return compound_expression669;
    ImplTraits::TreeTypePtr::pointer compound_expression669_last = NULL;
    OracleDML_OracleDMLCommons::not_equal_op_return not_equal_op671;
    ImplTraits::TreeTypePtr::pointer not_equal_op671_last = NULL;
    OracleDML_OracleDMLCommons::less_than_or_equals_op_return less_than_or_equals_op674;
    ImplTraits::TreeTypePtr::pointer less_than_or_equals_op674_last = NULL;
    OracleDML_OracleDMLCommons::greater_than_or_equals_op_return greater_than_or_equals_op675;
    ImplTraits::TreeTypePtr::pointer greater_than_or_equals_op675_last = NULL;
    OracleDML::compound_expression_return compound_expression676;
    ImplTraits::TreeTypePtr::pointer compound_expression676_last = NULL;
    ImplTraits::TreeTypePtr EQUALS_OP670_tree;
    ImplTraits::TreeTypePtr LESS_THAN_OP672_tree;
    ImplTraits::TreeTypePtr GREATER_THAN_OP673_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:927:5: ( compound_expression ( ( EQUALS_OP ^| not_equal_op ^| LESS_THAN_OP ^| GREATER_THAN_OP ^| less_than_or_equals_op ^| greater_than_or_equals_op ^) compound_expression )* )
        // OracleDML.g:927:10: compound_expression ( ( EQUALS_OP ^| not_equal_op ^| LESS_THAN_OP ^| GREATER_THAN_OP ^| less_than_or_equals_op ^| greater_than_or_equals_op ^) compound_expression )*
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            this->followPush(FOLLOW_compound_expression_in_relational_expression9271);
            compound_expression669=compound_expression();

            this->followPop();
            if  (this->hasException())
            {
                goto rulerelational_expressionEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, compound_expression669.tree);


            // OracleDML.g:928:5: ( ( EQUALS_OP ^| not_equal_op ^| LESS_THAN_OP ^| GREATER_THAN_OP ^| less_than_or_equals_op ^| greater_than_or_equals_op ^) compound_expression )*

            for (;;)
            {
                ANTLR_UINT32 alt229=2;
                switch ( this->LA(1) )
                {
                case EQUALS_OP:
                	{
                		alt229=1;
                	}
                    break;
                case NOT_EQUAL_OP:
                	{
                		alt229=1;
                	}
                    break;
                case LESS_THAN_OP:
                	{
                		alt229=1;
                	}
                    break;
                case EXCLAMATION_OPERATOR_PART:
                	{
                		alt229=1;
                	}
                    break;
                case CARRET_OPERATOR_PART:
                	{
                		alt229=1;
                	}
                    break;
                case GREATER_THAN_OP:
                	{
                		alt229=1;
                	}
                    break;
                case LESS_THAN_OR_EQUALS_OP:
                	{
                		alt229=1;
                	}
                    break;
                case GREATER_THAN_OR_EQUALS_OP:
                	{
                		alt229=1;
                	}
                    break;

                }

                switch (alt229)
                {
            	case 1:
            	    // OracleDML.g:928:7: ( EQUALS_OP ^| not_equal_op ^| LESS_THAN_OP ^| GREATER_THAN_OP ^| less_than_or_equals_op ^| greater_than_or_equals_op ^) compound_expression
            	    {
            	        // OracleDML.g:928:7: ( EQUALS_OP ^| not_equal_op ^| LESS_THAN_OP ^| GREATER_THAN_OP ^| less_than_or_equals_op ^| greater_than_or_equals_op ^)
            	        {
            	            ANTLR_UINT32 alt228=6;
            	            switch ( this->LA(1) )
            	            {
            	            case EQUALS_OP:
            	            	{
            	            		alt228=1;
            	            	}
            	                break;
            	            case CARRET_OPERATOR_PART:
            	            case EXCLAMATION_OPERATOR_PART:
            	            case NOT_EQUAL_OP:
            	            	{
            	            		alt228=2;
            	            	}
            	                break;
            	            case LESS_THAN_OP:
            	            	{
            	            		switch ( this->LA(2) )
            	            		{
            	            		case GREATER_THAN_OP:
            	            			{
            	            				alt228=2;
            	            			}
            	            		    break;
            	            		case EQUALS_OP:
            	            			{
            	            				alt228=5;
            	            			}
            	            		    break;
            	            		case APPROXIMATE_NUM_LIT:
            	            		case BINDVAR:
            	            		case CHAR_STRING:
            	            		case CHAR_STRING_PERL:
            	            		case COLON:
            	            		case DELIMITED_ID:
            	            		case EXACT_NUM_LIT:
            	            		case INTRODUCER:
            	            		case LEFT_PAREN:
            	            		case MINUS_SIGN:
            	            		case NATIONAL_CHAR_STRING_LIT:
            	            		case PLSQL_NON_RESERVED_CAST:
            	            		case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
            	            		case PLUS_SIGN:
            	            		case REGULAR_ID:
            	            		case SQL92_RESERVED_ALL:
            	            		case SQL92_RESERVED_ANY:
            	            		case SQL92_RESERVED_CASE:
            	            		case SQL92_RESERVED_DATE:
            	            		case SQL92_RESERVED_DEFAULT:
            	            		case SQL92_RESERVED_DISTINCT:
            	            		case SQL92_RESERVED_EXISTS:
            	            		case SQL92_RESERVED_FALSE:
            	            		case SQL92_RESERVED_NULL:
            	            		case SQL92_RESERVED_PRIOR:
            	            		case SQL92_RESERVED_TRUE:
            	            		case UNSIGNED_INTEGER:
            	            			{
            	            				alt228=3;
            	            			}
            	            		    break;

            	            		default:
            	            		    if (this->get_backtracking()>0)
            	            		    {
            	            		        this->set_failedflag( true );
            	            		        return retval;
            	            		    }

            	            		    ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	            		    ex->set_decisionNum( 228 );
            	            		    ex->set_state( 3 );


            	            		    goto rulerelational_expressionEx;

            	            		}

            	            	}
            	                break;
            	            case GREATER_THAN_OP:
            	            	{
            	            		switch ( this->LA(2) )
            	            		{
            	            		case EQUALS_OP:
            	            			{
            	            				alt228=6;
            	            			}
            	            		    break;
            	            		case APPROXIMATE_NUM_LIT:
            	            		case BINDVAR:
            	            		case CHAR_STRING:
            	            		case CHAR_STRING_PERL:
            	            		case COLON:
            	            		case DELIMITED_ID:
            	            		case EXACT_NUM_LIT:
            	            		case INTRODUCER:
            	            		case LEFT_PAREN:
            	            		case MINUS_SIGN:
            	            		case NATIONAL_CHAR_STRING_LIT:
            	            		case PLSQL_NON_RESERVED_CAST:
            	            		case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
            	            		case PLUS_SIGN:
            	            		case REGULAR_ID:
            	            		case SQL92_RESERVED_ALL:
            	            		case SQL92_RESERVED_ANY:
            	            		case SQL92_RESERVED_CASE:
            	            		case SQL92_RESERVED_DATE:
            	            		case SQL92_RESERVED_DEFAULT:
            	            		case SQL92_RESERVED_DISTINCT:
            	            		case SQL92_RESERVED_EXISTS:
            	            		case SQL92_RESERVED_FALSE:
            	            		case SQL92_RESERVED_NULL:
            	            		case SQL92_RESERVED_PRIOR:
            	            		case SQL92_RESERVED_TRUE:
            	            		case UNSIGNED_INTEGER:
            	            			{
            	            				alt228=4;
            	            			}
            	            		    break;

            	            		default:
            	            		    if (this->get_backtracking()>0)
            	            		    {
            	            		        this->set_failedflag( true );
            	            		        return retval;
            	            		    }

            	            		    ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	            		    ex->set_decisionNum( 228 );
            	            		    ex->set_state( 4 );


            	            		    goto rulerelational_expressionEx;

            	            		}

            	            	}
            	                break;
            	            case LESS_THAN_OR_EQUALS_OP:
            	            	{
            	            		alt228=5;
            	            	}
            	                break;
            	            case GREATER_THAN_OR_EQUALS_OP:
            	            	{
            	            		alt228=6;
            	            	}
            	                break;

            	            default:
            	                if (this->get_backtracking()>0)
            	                {
            	                    this->set_failedflag( true );
            	                    return retval;
            	                }

            	                ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                ex->set_decisionNum( 228 );
            	                ex->set_state( 0 );


            	                goto rulerelational_expressionEx;

            	            }

            	            switch (alt228)
            	            {
            	        	case 1:
            	        	    // OracleDML.g:928:9: EQUALS_OP ^
            	        	    {
            	        	        EQUALS_OP670 =  this->matchToken(EQUALS_OP, &FOLLOW_EQUALS_OP_in_relational_expression9281);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulerelational_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) {
            	        	        EQUALS_OP670_tree = get_psrstate()->get_treeAdaptor()->create(EQUALS_OP670);
            	        	        root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(EQUALS_OP670_tree, root_0);
            	        	        }


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // OracleDML.g:928:22: not_equal_op ^
            	        	    {
            	        	        this->followPush(FOLLOW_not_equal_op_in_relational_expression9286);
            	        	        not_equal_op671=not_equal_op();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulerelational_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(not_equal_op671.tree, root_0);

            	        	    }
            	        	    break;
            	        	case 3:
            	        	    // OracleDML.g:928:38: LESS_THAN_OP ^
            	        	    {
            	        	        LESS_THAN_OP672 =  this->matchToken(LESS_THAN_OP, &FOLLOW_LESS_THAN_OP_in_relational_expression9291);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulerelational_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) {
            	        	        LESS_THAN_OP672_tree = get_psrstate()->get_treeAdaptor()->create(LESS_THAN_OP672);
            	        	        root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(LESS_THAN_OP672_tree, root_0);
            	        	        }


            	        	    }
            	        	    break;
            	        	case 4:
            	        	    // OracleDML.g:928:54: GREATER_THAN_OP ^
            	        	    {
            	        	        GREATER_THAN_OP673 =  this->matchToken(GREATER_THAN_OP, &FOLLOW_GREATER_THAN_OP_in_relational_expression9296);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulerelational_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) {
            	        	        GREATER_THAN_OP673_tree = get_psrstate()->get_treeAdaptor()->create(GREATER_THAN_OP673);
            	        	        root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(GREATER_THAN_OP673_tree, root_0);
            	        	        }


            	        	    }
            	        	    break;
            	        	case 5:
            	        	    // OracleDML.g:928:73: less_than_or_equals_op ^
            	        	    {
            	        	        this->followPush(FOLLOW_less_than_or_equals_op_in_relational_expression9301);
            	        	        less_than_or_equals_op674=less_than_or_equals_op();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulerelational_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(less_than_or_equals_op674.tree, root_0);

            	        	    }
            	        	    break;
            	        	case 6:
            	        	    // OracleDML.g:928:99: greater_than_or_equals_op ^
            	        	    {
            	        	        this->followPush(FOLLOW_greater_than_or_equals_op_in_relational_expression9306);
            	        	        greater_than_or_equals_op675=greater_than_or_equals_op();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulerelational_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(greater_than_or_equals_op675.tree, root_0);

            	        	    }
            	        	    break;

            	            }
            	        }

            	        this->followPush(FOLLOW_compound_expression_in_relational_expression9311);
            	        compound_expression676=compound_expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulerelational_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, compound_expression676.tree);


            	    }
            	    break;

            	default:
            	    goto loop229;	/* break out of the loop */
            	    break;
                }
            }
            loop229: ; /* Jump out to here if this rule does not match */


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulerelational_expressionEx; /* Prevent compiler warnings */
    rulerelational_expressionEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end relational_expression */

/**
 * $ANTLR start compound_expression
 * OracleDML.g:931:1: compound_expression : ( concatenation -> concatenation ) ( ( not_key )? ( in_key in_elements -> {isNegated}? ^( NOT_IN $compound_expression in_elements ) -> ^( in_key $compound_expression in_elements ) | between_key between_elements -> {isNegated}? ^( NOT_BETWEEN $compound_expression between_elements ) -> ^( between_key $compound_expression between_elements ) | like_type concatenation ( like_escape_part )? -> {isNegated}? ^( NOT_LIKE $compound_expression ^( EXPR concatenation ) ( like_escape_part )? ) -> ^( like_type $compound_expression ^( EXPR concatenation ) ( like_escape_part )? ) ) )? ;
 */
OracleDML::compound_expression_return
OracleDML::compound_expression()
{
    OracleDML::compound_expression_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML::concatenation_return concatenation677;
    ImplTraits::TreeTypePtr::pointer concatenation677_last = NULL;
    OracleDML_OracleDMLKeys::not_key_return not_key678;
    ImplTraits::TreeTypePtr::pointer not_key678_last = NULL;
    OracleDML_OracleDMLKeys::in_key_return in_key679;
    ImplTraits::TreeTypePtr::pointer in_key679_last = NULL;
    OracleDML::in_elements_return in_elements680;
    ImplTraits::TreeTypePtr::pointer in_elements680_last = NULL;
    OracleDML_OracleDMLKeys::between_key_return between_key681;
    ImplTraits::TreeTypePtr::pointer between_key681_last = NULL;
    OracleDML::between_elements_return between_elements682;
    ImplTraits::TreeTypePtr::pointer between_elements682_last = NULL;
    OracleDML::like_type_return like_type683;
    ImplTraits::TreeTypePtr::pointer like_type683_last = NULL;
    OracleDML::concatenation_return concatenation684;
    ImplTraits::TreeTypePtr::pointer concatenation684_last = NULL;
    OracleDML::like_escape_part_return like_escape_part685;
    ImplTraits::TreeTypePtr::pointer like_escape_part685_last = NULL;
    RewriteRuleSubtreeStream<ImplTraits> stream_between_elements(get_psrstate()->get_treeAdaptor(), "rule between_elements");
    RewriteRuleSubtreeStream<ImplTraits> stream_like_escape_part(get_psrstate()->get_treeAdaptor(), "rule like_escape_part");
    RewriteRuleSubtreeStream<ImplTraits> stream_between_key(get_psrstate()->get_treeAdaptor(), "rule between_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_not_key(get_psrstate()->get_treeAdaptor(), "rule not_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_like_type(get_psrstate()->get_treeAdaptor(), "rule like_type");
    RewriteRuleSubtreeStream<ImplTraits> stream_concatenation(get_psrstate()->get_treeAdaptor(), "rule concatenation");
    RewriteRuleSubtreeStream<ImplTraits> stream_in_key(get_psrstate()->get_treeAdaptor(), "rule in_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_in_elements(get_psrstate()->get_treeAdaptor(), "rule in_elements");

    /* Initialize rule variables
     */

        int isNegated = false;    
    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:933:5: ( ( concatenation -> concatenation ) ( ( not_key )? ( in_key in_elements -> {isNegated}? ^( NOT_IN $compound_expression in_elements ) -> ^( in_key $compound_expression in_elements ) | between_key between_elements -> {isNegated}? ^( NOT_BETWEEN $compound_expression between_elements ) -> ^( between_key $compound_expression between_elements ) | like_type concatenation ( like_escape_part )? -> {isNegated}? ^( NOT_LIKE $compound_expression ^( EXPR concatenation ) ( like_escape_part )? ) -> ^( like_type $compound_expression ^( EXPR concatenation ) ( like_escape_part )? ) ) )? )
        // OracleDML.g:933:10: ( concatenation -> concatenation ) ( ( not_key )? ( in_key in_elements -> {isNegated}? ^( NOT_IN $compound_expression in_elements ) -> ^( in_key $compound_expression in_elements ) | between_key between_elements -> {isNegated}? ^( NOT_BETWEEN $compound_expression between_elements ) -> ^( between_key $compound_expression between_elements ) | like_type concatenation ( like_escape_part )? -> {isNegated}? ^( NOT_LIKE $compound_expression ^( EXPR concatenation ) ( like_escape_part )? ) -> ^( like_type $compound_expression ^( EXPR concatenation ) ( like_escape_part )? ) ) )?
        {
            // OracleDML.g:933:10: ( concatenation -> concatenation )
            // OracleDML.g:933:11: concatenation
            {
                this->followPush(FOLLOW_concatenation_in_compound_expression9342);
                concatenation677=concatenation();

                this->followPop();
                if  (this->hasException())
                {
                    goto rulecompound_expressionEx;
                }
                if (this->hasFailed())
                {
                    return retval;
                }

                if ( this->get_backtracking()==0 ) 
                {
                    concatenation677_last = concatenation677.tree.get();
                    stream_concatenation.add(concatenation677.tree);
                }

                // AST REWRITE
                // elements: concatenation
                // token labels: 
                // rule labels: retval
                // token list labels: 
                // rule list labels: 
                // wildcard labels: 
                if ( this->get_backtracking()==0 ) {
                retval.tree = std::move(root_0);
                RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

                root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
                // 933:25: -> concatenation
                {
                	get_psrstate()->get_treeAdaptor()->addChild(root_0, stream_concatenation.nextTree());
                }


                //retval.tree = std::move(root_0);
                }

            }


            // OracleDML.g:934:5: ( ( not_key )? ( in_key in_elements -> {isNegated}? ^( NOT_IN $compound_expression in_elements ) -> ^( in_key $compound_expression in_elements ) | between_key between_elements -> {isNegated}? ^( NOT_BETWEEN $compound_expression between_elements ) -> ^( between_key $compound_expression between_elements ) | like_type concatenation ( like_escape_part )? -> {isNegated}? ^( NOT_LIKE $compound_expression ^( EXPR concatenation ) ( like_escape_part )? ) -> ^( like_type $compound_expression ^( EXPR concatenation ) ( like_escape_part )? ) ) )?
            {
                ANTLR_UINT32 alt233=2;
                switch ( this->LA(1) )
                {
                    case SQL92_RESERVED_NOT:
                    	{
                    		alt233=1;
                    	}
                        break;
                    case SQL92_RESERVED_IN:
                    	{
                    		alt233=1;
                    	}
                        break;
                    case SQL92_RESERVED_BETWEEN:
                    	{
                    		alt233=1;
                    	}
                        break;
                    case SQL92_RESERVED_LIKE:
                    	{
                    		alt233=1;
                    	}
                        break;
                    case REGULAR_ID:
                    	{
                    		{
                    		    ANTLR_UINT32 LA233_5 = this->LA(2);
                    		    if ( ((((toUpper(LT(1)->getText()) == "LIKE4"))||((toUpper(LT(1)->getText()) == "LIKE2"))||((toUpper(LT(1)->getText()) == "LIKEC")))))
                    		    {
                    		        alt233=1;
                    		    }
                    		}
                    	}
                        break;
                }

                switch (alt233)
                {
            	case 1:
            	    // OracleDML.g:934:10: ( not_key )? ( in_key in_elements -> {isNegated}? ^( NOT_IN $compound_expression in_elements ) -> ^( in_key $compound_expression in_elements ) | between_key between_elements -> {isNegated}? ^( NOT_BETWEEN $compound_expression between_elements ) -> ^( between_key $compound_expression between_elements ) | like_type concatenation ( like_escape_part )? -> {isNegated}? ^( NOT_LIKE $compound_expression ^( EXPR concatenation ) ( like_escape_part )? ) -> ^( like_type $compound_expression ^( EXPR concatenation ) ( like_escape_part )? ) )
            	    {
            	        // OracleDML.g:934:10: ( not_key )?
            	        {
            	            ANTLR_UINT32 alt230=2;
            	            switch ( this->LA(1) )
            	            {
            	                case SQL92_RESERVED_NOT:
            	                	{
            	                		alt230=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt230)
            	            {
            	        	case 1:
            	        	    // OracleDML.g:934:11: not_key
            	        	    {
            	        	        this->followPush(FOLLOW_not_key_in_compound_expression9359);
            	        	        not_key678=not_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulecompound_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) 
            	        	        {
            	        	            not_key678_last = not_key678.tree.get();
            	        	            stream_not_key.add(not_key678.tree);
            	        	        }

            	        	        if ( this->get_backtracking()==0 )
            	        	        {
            	        	            isNegated = true;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	        // OracleDML.g:935:9: ( in_key in_elements -> {isNegated}? ^( NOT_IN $compound_expression in_elements ) -> ^( in_key $compound_expression in_elements ) | between_key between_elements -> {isNegated}? ^( NOT_BETWEEN $compound_expression between_elements ) -> ^( between_key $compound_expression between_elements ) | like_type concatenation ( like_escape_part )? -> {isNegated}? ^( NOT_LIKE $compound_expression ^( EXPR concatenation ) ( like_escape_part )? ) -> ^( like_type $compound_expression ^( EXPR concatenation ) ( like_escape_part )? ) )
            	        {
            	            ANTLR_UINT32 alt232=3;
            	            {
            	                ANTLR_UINT32 LA232_0 = this->LA(1);
            	                if ( (LA232_0 == SQL92_RESERVED_IN))
            	                {
            	                    alt232=1;
            	                }
            	                else if ( (LA232_0 == SQL92_RESERVED_BETWEEN))
            	                {
            	                    alt232=2;
            	                }
            	                else if ( (LA232_0 == SQL92_RESERVED_LIKE))
            	                {
            	                    alt232=3;
            	                }
            	                else if ( (LA232_0 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "LIKE4"))||((toUpper(LT(1)->getText()) == "LIKE2"))||((toUpper(LT(1)->getText()) == "LIKEC")))))
            	                {
            	                    alt232=3;
            	                }
            	                else
            	                {
            	                    if (this->get_backtracking()>0)
            	                    {
            	                        this->set_failedflag( true );
            	                        return retval;
            	                    }


            	                    ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                    ex->set_decisionNum( 232 );
            	                    ex->set_state( 0 );


            	                    goto rulecompound_expressionEx;

            	                }
            	            }
            	            switch (alt232)
            	            {
            	        	case 1:
            	        	    // OracleDML.g:935:14: in_key in_elements
            	        	    {
            	        	        this->followPush(FOLLOW_in_key_in_compound_expression9379);
            	        	        in_key679=in_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulecompound_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) 
            	        	        {
            	        	            in_key679_last = in_key679.tree.get();
            	        	            stream_in_key.add(in_key679.tree);
            	        	        }

            	        	        this->followPush(FOLLOW_in_elements_in_compound_expression9381);
            	        	        in_elements680=in_elements();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulecompound_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) 
            	        	        {
            	        	            in_elements680_last = in_elements680.tree.get();
            	        	            stream_in_elements.add(in_elements680.tree);
            	        	        }

            	        	        // AST REWRITE
            	        	        // elements: compound_expression, in_elements, in_key, in_elements, compound_expression
            	        	        // token labels: 
            	        	        // rule labels: retval
            	        	        // token list labels: 
            	        	        // rule list labels: 
            	        	        // wildcard labels: 
            	        	        if ( this->get_backtracking()==0 ) {
            	        	        retval.tree = std::move(root_0);
            	        	        RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            	        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            	        	        // 936:17: -> {isNegated}? ^( NOT_IN $compound_expression in_elements )
            	        	        if (isNegated) {
            	        	        	// OracleDML.g:936:33: ^( NOT_IN $compound_expression in_elements )
            	        	        	{
            	        	        	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	        	        	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(NOT_IN, "NOT_IN"), root_1);
            	        	        	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_retval.nextTree());
            	        	        	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_in_elements.nextTree());
            	        	        	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	        	        	}
            	        	        }

            	        	        else // 937:17: -> ^( in_key $compound_expression in_elements )
            	        	        {
            	        	        	// OracleDML.g:937:20: ^( in_key $compound_expression in_elements )
            	        	        	{
            	        	        	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	        	        	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(stream_in_key.nextNode(), root_1);
            	        	        	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_retval.nextTree());
            	        	        	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_in_elements.nextTree());
            	        	        	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	        	        	}
            	        	        }


            	        	        //retval.tree = std::move(root_0);
            	        	        }

            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // OracleDML.g:938:14: between_key between_elements
            	        	    {
            	        	        this->followPush(FOLLOW_between_key_in_compound_expression9452);
            	        	        between_key681=between_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulecompound_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) 
            	        	        {
            	        	            between_key681_last = between_key681.tree.get();
            	        	            stream_between_key.add(between_key681.tree);
            	        	        }

            	        	        this->followPush(FOLLOW_between_elements_in_compound_expression9454);
            	        	        between_elements682=between_elements();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulecompound_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) 
            	        	        {
            	        	            between_elements682_last = between_elements682.tree.get();
            	        	            stream_between_elements.add(between_elements682.tree);
            	        	        }

            	        	        // AST REWRITE
            	        	        // elements: between_key, compound_expression, between_elements, between_elements, compound_expression
            	        	        // token labels: 
            	        	        // rule labels: retval
            	        	        // token list labels: 
            	        	        // rule list labels: 
            	        	        // wildcard labels: 
            	        	        if ( this->get_backtracking()==0 ) {
            	        	        retval.tree = std::move(root_0);
            	        	        RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            	        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            	        	        // 939:17: -> {isNegated}? ^( NOT_BETWEEN $compound_expression between_elements )
            	        	        if (isNegated) {
            	        	        	// OracleDML.g:939:33: ^( NOT_BETWEEN $compound_expression between_elements )
            	        	        	{
            	        	        	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	        	        	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(NOT_BETWEEN, "NOT_BETWEEN"), root_1);
            	        	        	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_retval.nextTree());
            	        	        	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_between_elements.nextTree());
            	        	        	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	        	        	}
            	        	        }

            	        	        else // 940:17: -> ^( between_key $compound_expression between_elements )
            	        	        {
            	        	        	// OracleDML.g:940:20: ^( between_key $compound_expression between_elements )
            	        	        	{
            	        	        	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	        	        	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(stream_between_key.nextNode(), root_1);
            	        	        	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_retval.nextTree());
            	        	        	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_between_elements.nextTree());
            	        	        	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	        	        	}
            	        	        }


            	        	        //retval.tree = std::move(root_0);
            	        	        }

            	        	    }
            	        	    break;
            	        	case 3:
            	        	    // OracleDML.g:941:14: like_type concatenation ( like_escape_part )?
            	        	    {
            	        	        this->followPush(FOLLOW_like_type_in_compound_expression9525);
            	        	        like_type683=like_type();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulecompound_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) 
            	        	        {
            	        	            like_type683_last = like_type683.tree.get();
            	        	            stream_like_type.add(like_type683.tree);
            	        	        }

            	        	        this->followPush(FOLLOW_concatenation_in_compound_expression9527);
            	        	        concatenation684=concatenation();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulecompound_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) 
            	        	        {
            	        	            concatenation684_last = concatenation684.tree.get();
            	        	            stream_concatenation.add(concatenation684.tree);
            	        	        }

            	        	        // OracleDML.g:941:38: ( like_escape_part )?
            	        	        {
            	        	            ANTLR_UINT32 alt231=2;
            	        	            switch ( this->LA(1) )
            	        	            {
            	        	                case REGULAR_ID:
            	        	                	{
            	        	                		{
            	        	                		    ANTLR_UINT32 LA231_1 = this->LA(2);
            	        	                		    if ( ((toUpper(LT(1)->getText()) == "ESCAPE")))
            	        	                		    {
            	        	                		        alt231=1;
            	        	                		    }
            	        	                		}
            	        	                	}
            	        	                    break;
            	        	            }

            	        	            switch (alt231)
            	        	            {
            	        	        	case 1:
            	        	        	    // OracleDML.g:941:38: like_escape_part
            	        	        	    {
            	        	        	        this->followPush(FOLLOW_like_escape_part_in_compound_expression9529);
            	        	        	        like_escape_part685=like_escape_part();

            	        	        	        this->followPop();
            	        	        	        if  (this->hasException())
            	        	        	        {
            	        	        	            goto rulecompound_expressionEx;
            	        	        	        }
            	        	        	        if (this->hasFailed())
            	        	        	        {
            	        	        	            return retval;
            	        	        	        }

            	        	        	        if ( this->get_backtracking()==0 ) 
            	        	        	        {
            	        	        	            like_escape_part685_last = like_escape_part685.tree.get();
            	        	        	            stream_like_escape_part.add(like_escape_part685.tree);
            	        	        	        }

            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	        // AST REWRITE
            	        	        // elements: like_escape_part, like_escape_part, concatenation, compound_expression, concatenation, compound_expression, like_type
            	        	        // token labels: 
            	        	        // rule labels: retval
            	        	        // token list labels: 
            	        	        // rule list labels: 
            	        	        // wildcard labels: 
            	        	        if ( this->get_backtracking()==0 ) {
            	        	        retval.tree = std::move(root_0);
            	        	        RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            	        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            	        	        // 942:17: -> {isNegated}? ^( NOT_LIKE $compound_expression ^( EXPR concatenation ) ( like_escape_part )? )
            	        	        if (isNegated) {
            	        	        	// OracleDML.g:942:33: ^( NOT_LIKE $compound_expression ^( EXPR concatenation ) ( like_escape_part )? )
            	        	        	{
            	        	        	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	        	        	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(NOT_LIKE, "NOT_LIKE"), root_1);
            	        	        	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_retval.nextTree());
            	        	        	// OracleDML.g:942:65: ^( EXPR concatenation )
            	        	        	{
            	        	        	ImplTraits::TreeTypePtr root_2 = get_psrstate()->get_treeAdaptor()->nilNode();
            	        	        	root_2 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(EXPR, "EXPR"), root_2);
            	        	        	get_psrstate()->get_treeAdaptor()->addChild(root_2, stream_concatenation.nextTree());
            	        	        	get_psrstate()->get_treeAdaptor()->addChild(root_1, root_2);
            	        	        	}
            	        	        	// OracleDML.g:942:87: ( like_escape_part )?
            	        	        	if ( stream_like_escape_part.hasNext() ) {
            	        	        		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_like_escape_part.nextTree());
            	        	        	}
            	        	        	stream_like_escape_part.reset();

            	        	        	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	        	        	}
            	        	        }

            	        	        else // 943:17: -> ^( like_type $compound_expression ^( EXPR concatenation ) ( like_escape_part )? )
            	        	        {
            	        	        	// OracleDML.g:943:20: ^( like_type $compound_expression ^( EXPR concatenation ) ( like_escape_part )? )
            	        	        	{
            	        	        	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	        	        	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(stream_like_type.nextNode(), root_1);
            	        	        	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_retval.nextTree());
            	        	        	// OracleDML.g:943:54: ^( EXPR concatenation )
            	        	        	{
            	        	        	ImplTraits::TreeTypePtr root_2 = get_psrstate()->get_treeAdaptor()->nilNode();
            	        	        	root_2 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(EXPR, "EXPR"), root_2);
            	        	        	get_psrstate()->get_treeAdaptor()->addChild(root_2, stream_concatenation.nextTree());
            	        	        	get_psrstate()->get_treeAdaptor()->addChild(root_1, root_2);
            	        	        	}
            	        	        	// OracleDML.g:943:76: ( like_escape_part )?
            	        	        	if ( stream_like_escape_part.hasNext() ) {
            	        	        		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_like_escape_part.nextTree());
            	        	        	}
            	        	        	stream_like_escape_part.reset();

            	        	        	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	        	        	}
            	        	        }


            	        	        //retval.tree = std::move(root_0);
            	        	        }

            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

                }
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulecompound_expressionEx; /* Prevent compiler warnings */
    rulecompound_expressionEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end compound_expression */

/**
 * $ANTLR start like_type
 * OracleDML.g:948:1: like_type : ( like_key | likec_key | like2_key | like4_key );
 */
OracleDML::like_type_return
OracleDML::like_type()
{
    OracleDML::like_type_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML_OracleDMLKeys::like_key_return like_key686;
    ImplTraits::TreeTypePtr::pointer like_key686_last = NULL;
    OracleDML_OracleDMLKeys::likec_key_return likec_key687;
    ImplTraits::TreeTypePtr::pointer likec_key687_last = NULL;
    OracleDML_OracleDMLKeys::like2_key_return like2_key688;
    ImplTraits::TreeTypePtr::pointer like2_key688_last = NULL;
    OracleDML_OracleDMLKeys::like4_key_return like4_key689;
    ImplTraits::TreeTypePtr::pointer like4_key689_last = NULL;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        {
            //  OracleDML.g:949:5: ( like_key | likec_key | like2_key | like4_key )

            ANTLR_UINT32 alt234;

            alt234=4;

            {
                ANTLR_UINT32 LA234_0 = this->LA(1);
                if ( (LA234_0 == SQL92_RESERVED_LIKE))
                {
                    alt234=1;
                }
                else if ( (LA234_0 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "LIKE4"))||((toUpper(LT(1)->getText()) == "LIKE2"))||((toUpper(LT(1)->getText()) == "LIKEC")))))
                {
                    {
                        ANTLR_UINT32 LA234_2 = this->LA(2);
                        if ( ((toUpper(LT(1)->getText()) == "LIKEC")))
                        {
                            alt234=2;
                        }
                        else if ( ((toUpper(LT(1)->getText()) == "LIKE2")))
                        {
                            alt234=3;
                        }
                        else if ( ((toUpper(LT(1)->getText()) == "LIKE4")))
                        {
                            alt234=4;
                        }
                        else
                        {
                            if (this->get_backtracking()>0)
                            {
                                this->set_failedflag( true );
                                return retval;
                            }


                            ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                            ex->set_decisionNum( 234 );
                            ex->set_state( 2 );


                            goto rulelike_typeEx;

                        }
                    }
                }
                else
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return retval;
                    }


                    ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 234 );
                    ex->set_state( 0 );


                    goto rulelike_typeEx;

                }
            }
            switch (alt234)
            {
        	case 1:
        	    // OracleDML.g:949:10: like_key
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_like_key_in_like_type9638);
        	        like_key686=like_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulelike_typeEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, like_key686.tree);


        	    }
        	    break;
        	case 2:
        	    // OracleDML.g:950:10: likec_key
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_likec_key_in_like_type9649);
        	        likec_key687=likec_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulelike_typeEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, likec_key687.tree);


        	    }
        	    break;
        	case 3:
        	    // OracleDML.g:951:10: like2_key
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_like2_key_in_like_type9660);
        	        like2_key688=like2_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulelike_typeEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, like2_key688.tree);


        	    }
        	    break;
        	case 4:
        	    // OracleDML.g:952:10: like4_key
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_like4_key_in_like_type9671);
        	        like4_key689=like4_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulelike_typeEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, like4_key689.tree);


        	    }
        	    break;

            }
        }
    }//...
    // This is where rules clean up and exit
    //
    goto rulelike_typeEx; /* Prevent compiler warnings */
    rulelike_typeEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end like_type */

/**
 * $ANTLR start like_escape_part
 * OracleDML.g:955:1: like_escape_part : escape_key concatenation -> ^( EXPR concatenation ) ;
 */
OracleDML::like_escape_part_return
OracleDML::like_escape_part()
{
    OracleDML::like_escape_part_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML_OracleDMLKeys::escape_key_return escape_key690;
    ImplTraits::TreeTypePtr::pointer escape_key690_last = NULL;
    OracleDML::concatenation_return concatenation691;
    ImplTraits::TreeTypePtr::pointer concatenation691_last = NULL;
    RewriteRuleSubtreeStream<ImplTraits> stream_escape_key(get_psrstate()->get_treeAdaptor(), "rule escape_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_concatenation(get_psrstate()->get_treeAdaptor(), "rule concatenation");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:956:5: ( escape_key concatenation -> ^( EXPR concatenation ) )
        // OracleDML.g:956:10: escape_key concatenation
        {
            this->followPush(FOLLOW_escape_key_in_like_escape_part9691);
            escape_key690=escape_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulelike_escape_partEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                escape_key690_last = escape_key690.tree.get();
                stream_escape_key.add(escape_key690.tree);
            }

            this->followPush(FOLLOW_concatenation_in_like_escape_part9693);
            concatenation691=concatenation();

            this->followPop();
            if  (this->hasException())
            {
                goto rulelike_escape_partEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                concatenation691_last = concatenation691.tree.get();
                stream_concatenation.add(concatenation691.tree);
            }

            // AST REWRITE
            // elements: concatenation
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 957:9: -> ^( EXPR concatenation )
            {
            	// OracleDML.g:957:12: ^( EXPR concatenation )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(EXPR, "EXPR"), root_1);
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_concatenation.nextTree());
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulelike_escape_partEx; /* Prevent compiler warnings */
    rulelike_escape_partEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end like_escape_part */

/**
 * $ANTLR start in_elements
 * OracleDML.g:960:1: in_elements : ( ( ( LEFT_PAREN )+ ( select_key | with_key ) )=> LEFT_PAREN subquery RIGHT_PAREN -> ^( NESTED_SUBQUERY[$LEFT_PAREN] subquery RIGHT_PAREN ) | LEFT_PAREN concatenation_wrapper ( COMMA concatenation_wrapper )* RIGHT_PAREN -> ^( EXPR_LIST[$LEFT_PAREN] ( concatenation_wrapper )+ RIGHT_PAREN ) | constant -> ^( EXPR_LIST constant ) | bind_variable -> ^( EXPR_LIST bind_variable ) | general_element -> ^( EXPR_LIST general_element ) );
 */
OracleDML::in_elements_return
OracleDML::in_elements()
{
    OracleDML::in_elements_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* LEFT_PAREN692 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN694 = NULL;
    ImplTraits::CommonTokenType const* LEFT_PAREN695 = NULL;
    ImplTraits::CommonTokenType const* COMMA697 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN699 = NULL;
    OracleDML::subquery_return subquery693;
    ImplTraits::TreeTypePtr::pointer subquery693_last = NULL;
    OracleDML::concatenation_wrapper_return concatenation_wrapper696;
    ImplTraits::TreeTypePtr::pointer concatenation_wrapper696_last = NULL;
    OracleDML::concatenation_wrapper_return concatenation_wrapper698;
    ImplTraits::TreeTypePtr::pointer concatenation_wrapper698_last = NULL;
    OracleDML_OracleDMLCommons::constant_return constant700;
    ImplTraits::TreeTypePtr::pointer constant700_last = NULL;
    OracleDML_OracleDMLCommons::bind_variable_return bind_variable701;
    ImplTraits::TreeTypePtr::pointer bind_variable701_last = NULL;
    OracleDML_OracleDMLCommons::general_element_return general_element702;
    ImplTraits::TreeTypePtr::pointer general_element702_last = NULL;
    ImplTraits::TreeTypePtr LEFT_PAREN692_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN694_tree;
    ImplTraits::TreeTypePtr LEFT_PAREN695_tree;
    ImplTraits::TreeTypePtr COMMA697_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN699_tree;
    RewriteRuleTokenStream<ImplTraits> stream_LEFT_PAREN(get_psrstate()->get_treeAdaptor(), "token LEFT_PAREN");
    RewriteRuleTokenStream<ImplTraits> stream_RIGHT_PAREN(get_psrstate()->get_treeAdaptor(), "token RIGHT_PAREN");
    RewriteRuleTokenStream<ImplTraits> stream_COMMA(get_psrstate()->get_treeAdaptor(), "token COMMA");
    RewriteRuleSubtreeStream<ImplTraits> stream_concatenation_wrapper(get_psrstate()->get_treeAdaptor(), "rule concatenation_wrapper");
    RewriteRuleSubtreeStream<ImplTraits> stream_bind_variable(get_psrstate()->get_treeAdaptor(), "rule bind_variable");
    RewriteRuleSubtreeStream<ImplTraits> stream_constant(get_psrstate()->get_treeAdaptor(), "rule constant");
    RewriteRuleSubtreeStream<ImplTraits> stream_general_element(get_psrstate()->get_treeAdaptor(), "rule general_element");
    RewriteRuleSubtreeStream<ImplTraits> stream_subquery(get_psrstate()->get_treeAdaptor(), "rule subquery");

    /* Initialize rule variables
     */

        int mode = 0;    
    retval.call_start_placeholder(this);


 
    {
        {
            //  OracleDML.g:962:5: ( ( ( LEFT_PAREN )+ ( select_key | with_key ) )=> LEFT_PAREN subquery RIGHT_PAREN -> ^( NESTED_SUBQUERY[$LEFT_PAREN] subquery RIGHT_PAREN ) | LEFT_PAREN concatenation_wrapper ( COMMA concatenation_wrapper )* RIGHT_PAREN -> ^( EXPR_LIST[$LEFT_PAREN] ( concatenation_wrapper )+ RIGHT_PAREN ) | constant -> ^( EXPR_LIST constant ) | bind_variable -> ^( EXPR_LIST bind_variable ) | general_element -> ^( EXPR_LIST general_element ) )

            ANTLR_UINT32 alt236;

            alt236=5;

            switch ( this->LA(1) )
            {
            case LEFT_PAREN:
            	{
            		{
            		    ANTLR_UINT32 LA236_1 = this->LA(2);
            		    if ( (this->msynpred( antlr3::ClassForwarder<synpred29_OracleDML>() )))
            		    {
            		        alt236=1;
            		    }
            		    else if ( (true))
            		    {
            		        alt236=2;
            		    }
            		    else
            		    {
            		        if (this->get_backtracking()>0)
            		        {
            		            this->set_failedflag( true );
            		            return retval;
            		        }


            		        ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 236 );
            		        ex->set_state( 1 );


            		        goto rulein_elementsEx;

            		    }
            		}
            	}
                break;
            case REGULAR_ID:
            	{
            		{
            		    ANTLR_UINT32 LA236_2 = this->LA(2);
            		    if ( ((((toUpper(LT(1)->getText()) == "INTERVAL"))||((toUpper(LT(1)->getText()) == "MINVALUE"))||((toUpper(LT(1)->getText()) == "SESSIONTIMEZONE"))||((toUpper(LT(1)->getText()) == "TIMESTAMP"))||((toUpper(LT(1)->getText()) == "MAXVALUE"))||((toUpper(LT(1)->getText()) == "DBTIMEZONE")))))
            		    {
            		        alt236=3;
            		    }
            		    else if ( (true))
            		    {
            		        alt236=5;
            		    }
            		    else
            		    {
            		        if (this->get_backtracking()>0)
            		        {
            		            this->set_failedflag( true );
            		            return retval;
            		        }


            		        ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 236 );
            		        ex->set_state( 2 );


            		        goto rulein_elementsEx;

            		    }
            		}
            	}
                break;
            case APPROXIMATE_NUM_LIT:
            case CHAR_STRING:
            case CHAR_STRING_PERL:
            case EXACT_NUM_LIT:
            case NATIONAL_CHAR_STRING_LIT:
            case SQL92_RESERVED_DATE:
            case SQL92_RESERVED_DEFAULT:
            case SQL92_RESERVED_FALSE:
            case SQL92_RESERVED_NULL:
            case SQL92_RESERVED_TRUE:
            case UNSIGNED_INTEGER:
            	{
            		alt236=3;
            	}
                break;
            case BINDVAR:
            case COLON:
            	{
            		alt236=4;
            	}
                break;
            case DELIMITED_ID:
            case INTRODUCER:
            	{
            		alt236=5;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 236 );
                ex->set_state( 0 );


                goto rulein_elementsEx;

            }

            switch (alt236)
            {
        	case 1:
        	    // OracleDML.g:962:10: ( ( LEFT_PAREN )+ ( select_key | with_key ) )=> LEFT_PAREN subquery RIGHT_PAREN
        	    {
        	        LEFT_PAREN692 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_in_elements9751);
        	        if  (this->hasException())
        	        {
        	            goto rulein_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }
        	         
        	        if ( this->get_backtracking()==0 ) stream_LEFT_PAREN.add(LEFT_PAREN692);


        	        this->followPush(FOLLOW_subquery_in_in_elements9753);
        	        subquery693=subquery();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulein_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) 
        	        {
        	            subquery693_last = subquery693.tree.get();
        	            stream_subquery.add(subquery693.tree);
        	        }

        	        RIGHT_PAREN694 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_in_elements9755);
        	        if  (this->hasException())
        	        {
        	            goto rulein_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }
        	         
        	        if ( this->get_backtracking()==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN694);


        	        // AST REWRITE
        	        // elements: subquery, RIGHT_PAREN
        	        // token labels: 
        	        // rule labels: retval
        	        // token list labels: 
        	        // rule list labels: 
        	        // wildcard labels: 
        	        if ( this->get_backtracking()==0 ) {
        	        retval.tree = std::move(root_0);
        	        RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
        	        // 963:10: -> ^( NESTED_SUBQUERY[$LEFT_PAREN] subquery RIGHT_PAREN )
        	        {
        	        	// OracleDML.g:963:13: ^( NESTED_SUBQUERY[$LEFT_PAREN] subquery RIGHT_PAREN )
        	        	{
        	        	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
        	        	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(NESTED_SUBQUERY, LEFT_PAREN692), root_1);
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_subquery.nextTree());
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_RIGHT_PAREN.nextNode());
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
        	        	}
        	        }


        	        //retval.tree = std::move(root_0);
        	        }

        	    }
        	    break;
        	case 2:
        	    // OracleDML.g:964:10: LEFT_PAREN concatenation_wrapper ( COMMA concatenation_wrapper )* RIGHT_PAREN
        	    {
        	        LEFT_PAREN695 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_in_elements9786);
        	        if  (this->hasException())
        	        {
        	            goto rulein_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }
        	         
        	        if ( this->get_backtracking()==0 ) stream_LEFT_PAREN.add(LEFT_PAREN695);


        	        this->followPush(FOLLOW_concatenation_wrapper_in_in_elements9788);
        	        concatenation_wrapper696=concatenation_wrapper();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulein_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) 
        	        {
        	            concatenation_wrapper696_last = concatenation_wrapper696.tree.get();
        	            stream_concatenation_wrapper.add(concatenation_wrapper696.tree);
        	        }

        	        // OracleDML.g:964:43: ( COMMA concatenation_wrapper )*

        	        for (;;)
        	        {
        	            ANTLR_UINT32 alt235=2;
        	            switch ( this->LA(1) )
        	            {
        	            case COMMA:
        	            	{
        	            		alt235=1;
        	            	}
        	                break;

        	            }

        	            switch (alt235)
        	            {
        	        	case 1:
        	        	    // OracleDML.g:964:44: COMMA concatenation_wrapper
        	        	    {
        	        	        COMMA697 =  this->matchToken(COMMA, &FOLLOW_COMMA_in_in_elements9791);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulein_elementsEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }
        	        	         
        	        	        if ( this->get_backtracking()==0 ) stream_COMMA.add(COMMA697);


        	        	        this->followPush(FOLLOW_concatenation_wrapper_in_in_elements9793);
        	        	        concatenation_wrapper698=concatenation_wrapper();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulein_elementsEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) 
        	        	        {
        	        	            concatenation_wrapper698_last = concatenation_wrapper698.tree.get();
        	        	            stream_concatenation_wrapper.add(concatenation_wrapper698.tree);
        	        	        }

        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop235;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop235: ; /* Jump out to here if this rule does not match */


        	        RIGHT_PAREN699 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_in_elements9797);
        	        if  (this->hasException())
        	        {
        	            goto rulein_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }
        	         
        	        if ( this->get_backtracking()==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN699);


        	        // AST REWRITE
        	        // elements: concatenation_wrapper, RIGHT_PAREN
        	        // token labels: 
        	        // rule labels: retval
        	        // token list labels: 
        	        // rule list labels: 
        	        // wildcard labels: 
        	        if ( this->get_backtracking()==0 ) {
        	        retval.tree = std::move(root_0);
        	        RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
        	        // 965:10: -> ^( EXPR_LIST[$LEFT_PAREN] ( concatenation_wrapper )+ RIGHT_PAREN )
        	        {
        	        	// OracleDML.g:965:13: ^( EXPR_LIST[$LEFT_PAREN] ( concatenation_wrapper )+ RIGHT_PAREN )
        	        	{
        	        	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
        	        	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(EXPR_LIST, LEFT_PAREN695), root_1);
        	        	if ( !(stream_concatenation_wrapper.hasNext()) ) {
        	        		ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, REWRITE_EARLY_EXCEPTION, StreamType>( this->get_rec(), "concatenation_wrapper empty" );
        	        		goto rulein_elementsEx;
        	        	}
        	        	while ( stream_concatenation_wrapper.hasNext() ) {
        	        		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_concatenation_wrapper.nextTree());
        	        	}
        	        	stream_concatenation_wrapper.reset();

        	        	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_RIGHT_PAREN.nextNode());
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
        	        	}
        	        }


        	        //retval.tree = std::move(root_0);
        	        }

        	    }
        	    break;
        	case 3:
        	    // OracleDML.g:966:10: constant
        	    {
        	        this->followPush(FOLLOW_constant_in_in_elements9829);
        	        constant700=constant();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulein_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) 
        	        {
        	            constant700_last = constant700.tree.get();
        	            stream_constant.add(constant700.tree);
        	        }

        	        // AST REWRITE
        	        // elements: constant
        	        // token labels: 
        	        // rule labels: retval
        	        // token list labels: 
        	        // rule list labels: 
        	        // wildcard labels: 
        	        if ( this->get_backtracking()==0 ) {
        	        retval.tree = std::move(root_0);
        	        RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
        	        // 967:10: -> ^( EXPR_LIST constant )
        	        {
        	        	// OracleDML.g:967:13: ^( EXPR_LIST constant )
        	        	{
        	        	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
        	        	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(EXPR_LIST, "EXPR_LIST"), root_1);
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_constant.nextTree());
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
        	        	}
        	        }


        	        //retval.tree = std::move(root_0);
        	        }

        	    }
        	    break;
        	case 4:
        	    // OracleDML.g:968:10: bind_variable
        	    {
        	        this->followPush(FOLLOW_bind_variable_in_in_elements9857);
        	        bind_variable701=bind_variable();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulein_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) 
        	        {
        	            bind_variable701_last = bind_variable701.tree.get();
        	            stream_bind_variable.add(bind_variable701.tree);
        	        }

        	        // AST REWRITE
        	        // elements: bind_variable
        	        // token labels: 
        	        // rule labels: retval
        	        // token list labels: 
        	        // rule list labels: 
        	        // wildcard labels: 
        	        if ( this->get_backtracking()==0 ) {
        	        retval.tree = std::move(root_0);
        	        RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
        	        // 969:10: -> ^( EXPR_LIST bind_variable )
        	        {
        	        	// OracleDML.g:969:13: ^( EXPR_LIST bind_variable )
        	        	{
        	        	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
        	        	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(EXPR_LIST, "EXPR_LIST"), root_1);
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_bind_variable.nextTree());
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
        	        	}
        	        }


        	        //retval.tree = std::move(root_0);
        	        }

        	    }
        	    break;
        	case 5:
        	    // OracleDML.g:970:10: general_element
        	    {
        	        this->followPush(FOLLOW_general_element_in_in_elements9885);
        	        general_element702=general_element();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulein_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) 
        	        {
        	            general_element702_last = general_element702.tree.get();
        	            stream_general_element.add(general_element702.tree);
        	        }

        	        // AST REWRITE
        	        // elements: general_element
        	        // token labels: 
        	        // rule labels: retval
        	        // token list labels: 
        	        // rule list labels: 
        	        // wildcard labels: 
        	        if ( this->get_backtracking()==0 ) {
        	        retval.tree = std::move(root_0);
        	        RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
        	        // 971:10: -> ^( EXPR_LIST general_element )
        	        {
        	        	// OracleDML.g:971:13: ^( EXPR_LIST general_element )
        	        	{
        	        	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
        	        	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(EXPR_LIST, "EXPR_LIST"), root_1);
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_general_element.nextTree());
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
        	        	}
        	        }


        	        //retval.tree = std::move(root_0);
        	        }

        	    }
        	    break;

            }
        }
    }//...
    // This is where rules clean up and exit
    //
    goto rulein_elementsEx; /* Prevent compiler warnings */
    rulein_elementsEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end in_elements */

/**
 * $ANTLR start between_elements
 * OracleDML.g:974:1: between_elements : cn1= concatenation and_key cn2= concatenation -> ^( EXPR $cn1) ^( EXPR $cn2) ;
 */
OracleDML::between_elements_return
OracleDML::between_elements()
{
    OracleDML::between_elements_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML::concatenation_return cn1;
    ImplTraits::TreeTypePtr::pointer cn1_last = NULL;
    OracleDML::concatenation_return cn2;
    ImplTraits::TreeTypePtr::pointer cn2_last = NULL;
    OracleDML_OracleDMLKeys::and_key_return and_key703;
    ImplTraits::TreeTypePtr::pointer and_key703_last = NULL;
    RewriteRuleSubtreeStream<ImplTraits> stream_and_key(get_psrstate()->get_treeAdaptor(), "rule and_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_concatenation(get_psrstate()->get_treeAdaptor(), "rule concatenation");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:975:5: (cn1= concatenation and_key cn2= concatenation -> ^( EXPR $cn1) ^( EXPR $cn2) )
        // OracleDML.g:975:10: cn1= concatenation and_key cn2= concatenation
        {
            this->followPush(FOLLOW_concatenation_in_between_elements9924);
            cn1=concatenation();

            this->followPop();
            if  (this->hasException())
            {
                goto rulebetween_elementsEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                cn1_last = cn1.tree.get();
                stream_concatenation.add(cn1.tree);
            }

            this->followPush(FOLLOW_and_key_in_between_elements9926);
            and_key703=and_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulebetween_elementsEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                and_key703_last = and_key703.tree.get();
                stream_and_key.add(and_key703.tree);
            }

            this->followPush(FOLLOW_concatenation_in_between_elements9930);
            cn2=concatenation();

            this->followPop();
            if  (this->hasException())
            {
                goto rulebetween_elementsEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                cn2_last = cn2.tree.get();
                stream_concatenation.add(cn2.tree);
            }

            // AST REWRITE
            // elements: cn2, cn1
            // token labels: 
            // rule labels: retval, cn2, cn1
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval
            RewriteRuleSubtreeStream<ImplTraits> stream_cn2(get_psrstate()->get_treeAdaptor(), "rule cn2",cn2_last); // rewrite alias
            RewriteRuleSubtreeStream<ImplTraits> stream_cn1(get_psrstate()->get_treeAdaptor(), "rule cn1",cn1_last); // rewrite alias

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 976:9: -> ^( EXPR $cn1) ^( EXPR $cn2)
            {
            	// OracleDML.g:976:12: ^( EXPR $cn1)
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(EXPR, "EXPR"), root_1);
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_cn1.nextTree());
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            	// OracleDML.g:976:25: ^( EXPR $cn2)
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(EXPR, "EXPR"), root_1);
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_cn2.nextTree());
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulebetween_elementsEx; /* Prevent compiler warnings */
    rulebetween_elementsEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end between_elements */

/**
 * $ANTLR start concatenation
 * OracleDML.g:979:1: concatenation : additive_expression ( concatenation_seq )* -> { mode == 1 }? ^( CONCATENATION_OP additive_expression ( concatenation_seq )* ) -> additive_expression ;
 */
OracleDML::concatenation_return
OracleDML::concatenation()
{
    OracleDML::concatenation_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML::additive_expression_return additive_expression704;
    ImplTraits::TreeTypePtr::pointer additive_expression704_last = NULL;
    OracleDML::concatenation_seq_return concatenation_seq705;
    ImplTraits::TreeTypePtr::pointer concatenation_seq705_last = NULL;
    RewriteRuleSubtreeStream<ImplTraits> stream_concatenation_seq(get_psrstate()->get_treeAdaptor(), "rule concatenation_seq");
    RewriteRuleSubtreeStream<ImplTraits> stream_additive_expression(get_psrstate()->get_treeAdaptor(), "rule additive_expression");

    /* Initialize rule variables
     */

     int mode = 0; 
    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:981:5: ( additive_expression ( concatenation_seq )* -> { mode == 1 }? ^( CONCATENATION_OP additive_expression ( concatenation_seq )* ) -> additive_expression )
        // OracleDML.g:981:10: additive_expression ( concatenation_seq )*
        {
            this->followPush(FOLLOW_additive_expression_in_concatenation9983);
            additive_expression704=additive_expression();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleconcatenationEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                additive_expression704_last = additive_expression704.tree.get();
                stream_additive_expression.add(additive_expression704.tree);
            }

            // OracleDML.g:981:30: ( concatenation_seq )*

            for (;;)
            {
                ANTLR_UINT32 alt237=2;
                switch ( this->LA(1) )
                {
                case CONCATENATION_OP:
                	{
                		alt237=1;
                	}
                    break;
                case VERTICAL_BAR:
                	{
                		alt237=1;
                	}
                    break;

                }

                switch (alt237)
                {
            	case 1:
            	    // OracleDML.g:981:31: concatenation_seq
            	    {
            	        this->followPush(FOLLOW_concatenation_seq_in_concatenation9986);
            	        concatenation_seq705=concatenation_seq();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleconcatenationEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            concatenation_seq705_last = concatenation_seq705.tree.get();
            	            stream_concatenation_seq.add(concatenation_seq705.tree);
            	        }

            	        if ( this->get_backtracking()==0 )
            	        {
            	             mode = 1; 
            	        }


            	    }
            	    break;

            	default:
            	    goto loop237;	/* break out of the loop */
            	    break;
                }
            }
            loop237: ; /* Jump out to here if this rule does not match */


            // AST REWRITE
            // elements: additive_expression, additive_expression, concatenation_seq
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 982:9: -> { mode == 1 }? ^( CONCATENATION_OP additive_expression ( concatenation_seq )* )
            if ( mode == 1 ) {
            	// OracleDML.g:982:27: ^( CONCATENATION_OP additive_expression ( concatenation_seq )* )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(CONCATENATION_OP, "CONCATENATION_OP"), root_1);
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_additive_expression.nextTree());
            	// OracleDML.g:982:66: ( concatenation_seq )*
            	while ( stream_concatenation_seq.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_concatenation_seq.nextTree());
            	}
            	stream_concatenation_seq.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }

            else // 983:9: -> additive_expression
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, stream_additive_expression.nextTree());
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleconcatenationEx; /* Prevent compiler warnings */
    ruleconcatenationEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end concatenation */

/**
 * $ANTLR start concatenation_seq
 * OracleDML.g:986:1: concatenation_seq : ( concatenation_op ^ additive_expression ) ;
 */
OracleDML::concatenation_seq_return
OracleDML::concatenation_seq()
{
    OracleDML::concatenation_seq_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML_OracleDMLCommons::concatenation_op_return concatenation_op706;
    ImplTraits::TreeTypePtr::pointer concatenation_op706_last = NULL;
    OracleDML::additive_expression_return additive_expression707;
    ImplTraits::TreeTypePtr::pointer additive_expression707_last = NULL;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:987:5: ( ( concatenation_op ^ additive_expression ) )
        // OracleDML.g:987:10: ( concatenation_op ^ additive_expression )
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            // OracleDML.g:987:10: ( concatenation_op ^ additive_expression )
            // OracleDML.g:987:11: concatenation_op ^ additive_expression
            {
                this->followPush(FOLLOW_concatenation_op_in_concatenation_seq10045);
                concatenation_op706=concatenation_op();

                this->followPop();
                if  (this->hasException())
                {
                    goto ruleconcatenation_seqEx;
                }
                if (this->hasFailed())
                {
                    return retval;
                }

                if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(concatenation_op706.tree, root_0);

                this->followPush(FOLLOW_additive_expression_in_concatenation_seq10048);
                additive_expression707=additive_expression();

                this->followPop();
                if  (this->hasException())
                {
                    goto ruleconcatenation_seqEx;
                }
                if (this->hasFailed())
                {
                    return retval;
                }

                if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, additive_expression707.tree);


            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleconcatenation_seqEx; /* Prevent compiler warnings */
    ruleconcatenation_seqEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end concatenation_seq */

/**
 * $ANTLR start concatenation_wrapper
 * OracleDML.g:989:1: concatenation_wrapper : concatenation -> ^( EXPR concatenation ) ;
 */
OracleDML::concatenation_wrapper_return
OracleDML::concatenation_wrapper()
{
    OracleDML::concatenation_wrapper_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML::concatenation_return concatenation708;
    ImplTraits::TreeTypePtr::pointer concatenation708_last = NULL;
    RewriteRuleSubtreeStream<ImplTraits> stream_concatenation(get_psrstate()->get_treeAdaptor(), "rule concatenation");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:990:5: ( concatenation -> ^( EXPR concatenation ) )
        // OracleDML.g:990:10: concatenation
        {
            this->followPush(FOLLOW_concatenation_in_concatenation_wrapper10068);
            concatenation708=concatenation();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleconcatenation_wrapperEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                concatenation708_last = concatenation708.tree.get();
                stream_concatenation.add(concatenation708.tree);
            }

            // AST REWRITE
            // elements: concatenation
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 991:9: -> ^( EXPR concatenation )
            {
            	// OracleDML.g:991:12: ^( EXPR concatenation )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(EXPR, "EXPR"), root_1);
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_concatenation.nextTree());
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleconcatenation_wrapperEx; /* Prevent compiler warnings */
    ruleconcatenation_wrapperEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end concatenation_wrapper */

/**
 * $ANTLR start additive_expression
 * OracleDML.g:994:1: additive_expression : multiply_expression ( ( PLUS_SIGN ^| MINUS_SIGN ^) multiply_expression )* ;
 */
OracleDML::additive_expression_return
OracleDML::additive_expression()
{
    OracleDML::additive_expression_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* PLUS_SIGN710 = NULL;
    ImplTraits::CommonTokenType const* MINUS_SIGN711 = NULL;
    OracleDML::multiply_expression_return multiply_expression709;
    ImplTraits::TreeTypePtr::pointer multiply_expression709_last = NULL;
    OracleDML::multiply_expression_return multiply_expression712;
    ImplTraits::TreeTypePtr::pointer multiply_expression712_last = NULL;
    ImplTraits::TreeTypePtr PLUS_SIGN710_tree;
    ImplTraits::TreeTypePtr MINUS_SIGN711_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:995:5: ( multiply_expression ( ( PLUS_SIGN ^| MINUS_SIGN ^) multiply_expression )* )
        // OracleDML.g:995:10: multiply_expression ( ( PLUS_SIGN ^| MINUS_SIGN ^) multiply_expression )*
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            this->followPush(FOLLOW_multiply_expression_in_additive_expression10104);
            multiply_expression709=multiply_expression();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleadditive_expressionEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, multiply_expression709.tree);


            // OracleDML.g:995:30: ( ( PLUS_SIGN ^| MINUS_SIGN ^) multiply_expression )*

            for (;;)
            {
                ANTLR_UINT32 alt239=2;
                switch ( this->LA(1) )
                {
                case PLUS_SIGN:
                	{
                		alt239=1;
                	}
                    break;
                case MINUS_SIGN:
                	{
                		alt239=1;
                	}
                    break;

                }

                switch (alt239)
                {
            	case 1:
            	    // OracleDML.g:995:32: ( PLUS_SIGN ^| MINUS_SIGN ^) multiply_expression
            	    {
            	        // OracleDML.g:995:32: ( PLUS_SIGN ^| MINUS_SIGN ^)
            	        {
            	            ANTLR_UINT32 alt238=2;
            	            switch ( this->LA(1) )
            	            {
            	            case PLUS_SIGN:
            	            	{
            	            		alt238=1;
            	            	}
            	                break;
            	            case MINUS_SIGN:
            	            	{
            	            		alt238=2;
            	            	}
            	                break;

            	            default:
            	                if (this->get_backtracking()>0)
            	                {
            	                    this->set_failedflag( true );
            	                    return retval;
            	                }

            	                ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                ex->set_decisionNum( 238 );
            	                ex->set_state( 0 );


            	                goto ruleadditive_expressionEx;

            	            }

            	            switch (alt238)
            	            {
            	        	case 1:
            	        	    // OracleDML.g:995:34: PLUS_SIGN ^
            	        	    {
            	        	        PLUS_SIGN710 =  this->matchToken(PLUS_SIGN, &FOLLOW_PLUS_SIGN_in_additive_expression10110);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleadditive_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) {
            	        	        PLUS_SIGN710_tree = get_psrstate()->get_treeAdaptor()->create(PLUS_SIGN710);
            	        	        root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(PLUS_SIGN710_tree, root_0);
            	        	        }


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // OracleDML.g:995:47: MINUS_SIGN ^
            	        	    {
            	        	        MINUS_SIGN711 =  this->matchToken(MINUS_SIGN, &FOLLOW_MINUS_SIGN_in_additive_expression10115);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleadditive_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) {
            	        	        MINUS_SIGN711_tree = get_psrstate()->get_treeAdaptor()->create(MINUS_SIGN711);
            	        	        root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(MINUS_SIGN711_tree, root_0);
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	        this->followPush(FOLLOW_multiply_expression_in_additive_expression10120);
            	        multiply_expression712=multiply_expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleadditive_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, multiply_expression712.tree);


            	    }
            	    break;

            	default:
            	    goto loop239;	/* break out of the loop */
            	    break;
                }
            }
            loop239: ; /* Jump out to here if this rule does not match */


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleadditive_expressionEx; /* Prevent compiler warnings */
    ruleadditive_expressionEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end additive_expression */

/**
 * $ANTLR start multiply_expression
 * OracleDML.g:998:1: multiply_expression : datetime_expression ( ( ASTERISK ^| SOLIDUS ^) datetime_expression )* ;
 */
OracleDML::multiply_expression_return
OracleDML::multiply_expression()
{
    OracleDML::multiply_expression_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* ASTERISK714 = NULL;
    ImplTraits::CommonTokenType const* SOLIDUS715 = NULL;
    OracleDML::datetime_expression_return datetime_expression713;
    ImplTraits::TreeTypePtr::pointer datetime_expression713_last = NULL;
    OracleDML::datetime_expression_return datetime_expression716;
    ImplTraits::TreeTypePtr::pointer datetime_expression716_last = NULL;
    ImplTraits::TreeTypePtr ASTERISK714_tree;
    ImplTraits::TreeTypePtr SOLIDUS715_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:999:5: ( datetime_expression ( ( ASTERISK ^| SOLIDUS ^) datetime_expression )* )
        // OracleDML.g:999:10: datetime_expression ( ( ASTERISK ^| SOLIDUS ^) datetime_expression )*
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            this->followPush(FOLLOW_datetime_expression_in_multiply_expression10142);
            datetime_expression713=datetime_expression();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemultiply_expressionEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, datetime_expression713.tree);


            // OracleDML.g:999:30: ( ( ASTERISK ^| SOLIDUS ^) datetime_expression )*

            for (;;)
            {
                ANTLR_UINT32 alt241=2;
                switch ( this->LA(1) )
                {
                case ASTERISK:
                	{
                		alt241=1;
                	}
                    break;
                case SOLIDUS:
                	{
                		alt241=1;
                	}
                    break;

                }

                switch (alt241)
                {
            	case 1:
            	    // OracleDML.g:999:32: ( ASTERISK ^| SOLIDUS ^) datetime_expression
            	    {
            	        // OracleDML.g:999:32: ( ASTERISK ^| SOLIDUS ^)
            	        {
            	            ANTLR_UINT32 alt240=2;
            	            switch ( this->LA(1) )
            	            {
            	            case ASTERISK:
            	            	{
            	            		alt240=1;
            	            	}
            	                break;
            	            case SOLIDUS:
            	            	{
            	            		alt240=2;
            	            	}
            	                break;

            	            default:
            	                if (this->get_backtracking()>0)
            	                {
            	                    this->set_failedflag( true );
            	                    return retval;
            	                }

            	                ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                ex->set_decisionNum( 240 );
            	                ex->set_state( 0 );


            	                goto rulemultiply_expressionEx;

            	            }

            	            switch (alt240)
            	            {
            	        	case 1:
            	        	    // OracleDML.g:999:34: ASTERISK ^
            	        	    {
            	        	        ASTERISK714 =  this->matchToken(ASTERISK, &FOLLOW_ASTERISK_in_multiply_expression10148);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulemultiply_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) {
            	        	        ASTERISK714_tree = get_psrstate()->get_treeAdaptor()->create(ASTERISK714);
            	        	        root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(ASTERISK714_tree, root_0);
            	        	        }


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // OracleDML.g:999:46: SOLIDUS ^
            	        	    {
            	        	        SOLIDUS715 =  this->matchToken(SOLIDUS, &FOLLOW_SOLIDUS_in_multiply_expression10153);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulemultiply_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) {
            	        	        SOLIDUS715_tree = get_psrstate()->get_treeAdaptor()->create(SOLIDUS715);
            	        	        root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(SOLIDUS715_tree, root_0);
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	        this->followPush(FOLLOW_datetime_expression_in_multiply_expression10158);
            	        datetime_expression716=datetime_expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemultiply_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, datetime_expression716.tree);


            	    }
            	    break;

            	default:
            	    goto loop241;	/* break out of the loop */
            	    break;
                }
            }
            loop241: ; /* Jump out to here if this rule does not match */


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulemultiply_expressionEx; /* Prevent compiler warnings */
    rulemultiply_expressionEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end multiply_expression */

/**
 * $ANTLR start datetime_expression
 * OracleDML.g:1002:1: datetime_expression : ( model_expression -> model_expression ) ( at_key ( local_key | time_key zone_key concatenation_wrapper ) -> ^( DATETIME_OP $datetime_expression ^( at_key ( local_key )? ( time_key )? concatenation_wrapper ) ) | ( interval_expression )=> interval_expression -> ^( DATETIME_OP $datetime_expression interval_expression ) )? ;
 */
OracleDML::datetime_expression_return
OracleDML::datetime_expression()
{
    OracleDML::datetime_expression_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML::model_expression_return model_expression717;
    ImplTraits::TreeTypePtr::pointer model_expression717_last = NULL;
    OracleDML_OracleDMLKeys::at_key_return at_key718;
    ImplTraits::TreeTypePtr::pointer at_key718_last = NULL;
    OracleDML_OracleDMLKeys::local_key_return local_key719;
    ImplTraits::TreeTypePtr::pointer local_key719_last = NULL;
    OracleDML_OracleDMLKeys::time_key_return time_key720;
    ImplTraits::TreeTypePtr::pointer time_key720_last = NULL;
    OracleDML_OracleDMLKeys::zone_key_return zone_key721;
    ImplTraits::TreeTypePtr::pointer zone_key721_last = NULL;
    OracleDML::concatenation_wrapper_return concatenation_wrapper722;
    ImplTraits::TreeTypePtr::pointer concatenation_wrapper722_last = NULL;
    OracleDML::interval_expression_return interval_expression723;
    ImplTraits::TreeTypePtr::pointer interval_expression723_last = NULL;
    RewriteRuleSubtreeStream<ImplTraits> stream_at_key(get_psrstate()->get_treeAdaptor(), "rule at_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_concatenation_wrapper(get_psrstate()->get_treeAdaptor(), "rule concatenation_wrapper");
    RewriteRuleSubtreeStream<ImplTraits> stream_model_expression(get_psrstate()->get_treeAdaptor(), "rule model_expression");
    RewriteRuleSubtreeStream<ImplTraits> stream_local_key(get_psrstate()->get_treeAdaptor(), "rule local_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_zone_key(get_psrstate()->get_treeAdaptor(), "rule zone_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_interval_expression(get_psrstate()->get_treeAdaptor(), "rule interval_expression");
    RewriteRuleSubtreeStream<ImplTraits> stream_time_key(get_psrstate()->get_treeAdaptor(), "rule time_key");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:1003:5: ( ( model_expression -> model_expression ) ( at_key ( local_key | time_key zone_key concatenation_wrapper ) -> ^( DATETIME_OP $datetime_expression ^( at_key ( local_key )? ( time_key )? concatenation_wrapper ) ) | ( interval_expression )=> interval_expression -> ^( DATETIME_OP $datetime_expression interval_expression ) )? )
        // OracleDML.g:1003:10: ( model_expression -> model_expression ) ( at_key ( local_key | time_key zone_key concatenation_wrapper ) -> ^( DATETIME_OP $datetime_expression ^( at_key ( local_key )? ( time_key )? concatenation_wrapper ) ) | ( interval_expression )=> interval_expression -> ^( DATETIME_OP $datetime_expression interval_expression ) )?
        {
            // OracleDML.g:1003:10: ( model_expression -> model_expression )
            // OracleDML.g:1003:11: model_expression
            {
                this->followPush(FOLLOW_model_expression_in_datetime_expression10181);
                model_expression717=model_expression();

                this->followPop();
                if  (this->hasException())
                {
                    goto ruledatetime_expressionEx;
                }
                if (this->hasFailed())
                {
                    return retval;
                }

                if ( this->get_backtracking()==0 ) 
                {
                    model_expression717_last = model_expression717.tree.get();
                    stream_model_expression.add(model_expression717.tree);
                }

                // AST REWRITE
                // elements: model_expression
                // token labels: 
                // rule labels: retval
                // token list labels: 
                // rule list labels: 
                // wildcard labels: 
                if ( this->get_backtracking()==0 ) {
                retval.tree = std::move(root_0);
                RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

                root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
                // 1003:28: -> model_expression
                {
                	get_psrstate()->get_treeAdaptor()->addChild(root_0, stream_model_expression.nextTree());
                }


                //retval.tree = std::move(root_0);
                }

            }


            // OracleDML.g:1004:5: ( at_key ( local_key | time_key zone_key concatenation_wrapper ) -> ^( DATETIME_OP $datetime_expression ^( at_key ( local_key )? ( time_key )? concatenation_wrapper ) ) | ( interval_expression )=> interval_expression -> ^( DATETIME_OP $datetime_expression interval_expression ) )?
            {
                ANTLR_UINT32 alt243=3;
                switch ( this->LA(1) )
                {
                    case REGULAR_ID:
                    	{
                    		{
                    		    ANTLR_UINT32 LA243_1 = this->LA(2);
                    		    if ( ((toUpper(LT(1)->getText()) == "AT")))
                    		    {
                    		        alt243=1;
                    		    }
                    		    else if ( (( ((((toUpper(LT(1)->getText()) == "YEAR"))||((toUpper(LT(1)->getText()) == "DAY")))) && (this->msynpred( antlr3::ClassForwarder<synpred30_OracleDML>() )) )))
                    		    {
                    		        alt243=2;
                    		    }
                    		}
                    	}
                        break;
                }

                switch (alt243)
                {
            	case 1:
            	    // OracleDML.g:1004:10: at_key ( local_key | time_key zone_key concatenation_wrapper )
            	    {
            	        this->followPush(FOLLOW_at_key_in_datetime_expression10197);
            	        at_key718=at_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruledatetime_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            at_key718_last = at_key718.tree.get();
            	            stream_at_key.add(at_key718.tree);
            	        }

            	        // OracleDML.g:1004:17: ( local_key | time_key zone_key concatenation_wrapper )
            	        {
            	            ANTLR_UINT32 alt242=2;
            	            switch ( this->LA(1) )
            	            {
            	            case REGULAR_ID:
            	            	{
            	            		{
            	            		    ANTLR_UINT32 LA242_1 = this->LA(2);
            	            		    if ( ((toUpper(LT(1)->getText()) == "LOCAL")))
            	            		    {
            	            		        alt242=1;
            	            		    }
            	            		    else if ( ((toUpper(LT(1)->getText()) == "TIME")))
            	            		    {
            	            		        alt242=2;
            	            		    }
            	            		    else
            	            		    {
            	            		        if (this->get_backtracking()>0)
            	            		        {
            	            		            this->set_failedflag( true );
            	            		            return retval;
            	            		        }


            	            		        ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	            		        ex->set_decisionNum( 242 );
            	            		        ex->set_state( 1 );


            	            		        goto ruledatetime_expressionEx;

            	            		    }
            	            		}
            	            	}
            	                break;

            	            default:
            	                if (this->get_backtracking()>0)
            	                {
            	                    this->set_failedflag( true );
            	                    return retval;
            	                }

            	                ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                ex->set_decisionNum( 242 );
            	                ex->set_state( 0 );


            	                goto ruledatetime_expressionEx;

            	            }

            	            switch (alt242)
            	            {
            	        	case 1:
            	        	    // OracleDML.g:1004:18: local_key
            	        	    {
            	        	        this->followPush(FOLLOW_local_key_in_datetime_expression10200);
            	        	        local_key719=local_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruledatetime_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) 
            	        	        {
            	        	            local_key719_last = local_key719.tree.get();
            	        	            stream_local_key.add(local_key719.tree);
            	        	        }

            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // OracleDML.g:1004:28: time_key zone_key concatenation_wrapper
            	        	    {
            	        	        this->followPush(FOLLOW_time_key_in_datetime_expression10202);
            	        	        time_key720=time_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruledatetime_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) 
            	        	        {
            	        	            time_key720_last = time_key720.tree.get();
            	        	            stream_time_key.add(time_key720.tree);
            	        	        }

            	        	        this->followPush(FOLLOW_zone_key_in_datetime_expression10204);
            	        	        zone_key721=zone_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruledatetime_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) 
            	        	        {
            	        	            zone_key721_last = zone_key721.tree.get();
            	        	            stream_zone_key.add(zone_key721.tree);
            	        	        }

            	        	        this->followPush(FOLLOW_concatenation_wrapper_in_datetime_expression10206);
            	        	        concatenation_wrapper722=concatenation_wrapper();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruledatetime_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) 
            	        	        {
            	        	            concatenation_wrapper722_last = concatenation_wrapper722.tree.get();
            	        	            stream_concatenation_wrapper.add(concatenation_wrapper722.tree);
            	        	        }

            	        	    }
            	        	    break;

            	            }
            	        }

            	        // AST REWRITE
            	        // elements: local_key, time_key, datetime_expression, at_key, concatenation_wrapper
            	        // token labels: 
            	        // rule labels: retval
            	        // token list labels: 
            	        // rule list labels: 
            	        // wildcard labels: 
            	        if ( this->get_backtracking()==0 ) {
            	        retval.tree = std::move(root_0);
            	        RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            	        // 1005:13: -> ^( DATETIME_OP $datetime_expression ^( at_key ( local_key )? ( time_key )? concatenation_wrapper ) )
            	        {
            	        	// OracleDML.g:1005:16: ^( DATETIME_OP $datetime_expression ^( at_key ( local_key )? ( time_key )? concatenation_wrapper ) )
            	        	{
            	        	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	        	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(DATETIME_OP, "DATETIME_OP"), root_1);
            	        	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_retval.nextTree());
            	        	// OracleDML.g:1005:51: ^( at_key ( local_key )? ( time_key )? concatenation_wrapper )
            	        	{
            	        	ImplTraits::TreeTypePtr root_2 = get_psrstate()->get_treeAdaptor()->nilNode();
            	        	root_2 = get_psrstate()->get_treeAdaptor()->becomeRoot(stream_at_key.nextNode(), root_2);
            	        	// OracleDML.g:1005:60: ( local_key )?
            	        	if ( stream_local_key.hasNext() ) {
            	        		get_psrstate()->get_treeAdaptor()->addChild(root_2, stream_local_key.nextTree());
            	        	}
            	        	stream_local_key.reset();

            	        	// OracleDML.g:1005:71: ( time_key )?
            	        	if ( stream_time_key.hasNext() ) {
            	        		get_psrstate()->get_treeAdaptor()->addChild(root_2, stream_time_key.nextTree());
            	        	}
            	        	stream_time_key.reset();

            	        	get_psrstate()->get_treeAdaptor()->addChild(root_2, stream_concatenation_wrapper.nextTree());
            	        	get_psrstate()->get_treeAdaptor()->addChild(root_1, root_2);
            	        	}
            	        	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	        	}
            	        }


            	        //retval.tree = std::move(root_0);
            	        }

            	    }
            	    break;
            	case 2:
            	    // OracleDML.g:1006:10: ( interval_expression )=> interval_expression
            	    {
            	        this->followPush(FOLLOW_interval_expression_in_datetime_expression10256);
            	        interval_expression723=interval_expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruledatetime_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            interval_expression723_last = interval_expression723.tree.get();
            	            stream_interval_expression.add(interval_expression723.tree);
            	        }

            	        // AST REWRITE
            	        // elements: interval_expression, datetime_expression
            	        // token labels: 
            	        // rule labels: retval
            	        // token list labels: 
            	        // rule list labels: 
            	        // wildcard labels: 
            	        if ( this->get_backtracking()==0 ) {
            	        retval.tree = std::move(root_0);
            	        RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            	        // 1007:13: -> ^( DATETIME_OP $datetime_expression interval_expression )
            	        {
            	        	// OracleDML.g:1007:16: ^( DATETIME_OP $datetime_expression interval_expression )
            	        	{
            	        	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	        	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(DATETIME_OP, "DATETIME_OP"), root_1);
            	        	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_retval.nextTree());
            	        	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_interval_expression.nextTree());
            	        	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	        	}
            	        }


            	        //retval.tree = std::move(root_0);
            	        }

            	    }
            	    break;

                }
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruledatetime_expressionEx; /* Prevent compiler warnings */
    ruledatetime_expressionEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end datetime_expression */

/**
 * $ANTLR start interval_expression
 * OracleDML.g:1011:1: interval_expression : ( day_key ( LEFT_PAREN cn1= concatenation_wrapper RIGHT_PAREN )? to_key second_key ( LEFT_PAREN cn2= concatenation_wrapper RIGHT_PAREN )? -> ^( day_key ( $cn1)? to_key second_key ( $cn2)? ) | year_key ( LEFT_PAREN concatenation_wrapper RIGHT_PAREN )? to_key month_key -> ^( year_key to_key month_key concatenation_wrapper ) );
 */
OracleDML::interval_expression_return
OracleDML::interval_expression()
{
    OracleDML::interval_expression_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* LEFT_PAREN725 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN726 = NULL;
    ImplTraits::CommonTokenType const* LEFT_PAREN729 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN730 = NULL;
    ImplTraits::CommonTokenType const* LEFT_PAREN732 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN734 = NULL;
    OracleDML::concatenation_wrapper_return cn1;
    ImplTraits::TreeTypePtr::pointer cn1_last = NULL;
    OracleDML::concatenation_wrapper_return cn2;
    ImplTraits::TreeTypePtr::pointer cn2_last = NULL;
    OracleDML_OracleDMLKeys::day_key_return day_key724;
    ImplTraits::TreeTypePtr::pointer day_key724_last = NULL;
    OracleDML_OracleDMLKeys::to_key_return to_key727;
    ImplTraits::TreeTypePtr::pointer to_key727_last = NULL;
    OracleDML_OracleDMLKeys::second_key_return second_key728;
    ImplTraits::TreeTypePtr::pointer second_key728_last = NULL;
    OracleDML_OracleDMLKeys::year_key_return year_key731;
    ImplTraits::TreeTypePtr::pointer year_key731_last = NULL;
    OracleDML::concatenation_wrapper_return concatenation_wrapper733;
    ImplTraits::TreeTypePtr::pointer concatenation_wrapper733_last = NULL;
    OracleDML_OracleDMLKeys::to_key_return to_key735;
    ImplTraits::TreeTypePtr::pointer to_key735_last = NULL;
    OracleDML_OracleDMLKeys::month_key_return month_key736;
    ImplTraits::TreeTypePtr::pointer month_key736_last = NULL;
    ImplTraits::TreeTypePtr LEFT_PAREN725_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN726_tree;
    ImplTraits::TreeTypePtr LEFT_PAREN729_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN730_tree;
    ImplTraits::TreeTypePtr LEFT_PAREN732_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN734_tree;
    RewriteRuleTokenStream<ImplTraits> stream_LEFT_PAREN(get_psrstate()->get_treeAdaptor(), "token LEFT_PAREN");
    RewriteRuleTokenStream<ImplTraits> stream_RIGHT_PAREN(get_psrstate()->get_treeAdaptor(), "token RIGHT_PAREN");
    RewriteRuleSubtreeStream<ImplTraits> stream_year_key(get_psrstate()->get_treeAdaptor(), "rule year_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_day_key(get_psrstate()->get_treeAdaptor(), "rule day_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_second_key(get_psrstate()->get_treeAdaptor(), "rule second_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_concatenation_wrapper(get_psrstate()->get_treeAdaptor(), "rule concatenation_wrapper");
    RewriteRuleSubtreeStream<ImplTraits> stream_to_key(get_psrstate()->get_treeAdaptor(), "rule to_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_month_key(get_psrstate()->get_treeAdaptor(), "rule month_key");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        {
            //  OracleDML.g:1012:5: ( day_key ( LEFT_PAREN cn1= concatenation_wrapper RIGHT_PAREN )? to_key second_key ( LEFT_PAREN cn2= concatenation_wrapper RIGHT_PAREN )? -> ^( day_key ( $cn1)? to_key second_key ( $cn2)? ) | year_key ( LEFT_PAREN concatenation_wrapper RIGHT_PAREN )? to_key month_key -> ^( year_key to_key month_key concatenation_wrapper ) )

            ANTLR_UINT32 alt247;

            alt247=2;

            {
                ANTLR_UINT32 LA247_0 = this->LA(1);
                if ( (LA247_0 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "YEAR"))||((toUpper(LT(1)->getText()) == "DAY")))))
                {
                    {
                        ANTLR_UINT32 LA247_1 = this->LA(2);
                        if ( ((toUpper(LT(1)->getText()) == "DAY")))
                        {
                            alt247=1;
                        }
                        else if ( ((toUpper(LT(1)->getText()) == "YEAR")))
                        {
                            alt247=2;
                        }
                        else
                        {
                            if (this->get_backtracking()>0)
                            {
                                this->set_failedflag( true );
                                return retval;
                            }


                            ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                            ex->set_decisionNum( 247 );
                            ex->set_state( 1 );


                            goto ruleinterval_expressionEx;

                        }
                    }
                }
                else
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return retval;
                    }


                    ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 247 );
                    ex->set_state( 0 );


                    goto ruleinterval_expressionEx;

                }
            }
            switch (alt247)
            {
        	case 1:
        	    // OracleDML.g:1012:10: day_key ( LEFT_PAREN cn1= concatenation_wrapper RIGHT_PAREN )? to_key second_key ( LEFT_PAREN cn2= concatenation_wrapper RIGHT_PAREN )?
        	    {
        	        this->followPush(FOLLOW_day_key_in_interval_expression10306);
        	        day_key724=day_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleinterval_expressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) 
        	        {
        	            day_key724_last = day_key724.tree.get();
        	            stream_day_key.add(day_key724.tree);
        	        }

        	        // OracleDML.g:1012:19: ( LEFT_PAREN cn1= concatenation_wrapper RIGHT_PAREN )?
        	        {
        	            ANTLR_UINT32 alt244=2;
        	            switch ( this->LA(1) )
        	            {
        	                case LEFT_PAREN:
        	                	{
        	                		alt244=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt244)
        	            {
        	        	case 1:
        	        	    // OracleDML.g:1012:20: LEFT_PAREN cn1= concatenation_wrapper RIGHT_PAREN
        	        	    {
        	        	        LEFT_PAREN725 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_interval_expression10310);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleinterval_expressionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }
        	        	         
        	        	        if ( this->get_backtracking()==0 ) stream_LEFT_PAREN.add(LEFT_PAREN725);


        	        	        this->followPush(FOLLOW_concatenation_wrapper_in_interval_expression10314);
        	        	        cn1=concatenation_wrapper();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleinterval_expressionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) 
        	        	        {
        	        	            cn1_last = cn1.tree.get();
        	        	            stream_concatenation_wrapper.add(cn1.tree);
        	        	        }

        	        	        RIGHT_PAREN726 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_interval_expression10316);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleinterval_expressionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }
        	        	         
        	        	        if ( this->get_backtracking()==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN726);


        	        	    }
        	        	    break;

        	            }
        	        }

        	        this->followPush(FOLLOW_to_key_in_interval_expression10320);
        	        to_key727=to_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleinterval_expressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) 
        	        {
        	            to_key727_last = to_key727.tree.get();
        	            stream_to_key.add(to_key727.tree);
        	        }

        	        this->followPush(FOLLOW_second_key_in_interval_expression10322);
        	        second_key728=second_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleinterval_expressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) 
        	        {
        	            second_key728_last = second_key728.tree.get();
        	            stream_second_key.add(second_key728.tree);
        	        }

        	        // OracleDML.g:1012:89: ( LEFT_PAREN cn2= concatenation_wrapper RIGHT_PAREN )?
        	        {
        	            ANTLR_UINT32 alt245=2;
        	            switch ( this->LA(1) )
        	            {
        	                case LEFT_PAREN:
        	                	{
        	                		alt245=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt245)
        	            {
        	        	case 1:
        	        	    // OracleDML.g:1012:90: LEFT_PAREN cn2= concatenation_wrapper RIGHT_PAREN
        	        	    {
        	        	        LEFT_PAREN729 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_interval_expression10325);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleinterval_expressionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }
        	        	         
        	        	        if ( this->get_backtracking()==0 ) stream_LEFT_PAREN.add(LEFT_PAREN729);


        	        	        this->followPush(FOLLOW_concatenation_wrapper_in_interval_expression10329);
        	        	        cn2=concatenation_wrapper();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleinterval_expressionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) 
        	        	        {
        	        	            cn2_last = cn2.tree.get();
        	        	            stream_concatenation_wrapper.add(cn2.tree);
        	        	        }

        	        	        RIGHT_PAREN730 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_interval_expression10331);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleinterval_expressionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }
        	        	         
        	        	        if ( this->get_backtracking()==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN730);


        	        	    }
        	        	    break;

        	            }
        	        }

        	        // AST REWRITE
        	        // elements: second_key, cn2, cn1, day_key, to_key
        	        // token labels: 
        	        // rule labels: retval, cn2, cn1
        	        // token list labels: 
        	        // rule list labels: 
        	        // wildcard labels: 
        	        if ( this->get_backtracking()==0 ) {
        	        retval.tree = std::move(root_0);
        	        RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval
        	        RewriteRuleSubtreeStream<ImplTraits> stream_cn2(get_psrstate()->get_treeAdaptor(), "rule cn2",cn2_last); // rewrite alias
        	        RewriteRuleSubtreeStream<ImplTraits> stream_cn1(get_psrstate()->get_treeAdaptor(), "rule cn1",cn1_last); // rewrite alias

        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
        	        // 1013:9: -> ^( day_key ( $cn1)? to_key second_key ( $cn2)? )
        	        {
        	        	// OracleDML.g:1013:12: ^( day_key ( $cn1)? to_key second_key ( $cn2)? )
        	        	{
        	        	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
        	        	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(stream_day_key.nextNode(), root_1);
        	        	// OracleDML.g:1013:23: ( $cn1)?
        	        	if ( stream_cn1.hasNext() ) {
        	        		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_cn1.nextTree());
        	        	}
        	        	stream_cn1.reset();

        	        	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_to_key.nextTree());
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_second_key.nextTree());
        	        	// OracleDML.g:1013:47: ( $cn2)?
        	        	if ( stream_cn2.hasNext() ) {
        	        		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_cn2.nextTree());
        	        	}
        	        	stream_cn2.reset();

        	        	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
        	        	}
        	        }


        	        //retval.tree = std::move(root_0);
        	        }

        	    }
        	    break;
        	case 2:
        	    // OracleDML.g:1014:10: year_key ( LEFT_PAREN concatenation_wrapper RIGHT_PAREN )? to_key month_key
        	    {
        	        this->followPush(FOLLOW_year_key_in_interval_expression10370);
        	        year_key731=year_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleinterval_expressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) 
        	        {
        	            year_key731_last = year_key731.tree.get();
        	            stream_year_key.add(year_key731.tree);
        	        }

        	        // OracleDML.g:1014:19: ( LEFT_PAREN concatenation_wrapper RIGHT_PAREN )?
        	        {
        	            ANTLR_UINT32 alt246=2;
        	            switch ( this->LA(1) )
        	            {
        	                case LEFT_PAREN:
        	                	{
        	                		alt246=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt246)
        	            {
        	        	case 1:
        	        	    // OracleDML.g:1014:20: LEFT_PAREN concatenation_wrapper RIGHT_PAREN
        	        	    {
        	        	        LEFT_PAREN732 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_interval_expression10373);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleinterval_expressionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }
        	        	         
        	        	        if ( this->get_backtracking()==0 ) stream_LEFT_PAREN.add(LEFT_PAREN732);


        	        	        this->followPush(FOLLOW_concatenation_wrapper_in_interval_expression10375);
        	        	        concatenation_wrapper733=concatenation_wrapper();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleinterval_expressionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) 
        	        	        {
        	        	            concatenation_wrapper733_last = concatenation_wrapper733.tree.get();
        	        	            stream_concatenation_wrapper.add(concatenation_wrapper733.tree);
        	        	        }

        	        	        RIGHT_PAREN734 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_interval_expression10377);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleinterval_expressionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }
        	        	         
        	        	        if ( this->get_backtracking()==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN734);


        	        	    }
        	        	    break;

        	            }
        	        }

        	        this->followPush(FOLLOW_to_key_in_interval_expression10381);
        	        to_key735=to_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleinterval_expressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) 
        	        {
        	            to_key735_last = to_key735.tree.get();
        	            stream_to_key.add(to_key735.tree);
        	        }

        	        this->followPush(FOLLOW_month_key_in_interval_expression10383);
        	        month_key736=month_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleinterval_expressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) 
        	        {
        	            month_key736_last = month_key736.tree.get();
        	            stream_month_key.add(month_key736.tree);
        	        }

        	        // AST REWRITE
        	        // elements: concatenation_wrapper, month_key, to_key, year_key
        	        // token labels: 
        	        // rule labels: retval
        	        // token list labels: 
        	        // rule list labels: 
        	        // wildcard labels: 
        	        if ( this->get_backtracking()==0 ) {
        	        retval.tree = std::move(root_0);
        	        RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
        	        // 1015:9: -> ^( year_key to_key month_key concatenation_wrapper )
        	        {
        	        	// OracleDML.g:1015:12: ^( year_key to_key month_key concatenation_wrapper )
        	        	{
        	        	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
        	        	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(stream_year_key.nextNode(), root_1);
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_to_key.nextTree());
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_month_key.nextTree());
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_concatenation_wrapper.nextTree());
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
        	        	}
        	        }


        	        //retval.tree = std::move(root_0);
        	        }

        	    }
        	    break;

            }
        }
    }//...
    // This is where rules clean up and exit
    //
    goto ruleinterval_expressionEx; /* Prevent compiler warnings */
    ruleinterval_expressionEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end interval_expression */

/**
 * $ANTLR start model_expression
 * OracleDML.g:1018:1: model_expression : ( multiset_expression -> multiset_expression ) ( LEFT_BRACKET model_expression_element RIGHT_BRACKET -> ^( MODEL_EXPRESSION[$LEFT_BRACKET] $model_expression model_expression_element ) )? ;
 */
OracleDML::model_expression_return
OracleDML::model_expression()
{
    OracleDML::model_expression_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* LEFT_BRACKET738 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_BRACKET740 = NULL;
    OracleDML::multiset_expression_return multiset_expression737;
    ImplTraits::TreeTypePtr::pointer multiset_expression737_last = NULL;
    OracleDML::model_expression_element_return model_expression_element739;
    ImplTraits::TreeTypePtr::pointer model_expression_element739_last = NULL;
    ImplTraits::TreeTypePtr LEFT_BRACKET738_tree;
    ImplTraits::TreeTypePtr RIGHT_BRACKET740_tree;
    RewriteRuleTokenStream<ImplTraits> stream_LEFT_BRACKET(get_psrstate()->get_treeAdaptor(), "token LEFT_BRACKET");
    RewriteRuleTokenStream<ImplTraits> stream_RIGHT_BRACKET(get_psrstate()->get_treeAdaptor(), "token RIGHT_BRACKET");
    RewriteRuleSubtreeStream<ImplTraits> stream_multiset_expression(get_psrstate()->get_treeAdaptor(), "rule multiset_expression");
    RewriteRuleSubtreeStream<ImplTraits> stream_model_expression_element(get_psrstate()->get_treeAdaptor(), "rule model_expression_element");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:1019:5: ( ( multiset_expression -> multiset_expression ) ( LEFT_BRACKET model_expression_element RIGHT_BRACKET -> ^( MODEL_EXPRESSION[$LEFT_BRACKET] $model_expression model_expression_element ) )? )
        // OracleDML.g:1019:10: ( multiset_expression -> multiset_expression ) ( LEFT_BRACKET model_expression_element RIGHT_BRACKET -> ^( MODEL_EXPRESSION[$LEFT_BRACKET] $model_expression model_expression_element ) )?
        {
            // OracleDML.g:1019:10: ( multiset_expression -> multiset_expression )
            // OracleDML.g:1019:11: multiset_expression
            {
                this->followPush(FOLLOW_multiset_expression_in_model_expression10424);
                multiset_expression737=multiset_expression();

                this->followPop();
                if  (this->hasException())
                {
                    goto rulemodel_expressionEx;
                }
                if (this->hasFailed())
                {
                    return retval;
                }

                if ( this->get_backtracking()==0 ) 
                {
                    multiset_expression737_last = multiset_expression737.tree.get();
                    stream_multiset_expression.add(multiset_expression737.tree);
                }

                // AST REWRITE
                // elements: multiset_expression
                // token labels: 
                // rule labels: retval
                // token list labels: 
                // rule list labels: 
                // wildcard labels: 
                if ( this->get_backtracking()==0 ) {
                retval.tree = std::move(root_0);
                RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

                root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
                // 1019:31: -> multiset_expression
                {
                	get_psrstate()->get_treeAdaptor()->addChild(root_0, stream_multiset_expression.nextTree());
                }


                //retval.tree = std::move(root_0);
                }

            }


            // OracleDML.g:1020:9: ( LEFT_BRACKET model_expression_element RIGHT_BRACKET -> ^( MODEL_EXPRESSION[$LEFT_BRACKET] $model_expression model_expression_element ) )?
            {
                ANTLR_UINT32 alt248=2;
                switch ( this->LA(1) )
                {
                    case LEFT_BRACKET:
                    	{
                    		alt248=1;
                    	}
                        break;
                }

                switch (alt248)
                {
            	case 1:
            	    // OracleDML.g:1020:10: LEFT_BRACKET model_expression_element RIGHT_BRACKET
            	    {
            	        LEFT_BRACKET738 =  this->matchToken(LEFT_BRACKET, &FOLLOW_LEFT_BRACKET_in_model_expression10440);
            	        if  (this->hasException())
            	        {
            	            goto rulemodel_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( this->get_backtracking()==0 ) stream_LEFT_BRACKET.add(LEFT_BRACKET738);


            	        this->followPush(FOLLOW_model_expression_element_in_model_expression10442);
            	        model_expression_element739=model_expression_element();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemodel_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            model_expression_element739_last = model_expression_element739.tree.get();
            	            stream_model_expression_element.add(model_expression_element739.tree);
            	        }

            	        RIGHT_BRACKET740 =  this->matchToken(RIGHT_BRACKET, &FOLLOW_RIGHT_BRACKET_in_model_expression10444);
            	        if  (this->hasException())
            	        {
            	            goto rulemodel_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( this->get_backtracking()==0 ) stream_RIGHT_BRACKET.add(RIGHT_BRACKET740);


            	        // AST REWRITE
            	        // elements: model_expression, model_expression_element
            	        // token labels: 
            	        // rule labels: retval
            	        // token list labels: 
            	        // rule list labels: 
            	        // wildcard labels: 
            	        if ( this->get_backtracking()==0 ) {
            	        retval.tree = std::move(root_0);
            	        RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            	        // 1021:13: -> ^( MODEL_EXPRESSION[$LEFT_BRACKET] $model_expression model_expression_element )
            	        {
            	        	// OracleDML.g:1021:16: ^( MODEL_EXPRESSION[$LEFT_BRACKET] $model_expression model_expression_element )
            	        	{
            	        	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	        	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(MODEL_EXPRESSION, LEFT_BRACKET738), root_1);
            	        	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_retval.nextTree());
            	        	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_model_expression_element.nextTree());
            	        	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	        	}
            	        }


            	        //retval.tree = std::move(root_0);
            	        }

            	    }
            	    break;

                }
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulemodel_expressionEx; /* Prevent compiler warnings */
    rulemodel_expressionEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end model_expression */

/**
 * $ANTLR start model_expression_element
 * OracleDML.g:1024:1: model_expression_element : ( ( ( any_key )=> any_key | condition_wrapper ) ( COMMA ! ( ( any_key )=> any_key | condition_wrapper ) )* | single_column_for_loop ( COMMA ! single_column_for_loop )* | multi_column_for_loop );
 */
OracleDML::model_expression_element_return
OracleDML::model_expression_element()
{
    OracleDML::model_expression_element_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* COMMA743 = NULL;
    ImplTraits::CommonTokenType const* COMMA747 = NULL;
    OracleDML_OracleDMLKeys::any_key_return any_key741;
    ImplTraits::TreeTypePtr::pointer any_key741_last = NULL;
    OracleDML::condition_wrapper_return condition_wrapper742;
    ImplTraits::TreeTypePtr::pointer condition_wrapper742_last = NULL;
    OracleDML_OracleDMLKeys::any_key_return any_key744;
    ImplTraits::TreeTypePtr::pointer any_key744_last = NULL;
    OracleDML::condition_wrapper_return condition_wrapper745;
    ImplTraits::TreeTypePtr::pointer condition_wrapper745_last = NULL;
    OracleDML::single_column_for_loop_return single_column_for_loop746;
    ImplTraits::TreeTypePtr::pointer single_column_for_loop746_last = NULL;
    OracleDML::single_column_for_loop_return single_column_for_loop748;
    ImplTraits::TreeTypePtr::pointer single_column_for_loop748_last = NULL;
    OracleDML::multi_column_for_loop_return multi_column_for_loop749;
    ImplTraits::TreeTypePtr::pointer multi_column_for_loop749_last = NULL;
    ImplTraits::TreeTypePtr COMMA743_tree;
    ImplTraits::TreeTypePtr COMMA747_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        {
            //  OracleDML.g:1025:5: ( ( ( any_key )=> any_key | condition_wrapper ) ( COMMA ! ( ( any_key )=> any_key | condition_wrapper ) )* | single_column_for_loop ( COMMA ! single_column_for_loop )* | multi_column_for_loop )

            ANTLR_UINT32 alt253;

            alt253=3;

            switch ( this->LA(1) )
            {
            case APPROXIMATE_NUM_LIT:
            case BINDVAR:
            case CHAR_STRING:
            case CHAR_STRING_PERL:
            case COLON:
            case DELIMITED_ID:
            case EXACT_NUM_LIT:
            case INTRODUCER:
            case LEFT_PAREN:
            case MINUS_SIGN:
            case NATIONAL_CHAR_STRING_LIT:
            case PLSQL_NON_RESERVED_CAST:
            case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
            case PLUS_SIGN:
            case REGULAR_ID:
            case SQL92_RESERVED_ALL:
            case SQL92_RESERVED_ANY:
            case SQL92_RESERVED_CASE:
            case SQL92_RESERVED_CURSOR:
            case SQL92_RESERVED_DATE:
            case SQL92_RESERVED_DEFAULT:
            case SQL92_RESERVED_DISTINCT:
            case SQL92_RESERVED_EXISTS:
            case SQL92_RESERVED_FALSE:
            case SQL92_RESERVED_NOT:
            case SQL92_RESERVED_NULL:
            case SQL92_RESERVED_PRIOR:
            case SQL92_RESERVED_TRUE:
            case UNSIGNED_INTEGER:
            	{
            		alt253=1;
            	}
                break;
            case SQL92_RESERVED_FOR:
            	{
            		switch ( this->LA(2) )
            		{
            		case DELIMITED_ID:
            		case INTRODUCER:
            		case REGULAR_ID:
            			{
            				alt253=2;
            			}
            		    break;
            		case LEFT_PAREN:
            			{
            				alt253=3;
            			}
            		    break;

            		default:
            		    if (this->get_backtracking()>0)
            		    {
            		        this->set_failedflag( true );
            		        return retval;
            		    }

            		    ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		    ex->set_decisionNum( 253 );
            		    ex->set_state( 2 );


            		    goto rulemodel_expression_elementEx;

            		}

            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 253 );
                ex->set_state( 0 );


                goto rulemodel_expression_elementEx;

            }

            switch (alt253)
            {
        	case 1:
        	    // OracleDML.g:1025:10: ( ( any_key )=> any_key | condition_wrapper ) ( COMMA ! ( ( any_key )=> any_key | condition_wrapper ) )*
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        // OracleDML.g:1025:10: ( ( any_key )=> any_key | condition_wrapper )
        	        {
        	            ANTLR_UINT32 alt249=2;
        	            switch ( this->LA(1) )
        	            {
        	            case SQL92_RESERVED_ANY:
        	            	{
        	            		{
        	            		    ANTLR_UINT32 LA249_1 = this->LA(2);
        	            		    if ( (LA249_1 == COMMA) && (this->msynpred( antlr3::ClassForwarder<synpred31_OracleDML>() )))
        	            		    {
        	            		        alt249=1;
        	            		    }
        	            		    else if ( (LA249_1 == RIGHT_BRACKET) && (this->msynpred( antlr3::ClassForwarder<synpred31_OracleDML>() )))
        	            		    {
        	            		        alt249=1;
        	            		    }
        	            		    else if ( (LA249_1 == LEFT_PAREN))
        	            		    {
        	            		        alt249=2;
        	            		    }
        	            		    else
        	            		    {
        	            		        if (this->get_backtracking()>0)
        	            		        {
        	            		            this->set_failedflag( true );
        	            		            return retval;
        	            		        }


        	            		        ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	            		        ex->set_decisionNum( 249 );
        	            		        ex->set_state( 1 );


        	            		        goto rulemodel_expression_elementEx;

        	            		    }
        	            		}
        	            	}
        	                break;
        	            case APPROXIMATE_NUM_LIT:
        	            case BINDVAR:
        	            case CHAR_STRING:
        	            case CHAR_STRING_PERL:
        	            case COLON:
        	            case DELIMITED_ID:
        	            case EXACT_NUM_LIT:
        	            case INTRODUCER:
        	            case LEFT_PAREN:
        	            case MINUS_SIGN:
        	            case NATIONAL_CHAR_STRING_LIT:
        	            case PLSQL_NON_RESERVED_CAST:
        	            case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
        	            case PLUS_SIGN:
        	            case REGULAR_ID:
        	            case SQL92_RESERVED_ALL:
        	            case SQL92_RESERVED_CASE:
        	            case SQL92_RESERVED_CURSOR:
        	            case SQL92_RESERVED_DATE:
        	            case SQL92_RESERVED_DEFAULT:
        	            case SQL92_RESERVED_DISTINCT:
        	            case SQL92_RESERVED_EXISTS:
        	            case SQL92_RESERVED_FALSE:
        	            case SQL92_RESERVED_NOT:
        	            case SQL92_RESERVED_NULL:
        	            case SQL92_RESERVED_PRIOR:
        	            case SQL92_RESERVED_TRUE:
        	            case UNSIGNED_INTEGER:
        	            	{
        	            		alt249=2;
        	            	}
        	                break;

        	            default:
        	                if (this->get_backtracking()>0)
        	                {
        	                    this->set_failedflag( true );
        	                    return retval;
        	                }

        	                ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                ex->set_decisionNum( 249 );
        	                ex->set_state( 0 );


        	                goto rulemodel_expression_elementEx;

        	            }

        	            switch (alt249)
        	            {
        	        	case 1:
        	        	    // OracleDML.g:1025:11: ( any_key )=> any_key
        	        	    {
        	        	        this->followPush(FOLLOW_any_key_in_model_expression_element10496);
        	        	        any_key741=any_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulemodel_expression_elementEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, any_key741.tree);


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // OracleDML.g:1025:31: condition_wrapper
        	        	    {
        	        	        this->followPush(FOLLOW_condition_wrapper_in_model_expression_element10498);
        	        	        condition_wrapper742=condition_wrapper();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulemodel_expression_elementEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, condition_wrapper742.tree);


        	        	    }
        	        	    break;

        	            }
        	        }

        	        // OracleDML.g:1025:50: ( COMMA ! ( ( any_key )=> any_key | condition_wrapper ) )*

        	        for (;;)
        	        {
        	            ANTLR_UINT32 alt251=2;
        	            switch ( this->LA(1) )
        	            {
        	            case COMMA:
        	            	{
        	            		alt251=1;
        	            	}
        	                break;

        	            }

        	            switch (alt251)
        	            {
        	        	case 1:
        	        	    // OracleDML.g:1025:51: COMMA ! ( ( any_key )=> any_key | condition_wrapper )
        	        	    {
        	        	        COMMA743 =  this->matchToken(COMMA, &FOLLOW_COMMA_in_model_expression_element10502);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulemodel_expression_elementEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }


        	        	        // OracleDML.g:1025:58: ( ( any_key )=> any_key | condition_wrapper )
        	        	        {
        	        	            ANTLR_UINT32 alt250=2;
        	        	            switch ( this->LA(1) )
        	        	            {
        	        	            case SQL92_RESERVED_ANY:
        	        	            	{
        	        	            		{
        	        	            		    ANTLR_UINT32 LA250_1 = this->LA(2);
        	        	            		    if ( (LA250_1 == RIGHT_BRACKET) && (this->msynpred( antlr3::ClassForwarder<synpred32_OracleDML>() )))
        	        	            		    {
        	        	            		        alt250=1;
        	        	            		    }
        	        	            		    else if ( (LA250_1 == COMMA) && (this->msynpred( antlr3::ClassForwarder<synpred32_OracleDML>() )))
        	        	            		    {
        	        	            		        alt250=1;
        	        	            		    }
        	        	            		    else if ( (LA250_1 == LEFT_PAREN))
        	        	            		    {
        	        	            		        alt250=2;
        	        	            		    }
        	        	            		    else
        	        	            		    {
        	        	            		        if (this->get_backtracking()>0)
        	        	            		        {
        	        	            		            this->set_failedflag( true );
        	        	            		            return retval;
        	        	            		        }


        	        	            		        ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	        	            		        ex->set_decisionNum( 250 );
        	        	            		        ex->set_state( 1 );


        	        	            		        goto rulemodel_expression_elementEx;

        	        	            		    }
        	        	            		}
        	        	            	}
        	        	                break;
        	        	            case APPROXIMATE_NUM_LIT:
        	        	            case BINDVAR:
        	        	            case CHAR_STRING:
        	        	            case CHAR_STRING_PERL:
        	        	            case COLON:
        	        	            case DELIMITED_ID:
        	        	            case EXACT_NUM_LIT:
        	        	            case INTRODUCER:
        	        	            case LEFT_PAREN:
        	        	            case MINUS_SIGN:
        	        	            case NATIONAL_CHAR_STRING_LIT:
        	        	            case PLSQL_NON_RESERVED_CAST:
        	        	            case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
        	        	            case PLUS_SIGN:
        	        	            case REGULAR_ID:
        	        	            case SQL92_RESERVED_ALL:
        	        	            case SQL92_RESERVED_CASE:
        	        	            case SQL92_RESERVED_CURSOR:
        	        	            case SQL92_RESERVED_DATE:
        	        	            case SQL92_RESERVED_DEFAULT:
        	        	            case SQL92_RESERVED_DISTINCT:
        	        	            case SQL92_RESERVED_EXISTS:
        	        	            case SQL92_RESERVED_FALSE:
        	        	            case SQL92_RESERVED_NOT:
        	        	            case SQL92_RESERVED_NULL:
        	        	            case SQL92_RESERVED_PRIOR:
        	        	            case SQL92_RESERVED_TRUE:
        	        	            case UNSIGNED_INTEGER:
        	        	            	{
        	        	            		alt250=2;
        	        	            	}
        	        	                break;

        	        	            default:
        	        	                if (this->get_backtracking()>0)
        	        	                {
        	        	                    this->set_failedflag( true );
        	        	                    return retval;
        	        	                }

        	        	                ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	        	                ex->set_decisionNum( 250 );
        	        	                ex->set_state( 0 );


        	        	                goto rulemodel_expression_elementEx;

        	        	            }

        	        	            switch (alt250)
        	        	            {
        	        	        	case 1:
        	        	        	    // OracleDML.g:1025:59: ( any_key )=> any_key
        	        	        	    {
        	        	        	        this->followPush(FOLLOW_any_key_in_model_expression_element10511);
        	        	        	        any_key744=any_key();

        	        	        	        this->followPop();
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto rulemodel_expression_elementEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return retval;
        	        	        	        }

        	        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, any_key744.tree);


        	        	        	    }
        	        	        	    break;
        	        	        	case 2:
        	        	        	    // OracleDML.g:1025:79: condition_wrapper
        	        	        	    {
        	        	        	        this->followPush(FOLLOW_condition_wrapper_in_model_expression_element10513);
        	        	        	        condition_wrapper745=condition_wrapper();

        	        	        	        this->followPop();
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto rulemodel_expression_elementEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return retval;
        	        	        	        }

        	        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, condition_wrapper745.tree);


        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop251;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop251: ; /* Jump out to here if this rule does not match */


        	    }
        	    break;
        	case 2:
        	    // OracleDML.g:1026:10: single_column_for_loop ( COMMA ! single_column_for_loop )*
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_single_column_for_loop_in_model_expression_element10527);
        	        single_column_for_loop746=single_column_for_loop();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulemodel_expression_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, single_column_for_loop746.tree);


        	        // OracleDML.g:1026:33: ( COMMA ! single_column_for_loop )*

        	        for (;;)
        	        {
        	            ANTLR_UINT32 alt252=2;
        	            switch ( this->LA(1) )
        	            {
        	            case COMMA:
        	            	{
        	            		alt252=1;
        	            	}
        	                break;

        	            }

        	            switch (alt252)
        	            {
        	        	case 1:
        	        	    // OracleDML.g:1026:34: COMMA ! single_column_for_loop
        	        	    {
        	        	        COMMA747 =  this->matchToken(COMMA, &FOLLOW_COMMA_in_model_expression_element10530);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulemodel_expression_elementEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }


        	        	        this->followPush(FOLLOW_single_column_for_loop_in_model_expression_element10533);
        	        	        single_column_for_loop748=single_column_for_loop();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulemodel_expression_elementEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, single_column_for_loop748.tree);


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop252;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop252: ; /* Jump out to here if this rule does not match */


        	    }
        	    break;
        	case 3:
        	    // OracleDML.g:1027:10: multi_column_for_loop
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_multi_column_for_loop_in_model_expression_element10546);
        	        multi_column_for_loop749=multi_column_for_loop();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulemodel_expression_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, multi_column_for_loop749.tree);


        	    }
        	    break;

            }
        }
    }//...
    // This is where rules clean up and exit
    //
    goto rulemodel_expression_elementEx; /* Prevent compiler warnings */
    rulemodel_expression_elementEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end model_expression_element */

/**
 * $ANTLR start single_column_for_loop
 * OracleDML.g:1030:1: single_column_for_loop : for_key column_name ( in_key expression_list | ( for_like_part )? from_key ex1= expression to_key ex2= expression for_increment_decrement_type ex3= expression ) -> {mode == 1}? ^( FOR_SINGLE_COLUMN[$for_key.start] column_name ^( in_key expression_list ) ) -> ^( FOR_SINGLE_COLUMN[$for_key.start] column_name ^( from_key ^( EXPR $ex1) ) ^( to_key ^( EXPR $ex2) ) ^( for_increment_decrement_type ^( EXPR $ex3) ) ( for_like_part )? ) ;
 */
OracleDML::single_column_for_loop_return
OracleDML::single_column_for_loop()
{
    OracleDML::single_column_for_loop_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML::expression_return ex1;
    ImplTraits::TreeTypePtr::pointer ex1_last = NULL;
    OracleDML::expression_return ex2;
    ImplTraits::TreeTypePtr::pointer ex2_last = NULL;
    OracleDML::expression_return ex3;
    ImplTraits::TreeTypePtr::pointer ex3_last = NULL;
    OracleDML_OracleDMLKeys::for_key_return for_key750;
    ImplTraits::TreeTypePtr::pointer for_key750_last = NULL;
    OracleDML_OracleDMLCommons::column_name_return column_name751;
    ImplTraits::TreeTypePtr::pointer column_name751_last = NULL;
    OracleDML_OracleDMLKeys::in_key_return in_key752;
    ImplTraits::TreeTypePtr::pointer in_key752_last = NULL;
    OracleDML::expression_list_return expression_list753;
    ImplTraits::TreeTypePtr::pointer expression_list753_last = NULL;
    OracleDML::for_like_part_return for_like_part754;
    ImplTraits::TreeTypePtr::pointer for_like_part754_last = NULL;
    OracleDML_OracleDMLKeys::from_key_return from_key755;
    ImplTraits::TreeTypePtr::pointer from_key755_last = NULL;
    OracleDML_OracleDMLKeys::to_key_return to_key756;
    ImplTraits::TreeTypePtr::pointer to_key756_last = NULL;
    OracleDML::for_increment_decrement_type_return for_increment_decrement_type757;
    ImplTraits::TreeTypePtr::pointer for_increment_decrement_type757_last = NULL;
    RewriteRuleSubtreeStream<ImplTraits> stream_expression(get_psrstate()->get_treeAdaptor(), "rule expression");
    RewriteRuleSubtreeStream<ImplTraits> stream_expression_list(get_psrstate()->get_treeAdaptor(), "rule expression_list");
    RewriteRuleSubtreeStream<ImplTraits> stream_for_like_part(get_psrstate()->get_treeAdaptor(), "rule for_like_part");
    RewriteRuleSubtreeStream<ImplTraits> stream_to_key(get_psrstate()->get_treeAdaptor(), "rule to_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_column_name(get_psrstate()->get_treeAdaptor(), "rule column_name");
    RewriteRuleSubtreeStream<ImplTraits> stream_for_increment_decrement_type(get_psrstate()->get_treeAdaptor(), "rule for_increment_decrement_type");
    RewriteRuleSubtreeStream<ImplTraits> stream_in_key(get_psrstate()->get_treeAdaptor(), "rule in_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_for_key(get_psrstate()->get_treeAdaptor(), "rule for_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_from_key(get_psrstate()->get_treeAdaptor(), "rule from_key");

    /* Initialize rule variables
     */

        int mode = 0;    
    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:1032:5: ( for_key column_name ( in_key expression_list | ( for_like_part )? from_key ex1= expression to_key ex2= expression for_increment_decrement_type ex3= expression ) -> {mode == 1}? ^( FOR_SINGLE_COLUMN[$for_key.start] column_name ^( in_key expression_list ) ) -> ^( FOR_SINGLE_COLUMN[$for_key.start] column_name ^( from_key ^( EXPR $ex1) ) ^( to_key ^( EXPR $ex2) ) ^( for_increment_decrement_type ^( EXPR $ex3) ) ( for_like_part )? ) )
        // OracleDML.g:1032:10: for_key column_name ( in_key expression_list | ( for_like_part )? from_key ex1= expression to_key ex2= expression for_increment_decrement_type ex3= expression )
        {
            this->followPush(FOLLOW_for_key_in_single_column_for_loop10574);
            for_key750=for_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesingle_column_for_loopEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                for_key750_last = for_key750.tree.get();
                stream_for_key.add(for_key750.tree);
            }

            this->followPush(FOLLOW_column_name_in_single_column_for_loop10576);
            column_name751=column_name();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesingle_column_for_loopEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                column_name751_last = column_name751.tree.get();
                stream_column_name.add(column_name751.tree);
            }

            // OracleDML.g:1033:5: ( in_key expression_list | ( for_like_part )? from_key ex1= expression to_key ex2= expression for_increment_decrement_type ex3= expression )
            {
                ANTLR_UINT32 alt255=2;
                switch ( this->LA(1) )
                {
                case SQL92_RESERVED_IN:
                	{
                		alt255=1;
                	}
                    break;
                case SQL92_RESERVED_FROM:
                case SQL92_RESERVED_LIKE:
                	{
                		alt255=2;
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return retval;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 255 );
                    ex->set_state( 0 );


                    goto rulesingle_column_for_loopEx;

                }

                switch (alt255)
                {
            	case 1:
            	    // OracleDML.g:1033:10: in_key expression_list
            	    {
            	        this->followPush(FOLLOW_in_key_in_single_column_for_loop10588);
            	        in_key752=in_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesingle_column_for_loopEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            in_key752_last = in_key752.tree.get();
            	            stream_in_key.add(in_key752.tree);
            	        }

            	        this->followPush(FOLLOW_expression_list_in_single_column_for_loop10590);
            	        expression_list753=expression_list();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesingle_column_for_loopEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            expression_list753_last = expression_list753.tree.get();
            	            stream_expression_list.add(expression_list753.tree);
            	        }

            	        if ( this->get_backtracking()==0 )
            	        {
            	            mode = 1;
            	        }


            	    }
            	    break;
            	case 2:
            	    // OracleDML.g:1034:10: ( for_like_part )? from_key ex1= expression to_key ex2= expression for_increment_decrement_type ex3= expression
            	    {
            	        // OracleDML.g:1034:10: ( for_like_part )?
            	        {
            	            ANTLR_UINT32 alt254=2;
            	            switch ( this->LA(1) )
            	            {
            	                case SQL92_RESERVED_LIKE:
            	                	{
            	                		alt254=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt254)
            	            {
            	        	case 1:
            	        	    // OracleDML.g:1034:10: for_like_part
            	        	    {
            	        	        this->followPush(FOLLOW_for_like_part_in_single_column_for_loop10603);
            	        	        for_like_part754=for_like_part();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulesingle_column_for_loopEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) 
            	        	        {
            	        	            for_like_part754_last = for_like_part754.tree.get();
            	        	            stream_for_like_part.add(for_like_part754.tree);
            	        	        }

            	        	    }
            	        	    break;

            	            }
            	        }

            	        this->followPush(FOLLOW_from_key_in_single_column_for_loop10606);
            	        from_key755=from_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesingle_column_for_loopEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            from_key755_last = from_key755.tree.get();
            	            stream_from_key.add(from_key755.tree);
            	        }

            	        this->followPush(FOLLOW_expression_in_single_column_for_loop10610);
            	        ex1=expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesingle_column_for_loopEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            ex1_last = ex1.tree.get();
            	            stream_expression.add(ex1.tree);
            	        }

            	        this->followPush(FOLLOW_to_key_in_single_column_for_loop10624);
            	        to_key756=to_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesingle_column_for_loopEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            to_key756_last = to_key756.tree.get();
            	            stream_to_key.add(to_key756.tree);
            	        }

            	        this->followPush(FOLLOW_expression_in_single_column_for_loop10628);
            	        ex2=expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesingle_column_for_loopEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            ex2_last = ex2.tree.get();
            	            stream_expression.add(ex2.tree);
            	        }

            	        this->followPush(FOLLOW_for_increment_decrement_type_in_single_column_for_loop10630);
            	        for_increment_decrement_type757=for_increment_decrement_type();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesingle_column_for_loopEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            for_increment_decrement_type757_last = for_increment_decrement_type757.tree.get();
            	            stream_for_increment_decrement_type.add(for_increment_decrement_type757.tree);
            	        }

            	        this->followPush(FOLLOW_expression_in_single_column_for_loop10634);
            	        ex3=expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesingle_column_for_loopEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            ex3_last = ex3.tree.get();
            	            stream_expression.add(ex3.tree);
            	        }

            	    }
            	    break;

                }
            }

            // AST REWRITE
            // elements: in_key, ex2, for_increment_decrement_type, expression_list, column_name, column_name, for_like_part, from_key, ex1, ex3, to_key
            // token labels: 
            // rule labels: retval, ex3, ex2, ex1
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval
            RewriteRuleSubtreeStream<ImplTraits> stream_ex3(get_psrstate()->get_treeAdaptor(), "rule ex3",ex3_last); // rewrite alias
            RewriteRuleSubtreeStream<ImplTraits> stream_ex2(get_psrstate()->get_treeAdaptor(), "rule ex2",ex2_last); // rewrite alias
            RewriteRuleSubtreeStream<ImplTraits> stream_ex1(get_psrstate()->get_treeAdaptor(), "rule ex1",ex1_last); // rewrite alias

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1037:9: -> {mode == 1}? ^( FOR_SINGLE_COLUMN[$for_key.start] column_name ^( in_key expression_list ) )
            if (mode == 1) {
            	// OracleDML.g:1037:24: ^( FOR_SINGLE_COLUMN[$for_key.start] column_name ^( in_key expression_list ) )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(FOR_SINGLE_COLUMN, (for_key750.start)), root_1);
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_column_name.nextTree());
            	// OracleDML.g:1037:72: ^( in_key expression_list )
            	{
            	ImplTraits::TreeTypePtr root_2 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_2 = get_psrstate()->get_treeAdaptor()->becomeRoot(stream_in_key.nextNode(), root_2);
            	get_psrstate()->get_treeAdaptor()->addChild(root_2, stream_expression_list.nextTree());
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, root_2);
            	}
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }

            else // 1038:9: -> ^( FOR_SINGLE_COLUMN[$for_key.start] column_name ^( from_key ^( EXPR $ex1) ) ^( to_key ^( EXPR $ex2) ) ^( for_increment_decrement_type ^( EXPR $ex3) ) ( for_like_part )? )
            {
            	// OracleDML.g:1038:12: ^( FOR_SINGLE_COLUMN[$for_key.start] column_name ^( from_key ^( EXPR $ex1) ) ^( to_key ^( EXPR $ex2) ) ^( for_increment_decrement_type ^( EXPR $ex3) ) ( for_like_part )? )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(FOR_SINGLE_COLUMN, (for_key750.start)), root_1);
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_column_name.nextTree());
            	// OracleDML.g:1038:60: ^( from_key ^( EXPR $ex1) )
            	{
            	ImplTraits::TreeTypePtr root_2 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_2 = get_psrstate()->get_treeAdaptor()->becomeRoot(stream_from_key.nextNode(), root_2);
            	// OracleDML.g:1038:71: ^( EXPR $ex1)
            	{
            	ImplTraits::TreeTypePtr root_3 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_3 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(EXPR, "EXPR"), root_3);
            	get_psrstate()->get_treeAdaptor()->addChild(root_3, stream_ex1.nextTree());
            	get_psrstate()->get_treeAdaptor()->addChild(root_2, root_3);
            	}
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, root_2);
            	}
            	// OracleDML.g:1038:85: ^( to_key ^( EXPR $ex2) )
            	{
            	ImplTraits::TreeTypePtr root_2 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_2 = get_psrstate()->get_treeAdaptor()->becomeRoot(stream_to_key.nextNode(), root_2);
            	// OracleDML.g:1038:94: ^( EXPR $ex2)
            	{
            	ImplTraits::TreeTypePtr root_3 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_3 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(EXPR, "EXPR"), root_3);
            	get_psrstate()->get_treeAdaptor()->addChild(root_3, stream_ex2.nextTree());
            	get_psrstate()->get_treeAdaptor()->addChild(root_2, root_3);
            	}
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, root_2);
            	}
            	// OracleDML.g:1038:108: ^( for_increment_decrement_type ^( EXPR $ex3) )
            	{
            	ImplTraits::TreeTypePtr root_2 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_2 = get_psrstate()->get_treeAdaptor()->becomeRoot(stream_for_increment_decrement_type.nextNode(), root_2);
            	// OracleDML.g:1038:139: ^( EXPR $ex3)
            	{
            	ImplTraits::TreeTypePtr root_3 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_3 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(EXPR, "EXPR"), root_3);
            	get_psrstate()->get_treeAdaptor()->addChild(root_3, stream_ex3.nextTree());
            	get_psrstate()->get_treeAdaptor()->addChild(root_2, root_3);
            	}
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, root_2);
            	}
            	// OracleDML.g:1038:153: ( for_like_part )?
            	if ( stream_for_like_part.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_for_like_part.nextTree());
            	}
            	stream_for_like_part.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulesingle_column_for_loopEx; /* Prevent compiler warnings */
    rulesingle_column_for_loopEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end single_column_for_loop */

/**
 * $ANTLR start for_like_part
 * OracleDML.g:1041:1: for_like_part : like_key expression -> ^( like_key ^( EXPR expression ) ) ;
 */
OracleDML::for_like_part_return
OracleDML::for_like_part()
{
    OracleDML::for_like_part_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML_OracleDMLKeys::like_key_return like_key758;
    ImplTraits::TreeTypePtr::pointer like_key758_last = NULL;
    OracleDML::expression_return expression759;
    ImplTraits::TreeTypePtr::pointer expression759_last = NULL;
    RewriteRuleSubtreeStream<ImplTraits> stream_expression(get_psrstate()->get_treeAdaptor(), "rule expression");
    RewriteRuleSubtreeStream<ImplTraits> stream_like_key(get_psrstate()->get_treeAdaptor(), "rule like_key");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:1042:5: ( like_key expression -> ^( like_key ^( EXPR expression ) ) )
        // OracleDML.g:1042:10: like_key expression
        {
            this->followPush(FOLLOW_like_key_in_for_like_part10743);
            like_key758=like_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulefor_like_partEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                like_key758_last = like_key758.tree.get();
                stream_like_key.add(like_key758.tree);
            }

            this->followPush(FOLLOW_expression_in_for_like_part10745);
            expression759=expression();

            this->followPop();
            if  (this->hasException())
            {
                goto rulefor_like_partEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                expression759_last = expression759.tree.get();
                stream_expression.add(expression759.tree);
            }

            // AST REWRITE
            // elements: like_key, expression
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1043:9: -> ^( like_key ^( EXPR expression ) )
            {
            	// OracleDML.g:1043:12: ^( like_key ^( EXPR expression ) )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(stream_like_key.nextNode(), root_1);
            	// OracleDML.g:1043:23: ^( EXPR expression )
            	{
            	ImplTraits::TreeTypePtr root_2 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_2 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(EXPR, "EXPR"), root_2);
            	get_psrstate()->get_treeAdaptor()->addChild(root_2, stream_expression.nextTree());
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, root_2);
            	}
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulefor_like_partEx; /* Prevent compiler warnings */
    rulefor_like_partEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end for_like_part */

/**
 * $ANTLR start for_increment_decrement_type
 * OracleDML.g:1046:1: for_increment_decrement_type : ( increment_key | decrement_key );
 */
OracleDML::for_increment_decrement_type_return
OracleDML::for_increment_decrement_type()
{
    OracleDML::for_increment_decrement_type_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML_OracleDMLKeys::increment_key_return increment_key760;
    ImplTraits::TreeTypePtr::pointer increment_key760_last = NULL;
    OracleDML_OracleDMLKeys::decrement_key_return decrement_key761;
    ImplTraits::TreeTypePtr::pointer decrement_key761_last = NULL;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        {
            //  OracleDML.g:1047:5: ( increment_key | decrement_key )

            ANTLR_UINT32 alt256;

            alt256=2;

            {
                ANTLR_UINT32 LA256_0 = this->LA(1);
                if ( (LA256_0 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "DECREMENT"))||((toUpper(LT(1)->getText()) == "INCREMENT")))))
                {
                    {
                        ANTLR_UINT32 LA256_1 = this->LA(2);
                        if ( ((toUpper(LT(1)->getText()) == "INCREMENT")))
                        {
                            alt256=1;
                        }
                        else if ( ((toUpper(LT(1)->getText()) == "DECREMENT")))
                        {
                            alt256=2;
                        }
                        else
                        {
                            if (this->get_backtracking()>0)
                            {
                                this->set_failedflag( true );
                                return retval;
                            }


                            ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                            ex->set_decisionNum( 256 );
                            ex->set_state( 1 );


                            goto rulefor_increment_decrement_typeEx;

                        }
                    }
                }
                else
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return retval;
                    }


                    ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 256 );
                    ex->set_state( 0 );


                    goto rulefor_increment_decrement_typeEx;

                }
            }
            switch (alt256)
            {
        	case 1:
        	    // OracleDML.g:1047:10: increment_key
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_increment_key_in_for_increment_decrement_type10785);
        	        increment_key760=increment_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulefor_increment_decrement_typeEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, increment_key760.tree);


        	    }
        	    break;
        	case 2:
        	    // OracleDML.g:1048:10: decrement_key
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_decrement_key_in_for_increment_decrement_type10796);
        	        decrement_key761=decrement_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulefor_increment_decrement_typeEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, decrement_key761.tree);


        	    }
        	    break;

            }
        }
    }//...
    // This is where rules clean up and exit
    //
    goto rulefor_increment_decrement_typeEx; /* Prevent compiler warnings */
    rulefor_increment_decrement_typeEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end for_increment_decrement_type */

/**
 * $ANTLR start multi_column_for_loop
 * OracleDML.g:1051:1: multi_column_for_loop : for_key LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN in_key LEFT_PAREN ( ( select_key )=> subquery | ( LEFT_PAREN )=> LEFT_PAREN expression_list ( COMMA expression_list )* RIGHT_PAREN ) RIGHT_PAREN -> ^( FOR_MULTI_COLUMN[$for_key.start] ( column_name )+ ^( in_key ( subquery )? ( expression_list )* ) ) ;
 */
OracleDML::multi_column_for_loop_return
OracleDML::multi_column_for_loop()
{
    OracleDML::multi_column_for_loop_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* LEFT_PAREN763 = NULL;
    ImplTraits::CommonTokenType const* COMMA765 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN767 = NULL;
    ImplTraits::CommonTokenType const* LEFT_PAREN769 = NULL;
    ImplTraits::CommonTokenType const* LEFT_PAREN771 = NULL;
    ImplTraits::CommonTokenType const* COMMA773 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN775 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN776 = NULL;
    OracleDML_OracleDMLKeys::for_key_return for_key762;
    ImplTraits::TreeTypePtr::pointer for_key762_last = NULL;
    OracleDML_OracleDMLCommons::column_name_return column_name764;
    ImplTraits::TreeTypePtr::pointer column_name764_last = NULL;
    OracleDML_OracleDMLCommons::column_name_return column_name766;
    ImplTraits::TreeTypePtr::pointer column_name766_last = NULL;
    OracleDML_OracleDMLKeys::in_key_return in_key768;
    ImplTraits::TreeTypePtr::pointer in_key768_last = NULL;
    OracleDML::subquery_return subquery770;
    ImplTraits::TreeTypePtr::pointer subquery770_last = NULL;
    OracleDML::expression_list_return expression_list772;
    ImplTraits::TreeTypePtr::pointer expression_list772_last = NULL;
    OracleDML::expression_list_return expression_list774;
    ImplTraits::TreeTypePtr::pointer expression_list774_last = NULL;
    ImplTraits::TreeTypePtr LEFT_PAREN763_tree;
    ImplTraits::TreeTypePtr COMMA765_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN767_tree;
    ImplTraits::TreeTypePtr LEFT_PAREN769_tree;
    ImplTraits::TreeTypePtr LEFT_PAREN771_tree;
    ImplTraits::TreeTypePtr COMMA773_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN775_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN776_tree;
    RewriteRuleTokenStream<ImplTraits> stream_LEFT_PAREN(get_psrstate()->get_treeAdaptor(), "token LEFT_PAREN");
    RewriteRuleTokenStream<ImplTraits> stream_RIGHT_PAREN(get_psrstate()->get_treeAdaptor(), "token RIGHT_PAREN");
    RewriteRuleTokenStream<ImplTraits> stream_COMMA(get_psrstate()->get_treeAdaptor(), "token COMMA");
    RewriteRuleSubtreeStream<ImplTraits> stream_expression_list(get_psrstate()->get_treeAdaptor(), "rule expression_list");
    RewriteRuleSubtreeStream<ImplTraits> stream_column_name(get_psrstate()->get_treeAdaptor(), "rule column_name");
    RewriteRuleSubtreeStream<ImplTraits> stream_in_key(get_psrstate()->get_treeAdaptor(), "rule in_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_for_key(get_psrstate()->get_treeAdaptor(), "rule for_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_subquery(get_psrstate()->get_treeAdaptor(), "rule subquery");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:1052:5: ( for_key LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN in_key LEFT_PAREN ( ( select_key )=> subquery | ( LEFT_PAREN )=> LEFT_PAREN expression_list ( COMMA expression_list )* RIGHT_PAREN ) RIGHT_PAREN -> ^( FOR_MULTI_COLUMN[$for_key.start] ( column_name )+ ^( in_key ( subquery )? ( expression_list )* ) ) )
        // OracleDML.g:1052:10: for_key LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN in_key LEFT_PAREN ( ( select_key )=> subquery | ( LEFT_PAREN )=> LEFT_PAREN expression_list ( COMMA expression_list )* RIGHT_PAREN ) RIGHT_PAREN
        {
            this->followPush(FOLLOW_for_key_in_multi_column_for_loop10816);
            for_key762=for_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemulti_column_for_loopEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                for_key762_last = for_key762.tree.get();
                stream_for_key.add(for_key762.tree);
            }

            LEFT_PAREN763 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_multi_column_for_loop10818);
            if  (this->hasException())
            {
                goto rulemulti_column_for_loopEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_LEFT_PAREN.add(LEFT_PAREN763);


            this->followPush(FOLLOW_column_name_in_multi_column_for_loop10820);
            column_name764=column_name();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemulti_column_for_loopEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                column_name764_last = column_name764.tree.get();
                stream_column_name.add(column_name764.tree);
            }

            // OracleDML.g:1052:41: ( COMMA column_name )*

            for (;;)
            {
                ANTLR_UINT32 alt257=2;
                switch ( this->LA(1) )
                {
                case COMMA:
                	{
                		alt257=1;
                	}
                    break;

                }

                switch (alt257)
                {
            	case 1:
            	    // OracleDML.g:1052:42: COMMA column_name
            	    {
            	        COMMA765 =  this->matchToken(COMMA, &FOLLOW_COMMA_in_multi_column_for_loop10823);
            	        if  (this->hasException())
            	        {
            	            goto rulemulti_column_for_loopEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( this->get_backtracking()==0 ) stream_COMMA.add(COMMA765);


            	        this->followPush(FOLLOW_column_name_in_multi_column_for_loop10825);
            	        column_name766=column_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemulti_column_for_loopEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            column_name766_last = column_name766.tree.get();
            	            stream_column_name.add(column_name766.tree);
            	        }

            	    }
            	    break;

            	default:
            	    goto loop257;	/* break out of the loop */
            	    break;
                }
            }
            loop257: ; /* Jump out to here if this rule does not match */


            RIGHT_PAREN767 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_multi_column_for_loop10829);
            if  (this->hasException())
            {
                goto rulemulti_column_for_loopEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN767);


            this->followPush(FOLLOW_in_key_in_multi_column_for_loop10831);
            in_key768=in_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemulti_column_for_loopEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                in_key768_last = in_key768.tree.get();
                stream_in_key.add(in_key768.tree);
            }

            LEFT_PAREN769 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_multi_column_for_loop10841);
            if  (this->hasException())
            {
                goto rulemulti_column_for_loopEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_LEFT_PAREN.add(LEFT_PAREN769);


            // OracleDML.g:1054:13: ( ( select_key )=> subquery | ( LEFT_PAREN )=> LEFT_PAREN expression_list ( COMMA expression_list )* RIGHT_PAREN )
            {
                ANTLR_UINT32 alt259=2;
                {
                    ANTLR_UINT32 LA259_0 = this->LA(1);
                    if ( (LA259_0 == SQL92_RESERVED_SELECT) && (this->msynpred( antlr3::ClassForwarder<synpred33_OracleDML>() )))
                    {
                        alt259=1;
                    }
                    else if ( (LA259_0 == LEFT_PAREN))
                    {
                        {
                            ANTLR_UINT32 LA259_2 = this->LA(2);
                            if ( (this->msynpred( antlr3::ClassForwarder<synpred33_OracleDML>() )))
                            {
                                alt259=1;
                            }
                            else if ( (this->msynpred( antlr3::ClassForwarder<synpred34_OracleDML>() )))
                            {
                                alt259=2;
                            }
                            else
                            {
                                if (this->get_backtracking()>0)
                                {
                                    this->set_failedflag( true );
                                    return retval;
                                }


                                ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                ex->set_decisionNum( 259 );
                                ex->set_state( 2 );


                                goto rulemulti_column_for_loopEx;

                            }
                        }
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return retval;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 259 );
                        ex->set_state( 0 );


                        goto rulemulti_column_for_loopEx;

                    }
                }
                switch (alt259)
                {
            	case 1:
            	    // OracleDML.g:1054:18: ( select_key )=> subquery
            	    {
            	        this->followPush(FOLLOW_subquery_in_multi_column_for_loop10865);
            	        subquery770=subquery();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemulti_column_for_loopEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            subquery770_last = subquery770.tree.get();
            	            stream_subquery.add(subquery770.tree);
            	        }

            	    }
            	    break;
            	case 2:
            	    // OracleDML.g:1055:18: ( LEFT_PAREN )=> LEFT_PAREN expression_list ( COMMA expression_list )* RIGHT_PAREN
            	    {
            	        LEFT_PAREN771 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_multi_column_for_loop10889);
            	        if  (this->hasException())
            	        {
            	            goto rulemulti_column_for_loopEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( this->get_backtracking()==0 ) stream_LEFT_PAREN.add(LEFT_PAREN771);


            	        this->followPush(FOLLOW_expression_list_in_multi_column_for_loop10891);
            	        expression_list772=expression_list();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemulti_column_for_loopEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            expression_list772_last = expression_list772.tree.get();
            	            stream_expression_list.add(expression_list772.tree);
            	        }

            	        // OracleDML.g:1055:60: ( COMMA expression_list )*

            	        for (;;)
            	        {
            	            ANTLR_UINT32 alt258=2;
            	            switch ( this->LA(1) )
            	            {
            	            case COMMA:
            	            	{
            	            		alt258=1;
            	            	}
            	                break;

            	            }

            	            switch (alt258)
            	            {
            	        	case 1:
            	        	    // OracleDML.g:1055:61: COMMA expression_list
            	        	    {
            	        	        COMMA773 =  this->matchToken(COMMA, &FOLLOW_COMMA_in_multi_column_for_loop10894);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulemulti_column_for_loopEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }
            	        	         
            	        	        if ( this->get_backtracking()==0 ) stream_COMMA.add(COMMA773);


            	        	        this->followPush(FOLLOW_expression_list_in_multi_column_for_loop10896);
            	        	        expression_list774=expression_list();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulemulti_column_for_loopEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) 
            	        	        {
            	        	            expression_list774_last = expression_list774.tree.get();
            	        	            stream_expression_list.add(expression_list774.tree);
            	        	        }

            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop258;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop258: ; /* Jump out to here if this rule does not match */


            	        RIGHT_PAREN775 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_multi_column_for_loop10900);
            	        if  (this->hasException())
            	        {
            	            goto rulemulti_column_for_loopEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( this->get_backtracking()==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN775);


            	    }
            	    break;

                }
            }

            RIGHT_PAREN776 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_multi_column_for_loop10924);
            if  (this->hasException())
            {
                goto rulemulti_column_for_loopEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN776);


            // AST REWRITE
            // elements: subquery, in_key, expression_list, column_name
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1058:9: -> ^( FOR_MULTI_COLUMN[$for_key.start] ( column_name )+ ^( in_key ( subquery )? ( expression_list )* ) )
            {
            	// OracleDML.g:1058:12: ^( FOR_MULTI_COLUMN[$for_key.start] ( column_name )+ ^( in_key ( subquery )? ( expression_list )* ) )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(FOR_MULTI_COLUMN, (for_key762.start)), root_1);
            	if ( !(stream_column_name.hasNext()) ) {
            		ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, REWRITE_EARLY_EXCEPTION, StreamType>( this->get_rec(), "column_name empty" );
            		goto rulemulti_column_for_loopEx;
            	}
            	while ( stream_column_name.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_column_name.nextTree());
            	}
            	stream_column_name.reset();

            	// OracleDML.g:1058:60: ^( in_key ( subquery )? ( expression_list )* )
            	{
            	ImplTraits::TreeTypePtr root_2 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_2 = get_psrstate()->get_treeAdaptor()->becomeRoot(stream_in_key.nextNode(), root_2);
            	// OracleDML.g:1058:69: ( subquery )?
            	if ( stream_subquery.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_2, stream_subquery.nextTree());
            	}
            	stream_subquery.reset();

            	// OracleDML.g:1058:79: ( expression_list )*
            	while ( stream_expression_list.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_2, stream_expression_list.nextTree());
            	}
            	stream_expression_list.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_1, root_2);
            	}
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulemulti_column_for_loopEx; /* Prevent compiler warnings */
    rulemulti_column_for_loopEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end multi_column_for_loop */

/**
 * $ANTLR start multiset_expression
 * OracleDML.g:1061:1: multiset_expression : unary_expression ( multiset_op ^ unary_expression )* ;
 */
OracleDML::multiset_expression_return
OracleDML::multiset_expression()
{
    OracleDML::multiset_expression_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML::unary_expression_return unary_expression777;
    ImplTraits::TreeTypePtr::pointer unary_expression777_last = NULL;
    OracleDML_OracleDMLCommons::multiset_op_return multiset_op778;
    ImplTraits::TreeTypePtr::pointer multiset_op778_last = NULL;
    OracleDML::unary_expression_return unary_expression779;
    ImplTraits::TreeTypePtr::pointer unary_expression779_last = NULL;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:1062:5: ( unary_expression ( multiset_op ^ unary_expression )* )
        // OracleDML.g:1062:10: unary_expression ( multiset_op ^ unary_expression )*
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            this->followPush(FOLLOW_unary_expression_in_multiset_expression10972);
            unary_expression777=unary_expression();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemultiset_expressionEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, unary_expression777.tree);


            // OracleDML.g:1063:10: ( multiset_op ^ unary_expression )*

            for (;;)
            {
                ANTLR_UINT32 alt260=2;
                switch ( this->LA(1) )
                {
                case PLSQL_NON_RESERVED_MULTISET:
                	{
                		alt260=1;
                	}
                    break;

                }

                switch (alt260)
                {
            	case 1:
            	    // OracleDML.g:1063:12: multiset_op ^ unary_expression
            	    {
            	        this->followPush(FOLLOW_multiset_op_in_multiset_expression10985);
            	        multiset_op778=multiset_op();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemultiset_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(multiset_op778.tree, root_0);

            	        this->followPush(FOLLOW_unary_expression_in_multiset_expression10988);
            	        unary_expression779=unary_expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemultiset_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, unary_expression779.tree);


            	    }
            	    break;

            	default:
            	    goto loop260;	/* break out of the loop */
            	    break;
                }
            }
            loop260: ; /* Jump out to here if this rule does not match */


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulemultiset_expressionEx; /* Prevent compiler warnings */
    rulemultiset_expressionEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end multiset_expression */

/**
 * $ANTLR start unary_expression
 * OracleDML.g:1066:1: unary_expression options {backtrack=true; } : ( MINUS_SIGN unary_expression -> ^( UNARY_OPERATOR[$MINUS_SIGN] unary_expression ) | PLUS_SIGN unary_expression -> ^( UNARY_OPERATOR[$PLUS_SIGN] unary_expression ) | prior_key ^ unary_expression | connect_by_root_key ^ unary_expression |{...}? => new_key ^ unary_expression | distinct_key ^ unary_expression | all_key ^ unary_expression |{...}? case_statement[false] | quantified_expression | standard_function -> ^( STANDARD_FUNCTION standard_function ) | atom );
 */
OracleDML::unary_expression_return
OracleDML::unary_expression()
{
    OracleDML::unary_expression_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* MINUS_SIGN780 = NULL;
    ImplTraits::CommonTokenType const* PLUS_SIGN782 = NULL;
    OracleDML::unary_expression_return unary_expression781;
    ImplTraits::TreeTypePtr::pointer unary_expression781_last = NULL;
    OracleDML::unary_expression_return unary_expression783;
    ImplTraits::TreeTypePtr::pointer unary_expression783_last = NULL;
    OracleDML_OracleDMLKeys::prior_key_return prior_key784;
    ImplTraits::TreeTypePtr::pointer prior_key784_last = NULL;
    OracleDML::unary_expression_return unary_expression785;
    ImplTraits::TreeTypePtr::pointer unary_expression785_last = NULL;
    OracleDML_OracleDMLKeys::connect_by_root_key_return connect_by_root_key786;
    ImplTraits::TreeTypePtr::pointer connect_by_root_key786_last = NULL;
    OracleDML::unary_expression_return unary_expression787;
    ImplTraits::TreeTypePtr::pointer unary_expression787_last = NULL;
    OracleDML_OracleDMLKeys::new_key_return new_key788;
    ImplTraits::TreeTypePtr::pointer new_key788_last = NULL;
    OracleDML::unary_expression_return unary_expression789;
    ImplTraits::TreeTypePtr::pointer unary_expression789_last = NULL;
    OracleDML_OracleDMLKeys::distinct_key_return distinct_key790;
    ImplTraits::TreeTypePtr::pointer distinct_key790_last = NULL;
    OracleDML::unary_expression_return unary_expression791;
    ImplTraits::TreeTypePtr::pointer unary_expression791_last = NULL;
    OracleDML_OracleDMLKeys::all_key_return all_key792;
    ImplTraits::TreeTypePtr::pointer all_key792_last = NULL;
    OracleDML::unary_expression_return unary_expression793;
    ImplTraits::TreeTypePtr::pointer unary_expression793_last = NULL;
    OracleDML::case_statement_return case_statement794;
    ImplTraits::TreeTypePtr::pointer case_statement794_last = NULL;
    OracleDML::quantified_expression_return quantified_expression795;
    ImplTraits::TreeTypePtr::pointer quantified_expression795_last = NULL;
    OracleDML::standard_function_return standard_function796;
    ImplTraits::TreeTypePtr::pointer standard_function796_last = NULL;
    OracleDML::atom_return atom797;
    ImplTraits::TreeTypePtr::pointer atom797_last = NULL;
    ImplTraits::TreeTypePtr MINUS_SIGN780_tree;
    ImplTraits::TreeTypePtr PLUS_SIGN782_tree;
    RewriteRuleTokenStream<ImplTraits> stream_PLUS_SIGN(get_psrstate()->get_treeAdaptor(), "token PLUS_SIGN");
    RewriteRuleTokenStream<ImplTraits> stream_MINUS_SIGN(get_psrstate()->get_treeAdaptor(), "token MINUS_SIGN");
    RewriteRuleSubtreeStream<ImplTraits> stream_unary_expression(get_psrstate()->get_treeAdaptor(), "rule unary_expression");
    RewriteRuleSubtreeStream<ImplTraits> stream_standard_function(get_psrstate()->get_treeAdaptor(), "rule standard_function");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        {
            //  OracleDML.g:1071:5: ( MINUS_SIGN unary_expression -> ^( UNARY_OPERATOR[$MINUS_SIGN] unary_expression ) | PLUS_SIGN unary_expression -> ^( UNARY_OPERATOR[$PLUS_SIGN] unary_expression ) | prior_key ^ unary_expression | connect_by_root_key ^ unary_expression |{...}? => new_key ^ unary_expression | distinct_key ^ unary_expression | all_key ^ unary_expression |{...}? case_statement[false] | quantified_expression | standard_function -> ^( STANDARD_FUNCTION standard_function ) | atom )

            ANTLR_UINT32 alt261;

            alt261=11;

            switch ( this->LA(1) )
            {
            case MINUS_SIGN:
            	{
            		alt261=1;
            	}
                break;
            case PLUS_SIGN:
            	{
            		alt261=2;
            	}
                break;
            case SQL92_RESERVED_PRIOR:
            	{
            		alt261=3;
            	}
                break;
            case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
            	{
            		alt261=4;
            	}
                break;
            case REGULAR_ID:
            	{
            		{
            		    ANTLR_UINT32 LA261_5 = this->LA(2);
            		    if ( (( (( ((LT(1)->getText() == "NEW" && LT(2)->getText() != ".")) && (this->msynpred( antlr3::ClassForwarder<synpred39_OracleDML>() )) )) && ((toUpper(LT(1)->getText()) == "NEW")) )))
            		    {
            		        alt261=5;
            		    }
            		    else if ( (( (( (((LA(1) == SQL92_RESERVED_CASE || LA(2) == SQL92_RESERVED_CASE))) && ((!m_case_statement_stack.peek().isStatement)) )) && (this->msynpred( antlr3::ClassForwarder<synpred42_OracleDML>() )) )))
            		    {
            		        alt261=8;
            		    }
            		    else if ( (( (this->msynpred( antlr3::ClassForwarder<synpred43_OracleDML>() )) && ((toUpper(LT(1)->getText()) == "SOME")) )))
            		    {
            		        alt261=9;
            		    }
            		    else if ( (( ((((toUpper(LT(1)->getText()) == "XMLCAST"))||((toUpper(LT(1)->getText()) == "XMLEXISTS"))||((toUpper(LT(1)->getText()) == "XMLCOLATTVAL"))||((toUpper(LT(1)->getText()) == "DECOMPOSE"))||((enablesWithinOrOverClause(LT(1)->getText())))||((isStandardPredictionFunction(LT(1)->getText())))||((toUpper(LT(1)->getText()) == "TRANSLATE"))||((toUpper(LT(1)->getText()) == "TREAT"))||((toUpper(LT(1)->getText()) == "XMLAGG"))||((toUpper(LT(1)->getText()) == "COLLECT"))||((toUpper(LT(1)->getText()) == "XMLELEMENT"))||((toUpper(LT(1)->getText()) == "LAST_VALUE"))||((enablesOverClause(LT(1)->getText())))||((enablesUsingClause(LT(1)->getText())))||((toUpper(LT(1)->getText()) == "EXTRACT"))||((toUpper(LT(1)->getText()) == "XMLQUERY"))||((toUpper(LT(1)->getText()) == "TRIM"))||((toUpper(LT(1)->getText()) == "XMLPI"))||((toUpper(LT(1)->getText()) == "FIRST_VALUE"))||((toUpper(LT(1)->getText()) == "COUNT" ))||((toUpper(LT(1)->getText()) == "XMLTABLE"))||((toUpper(LT(1)->getText()) == "XMLPARSE"))||((toUpper(LT(1)->getText()) == "CHR"))||((toUpper(LT(1)->getText()) == "XMLSERIALIZE"))||((toUpper(LT(1)->getText()) == "XMLROOT"))||((toUpper(LT(1)->getText()) == "XMLFOREST")))) && (this->msynpred( antlr3::ClassForwarder<synpred44_OracleDML>() )) )))
            		    {
            		        alt261=10;
            		    }
            		    else if ( (true))
            		    {
            		        alt261=11;
            		    }
            		    else
            		    {
            		        if (this->get_backtracking()>0)
            		        {
            		            this->set_failedflag( true );
            		            return retval;
            		        }


            		        ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 261 );
            		        ex->set_state( 5 );


            		        goto ruleunary_expressionEx;

            		    }
            		}
            	}
                break;
            case SQL92_RESERVED_DISTINCT:
            	{
            		alt261=6;
            	}
                break;
            case SQL92_RESERVED_ALL:
            	{
            		{
            		    ANTLR_UINT32 LA261_7 = this->LA(2);
            		    if ( (this->msynpred( antlr3::ClassForwarder<synpred41_OracleDML>() )))
            		    {
            		        alt261=7;
            		    }
            		    else if ( (this->msynpred( antlr3::ClassForwarder<synpred43_OracleDML>() )))
            		    {
            		        alt261=9;
            		    }
            		    else
            		    {
            		        if (this->get_backtracking()>0)
            		        {
            		            this->set_failedflag( true );
            		            return retval;
            		        }


            		        ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 261 );
            		        ex->set_state( 7 );


            		        goto ruleunary_expressionEx;

            		    }
            		}
            	}
                break;
            case DELIMITED_ID:
            	{
            		{
            		    ANTLR_UINT32 LA261_8 = this->LA(2);
            		    if ( (( (( (((LA(1) == SQL92_RESERVED_CASE || LA(2) == SQL92_RESERVED_CASE))) && ((!m_case_statement_stack.peek().isStatement)) )) && (this->msynpred( antlr3::ClassForwarder<synpred42_OracleDML>() )) )))
            		    {
            		        alt261=8;
            		    }
            		    else if ( (true))
            		    {
            		        alt261=11;
            		    }
            		    else
            		    {
            		        if (this->get_backtracking()>0)
            		        {
            		            this->set_failedflag( true );
            		            return retval;
            		        }


            		        ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 261 );
            		        ex->set_state( 8 );


            		        goto ruleunary_expressionEx;

            		    }
            		}
            	}
                break;
            case SQL92_RESERVED_CASE:
            	{
            		alt261=8;
            	}
                break;
            case SQL92_RESERVED_ANY:
            case SQL92_RESERVED_EXISTS:
            	{
            		alt261=9;
            	}
                break;
            case PLSQL_NON_RESERVED_CAST:
            	{
            		alt261=10;
            	}
                break;
            case APPROXIMATE_NUM_LIT:
            case BINDVAR:
            case CHAR_STRING:
            case CHAR_STRING_PERL:
            case COLON:
            case EXACT_NUM_LIT:
            case INTRODUCER:
            case LEFT_PAREN:
            case NATIONAL_CHAR_STRING_LIT:
            case SQL92_RESERVED_DATE:
            case SQL92_RESERVED_DEFAULT:
            case SQL92_RESERVED_FALSE:
            case SQL92_RESERVED_NULL:
            case SQL92_RESERVED_TRUE:
            case UNSIGNED_INTEGER:
            	{
            		alt261=11;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 261 );
                ex->set_state( 0 );


                goto ruleunary_expressionEx;

            }

            switch (alt261)
            {
        	case 1:
        	    // OracleDML.g:1071:10: MINUS_SIGN unary_expression
        	    {
        	        MINUS_SIGN780 =  this->matchToken(MINUS_SIGN, &FOLLOW_MINUS_SIGN_in_unary_expression11020);
        	        if  (this->hasException())
        	        {
        	            goto ruleunary_expressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }
        	         
        	        if ( this->get_backtracking()==0 ) stream_MINUS_SIGN.add(MINUS_SIGN780);


        	        this->followPush(FOLLOW_unary_expression_in_unary_expression11022);
        	        unary_expression781=unary_expression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleunary_expressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) 
        	        {
        	            unary_expression781_last = unary_expression781.tree.get();
        	            stream_unary_expression.add(unary_expression781.tree);
        	        }

        	        // AST REWRITE
        	        // elements: unary_expression
        	        // token labels: 
        	        // rule labels: retval
        	        // token list labels: 
        	        // rule list labels: 
        	        // wildcard labels: 
        	        if ( this->get_backtracking()==0 ) {
        	        retval.tree = std::move(root_0);
        	        RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
        	        // 1071:38: -> ^( UNARY_OPERATOR[$MINUS_SIGN] unary_expression )
        	        {
        	        	// OracleDML.g:1071:41: ^( UNARY_OPERATOR[$MINUS_SIGN] unary_expression )
        	        	{
        	        	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
        	        	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(UNARY_OPERATOR, MINUS_SIGN780), root_1);
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_unary_expression.nextTree());
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
        	        	}
        	        }


        	        //retval.tree = std::move(root_0);
        	        }

        	    }
        	    break;
        	case 2:
        	    // OracleDML.g:1072:10: PLUS_SIGN unary_expression
        	    {
        	        PLUS_SIGN782 =  this->matchToken(PLUS_SIGN, &FOLLOW_PLUS_SIGN_in_unary_expression11042);
        	        if  (this->hasException())
        	        {
        	            goto ruleunary_expressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }
        	         
        	        if ( this->get_backtracking()==0 ) stream_PLUS_SIGN.add(PLUS_SIGN782);


        	        this->followPush(FOLLOW_unary_expression_in_unary_expression11044);
        	        unary_expression783=unary_expression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleunary_expressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) 
        	        {
        	            unary_expression783_last = unary_expression783.tree.get();
        	            stream_unary_expression.add(unary_expression783.tree);
        	        }

        	        // AST REWRITE
        	        // elements: unary_expression
        	        // token labels: 
        	        // rule labels: retval
        	        // token list labels: 
        	        // rule list labels: 
        	        // wildcard labels: 
        	        if ( this->get_backtracking()==0 ) {
        	        retval.tree = std::move(root_0);
        	        RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
        	        // 1072:37: -> ^( UNARY_OPERATOR[$PLUS_SIGN] unary_expression )
        	        {
        	        	// OracleDML.g:1072:40: ^( UNARY_OPERATOR[$PLUS_SIGN] unary_expression )
        	        	{
        	        	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
        	        	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(UNARY_OPERATOR, PLUS_SIGN782), root_1);
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_unary_expression.nextTree());
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
        	        	}
        	        }


        	        //retval.tree = std::move(root_0);
        	        }

        	    }
        	    break;
        	case 3:
        	    // OracleDML.g:1073:10: prior_key ^ unary_expression
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_prior_key_in_unary_expression11064);
        	        prior_key784=prior_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleunary_expressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(prior_key784.tree, root_0);

        	        this->followPush(FOLLOW_unary_expression_in_unary_expression11067);
        	        unary_expression785=unary_expression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleunary_expressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, unary_expression785.tree);


        	    }
        	    break;
        	case 4:
        	    // OracleDML.g:1074:10: connect_by_root_key ^ unary_expression
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_connect_by_root_key_in_unary_expression11078);
        	        connect_by_root_key786=connect_by_root_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleunary_expressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(connect_by_root_key786.tree, root_0);

        	        this->followPush(FOLLOW_unary_expression_in_unary_expression11081);
        	        unary_expression787=unary_expression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleunary_expressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, unary_expression787.tree);


        	    }
        	    break;
        	case 5:
        	    // OracleDML.g:1075:10: {...}? => new_key ^ unary_expression
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        if ( !((LT(1)->getText() == "NEW" && LT(2)->getText() != ".")) )
        	        {
        	            if (this->get_backtracking()>0)
        	            {
        	                this->set_failedflag( true );
        	                return retval;
        	            }

        	            	ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "LT(1)->getText() == \"NEW\" && LT(2)->getText() != \".\"" );
        	                ex->set_ruleName( "unary_expression" );


        	        }

        	        this->followPush(FOLLOW_new_key_in_unary_expression11095);
        	        new_key788=new_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleunary_expressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(new_key788.tree, root_0);

        	        this->followPush(FOLLOW_unary_expression_in_unary_expression11098);
        	        unary_expression789=unary_expression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleunary_expressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, unary_expression789.tree);


        	    }
        	    break;
        	case 6:
        	    // OracleDML.g:1076:10: distinct_key ^ unary_expression
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_distinct_key_in_unary_expression11109);
        	        distinct_key790=distinct_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleunary_expressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(distinct_key790.tree, root_0);

        	        this->followPush(FOLLOW_unary_expression_in_unary_expression11112);
        	        unary_expression791=unary_expression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleunary_expressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, unary_expression791.tree);


        	    }
        	    break;
        	case 7:
        	    // OracleDML.g:1077:10: all_key ^ unary_expression
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_all_key_in_unary_expression11123);
        	        all_key792=all_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleunary_expressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(all_key792.tree, root_0);

        	        this->followPush(FOLLOW_unary_expression_in_unary_expression11126);
        	        unary_expression793=unary_expression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleunary_expressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, unary_expression793.tree);


        	    }
        	    break;
        	case 8:
        	    // OracleDML.g:1078:10: {...}? case_statement[false]
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        if ( !(((LA(1) == SQL92_RESERVED_CASE || LA(2) == SQL92_RESERVED_CASE))) )
        	        {
        	            if (this->get_backtracking()>0)
        	            {
        	                this->set_failedflag( true );
        	                return retval;
        	            }

        	            	ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "(LA(1) == SQL92_RESERVED_CASE || LA(2) == SQL92_RESERVED_CASE)" );
        	                ex->set_ruleName( "unary_expression" );


        	        }

        	        this->followPush(FOLLOW_case_statement_in_unary_expression11139);
        	        case_statement794=case_statement(false);

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleunary_expressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, case_statement794.tree);


        	    }
        	    break;
        	case 9:
        	    // OracleDML.g:1079:10: quantified_expression
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_quantified_expression_in_unary_expression11151);
        	        quantified_expression795=quantified_expression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleunary_expressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, quantified_expression795.tree);


        	    }
        	    break;
        	case 10:
        	    // OracleDML.g:1080:10: standard_function
        	    {
        	        this->followPush(FOLLOW_standard_function_in_unary_expression11162);
        	        standard_function796=standard_function();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleunary_expressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) 
        	        {
        	            standard_function796_last = standard_function796.tree.get();
        	            stream_standard_function.add(standard_function796.tree);
        	        }

        	        // AST REWRITE
        	        // elements: standard_function
        	        // token labels: 
        	        // rule labels: retval
        	        // token list labels: 
        	        // rule list labels: 
        	        // wildcard labels: 
        	        if ( this->get_backtracking()==0 ) {
        	        retval.tree = std::move(root_0);
        	        RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
        	        // 1080:28: -> ^( STANDARD_FUNCTION standard_function )
        	        {
        	        	// OracleDML.g:1080:31: ^( STANDARD_FUNCTION standard_function )
        	        	{
        	        	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
        	        	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(STANDARD_FUNCTION, "STANDARD_FUNCTION"), root_1);
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_standard_function.nextTree());
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
        	        	}
        	        }


        	        //retval.tree = std::move(root_0);
        	        }

        	    }
        	    break;
        	case 11:
        	    // OracleDML.g:1081:10: atom
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_atom_in_unary_expression11181);
        	        atom797=atom();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleunary_expressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, atom797.tree);


        	    }
        	    break;

            }
        }
    }//...
    // This is where rules clean up and exit
    //
    goto ruleunary_expressionEx; /* Prevent compiler warnings */
    ruleunary_expressionEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end unary_expression */

/**
 * $ANTLR start case_statement
 * OracleDML.g:1084:1: case_statement[int isStatementParameter] : ( ( ( label_name )? case_key when_key )=> searched_case_statement | simple_case_statement );
 */
OracleDML::case_statement_return
OracleDML::case_statement(int isStatementParameter)
{
    OracleDML::case_statement_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML::searched_case_statement_return searched_case_statement798;
    ImplTraits::TreeTypePtr::pointer searched_case_statement798_last = NULL;
    OracleDML::simple_case_statement_return simple_case_statement799;
    ImplTraits::TreeTypePtr::pointer simple_case_statement799_last = NULL;

    /* Initialize rule variables
     */
    m_case_statement_stack.push(case_statementScope()); 
    m_case_statement_stack.peek().isStatement = isStatementParameter;
    retval.call_start_placeholder(this);


 
    {
        {
            //  OracleDML.g:1089:5: ( ( ( label_name )? case_key when_key )=> searched_case_statement | simple_case_statement )

            ANTLR_UINT32 alt262;

            alt262=2;

            switch ( this->LA(1) )
            {
            case REGULAR_ID:
            	{
            		switch ( this->LA(2) )
            		{
            		case SQL92_RESERVED_CASE:
            			{
            				{
            				    ANTLR_UINT32 LA262_3 = this->LA(3);
            				    if ( (LA262_3 == SQL92_RESERVED_WHEN) && (this->msynpred( antlr3::ClassForwarder<synpred45_OracleDML>() )))
            				    {
            				        alt262=1;
            				    }
            				    else if ( (LA262_3 == APPROXIMATE_NUM_LIT || LA262_3 == BINDVAR || ((LA262_3 >= CHAR_STRING) && (LA262_3 <= CHAR_STRING_PERL)) || LA262_3 == COLON || LA262_3 == DELIMITED_ID || LA262_3 == EXACT_NUM_LIT || LA262_3 == INTRODUCER || LA262_3 == LEFT_PAREN || LA262_3 == NATIONAL_CHAR_STRING_LIT || LA262_3 == REGULAR_ID || LA262_3 == SQL92_RESERVED_DATE || LA262_3 == SQL92_RESERVED_DEFAULT || LA262_3 == SQL92_RESERVED_FALSE || LA262_3 == SQL92_RESERVED_NULL || LA262_3 == SQL92_RESERVED_TRUE || LA262_3 == UNSIGNED_INTEGER))
            				    {
            				        alt262=2;
            				    }
            				    else
            				    {
            				        if (this->get_backtracking()>0)
            				        {
            				            this->set_failedflag( true );
            				            m_case_statement_stack.pop(); 

            				            return retval;
            				        }


            				        ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            				        ex->set_decisionNum( 262 );
            				        ex->set_state( 3 );


            				        goto rulecase_statementEx;

            				    }
            				}
            			}
            		    break;

            		default:
            		    if (this->get_backtracking()>0)
            		    {
            		        this->set_failedflag( true );
            		        m_case_statement_stack.pop(); 

            		        return retval;
            		    }

            		    ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		    ex->set_decisionNum( 262 );
            		    ex->set_state( 1 );


            		    goto rulecase_statementEx;

            		}

            	}
                break;
            case DELIMITED_ID:
            	{
            		switch ( this->LA(2) )
            		{
            		case SQL92_RESERVED_CASE:
            			{
            				{
            				    ANTLR_UINT32 LA262_3 = this->LA(3);
            				    if ( (LA262_3 == SQL92_RESERVED_WHEN) && (this->msynpred( antlr3::ClassForwarder<synpred45_OracleDML>() )))
            				    {
            				        alt262=1;
            				    }
            				    else if ( (LA262_3 == APPROXIMATE_NUM_LIT || LA262_3 == BINDVAR || ((LA262_3 >= CHAR_STRING) && (LA262_3 <= CHAR_STRING_PERL)) || LA262_3 == COLON || LA262_3 == DELIMITED_ID || LA262_3 == EXACT_NUM_LIT || LA262_3 == INTRODUCER || LA262_3 == LEFT_PAREN || LA262_3 == NATIONAL_CHAR_STRING_LIT || LA262_3 == REGULAR_ID || LA262_3 == SQL92_RESERVED_DATE || LA262_3 == SQL92_RESERVED_DEFAULT || LA262_3 == SQL92_RESERVED_FALSE || LA262_3 == SQL92_RESERVED_NULL || LA262_3 == SQL92_RESERVED_TRUE || LA262_3 == UNSIGNED_INTEGER))
            				    {
            				        alt262=2;
            				    }
            				    else
            				    {
            				        if (this->get_backtracking()>0)
            				        {
            				            this->set_failedflag( true );
            				            m_case_statement_stack.pop(); 

            				            return retval;
            				        }


            				        ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            				        ex->set_decisionNum( 262 );
            				        ex->set_state( 3 );


            				        goto rulecase_statementEx;

            				    }
            				}
            			}
            		    break;

            		default:
            		    if (this->get_backtracking()>0)
            		    {
            		        this->set_failedflag( true );
            		        m_case_statement_stack.pop(); 

            		        return retval;
            		    }

            		    ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		    ex->set_decisionNum( 262 );
            		    ex->set_state( 2 );


            		    goto rulecase_statementEx;

            		}

            	}
                break;
            case SQL92_RESERVED_CASE:
            	{
            		{
            		    ANTLR_UINT32 LA262_3 = this->LA(2);
            		    if ( (LA262_3 == SQL92_RESERVED_WHEN) && (this->msynpred( antlr3::ClassForwarder<synpred45_OracleDML>() )))
            		    {
            		        alt262=1;
            		    }
            		    else if ( (LA262_3 == APPROXIMATE_NUM_LIT || LA262_3 == BINDVAR || ((LA262_3 >= CHAR_STRING) && (LA262_3 <= CHAR_STRING_PERL)) || LA262_3 == COLON || LA262_3 == DELIMITED_ID || LA262_3 == EXACT_NUM_LIT || LA262_3 == INTRODUCER || LA262_3 == LEFT_PAREN || LA262_3 == NATIONAL_CHAR_STRING_LIT || LA262_3 == REGULAR_ID || LA262_3 == SQL92_RESERVED_DATE || LA262_3 == SQL92_RESERVED_DEFAULT || LA262_3 == SQL92_RESERVED_FALSE || LA262_3 == SQL92_RESERVED_NULL || LA262_3 == SQL92_RESERVED_TRUE || LA262_3 == UNSIGNED_INTEGER))
            		    {
            		        alt262=2;
            		    }
            		    else
            		    {
            		        if (this->get_backtracking()>0)
            		        {
            		            this->set_failedflag( true );
            		            m_case_statement_stack.pop(); 

            		            return retval;
            		        }


            		        ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 262 );
            		        ex->set_state( 3 );


            		        goto rulecase_statementEx;

            		    }
            		}
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    m_case_statement_stack.pop(); 

                    return retval;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 262 );
                ex->set_state( 0 );


                goto rulecase_statementEx;

            }

            switch (alt262)
            {
        	case 1:
        	    // OracleDML.g:1089:10: ( ( label_name )? case_key when_key )=> searched_case_statement
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_searched_case_statement_in_case_statement11228);
        	        searched_case_statement798=searched_case_statement();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulecase_statementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            m_case_statement_stack.pop(); 

        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, searched_case_statement798.tree);


        	    }
        	    break;
        	case 2:
        	    // OracleDML.g:1090:10: simple_case_statement
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_simple_case_statement_in_case_statement11239);
        	        simple_case_statement799=simple_case_statement();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulecase_statementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            m_case_statement_stack.pop(); 

        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, simple_case_statement799.tree);


        	    }
        	    break;

            }
        }
    }//...
    // This is where rules clean up and exit
    //
    goto rulecase_statementEx; /* Prevent compiler warnings */
    rulecase_statementEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    m_case_statement_stack.pop(); 

    return retval;
}
/* $ANTLR end case_statement */

/**
 * $ANTLR start simple_case_statement
 * OracleDML.g:1095:1: simple_case_statement : ({...}? ( label_name )? ) ck1= case_key atom ( simple_case_when_part )+ ( case_else_part )? end_key ({...}? case_key ( label_name )? |) -> ^( SIMPLE_CASE[$ck1.start] ( label_name )* ^( EXPR atom ) ( simple_case_when_part )+ ( case_else_part )? end_key ) ;
 */
OracleDML::simple_case_statement_return
OracleDML::simple_case_statement()
{
    OracleDML::simple_case_statement_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML_OracleDMLKeys::case_key_return ck1;
    ImplTraits::TreeTypePtr::pointer ck1_last = NULL;
    OracleDML_OracleDMLCommons::label_name_return label_name800;
    ImplTraits::TreeTypePtr::pointer label_name800_last = NULL;
    OracleDML::atom_return atom801;
    ImplTraits::TreeTypePtr::pointer atom801_last = NULL;
    OracleDML::simple_case_when_part_return simple_case_when_part802;
    ImplTraits::TreeTypePtr::pointer simple_case_when_part802_last = NULL;
    OracleDML::case_else_part_return case_else_part803;
    ImplTraits::TreeTypePtr::pointer case_else_part803_last = NULL;
    OracleDML_OracleDMLKeys::end_key_return end_key804;
    ImplTraits::TreeTypePtr::pointer end_key804_last = NULL;
    OracleDML_OracleDMLKeys::case_key_return case_key805;
    ImplTraits::TreeTypePtr::pointer case_key805_last = NULL;
    OracleDML_OracleDMLCommons::label_name_return label_name806;
    ImplTraits::TreeTypePtr::pointer label_name806_last = NULL;
    RewriteRuleSubtreeStream<ImplTraits> stream_atom(get_psrstate()->get_treeAdaptor(), "rule atom");
    RewriteRuleSubtreeStream<ImplTraits> stream_simple_case_when_part(get_psrstate()->get_treeAdaptor(), "rule simple_case_when_part");
    RewriteRuleSubtreeStream<ImplTraits> stream_label_name(get_psrstate()->get_treeAdaptor(), "rule label_name");
    RewriteRuleSubtreeStream<ImplTraits> stream_case_else_part(get_psrstate()->get_treeAdaptor(), "rule case_else_part");
    RewriteRuleSubtreeStream<ImplTraits> stream_case_key(get_psrstate()->get_treeAdaptor(), "rule case_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_end_key(get_psrstate()->get_treeAdaptor(), "rule end_key");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:1096:5: ( ({...}? ( label_name )? ) ck1= case_key atom ( simple_case_when_part )+ ( case_else_part )? end_key ({...}? case_key ( label_name )? |) -> ^( SIMPLE_CASE[$ck1.start] ( label_name )* ^( EXPR atom ) ( simple_case_when_part )+ ( case_else_part )? end_key ) )
        // OracleDML.g:1096:9: ({...}? ( label_name )? ) ck1= case_key atom ( simple_case_when_part )+ ( case_else_part )? end_key ({...}? case_key ( label_name )? |)
        {
            // OracleDML.g:1096:9: ({...}? ( label_name )? )
            // OracleDML.g:1096:10: {...}? ( label_name )?
            {
                if ( !((!m_case_statement_stack.peek().isStatement)) )
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return retval;
                    }

                    	ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "!$case_statement::isStatement" );
                        ex->set_ruleName( "simple_case_statement" );


                }

                // OracleDML.g:1096:43: ( label_name )?
                {
                    ANTLR_UINT32 alt263=2;
                    switch ( this->LA(1) )
                    {
                        case DELIMITED_ID:
                        case REGULAR_ID:
                        	{
                        		alt263=1;
                        	}
                            break;
                    }

                    switch (alt263)
                    {
                	case 1:
                	    // OracleDML.g:1096:43: label_name
                	    {
                	        this->followPush(FOLLOW_label_name_in_simple_case_statement11263);
                	        label_name800=label_name();

                	        this->followPop();
                	        if  (this->hasException())
                	        {
                	            goto rulesimple_case_statementEx;
                	        }
                	        if (this->hasFailed())
                	        {
                	            return retval;
                	        }

                	        if ( this->get_backtracking()==0 ) 
                	        {
                	            label_name800_last = label_name800.tree.get();
                	            stream_label_name.add(label_name800.tree);
                	        }

                	    }
                	    break;

                    }
                }

            }


            this->followPush(FOLLOW_case_key_in_simple_case_statement11269);
            ck1=case_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesimple_case_statementEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                ck1_last = ck1.tree.get();
                stream_case_key.add(ck1.tree);
            }

            this->followPush(FOLLOW_atom_in_simple_case_statement11271);
            atom801=atom();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesimple_case_statementEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                atom801_last = atom801.tree.get();
                stream_atom.add(atom801.tree);
            }

            // OracleDML.g:1097:9: ( simple_case_when_part )+
            {
                int cnt264=0;

                for (;;)
                {
                    ANTLR_UINT32 alt264=2;
            	switch ( this->LA(1) )
            	{
            	case SQL92_RESERVED_WHEN:
            		{
            			alt264=1;
            		}
            	    break;

            	}

            	switch (alt264)
            	{
            	    case 1:
            	        // OracleDML.g:1097:9: simple_case_when_part
            	        {
            	            this->followPush(FOLLOW_simple_case_when_part_in_simple_case_statement11281);
            	            simple_case_when_part802=simple_case_when_part();

            	            this->followPop();
            	            if  (this->hasException())
            	            {
            	                goto rulesimple_case_statementEx;
            	            }
            	            if (this->hasFailed())
            	            {
            	                return retval;
            	            }

            	            if ( this->get_backtracking()==0 ) 
            	            {
            	                simple_case_when_part802_last = simple_case_when_part802.tree.get();
            	                stream_simple_case_when_part.add(simple_case_when_part802.tree);
            	            }

            	        }
            	        break;

            	    default:

            		if ( cnt264 >= 1 )
            		{
            		    goto loop264;
            		}
            		if (this->get_backtracking()>0)
            		{
            		    this->set_failedflag( true );
            		    return retval;
            		}

            		/* mismatchedSetEx()
            		 */
            		new ANTLR_Exception< OracleDMLImplTraits, EARLY_EXIT_EXCEPTION, StreamType>( this->get_rec(), "" );


            		goto rulesimple_case_statementEx;
            	}
            	cnt264++;
                }
                loop264: ;	/* Jump to here if this rule does not match */
            }

            // OracleDML.g:1098:9: ( case_else_part )?
            {
                ANTLR_UINT32 alt265=2;
                switch ( this->LA(1) )
                {
                    case SQL92_RESERVED_ELSE:
                    	{
                    		alt265=1;
                    	}
                        break;
                }

                switch (alt265)
                {
            	case 1:
            	    // OracleDML.g:1098:9: case_else_part
            	    {
            	        this->followPush(FOLLOW_case_else_part_in_simple_case_statement11293);
            	        case_else_part803=case_else_part();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesimple_case_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            case_else_part803_last = case_else_part803.tree.get();
            	            stream_case_else_part.add(case_else_part803.tree);
            	        }

            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_end_key_in_simple_case_statement11304);
            end_key804=end_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesimple_case_statementEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                end_key804_last = end_key804.tree.get();
                stream_end_key.add(end_key804.tree);
            }

            // OracleDML.g:1099:17: ({...}? case_key ( label_name )? |)
            {
                ANTLR_UINT32 alt267=2;
                switch ( this->LA(1) )
                {
                case SQL92_RESERVED_CASE:
                	{
                		alt267=1;
                	}
                    break;
                case EOF_TOKEN:
                case ASTERISK:
                case CARRET_OPERATOR_PART:
                case CHAR_STRING:
                case CHAR_STRING_PERL:
                case COMMA:
                case CONCATENATION_OP:
                case DELIMITED_ID:
                case EQUALS_OP:
                case EXCLAMATION_OPERATOR_PART:
                case GREATER_THAN_OP:
                case GREATER_THAN_OR_EQUALS_OP:
                case INTRODUCER:
                case LEFT_BRACKET:
                case LEFT_PAREN:
                case LESS_THAN_OP:
                case LESS_THAN_OR_EQUALS_OP:
                case MINUS_SIGN:
                case NATIONAL_CHAR_STRING_LIT:
                case NOT_EQUAL_OP:
                case PLSQL_NON_RESERVED_MODEL:
                case PLSQL_NON_RESERVED_MULTISET:
                case PLSQL_NON_RESERVED_PIVOT:
                case PLSQL_NON_RESERVED_UNPIVOT:
                case PLSQL_NON_RESERVED_USING:
                case PLSQL_RESERVED_MINUS:
                case PLSQL_RESERVED_START:
                case PLUS_SIGN:
                case REGULAR_ID:
                case RIGHT_BRACKET:
                case RIGHT_PAREN:
                case SEMICOLON:
                case SOLIDUS:
                case SQL92_RESERVED_AND:
                case SQL92_RESERVED_AS:
                case SQL92_RESERVED_ASC:
                case SQL92_RESERVED_BETWEEN:
                case SQL92_RESERVED_CONNECT:
                case SQL92_RESERVED_DEFAULT:
                case SQL92_RESERVED_DELETE:
                case SQL92_RESERVED_DESC:
                case SQL92_RESERVED_ELSE:
                case SQL92_RESERVED_END:
                case SQL92_RESERVED_FETCH:
                case SQL92_RESERVED_FOR:
                case SQL92_RESERVED_FROM:
                case SQL92_RESERVED_GROUP:
                case SQL92_RESERVED_HAVING:
                case SQL92_RESERVED_IN:
                case SQL92_RESERVED_INTERSECT:
                case SQL92_RESERVED_INTO:
                case SQL92_RESERVED_IS:
                case SQL92_RESERVED_LIKE:
                case SQL92_RESERVED_NOT:
                case SQL92_RESERVED_ON:
                case SQL92_RESERVED_OR:
                case SQL92_RESERVED_ORDER:
                case SQL92_RESERVED_SELECT:
                case SQL92_RESERVED_THEN:
                case SQL92_RESERVED_TO:
                case SQL92_RESERVED_UNION:
                case SQL92_RESERVED_WHEN:
                case SQL92_RESERVED_WHERE:
                case SQL92_RESERVED_WITH:
                case SQL_ISO_RESERVED_OFFSET:
                case VERTICAL_BAR:
                	{
                		alt267=2;
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return retval;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 267 );
                    ex->set_state( 0 );


                    goto rulesimple_case_statementEx;

                }

                switch (alt267)
                {
            	case 1:
            	    // OracleDML.g:1099:18: {...}? case_key ( label_name )?
            	    {
            	        if ( !((!m_case_statement_stack.peek().isStatement)) )
            	        {
            	            if (this->get_backtracking()>0)
            	            {
            	                this->set_failedflag( true );
            	                return retval;
            	            }

            	            	ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "!$case_statement::isStatement" );
            	                ex->set_ruleName( "simple_case_statement" );


            	        }

            	        this->followPush(FOLLOW_case_key_in_simple_case_statement11309);
            	        case_key805=case_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesimple_case_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            case_key805_last = case_key805.tree.get();
            	            stream_case_key.add(case_key805.tree);
            	        }

            	        // OracleDML.g:1099:60: ( label_name )?
            	        {
            	            ANTLR_UINT32 alt266=2;
            	            switch ( this->LA(1) )
            	            {
            	                case REGULAR_ID:
            	                	{
            	                		alt266=1;
            	                	}
            	                    break;
            	                case DELIMITED_ID:
            	                	{
            	                		alt266=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt266)
            	            {
            	        	case 1:
            	        	    // OracleDML.g:1099:60: label_name
            	        	    {
            	        	        this->followPush(FOLLOW_label_name_in_simple_case_statement11311);
            	        	        label_name806=label_name();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulesimple_case_statementEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) 
            	        	        {
            	        	            label_name806_last = label_name806.tree.get();
            	        	            stream_label_name.add(label_name806.tree);
            	        	        }

            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;
            	case 2:
            	    // OracleDML.g:1099:74: 
            	    {
            	    }
            	    break;

                }
            }

            // AST REWRITE
            // elements: simple_case_when_part, label_name, end_key, atom, case_else_part
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1100:9: -> ^( SIMPLE_CASE[$ck1.start] ( label_name )* ^( EXPR atom ) ( simple_case_when_part )+ ( case_else_part )? end_key )
            {
            	// OracleDML.g:1100:12: ^( SIMPLE_CASE[$ck1.start] ( label_name )* ^( EXPR atom ) ( simple_case_when_part )+ ( case_else_part )? end_key )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(SIMPLE_CASE, (ck1.start)), root_1);
            	// OracleDML.g:1100:38: ( label_name )*
            	while ( stream_label_name.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_label_name.nextTree());
            	}
            	stream_label_name.reset();

            	// OracleDML.g:1100:50: ^( EXPR atom )
            	{
            	ImplTraits::TreeTypePtr root_2 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_2 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(EXPR, "EXPR"), root_2);
            	get_psrstate()->get_treeAdaptor()->addChild(root_2, stream_atom.nextTree());
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, root_2);
            	}
            	if ( !(stream_simple_case_when_part.hasNext()) ) {
            		ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, REWRITE_EARLY_EXCEPTION, StreamType>( this->get_rec(), "simple_case_when_part empty" );
            		goto rulesimple_case_statementEx;
            	}
            	while ( stream_simple_case_when_part.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_simple_case_when_part.nextTree());
            	}
            	stream_simple_case_when_part.reset();

            	// OracleDML.g:1100:86: ( case_else_part )?
            	if ( stream_case_else_part.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_case_else_part.nextTree());
            	}
            	stream_case_else_part.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_end_key.nextTree());
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulesimple_case_statementEx; /* Prevent compiler warnings */
    rulesimple_case_statementEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end simple_case_statement */

/**
 * $ANTLR start simple_case_when_part
 * OracleDML.g:1103:1: simple_case_when_part : when_key ^ew1= expression_wrapper then_key ! ({...}? seq_of_statements |ew2= expression_wrapper ) ;
 */
OracleDML::simple_case_when_part_return
OracleDML::simple_case_when_part()
{
    OracleDML::simple_case_when_part_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML::expression_wrapper_return ew1;
    ImplTraits::TreeTypePtr::pointer ew1_last = NULL;
    OracleDML::expression_wrapper_return ew2;
    ImplTraits::TreeTypePtr::pointer ew2_last = NULL;
    OracleDML_OracleDMLKeys::when_key_return when_key807;
    ImplTraits::TreeTypePtr::pointer when_key807_last = NULL;
    OracleDML_OracleDMLKeys::then_key_return then_key808;
    ImplTraits::TreeTypePtr::pointer then_key808_last = NULL;
    OracleDML::seq_of_statements_return seq_of_statements809;
    ImplTraits::TreeTypePtr::pointer seq_of_statements809_last = NULL;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:1104:5: ( when_key ^ew1= expression_wrapper then_key ! ({...}? seq_of_statements |ew2= expression_wrapper ) )
        // OracleDML.g:1104:10: when_key ^ew1= expression_wrapper then_key ! ({...}? seq_of_statements |ew2= expression_wrapper )
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            this->followPush(FOLLOW_when_key_in_simple_case_when_part11368);
            when_key807=when_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesimple_case_when_partEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(when_key807.tree, root_0);

            this->followPush(FOLLOW_expression_wrapper_in_simple_case_when_part11373);
            ew1=expression_wrapper();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesimple_case_when_partEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, ew1.tree);


            this->followPush(FOLLOW_then_key_in_simple_case_when_part11375);
            then_key808=then_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesimple_case_when_partEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }


            // OracleDML.g:1104:53: ({...}? seq_of_statements |ew2= expression_wrapper )
            {
                ANTLR_UINT32 alt268=2;
                switch ( this->LA(1) )
                {
                case PLSQL_RESERVED_LOCK:
                case SQL92_RESERVED_DELETE:
                case SQL92_RESERVED_INSERT:
                case SQL92_RESERVED_SELECT:
                case SQL92_RESERVED_UPDATE:
                case SQL92_RESERVED_WITH:
                	{
                		alt268=1;
                	}
                    break;
                case LEFT_PAREN:
                	{
                		{
                		    ANTLR_UINT32 LA268_3 = this->LA(2);
                		    if ( ((m_case_statement_stack.peek().isStatement)))
                		    {
                		        alt268=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt268=2;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return retval;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 268 );
                		        ex->set_state( 3 );


                		        goto rulesimple_case_when_partEx;

                		    }
                		}
                	}
                    break;
                case REGULAR_ID:
                	{
                		{
                		    ANTLR_UINT32 LA268_8 = this->LA(2);
                		    if ( (( ((((toUpper(LT(1)->getText()) == "EXPLAIN"))||((toUpper(LT(1)->getText()) == "MERGE")))) && ((m_case_statement_stack.peek().isStatement)) )))
                		    {
                		        alt268=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt268=2;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return retval;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 268 );
                		        ex->set_state( 8 );


                		        goto rulesimple_case_when_partEx;

                		    }
                		}
                	}
                    break;
                case APPROXIMATE_NUM_LIT:
                case BINDVAR:
                case CHAR_STRING:
                case CHAR_STRING_PERL:
                case COLON:
                case DELIMITED_ID:
                case EXACT_NUM_LIT:
                case INTRODUCER:
                case MINUS_SIGN:
                case NATIONAL_CHAR_STRING_LIT:
                case PLSQL_NON_RESERVED_CAST:
                case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
                case PLUS_SIGN:
                case SQL92_RESERVED_ALL:
                case SQL92_RESERVED_ANY:
                case SQL92_RESERVED_CASE:
                case SQL92_RESERVED_CURSOR:
                case SQL92_RESERVED_DATE:
                case SQL92_RESERVED_DEFAULT:
                case SQL92_RESERVED_DISTINCT:
                case SQL92_RESERVED_EXISTS:
                case SQL92_RESERVED_FALSE:
                case SQL92_RESERVED_NOT:
                case SQL92_RESERVED_NULL:
                case SQL92_RESERVED_PRIOR:
                case SQL92_RESERVED_TRUE:
                case UNSIGNED_INTEGER:
                	{
                		alt268=2;
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return retval;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 268 );
                    ex->set_state( 0 );


                    goto rulesimple_case_when_partEx;

                }

                switch (alt268)
                {
            	case 1:
            	    // OracleDML.g:1104:54: {...}? seq_of_statements
            	    {
            	        if ( !((m_case_statement_stack.peek().isStatement)) )
            	        {
            	            if (this->get_backtracking()>0)
            	            {
            	                this->set_failedflag( true );
            	                return retval;
            	            }

            	            	ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "$case_statement::isStatement" );
            	                ex->set_ruleName( "simple_case_when_part" );


            	        }

            	        this->followPush(FOLLOW_seq_of_statements_in_simple_case_when_part11381);
            	        seq_of_statements809=seq_of_statements();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesimple_case_when_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, seq_of_statements809.tree);


            	    }
            	    break;
            	case 2:
            	    // OracleDML.g:1104:106: ew2= expression_wrapper
            	    {
            	        this->followPush(FOLLOW_expression_wrapper_in_simple_case_when_part11387);
            	        ew2=expression_wrapper();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesimple_case_when_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, ew2.tree);


            	    }
            	    break;

                }
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulesimple_case_when_partEx; /* Prevent compiler warnings */
    rulesimple_case_when_partEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end simple_case_when_part */

/**
 * $ANTLR start searched_case_statement
 * OracleDML.g:1107:1: searched_case_statement : ({...}? ( label_name )? ) ck1= case_key ( searched_case_when_part )+ ( case_else_part )? end_key ({...}? case_key ( label_name )? |) -> ^( SEARCHED_CASE[$ck1.start] ( label_name )* ( searched_case_when_part )+ ( case_else_part )? end_key ) ;
 */
OracleDML::searched_case_statement_return
OracleDML::searched_case_statement()
{
    OracleDML::searched_case_statement_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML_OracleDMLKeys::case_key_return ck1;
    ImplTraits::TreeTypePtr::pointer ck1_last = NULL;
    OracleDML_OracleDMLCommons::label_name_return label_name810;
    ImplTraits::TreeTypePtr::pointer label_name810_last = NULL;
    OracleDML::searched_case_when_part_return searched_case_when_part811;
    ImplTraits::TreeTypePtr::pointer searched_case_when_part811_last = NULL;
    OracleDML::case_else_part_return case_else_part812;
    ImplTraits::TreeTypePtr::pointer case_else_part812_last = NULL;
    OracleDML_OracleDMLKeys::end_key_return end_key813;
    ImplTraits::TreeTypePtr::pointer end_key813_last = NULL;
    OracleDML_OracleDMLKeys::case_key_return case_key814;
    ImplTraits::TreeTypePtr::pointer case_key814_last = NULL;
    OracleDML_OracleDMLCommons::label_name_return label_name815;
    ImplTraits::TreeTypePtr::pointer label_name815_last = NULL;
    RewriteRuleSubtreeStream<ImplTraits> stream_searched_case_when_part(get_psrstate()->get_treeAdaptor(), "rule searched_case_when_part");
    RewriteRuleSubtreeStream<ImplTraits> stream_label_name(get_psrstate()->get_treeAdaptor(), "rule label_name");
    RewriteRuleSubtreeStream<ImplTraits> stream_case_else_part(get_psrstate()->get_treeAdaptor(), "rule case_else_part");
    RewriteRuleSubtreeStream<ImplTraits> stream_case_key(get_psrstate()->get_treeAdaptor(), "rule case_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_end_key(get_psrstate()->get_treeAdaptor(), "rule end_key");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:1108:5: ( ({...}? ( label_name )? ) ck1= case_key ( searched_case_when_part )+ ( case_else_part )? end_key ({...}? case_key ( label_name )? |) -> ^( SEARCHED_CASE[$ck1.start] ( label_name )* ( searched_case_when_part )+ ( case_else_part )? end_key ) )
        // OracleDML.g:1108:9: ({...}? ( label_name )? ) ck1= case_key ( searched_case_when_part )+ ( case_else_part )? end_key ({...}? case_key ( label_name )? |)
        {
            // OracleDML.g:1108:9: ({...}? ( label_name )? )
            // OracleDML.g:1108:10: {...}? ( label_name )?
            {
                if ( !((!m_case_statement_stack.peek().isStatement)) )
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return retval;
                    }

                    	ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "!$case_statement::isStatement" );
                        ex->set_ruleName( "searched_case_statement" );


                }

                // OracleDML.g:1108:43: ( label_name )?
                {
                    ANTLR_UINT32 alt269=2;
                    switch ( this->LA(1) )
                    {
                        case DELIMITED_ID:
                        case REGULAR_ID:
                        	{
                        		alt269=1;
                        	}
                            break;
                    }

                    switch (alt269)
                    {
                	case 1:
                	    // OracleDML.g:1108:43: label_name
                	    {
                	        this->followPush(FOLLOW_label_name_in_searched_case_statement11410);
                	        label_name810=label_name();

                	        this->followPop();
                	        if  (this->hasException())
                	        {
                	            goto rulesearched_case_statementEx;
                	        }
                	        if (this->hasFailed())
                	        {
                	            return retval;
                	        }

                	        if ( this->get_backtracking()==0 ) 
                	        {
                	            label_name810_last = label_name810.tree.get();
                	            stream_label_name.add(label_name810.tree);
                	        }

                	    }
                	    break;

                    }
                }

            }


            this->followPush(FOLLOW_case_key_in_searched_case_statement11416);
            ck1=case_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesearched_case_statementEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                ck1_last = ck1.tree.get();
                stream_case_key.add(ck1.tree);
            }

            // OracleDML.g:1109:9: ( searched_case_when_part )+
            {
                int cnt270=0;

                for (;;)
                {
                    ANTLR_UINT32 alt270=2;
            	switch ( this->LA(1) )
            	{
            	case SQL92_RESERVED_WHEN:
            		{
            			alt270=1;
            		}
            	    break;

            	}

            	switch (alt270)
            	{
            	    case 1:
            	        // OracleDML.g:1109:9: searched_case_when_part
            	        {
            	            this->followPush(FOLLOW_searched_case_when_part_in_searched_case_statement11426);
            	            searched_case_when_part811=searched_case_when_part();

            	            this->followPop();
            	            if  (this->hasException())
            	            {
            	                goto rulesearched_case_statementEx;
            	            }
            	            if (this->hasFailed())
            	            {
            	                return retval;
            	            }

            	            if ( this->get_backtracking()==0 ) 
            	            {
            	                searched_case_when_part811_last = searched_case_when_part811.tree.get();
            	                stream_searched_case_when_part.add(searched_case_when_part811.tree);
            	            }

            	        }
            	        break;

            	    default:

            		if ( cnt270 >= 1 )
            		{
            		    goto loop270;
            		}
            		if (this->get_backtracking()>0)
            		{
            		    this->set_failedflag( true );
            		    return retval;
            		}

            		/* mismatchedSetEx()
            		 */
            		new ANTLR_Exception< OracleDMLImplTraits, EARLY_EXIT_EXCEPTION, StreamType>( this->get_rec(), "" );


            		goto rulesearched_case_statementEx;
            	}
            	cnt270++;
                }
                loop270: ;	/* Jump to here if this rule does not match */
            }

            // OracleDML.g:1110:9: ( case_else_part )?
            {
                ANTLR_UINT32 alt271=2;
                switch ( this->LA(1) )
                {
                    case SQL92_RESERVED_ELSE:
                    	{
                    		alt271=1;
                    	}
                        break;
                }

                switch (alt271)
                {
            	case 1:
            	    // OracleDML.g:1110:9: case_else_part
            	    {
            	        this->followPush(FOLLOW_case_else_part_in_searched_case_statement11437);
            	        case_else_part812=case_else_part();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesearched_case_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            case_else_part812_last = case_else_part812.tree.get();
            	            stream_case_else_part.add(case_else_part812.tree);
            	        }

            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_end_key_in_searched_case_statement11448);
            end_key813=end_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesearched_case_statementEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                end_key813_last = end_key813.tree.get();
                stream_end_key.add(end_key813.tree);
            }

            // OracleDML.g:1111:17: ({...}? case_key ( label_name )? |)
            {
                ANTLR_UINT32 alt273=2;
                switch ( this->LA(1) )
                {
                case SQL92_RESERVED_CASE:
                	{
                		alt273=1;
                	}
                    break;
                case EOF_TOKEN:
                case ASTERISK:
                case CARRET_OPERATOR_PART:
                case CHAR_STRING:
                case CHAR_STRING_PERL:
                case COMMA:
                case CONCATENATION_OP:
                case DELIMITED_ID:
                case EQUALS_OP:
                case EXCLAMATION_OPERATOR_PART:
                case GREATER_THAN_OP:
                case GREATER_THAN_OR_EQUALS_OP:
                case INTRODUCER:
                case LEFT_BRACKET:
                case LEFT_PAREN:
                case LESS_THAN_OP:
                case LESS_THAN_OR_EQUALS_OP:
                case MINUS_SIGN:
                case NATIONAL_CHAR_STRING_LIT:
                case NOT_EQUAL_OP:
                case PLSQL_NON_RESERVED_MODEL:
                case PLSQL_NON_RESERVED_MULTISET:
                case PLSQL_NON_RESERVED_PIVOT:
                case PLSQL_NON_RESERVED_UNPIVOT:
                case PLSQL_NON_RESERVED_USING:
                case PLSQL_RESERVED_MINUS:
                case PLSQL_RESERVED_START:
                case PLUS_SIGN:
                case REGULAR_ID:
                case RIGHT_BRACKET:
                case RIGHT_PAREN:
                case SEMICOLON:
                case SOLIDUS:
                case SQL92_RESERVED_AND:
                case SQL92_RESERVED_AS:
                case SQL92_RESERVED_ASC:
                case SQL92_RESERVED_BETWEEN:
                case SQL92_RESERVED_CONNECT:
                case SQL92_RESERVED_DEFAULT:
                case SQL92_RESERVED_DELETE:
                case SQL92_RESERVED_DESC:
                case SQL92_RESERVED_ELSE:
                case SQL92_RESERVED_END:
                case SQL92_RESERVED_FETCH:
                case SQL92_RESERVED_FOR:
                case SQL92_RESERVED_FROM:
                case SQL92_RESERVED_GROUP:
                case SQL92_RESERVED_HAVING:
                case SQL92_RESERVED_IN:
                case SQL92_RESERVED_INTERSECT:
                case SQL92_RESERVED_INTO:
                case SQL92_RESERVED_IS:
                case SQL92_RESERVED_LIKE:
                case SQL92_RESERVED_NOT:
                case SQL92_RESERVED_ON:
                case SQL92_RESERVED_OR:
                case SQL92_RESERVED_ORDER:
                case SQL92_RESERVED_SELECT:
                case SQL92_RESERVED_THEN:
                case SQL92_RESERVED_TO:
                case SQL92_RESERVED_UNION:
                case SQL92_RESERVED_WHEN:
                case SQL92_RESERVED_WHERE:
                case SQL92_RESERVED_WITH:
                case SQL_ISO_RESERVED_OFFSET:
                case VERTICAL_BAR:
                	{
                		alt273=2;
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return retval;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 273 );
                    ex->set_state( 0 );


                    goto rulesearched_case_statementEx;

                }

                switch (alt273)
                {
            	case 1:
            	    // OracleDML.g:1111:18: {...}? case_key ( label_name )?
            	    {
            	        if ( !((!m_case_statement_stack.peek().isStatement)) )
            	        {
            	            if (this->get_backtracking()>0)
            	            {
            	                this->set_failedflag( true );
            	                return retval;
            	            }

            	            	ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "!$case_statement::isStatement" );
            	                ex->set_ruleName( "searched_case_statement" );


            	        }

            	        this->followPush(FOLLOW_case_key_in_searched_case_statement11453);
            	        case_key814=case_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesearched_case_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            case_key814_last = case_key814.tree.get();
            	            stream_case_key.add(case_key814.tree);
            	        }

            	        // OracleDML.g:1111:60: ( label_name )?
            	        {
            	            ANTLR_UINT32 alt272=2;
            	            switch ( this->LA(1) )
            	            {
            	                case REGULAR_ID:
            	                	{
            	                		alt272=1;
            	                	}
            	                    break;
            	                case DELIMITED_ID:
            	                	{
            	                		alt272=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt272)
            	            {
            	        	case 1:
            	        	    // OracleDML.g:1111:60: label_name
            	        	    {
            	        	        this->followPush(FOLLOW_label_name_in_searched_case_statement11455);
            	        	        label_name815=label_name();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulesearched_case_statementEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) 
            	        	        {
            	        	            label_name815_last = label_name815.tree.get();
            	        	            stream_label_name.add(label_name815.tree);
            	        	        }

            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;
            	case 2:
            	    // OracleDML.g:1111:74: 
            	    {
            	    }
            	    break;

                }
            }

            // AST REWRITE
            // elements: end_key, case_else_part, label_name, searched_case_when_part
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1112:9: -> ^( SEARCHED_CASE[$ck1.start] ( label_name )* ( searched_case_when_part )+ ( case_else_part )? end_key )
            {
            	// OracleDML.g:1112:12: ^( SEARCHED_CASE[$ck1.start] ( label_name )* ( searched_case_when_part )+ ( case_else_part )? end_key )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(SEARCHED_CASE, (ck1.start)), root_1);
            	// OracleDML.g:1112:40: ( label_name )*
            	while ( stream_label_name.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_label_name.nextTree());
            	}
            	stream_label_name.reset();

            	if ( !(stream_searched_case_when_part.hasNext()) ) {
            		ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, REWRITE_EARLY_EXCEPTION, StreamType>( this->get_rec(), "searched_case_when_part empty" );
            		goto rulesearched_case_statementEx;
            	}
            	while ( stream_searched_case_when_part.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_searched_case_when_part.nextTree());
            	}
            	stream_searched_case_when_part.reset();

            	// OracleDML.g:1112:77: ( case_else_part )?
            	if ( stream_case_else_part.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_case_else_part.nextTree());
            	}
            	stream_case_else_part.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_end_key.nextTree());
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulesearched_case_statementEx; /* Prevent compiler warnings */
    rulesearched_case_statementEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end searched_case_statement */

/**
 * $ANTLR start searched_case_when_part
 * OracleDML.g:1115:1: searched_case_when_part : when_key ^ condition_wrapper then_key ! ({...}? seq_of_statements | expression_wrapper ) ;
 */
OracleDML::searched_case_when_part_return
OracleDML::searched_case_when_part()
{
    OracleDML::searched_case_when_part_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML_OracleDMLKeys::when_key_return when_key816;
    ImplTraits::TreeTypePtr::pointer when_key816_last = NULL;
    OracleDML::condition_wrapper_return condition_wrapper817;
    ImplTraits::TreeTypePtr::pointer condition_wrapper817_last = NULL;
    OracleDML_OracleDMLKeys::then_key_return then_key818;
    ImplTraits::TreeTypePtr::pointer then_key818_last = NULL;
    OracleDML::seq_of_statements_return seq_of_statements819;
    ImplTraits::TreeTypePtr::pointer seq_of_statements819_last = NULL;
    OracleDML::expression_wrapper_return expression_wrapper820;
    ImplTraits::TreeTypePtr::pointer expression_wrapper820_last = NULL;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:1116:5: ( when_key ^ condition_wrapper then_key ! ({...}? seq_of_statements | expression_wrapper ) )
        // OracleDML.g:1116:10: when_key ^ condition_wrapper then_key ! ({...}? seq_of_statements | expression_wrapper )
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            this->followPush(FOLLOW_when_key_in_searched_case_when_part11506);
            when_key816=when_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesearched_case_when_partEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(when_key816.tree, root_0);

            this->followPush(FOLLOW_condition_wrapper_in_searched_case_when_part11509);
            condition_wrapper817=condition_wrapper();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesearched_case_when_partEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, condition_wrapper817.tree);


            this->followPush(FOLLOW_then_key_in_searched_case_when_part11511);
            then_key818=then_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesearched_case_when_partEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }


            // OracleDML.g:1116:48: ({...}? seq_of_statements | expression_wrapper )
            {
                ANTLR_UINT32 alt274=2;
                switch ( this->LA(1) )
                {
                case PLSQL_RESERVED_LOCK:
                case SQL92_RESERVED_DELETE:
                case SQL92_RESERVED_INSERT:
                case SQL92_RESERVED_SELECT:
                case SQL92_RESERVED_UPDATE:
                case SQL92_RESERVED_WITH:
                	{
                		alt274=1;
                	}
                    break;
                case LEFT_PAREN:
                	{
                		{
                		    ANTLR_UINT32 LA274_3 = this->LA(2);
                		    if ( ((m_case_statement_stack.peek().isStatement)))
                		    {
                		        alt274=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt274=2;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return retval;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 274 );
                		        ex->set_state( 3 );


                		        goto rulesearched_case_when_partEx;

                		    }
                		}
                	}
                    break;
                case REGULAR_ID:
                	{
                		{
                		    ANTLR_UINT32 LA274_8 = this->LA(2);
                		    if ( (( ((((toUpper(LT(1)->getText()) == "EXPLAIN"))||((toUpper(LT(1)->getText()) == "MERGE")))) && ((m_case_statement_stack.peek().isStatement)) )))
                		    {
                		        alt274=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt274=2;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return retval;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 274 );
                		        ex->set_state( 8 );


                		        goto rulesearched_case_when_partEx;

                		    }
                		}
                	}
                    break;
                case APPROXIMATE_NUM_LIT:
                case BINDVAR:
                case CHAR_STRING:
                case CHAR_STRING_PERL:
                case COLON:
                case DELIMITED_ID:
                case EXACT_NUM_LIT:
                case INTRODUCER:
                case MINUS_SIGN:
                case NATIONAL_CHAR_STRING_LIT:
                case PLSQL_NON_RESERVED_CAST:
                case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
                case PLUS_SIGN:
                case SQL92_RESERVED_ALL:
                case SQL92_RESERVED_ANY:
                case SQL92_RESERVED_CASE:
                case SQL92_RESERVED_CURSOR:
                case SQL92_RESERVED_DATE:
                case SQL92_RESERVED_DEFAULT:
                case SQL92_RESERVED_DISTINCT:
                case SQL92_RESERVED_EXISTS:
                case SQL92_RESERVED_FALSE:
                case SQL92_RESERVED_NOT:
                case SQL92_RESERVED_NULL:
                case SQL92_RESERVED_PRIOR:
                case SQL92_RESERVED_TRUE:
                case UNSIGNED_INTEGER:
                	{
                		alt274=2;
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return retval;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 274 );
                    ex->set_state( 0 );


                    goto rulesearched_case_when_partEx;

                }

                switch (alt274)
                {
            	case 1:
            	    // OracleDML.g:1116:49: {...}? seq_of_statements
            	    {
            	        if ( !((m_case_statement_stack.peek().isStatement)) )
            	        {
            	            if (this->get_backtracking()>0)
            	            {
            	                this->set_failedflag( true );
            	                return retval;
            	            }

            	            	ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "$case_statement::isStatement" );
            	                ex->set_ruleName( "searched_case_when_part" );


            	        }

            	        this->followPush(FOLLOW_seq_of_statements_in_searched_case_when_part11517);
            	        seq_of_statements819=seq_of_statements();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesearched_case_when_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, seq_of_statements819.tree);


            	    }
            	    break;
            	case 2:
            	    // OracleDML.g:1116:101: expression_wrapper
            	    {
            	        this->followPush(FOLLOW_expression_wrapper_in_searched_case_when_part11521);
            	        expression_wrapper820=expression_wrapper();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesearched_case_when_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, expression_wrapper820.tree);


            	    }
            	    break;

                }
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulesearched_case_when_partEx; /* Prevent compiler warnings */
    rulesearched_case_when_partEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end searched_case_when_part */

/**
 * $ANTLR start case_else_part
 * OracleDML.g:1119:1: case_else_part : else_key ^ ({...}? seq_of_statements | expression_wrapper ) ;
 */
OracleDML::case_else_part_return
OracleDML::case_else_part()
{
    OracleDML::case_else_part_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML_OracleDMLKeys::else_key_return else_key821;
    ImplTraits::TreeTypePtr::pointer else_key821_last = NULL;
    OracleDML::seq_of_statements_return seq_of_statements822;
    ImplTraits::TreeTypePtr::pointer seq_of_statements822_last = NULL;
    OracleDML::expression_wrapper_return expression_wrapper823;
    ImplTraits::TreeTypePtr::pointer expression_wrapper823_last = NULL;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:1120:5: ( else_key ^ ({...}? seq_of_statements | expression_wrapper ) )
        // OracleDML.g:1120:10: else_key ^ ({...}? seq_of_statements | expression_wrapper )
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            this->followPush(FOLLOW_else_key_in_case_else_part11542);
            else_key821=else_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecase_else_partEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(else_key821.tree, root_0);

            // OracleDML.g:1120:20: ({...}? seq_of_statements | expression_wrapper )
            {
                ANTLR_UINT32 alt275=2;
                switch ( this->LA(1) )
                {
                case PLSQL_RESERVED_LOCK:
                case SQL92_RESERVED_DELETE:
                case SQL92_RESERVED_INSERT:
                case SQL92_RESERVED_SELECT:
                case SQL92_RESERVED_UPDATE:
                case SQL92_RESERVED_WITH:
                	{
                		alt275=1;
                	}
                    break;
                case LEFT_PAREN:
                	{
                		{
                		    ANTLR_UINT32 LA275_3 = this->LA(2);
                		    if ( ((m_case_statement_stack.peek().isStatement)))
                		    {
                		        alt275=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt275=2;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return retval;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 275 );
                		        ex->set_state( 3 );


                		        goto rulecase_else_partEx;

                		    }
                		}
                	}
                    break;
                case REGULAR_ID:
                	{
                		{
                		    ANTLR_UINT32 LA275_8 = this->LA(2);
                		    if ( (( ((((toUpper(LT(1)->getText()) == "EXPLAIN"))||((toUpper(LT(1)->getText()) == "MERGE")))) && ((m_case_statement_stack.peek().isStatement)) )))
                		    {
                		        alt275=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt275=2;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return retval;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 275 );
                		        ex->set_state( 8 );


                		        goto rulecase_else_partEx;

                		    }
                		}
                	}
                    break;
                case APPROXIMATE_NUM_LIT:
                case BINDVAR:
                case CHAR_STRING:
                case CHAR_STRING_PERL:
                case COLON:
                case DELIMITED_ID:
                case EXACT_NUM_LIT:
                case INTRODUCER:
                case MINUS_SIGN:
                case NATIONAL_CHAR_STRING_LIT:
                case PLSQL_NON_RESERVED_CAST:
                case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
                case PLUS_SIGN:
                case SQL92_RESERVED_ALL:
                case SQL92_RESERVED_ANY:
                case SQL92_RESERVED_CASE:
                case SQL92_RESERVED_CURSOR:
                case SQL92_RESERVED_DATE:
                case SQL92_RESERVED_DEFAULT:
                case SQL92_RESERVED_DISTINCT:
                case SQL92_RESERVED_EXISTS:
                case SQL92_RESERVED_FALSE:
                case SQL92_RESERVED_NOT:
                case SQL92_RESERVED_NULL:
                case SQL92_RESERVED_PRIOR:
                case SQL92_RESERVED_TRUE:
                case UNSIGNED_INTEGER:
                	{
                		alt275=2;
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return retval;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 275 );
                    ex->set_state( 0 );


                    goto rulecase_else_partEx;

                }

                switch (alt275)
                {
            	case 1:
            	    // OracleDML.g:1120:21: {...}? seq_of_statements
            	    {
            	        if ( !((m_case_statement_stack.peek().isStatement)) )
            	        {
            	            if (this->get_backtracking()>0)
            	            {
            	                this->set_failedflag( true );
            	                return retval;
            	            }

            	            	ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "$case_statement::isStatement" );
            	                ex->set_ruleName( "case_else_part" );


            	        }

            	        this->followPush(FOLLOW_seq_of_statements_in_case_else_part11548);
            	        seq_of_statements822=seq_of_statements();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecase_else_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, seq_of_statements822.tree);


            	    }
            	    break;
            	case 2:
            	    // OracleDML.g:1120:73: expression_wrapper
            	    {
            	        this->followPush(FOLLOW_expression_wrapper_in_case_else_part11552);
            	        expression_wrapper823=expression_wrapper();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecase_else_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, expression_wrapper823.tree);


            	    }
            	    break;

                }
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulecase_else_partEx; /* Prevent compiler warnings */
    rulecase_else_partEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end case_else_part */

/**
 * $ANTLR start atom
 * OracleDML.g:1124:1: atom options {backtrack=true; } : ( ( table_element outer_join_sign )=> table_element outer_join_sign | bind_variable | constant | general_element | LEFT_PAREN ( ( select_key | with_key )=> subquery RIGHT_PAREN ( subquery_operation_part )* | expression_or_vector RIGHT_PAREN ) -> { mode == 1 }? ^( NESTED_SUBQUERY LEFT_PAREN subquery RIGHT_PAREN ( subquery_operation_part )* ) -> ^( NESTED_EXPR LEFT_PAREN expression_or_vector RIGHT_PAREN ) );
 */
OracleDML::atom_return
OracleDML::atom()
{
    OracleDML::atom_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* LEFT_PAREN829 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN831 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN834 = NULL;
    OracleDML_OracleDMLCommons::table_element_return table_element824;
    ImplTraits::TreeTypePtr::pointer table_element824_last = NULL;
    OracleDML_OracleDMLCommons::outer_join_sign_return outer_join_sign825;
    ImplTraits::TreeTypePtr::pointer outer_join_sign825_last = NULL;
    OracleDML_OracleDMLCommons::bind_variable_return bind_variable826;
    ImplTraits::TreeTypePtr::pointer bind_variable826_last = NULL;
    OracleDML_OracleDMLCommons::constant_return constant827;
    ImplTraits::TreeTypePtr::pointer constant827_last = NULL;
    OracleDML_OracleDMLCommons::general_element_return general_element828;
    ImplTraits::TreeTypePtr::pointer general_element828_last = NULL;
    OracleDML::subquery_return subquery830;
    ImplTraits::TreeTypePtr::pointer subquery830_last = NULL;
    OracleDML::subquery_operation_part_return subquery_operation_part832;
    ImplTraits::TreeTypePtr::pointer subquery_operation_part832_last = NULL;
    OracleDML::expression_or_vector_return expression_or_vector833;
    ImplTraits::TreeTypePtr::pointer expression_or_vector833_last = NULL;
    ImplTraits::TreeTypePtr LEFT_PAREN829_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN831_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN834_tree;
    RewriteRuleTokenStream<ImplTraits> stream_LEFT_PAREN(get_psrstate()->get_treeAdaptor(), "token LEFT_PAREN");
    RewriteRuleTokenStream<ImplTraits> stream_RIGHT_PAREN(get_psrstate()->get_treeAdaptor(), "token RIGHT_PAREN");
    RewriteRuleSubtreeStream<ImplTraits> stream_subquery_operation_part(get_psrstate()->get_treeAdaptor(), "rule subquery_operation_part");
    RewriteRuleSubtreeStream<ImplTraits> stream_expression_or_vector(get_psrstate()->get_treeAdaptor(), "rule expression_or_vector");
    RewriteRuleSubtreeStream<ImplTraits> stream_subquery(get_psrstate()->get_treeAdaptor(), "rule subquery");

    /* Initialize rule variables
     */

        int mode = 0;    
    retval.call_start_placeholder(this);


 
    {
        {
            //  OracleDML.g:1130:5: ( ( table_element outer_join_sign )=> table_element outer_join_sign | bind_variable | constant | general_element | LEFT_PAREN ( ( select_key | with_key )=> subquery RIGHT_PAREN ( subquery_operation_part )* | expression_or_vector RIGHT_PAREN ) -> { mode == 1 }? ^( NESTED_SUBQUERY LEFT_PAREN subquery RIGHT_PAREN ( subquery_operation_part )* ) -> ^( NESTED_EXPR LEFT_PAREN expression_or_vector RIGHT_PAREN ) )

            ANTLR_UINT32 alt278;

            alt278=5;

            alt278 = cdfa278.predict(this, this->get_rec(), this->get_istream(), cdfa278 );
            if  (this->hasException())
            {
                goto ruleatomEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            switch (alt278)
            {
        	case 1:
        	    // OracleDML.g:1130:10: ( table_element outer_join_sign )=> table_element outer_join_sign
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_table_element_in_atom11599);
        	        table_element824=table_element();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleatomEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, table_element824.tree);


        	        this->followPush(FOLLOW_outer_join_sign_in_atom11601);
        	        outer_join_sign825=outer_join_sign();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleatomEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, outer_join_sign825.tree);


        	    }
        	    break;
        	case 2:
        	    // OracleDML.g:1131:10: bind_variable
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_bind_variable_in_atom11612);
        	        bind_variable826=bind_variable();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleatomEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, bind_variable826.tree);


        	    }
        	    break;
        	case 3:
        	    // OracleDML.g:1132:10: constant
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_constant_in_atom11623);
        	        constant827=constant();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleatomEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, constant827.tree);


        	    }
        	    break;
        	case 4:
        	    // OracleDML.g:1133:10: general_element
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_general_element_in_atom11634);
        	        general_element828=general_element();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleatomEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, general_element828.tree);


        	    }
        	    break;
        	case 5:
        	    // OracleDML.g:1134:10: LEFT_PAREN ( ( select_key | with_key )=> subquery RIGHT_PAREN ( subquery_operation_part )* | expression_or_vector RIGHT_PAREN )
        	    {
        	        LEFT_PAREN829 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_atom11645);
        	        if  (this->hasException())
        	        {
        	            goto ruleatomEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }
        	         
        	        if ( this->get_backtracking()==0 ) stream_LEFT_PAREN.add(LEFT_PAREN829);


        	        // OracleDML.g:1135:10: ( ( select_key | with_key )=> subquery RIGHT_PAREN ( subquery_operation_part )* | expression_or_vector RIGHT_PAREN )
        	        {
        	            ANTLR_UINT32 alt277=2;
        	            {
        	                ANTLR_UINT32 LA277_0 = this->LA(1);
        	                if ( (LA277_0 == SQL92_RESERVED_SELECT) && (this->msynpred( antlr3::ClassForwarder<synpred50_OracleDML>() )))
        	                {
        	                    alt277=1;
        	                }
        	                else if ( (LA277_0 == LEFT_PAREN))
        	                {
        	                    {
        	                        ANTLR_UINT32 LA277_2 = this->LA(2);
        	                        if ( (this->msynpred( antlr3::ClassForwarder<synpred50_OracleDML>() )))
        	                        {
        	                            alt277=1;
        	                        }
        	                        else if ( (true))
        	                        {
        	                            alt277=2;
        	                        }
        	                        else
        	                        {
        	                            if (this->get_backtracking()>0)
        	                            {
        	                                this->set_failedflag( true );
        	                                return retval;
        	                            }


        	                            ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                            ex->set_decisionNum( 277 );
        	                            ex->set_state( 2 );


        	                            goto ruleatomEx;

        	                        }
        	                    }
        	                }
        	                else if ( (LA277_0 == APPROXIMATE_NUM_LIT || LA277_0 == BINDVAR || ((LA277_0 >= CHAR_STRING) && (LA277_0 <= CHAR_STRING_PERL)) || LA277_0 == COLON || LA277_0 == DELIMITED_ID || LA277_0 == EXACT_NUM_LIT || LA277_0 == INTRODUCER || LA277_0 == MINUS_SIGN || LA277_0 == NATIONAL_CHAR_STRING_LIT || ((LA277_0 >= PLSQL_NON_RESERVED_CAST) && (LA277_0 <= PLSQL_NON_RESERVED_CONNECT_BY_ROOT)) || LA277_0 == PLUS_SIGN || LA277_0 == REGULAR_ID || LA277_0 == SQL92_RESERVED_ALL || LA277_0 == SQL92_RESERVED_ANY || LA277_0 == SQL92_RESERVED_CASE || ((LA277_0 >= SQL92_RESERVED_CURSOR) && (LA277_0 <= SQL92_RESERVED_DATE)) || LA277_0 == SQL92_RESERVED_DEFAULT || LA277_0 == SQL92_RESERVED_DISTINCT || ((LA277_0 >= SQL92_RESERVED_EXISTS) && (LA277_0 <= SQL92_RESERVED_FALSE)) || ((LA277_0 >= SQL92_RESERVED_NOT) && (LA277_0 <= SQL92_RESERVED_NULL)) || LA277_0 == SQL92_RESERVED_PRIOR || LA277_0 == SQL92_RESERVED_TRUE || LA277_0 == UNSIGNED_INTEGER))
        	                {
        	                    alt277=2;
        	                }
        	                else
        	                {
        	                    if (this->get_backtracking()>0)
        	                    {
        	                        this->set_failedflag( true );
        	                        return retval;
        	                    }


        	                    ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                    ex->set_decisionNum( 277 );
        	                    ex->set_state( 0 );


        	                    goto ruleatomEx;

        	                }
        	            }
        	            switch (alt277)
        	            {
        	        	case 1:
        	        	    // OracleDML.g:1136:15: ( select_key | with_key )=> subquery RIGHT_PAREN ( subquery_operation_part )*
        	        	    {
        	        	        this->followPush(FOLLOW_subquery_in_atom11682);
        	        	        subquery830=subquery();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleatomEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) 
        	        	        {
        	        	            subquery830_last = subquery830.tree.get();
        	        	            stream_subquery.add(subquery830.tree);
        	        	        }

        	        	        RIGHT_PAREN831 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_atom11684);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleatomEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }
        	        	         
        	        	        if ( this->get_backtracking()==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN831);


        	        	        // OracleDML.g:1136:63: ( subquery_operation_part )*

        	        	        for (;;)
        	        	        {
        	        	            ANTLR_UINT32 alt276=2;
        	        	            switch ( this->LA(1) )
        	        	            {
        	        	            case SQL92_RESERVED_UNION:
        	        	            	{
        	        	            		alt276=1;
        	        	            	}
        	        	                break;
        	        	            case SQL92_RESERVED_INTERSECT:
        	        	            	{
        	        	            		alt276=1;
        	        	            	}
        	        	                break;
        	        	            case PLSQL_RESERVED_MINUS:
        	        	            	{
        	        	            		alt276=1;
        	        	            	}
        	        	                break;

        	        	            }

        	        	            switch (alt276)
        	        	            {
        	        	        	case 1:
        	        	        	    // OracleDML.g:1136:63: subquery_operation_part
        	        	        	    {
        	        	        	        this->followPush(FOLLOW_subquery_operation_part_in_atom11686);
        	        	        	        subquery_operation_part832=subquery_operation_part();

        	        	        	        this->followPop();
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto ruleatomEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return retval;
        	        	        	        }

        	        	        	        if ( this->get_backtracking()==0 ) 
        	        	        	        {
        	        	        	            subquery_operation_part832_last = subquery_operation_part832.tree.get();
        	        	        	            stream_subquery_operation_part.add(subquery_operation_part832.tree);
        	        	        	        }

        	        	        	    }
        	        	        	    break;

        	        	        	default:
        	        	        	    goto loop276;	/* break out of the loop */
        	        	        	    break;
        	        	            }
        	        	        }
        	        	        loop276: ; /* Jump out to here if this rule does not match */


        	        	        if ( this->get_backtracking()==0 )
        	        	        {
        	        	             mode = 1; 
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // OracleDML.g:1137:17: expression_or_vector RIGHT_PAREN
        	        	    {
        	        	        this->followPush(FOLLOW_expression_or_vector_in_atom11707);
        	        	        expression_or_vector833=expression_or_vector();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleatomEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) 
        	        	        {
        	        	            expression_or_vector833_last = expression_or_vector833.tree.get();
        	        	            stream_expression_or_vector.add(expression_or_vector833.tree);
        	        	        }

        	        	        RIGHT_PAREN834 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_atom11709);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleatomEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }
        	        	         
        	        	        if ( this->get_backtracking()==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN834);


        	        	    }
        	        	    break;

        	            }
        	        }

        	        // AST REWRITE
        	        // elements: subquery_operation_part, expression_or_vector, RIGHT_PAREN, RIGHT_PAREN, LEFT_PAREN, subquery, LEFT_PAREN
        	        // token labels: 
        	        // rule labels: retval
        	        // token list labels: 
        	        // rule list labels: 
        	        // wildcard labels: 
        	        if ( this->get_backtracking()==0 ) {
        	        retval.tree = std::move(root_0);
        	        RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
        	        // 1139:10: -> { mode == 1 }? ^( NESTED_SUBQUERY LEFT_PAREN subquery RIGHT_PAREN ( subquery_operation_part )* )
        	        if ( mode == 1 ) {
        	        	// OracleDML.g:1139:28: ^( NESTED_SUBQUERY LEFT_PAREN subquery RIGHT_PAREN ( subquery_operation_part )* )
        	        	{
        	        	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
        	        	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(NESTED_SUBQUERY, "NESTED_SUBQUERY"), root_1);
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_LEFT_PAREN.nextNode());
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_subquery.nextTree());
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_RIGHT_PAREN.nextNode());
        	        	// OracleDML.g:1139:78: ( subquery_operation_part )*
        	        	while ( stream_subquery_operation_part.hasNext() ) {
        	        		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_subquery_operation_part.nextTree());
        	        	}
        	        	stream_subquery_operation_part.reset();

        	        	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
        	        	}
        	        }

        	        else // 1140:10: -> ^( NESTED_EXPR LEFT_PAREN expression_or_vector RIGHT_PAREN )
        	        {
        	        	// OracleDML.g:1140:28: ^( NESTED_EXPR LEFT_PAREN expression_or_vector RIGHT_PAREN )
        	        	{
        	        	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
        	        	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(NESTED_EXPR, "NESTED_EXPR"), root_1);
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_LEFT_PAREN.nextNode());
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_expression_or_vector.nextTree());
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_RIGHT_PAREN.nextNode());
        	        	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
        	        	}
        	        }


        	        //retval.tree = std::move(root_0);
        	        }

        	    }
        	    break;

            }
        }
    }//...
    // This is where rules clean up and exit
    //
    goto ruleatomEx; /* Prevent compiler warnings */
    ruleatomEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end atom */

/**
 * $ANTLR start expression_or_vector
 * OracleDML.g:1143:1: expression_or_vector : expression ( vector_expr )? -> {mode == 1}? ^( VECTOR_EXPR ^( EXPR expression ) vector_expr ) -> expression ;
 */
OracleDML::expression_or_vector_return
OracleDML::expression_or_vector()
{
    OracleDML::expression_or_vector_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML::expression_return expression835;
    ImplTraits::TreeTypePtr::pointer expression835_last = NULL;
    OracleDML::vector_expr_return vector_expr836;
    ImplTraits::TreeTypePtr::pointer vector_expr836_last = NULL;
    RewriteRuleSubtreeStream<ImplTraits> stream_expression(get_psrstate()->get_treeAdaptor(), "rule expression");
    RewriteRuleSubtreeStream<ImplTraits> stream_vector_expr(get_psrstate()->get_treeAdaptor(), "rule vector_expr");

    /* Initialize rule variables
     */

        int mode = 0;    
    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:1145:5: ( expression ( vector_expr )? -> {mode == 1}? ^( VECTOR_EXPR ^( EXPR expression ) vector_expr ) -> expression )
        // OracleDML.g:1145:10: expression ( vector_expr )?
        {
            this->followPush(FOLLOW_expression_in_expression_or_vector11810);
            expression835=expression();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleexpression_or_vectorEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                expression835_last = expression835.tree.get();
                stream_expression.add(expression835.tree);
            }

            // OracleDML.g:1145:21: ( vector_expr )?
            {
                ANTLR_UINT32 alt279=2;
                switch ( this->LA(1) )
                {
                    case COMMA:
                    	{
                    		alt279=1;
                    	}
                        break;
                }

                switch (alt279)
                {
            	case 1:
            	    // OracleDML.g:1145:22: vector_expr
            	    {
            	        this->followPush(FOLLOW_vector_expr_in_expression_or_vector11813);
            	        vector_expr836=vector_expr();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleexpression_or_vectorEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            vector_expr836_last = vector_expr836.tree.get();
            	            stream_vector_expr.add(vector_expr836.tree);
            	        }

            	        if ( this->get_backtracking()==0 )
            	        {
            	            mode = 1;
            	        }


            	    }
            	    break;

                }
            }

            // AST REWRITE
            // elements: expression, vector_expr, expression
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1146:9: -> {mode == 1}? ^( VECTOR_EXPR ^( EXPR expression ) vector_expr )
            if (mode == 1) {
            	// OracleDML.g:1146:25: ^( VECTOR_EXPR ^( EXPR expression ) vector_expr )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(VECTOR_EXPR, "VECTOR_EXPR"), root_1);
            	// OracleDML.g:1146:39: ^( EXPR expression )
            	{
            	ImplTraits::TreeTypePtr root_2 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_2 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(EXPR, "EXPR"), root_2);
            	get_psrstate()->get_treeAdaptor()->addChild(root_2, stream_expression.nextTree());
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, root_2);
            	}
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_vector_expr.nextTree());
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }

            else // 1147:9: -> expression
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, stream_expression.nextTree());
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleexpression_or_vectorEx; /* Prevent compiler warnings */
    ruleexpression_or_vectorEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end expression_or_vector */

/**
 * $ANTLR start vector_expr
 * OracleDML.g:1150:1: vector_expr : COMMA expression ( COMMA expression )* -> ( ^( EXPR expression ) )+ ;
 */
OracleDML::vector_expr_return
OracleDML::vector_expr()
{
    OracleDML::vector_expr_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* COMMA837 = NULL;
    ImplTraits::CommonTokenType const* COMMA839 = NULL;
    OracleDML::expression_return expression838;
    ImplTraits::TreeTypePtr::pointer expression838_last = NULL;
    OracleDML::expression_return expression840;
    ImplTraits::TreeTypePtr::pointer expression840_last = NULL;
    ImplTraits::TreeTypePtr COMMA837_tree;
    ImplTraits::TreeTypePtr COMMA839_tree;
    RewriteRuleTokenStream<ImplTraits> stream_COMMA(get_psrstate()->get_treeAdaptor(), "token COMMA");
    RewriteRuleSubtreeStream<ImplTraits> stream_expression(get_psrstate()->get_treeAdaptor(), "rule expression");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:1151:5: ( COMMA expression ( COMMA expression )* -> ( ^( EXPR expression ) )+ )
        // OracleDML.g:1151:10: COMMA expression ( COMMA expression )*
        {
            COMMA837 =  this->matchToken(COMMA, &FOLLOW_COMMA_in_vector_expr11873);
            if  (this->hasException())
            {
                goto rulevector_exprEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_COMMA.add(COMMA837);


            this->followPush(FOLLOW_expression_in_vector_expr11875);
            expression838=expression();

            this->followPop();
            if  (this->hasException())
            {
                goto rulevector_exprEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                expression838_last = expression838.tree.get();
                stream_expression.add(expression838.tree);
            }

            // OracleDML.g:1151:27: ( COMMA expression )*

            for (;;)
            {
                ANTLR_UINT32 alt280=2;
                switch ( this->LA(1) )
                {
                case COMMA:
                	{
                		alt280=1;
                	}
                    break;

                }

                switch (alt280)
                {
            	case 1:
            	    // OracleDML.g:1151:28: COMMA expression
            	    {
            	        COMMA839 =  this->matchToken(COMMA, &FOLLOW_COMMA_in_vector_expr11878);
            	        if  (this->hasException())
            	        {
            	            goto rulevector_exprEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( this->get_backtracking()==0 ) stream_COMMA.add(COMMA839);


            	        this->followPush(FOLLOW_expression_in_vector_expr11880);
            	        expression840=expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulevector_exprEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            expression840_last = expression840.tree.get();
            	            stream_expression.add(expression840.tree);
            	        }

            	    }
            	    break;

            	default:
            	    goto loop280;	/* break out of the loop */
            	    break;
                }
            }
            loop280: ; /* Jump out to here if this rule does not match */


            // AST REWRITE
            // elements: expression
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1152:9: -> ( ^( EXPR expression ) )+
            {
            	if ( !(stream_expression.hasNext()) ) {
            		ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, REWRITE_EARLY_EXCEPTION, StreamType>( this->get_rec(), "expression empty" );
            		goto rulevector_exprEx;
            	}
            	while ( stream_expression.hasNext() ) {
            		// OracleDML.g:1152:12: ^( EXPR expression )
            		{
            		ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            		root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(EXPR, "EXPR"), root_1);
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_expression.nextTree());
            		get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            		}
            	}
            	stream_expression.reset();

            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulevector_exprEx; /* Prevent compiler warnings */
    rulevector_exprEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end vector_expr */

/**
 * $ANTLR start quantified_expression
 * OracleDML.g:1155:1: quantified_expression : ( some_key | exists_key | all_key | any_key ) ( ( LEFT_PAREN ( select_key | with_key ) )=> LEFT_PAREN subquery RIGHT_PAREN | LEFT_PAREN expression_wrapper RIGHT_PAREN ) -> { mode == 1 }? ^( NESTED_EXPR ( some_key )? ( exists_key )? ( all_key )? ( any_key )? ^( NESTED_SUBQUERY LEFT_PAREN subquery RIGHT_PAREN ) ) -> ^( NESTED_EXPR ( some_key )? ( exists_key )? ( all_key )? ( any_key )? LEFT_PAREN expression_wrapper RIGHT_PAREN ) ;
 */
OracleDML::quantified_expression_return
OracleDML::quantified_expression()
{
    OracleDML::quantified_expression_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* LEFT_PAREN845 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN847 = NULL;
    ImplTraits::CommonTokenType const* LEFT_PAREN848 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN850 = NULL;
    OracleDML_OracleDMLKeys::some_key_return some_key841;
    ImplTraits::TreeTypePtr::pointer some_key841_last = NULL;
    OracleDML_OracleDMLKeys::exists_key_return exists_key842;
    ImplTraits::TreeTypePtr::pointer exists_key842_last = NULL;
    OracleDML_OracleDMLKeys::all_key_return all_key843;
    ImplTraits::TreeTypePtr::pointer all_key843_last = NULL;
    OracleDML_OracleDMLKeys::any_key_return any_key844;
    ImplTraits::TreeTypePtr::pointer any_key844_last = NULL;
    OracleDML::subquery_return subquery846;
    ImplTraits::TreeTypePtr::pointer subquery846_last = NULL;
    OracleDML::expression_wrapper_return expression_wrapper849;
    ImplTraits::TreeTypePtr::pointer expression_wrapper849_last = NULL;
    ImplTraits::TreeTypePtr LEFT_PAREN845_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN847_tree;
    ImplTraits::TreeTypePtr LEFT_PAREN848_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN850_tree;
    RewriteRuleTokenStream<ImplTraits> stream_LEFT_PAREN(get_psrstate()->get_treeAdaptor(), "token LEFT_PAREN");
    RewriteRuleTokenStream<ImplTraits> stream_RIGHT_PAREN(get_psrstate()->get_treeAdaptor(), "token RIGHT_PAREN");
    RewriteRuleSubtreeStream<ImplTraits> stream_all_key(get_psrstate()->get_treeAdaptor(), "rule all_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_expression_wrapper(get_psrstate()->get_treeAdaptor(), "rule expression_wrapper");
    RewriteRuleSubtreeStream<ImplTraits> stream_some_key(get_psrstate()->get_treeAdaptor(), "rule some_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_any_key(get_psrstate()->get_treeAdaptor(), "rule any_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_exists_key(get_psrstate()->get_treeAdaptor(), "rule exists_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_subquery(get_psrstate()->get_treeAdaptor(), "rule subquery");

    /* Initialize rule variables
     */

        int mode = 0;    
    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:1157:5: ( ( some_key | exists_key | all_key | any_key ) ( ( LEFT_PAREN ( select_key | with_key ) )=> LEFT_PAREN subquery RIGHT_PAREN | LEFT_PAREN expression_wrapper RIGHT_PAREN ) -> { mode == 1 }? ^( NESTED_EXPR ( some_key )? ( exists_key )? ( all_key )? ( any_key )? ^( NESTED_SUBQUERY LEFT_PAREN subquery RIGHT_PAREN ) ) -> ^( NESTED_EXPR ( some_key )? ( exists_key )? ( all_key )? ( any_key )? LEFT_PAREN expression_wrapper RIGHT_PAREN ) )
        // OracleDML.g:1157:10: ( some_key | exists_key | all_key | any_key ) ( ( LEFT_PAREN ( select_key | with_key ) )=> LEFT_PAREN subquery RIGHT_PAREN | LEFT_PAREN expression_wrapper RIGHT_PAREN )
        {
            // OracleDML.g:1157:10: ( some_key | exists_key | all_key | any_key )
            {
                ANTLR_UINT32 alt281=4;
                switch ( this->LA(1) )
                {
                case REGULAR_ID:
                	{
                		alt281=1;
                	}
                    break;
                case SQL92_RESERVED_EXISTS:
                	{
                		alt281=2;
                	}
                    break;
                case SQL92_RESERVED_ALL:
                	{
                		alt281=3;
                	}
                    break;
                case SQL92_RESERVED_ANY:
                	{
                		alt281=4;
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return retval;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 281 );
                    ex->set_state( 0 );


                    goto rulequantified_expressionEx;

                }

                switch (alt281)
                {
            	case 1:
            	    // OracleDML.g:1157:12: some_key
            	    {
            	        this->followPush(FOLLOW_some_key_in_quantified_expression11929);
            	        some_key841=some_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulequantified_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            some_key841_last = some_key841.tree.get();
            	            stream_some_key.add(some_key841.tree);
            	        }

            	    }
            	    break;
            	case 2:
            	    // OracleDML.g:1157:23: exists_key
            	    {
            	        this->followPush(FOLLOW_exists_key_in_quantified_expression11933);
            	        exists_key842=exists_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulequantified_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            exists_key842_last = exists_key842.tree.get();
            	            stream_exists_key.add(exists_key842.tree);
            	        }

            	    }
            	    break;
            	case 3:
            	    // OracleDML.g:1157:36: all_key
            	    {
            	        this->followPush(FOLLOW_all_key_in_quantified_expression11937);
            	        all_key843=all_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulequantified_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            all_key843_last = all_key843.tree.get();
            	            stream_all_key.add(all_key843.tree);
            	        }

            	    }
            	    break;
            	case 4:
            	    // OracleDML.g:1157:46: any_key
            	    {
            	        this->followPush(FOLLOW_any_key_in_quantified_expression11941);
            	        any_key844=any_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulequantified_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            any_key844_last = any_key844.tree.get();
            	            stream_any_key.add(any_key844.tree);
            	        }

            	    }
            	    break;

                }
            }

            // OracleDML.g:1158:10: ( ( LEFT_PAREN ( select_key | with_key ) )=> LEFT_PAREN subquery RIGHT_PAREN | LEFT_PAREN expression_wrapper RIGHT_PAREN )
            {
                ANTLR_UINT32 alt282=2;
                switch ( this->LA(1) )
                {
                case LEFT_PAREN:
                	{
                		{
                		    ANTLR_UINT32 LA282_1 = this->LA(2);
                		    if ( (this->msynpred( antlr3::ClassForwarder<synpred51_OracleDML>() )))
                		    {
                		        alt282=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt282=2;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return retval;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 282 );
                		        ex->set_state( 1 );


                		        goto rulequantified_expressionEx;

                		    }
                		}
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return retval;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 282 );
                    ex->set_state( 0 );


                    goto rulequantified_expressionEx;

                }

                switch (alt282)
                {
            	case 1:
            	    // OracleDML.g:1158:12: ( LEFT_PAREN ( select_key | with_key ) )=> LEFT_PAREN subquery RIGHT_PAREN
            	    {
            	        LEFT_PAREN845 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_quantified_expression11968);
            	        if  (this->hasException())
            	        {
            	            goto rulequantified_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( this->get_backtracking()==0 ) stream_LEFT_PAREN.add(LEFT_PAREN845);


            	        this->followPush(FOLLOW_subquery_in_quantified_expression11970);
            	        subquery846=subquery();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulequantified_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            subquery846_last = subquery846.tree.get();
            	            stream_subquery.add(subquery846.tree);
            	        }

            	        RIGHT_PAREN847 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_quantified_expression11972);
            	        if  (this->hasException())
            	        {
            	            goto rulequantified_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( this->get_backtracking()==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN847);


            	        if ( this->get_backtracking()==0 )
            	        {
            	             mode = 1; 
            	        }


            	    }
            	    break;
            	case 2:
            	    // OracleDML.g:1159:14: LEFT_PAREN expression_wrapper RIGHT_PAREN
            	    {
            	        LEFT_PAREN848 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_quantified_expression11989);
            	        if  (this->hasException())
            	        {
            	            goto rulequantified_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( this->get_backtracking()==0 ) stream_LEFT_PAREN.add(LEFT_PAREN848);


            	        this->followPush(FOLLOW_expression_wrapper_in_quantified_expression11991);
            	        expression_wrapper849=expression_wrapper();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulequantified_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            expression_wrapper849_last = expression_wrapper849.tree.get();
            	            stream_expression_wrapper.add(expression_wrapper849.tree);
            	        }

            	        RIGHT_PAREN850 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_quantified_expression11993);
            	        if  (this->hasException())
            	        {
            	            goto rulequantified_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }
            	         
            	        if ( this->get_backtracking()==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN850);


            	    }
            	    break;

                }
            }

            // AST REWRITE
            // elements: RIGHT_PAREN, subquery, any_key, some_key, all_key, LEFT_PAREN, all_key, exists_key, some_key, exists_key, RIGHT_PAREN, LEFT_PAREN, any_key, expression_wrapper
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1161:10: -> { mode == 1 }? ^( NESTED_EXPR ( some_key )? ( exists_key )? ( all_key )? ( any_key )? ^( NESTED_SUBQUERY LEFT_PAREN subquery RIGHT_PAREN ) )
            if ( mode == 1 ) {
            	// OracleDML.g:1161:28: ^( NESTED_EXPR ( some_key )? ( exists_key )? ( all_key )? ( any_key )? ^( NESTED_SUBQUERY LEFT_PAREN subquery RIGHT_PAREN ) )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(NESTED_EXPR, "NESTED_EXPR"), root_1);
            	// OracleDML.g:1161:42: ( some_key )?
            	if ( stream_some_key.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_some_key.nextTree());
            	}
            	stream_some_key.reset();

            	// OracleDML.g:1161:52: ( exists_key )?
            	if ( stream_exists_key.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_exists_key.nextTree());
            	}
            	stream_exists_key.reset();

            	// OracleDML.g:1161:64: ( all_key )?
            	if ( stream_all_key.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_all_key.nextTree());
            	}
            	stream_all_key.reset();

            	// OracleDML.g:1161:73: ( any_key )?
            	if ( stream_any_key.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_any_key.nextTree());
            	}
            	stream_any_key.reset();

            	// OracleDML.g:1161:82: ^( NESTED_SUBQUERY LEFT_PAREN subquery RIGHT_PAREN )
            	{
            	ImplTraits::TreeTypePtr root_2 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_2 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(NESTED_SUBQUERY, "NESTED_SUBQUERY"), root_2);
            	get_psrstate()->get_treeAdaptor()->addChild(root_2, stream_LEFT_PAREN.nextNode());
            	get_psrstate()->get_treeAdaptor()->addChild(root_2, stream_subquery.nextTree());
            	get_psrstate()->get_treeAdaptor()->addChild(root_2, stream_RIGHT_PAREN.nextNode());
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, root_2);
            	}
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }

            else // 1162:10: -> ^( NESTED_EXPR ( some_key )? ( exists_key )? ( all_key )? ( any_key )? LEFT_PAREN expression_wrapper RIGHT_PAREN )
            {
            	// OracleDML.g:1162:28: ^( NESTED_EXPR ( some_key )? ( exists_key )? ( all_key )? ( any_key )? LEFT_PAREN expression_wrapper RIGHT_PAREN )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(NESTED_EXPR, "NESTED_EXPR"), root_1);
            	// OracleDML.g:1162:42: ( some_key )?
            	if ( stream_some_key.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_some_key.nextTree());
            	}
            	stream_some_key.reset();

            	// OracleDML.g:1162:52: ( exists_key )?
            	if ( stream_exists_key.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_exists_key.nextTree());
            	}
            	stream_exists_key.reset();

            	// OracleDML.g:1162:64: ( all_key )?
            	if ( stream_all_key.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_all_key.nextTree());
            	}
            	stream_all_key.reset();

            	// OracleDML.g:1162:73: ( any_key )?
            	if ( stream_any_key.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_any_key.nextTree());
            	}
            	stream_any_key.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_LEFT_PAREN.nextNode());
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_expression_wrapper.nextTree());
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_RIGHT_PAREN.nextNode());
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulequantified_expressionEx; /* Prevent compiler warnings */
    rulequantified_expressionEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end quantified_expression */

/**
 * $ANTLR start standard_function
 * OracleDML.g:1165:1: standard_function : ( stantard_function_enabling_over ^ function_argument_analytic ( over_clause )? | stantard_function_enabling_using ^ function_argument_modeling ( using_clause )? | count_key ^ LEFT_PAREN ( ASTERISK | ( distinct_key | unique_key | all_key )? concatenation_wrapper ) RIGHT_PAREN ( over_clause )? | ( cast_key ^| xmlcast_key ^) LEFT_PAREN ( ( multiset_key ( LEFT_PAREN )+ ( select_key | with_key ) )=> ( multiset_key ! LEFT_PAREN subquery ( order_by_clause )? RIGHT_PAREN ) ( as_key ! type_spec )? | concatenation_wrapper as_key ! type_spec ) RIGHT_PAREN | chr_key ^ LEFT_PAREN concatenation_wrapper using_key ! nchar_cs_key RIGHT_PAREN | collect_key ^ LEFT_PAREN ( distinct_key | unique_key )? concatenation_wrapper ( collect_order_by_part )? RIGHT_PAREN | stantard_function_enabling_within_or_over ^ function_argument ( within_or_over_part )+ | decompose_key ^ LEFT_PAREN concatenation_wrapper ( canonical_key | compatibility_key )? RIGHT_PAREN | extract_key ^ LEFT_PAREN REGULAR_ID from_key ! concatenation_wrapper RIGHT_PAREN | ( first_value_key ^| last_value_key ^) function_argument_analytic ( respect_or_ignore_nulls )? over_clause | stantard_function_pedictions ^ LEFT_PAREN expression_wrapper ( COMMA expression_wrapper )* ( cost_matrix_clause )? ( using_clause )? RIGHT_PAREN | translate_key ^ LEFT_PAREN expression_wrapper ( using_key ! ( char_cs_key | nchar_cs_key ) )? ( COMMA expression_wrapper )* RIGHT_PAREN | treat_key ^ LEFT_PAREN expression_wrapper as_key ! ( ref_key )? type_spec RIGHT_PAREN | trim_key ^ LEFT_PAREN ( ( leading_key | trailing_key | both_key )? ( quoted_string )? from_key )? concatenation_wrapper RIGHT_PAREN | xmlagg_key ^ LEFT_PAREN expression_wrapper ( order_by_clause )? RIGHT_PAREN ( PERIOD general_element_part )? | ( xmlcolattval_key ^| xmlforest_key ^) LEFT_PAREN xml_multiuse_expression_element ( COMMA ! xml_multiuse_expression_element )* RIGHT_PAREN ( PERIOD general_element_part )? | xmlelement_key ^ LEFT_PAREN ( entityescaping_key | noentityescaping_key )? ( name_key | evalname_key )? expression_wrapper ({...}? COMMA ! xml_attributes_clause )? ( COMMA ! expression_wrapper ( column_alias )? )* RIGHT_PAREN ( PERIOD general_element_part )? | xmlexists_key ^ LEFT_PAREN expression_wrapper ( xml_passing_clause )? RIGHT_PAREN | xmlparse_key ^ LEFT_PAREN ( document_key | content_key ) concatenation_wrapper ( wellformed_key )? RIGHT_PAREN ( PERIOD general_element_part )? | xmlpi_key ^ LEFT_PAREN ( name_key id[T_UNKNOWN,T_USE] | evalname_key concatenation_wrapper ) ( COMMA ! concatenation_wrapper )? RIGHT_PAREN ( PERIOD general_element_part )? | xmlquery_key ^ LEFT_PAREN concatenation_wrapper ( xml_passing_clause )? returning_key ! content_key ! ( null_key on_key ! empty_key !)? RIGHT_PAREN ( PERIOD general_element_part )? | xmlroot_key ^ LEFT_PAREN concatenation_wrapper xmlroot_param_version_part ( COMMA ! xmlroot_param_standalone_part )? RIGHT_PAREN ( PERIOD general_element_part )? | xmlserialize_key ^ LEFT_PAREN ( document_key | content_key ) concatenation_wrapper ( as_key ! type_spec )? ( xmlserialize_param_enconding_part )? ( xmlserialize_param_version_part )? ( xmlserialize_param_ident_part )? ( ( hide_key | show_key ) defaults_key )? RIGHT_PAREN ( PERIOD general_element_part )? | xmltable_key ^ LEFT_PAREN ( xml_namespaces_clause )? concatenation_wrapper ( xml_passing_clause )? ( columns_key ! xml_table_column ( COMMA ! xml_table_column ) )? RIGHT_PAREN ( PERIOD general_element_part )? );
 */
OracleDML::standard_function_return
OracleDML::standard_function()
{
    OracleDML::standard_function_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* LEFT_PAREN858 = NULL;
    ImplTraits::CommonTokenType const* ASTERISK859 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN864 = NULL;
    ImplTraits::CommonTokenType const* LEFT_PAREN868 = NULL;
    ImplTraits::CommonTokenType const* LEFT_PAREN870 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN873 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN879 = NULL;
    ImplTraits::CommonTokenType const* LEFT_PAREN881 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN885 = NULL;
    ImplTraits::CommonTokenType const* LEFT_PAREN887 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN892 = NULL;
    ImplTraits::CommonTokenType const* LEFT_PAREN897 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN901 = NULL;
    ImplTraits::CommonTokenType const* LEFT_PAREN903 = NULL;
    ImplTraits::CommonTokenType const* REGULAR_ID904 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN907 = NULL;
    ImplTraits::CommonTokenType const* LEFT_PAREN914 = NULL;
    ImplTraits::CommonTokenType const* COMMA916 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN920 = NULL;
    ImplTraits::CommonTokenType const* LEFT_PAREN922 = NULL;
    ImplTraits::CommonTokenType const* COMMA927 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN929 = NULL;
    ImplTraits::CommonTokenType const* LEFT_PAREN931 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN936 = NULL;
    ImplTraits::CommonTokenType const* LEFT_PAREN938 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN945 = NULL;
    ImplTraits::CommonTokenType const* LEFT_PAREN947 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN950 = NULL;
    ImplTraits::CommonTokenType const* PERIOD951 = NULL;
    ImplTraits::CommonTokenType const* LEFT_PAREN955 = NULL;
    ImplTraits::CommonTokenType const* COMMA957 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN959 = NULL;
    ImplTraits::CommonTokenType const* PERIOD960 = NULL;
    ImplTraits::CommonTokenType const* LEFT_PAREN963 = NULL;
    ImplTraits::CommonTokenType const* COMMA969 = NULL;
    ImplTraits::CommonTokenType const* COMMA971 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN974 = NULL;
    ImplTraits::CommonTokenType const* PERIOD975 = NULL;
    ImplTraits::CommonTokenType const* LEFT_PAREN978 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN981 = NULL;
    ImplTraits::CommonTokenType const* LEFT_PAREN983 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN988 = NULL;
    ImplTraits::CommonTokenType const* PERIOD989 = NULL;
    ImplTraits::CommonTokenType const* LEFT_PAREN992 = NULL;
    ImplTraits::CommonTokenType const* COMMA997 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN999 = NULL;
    ImplTraits::CommonTokenType const* PERIOD1000 = NULL;
    ImplTraits::CommonTokenType const* LEFT_PAREN1003 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN1011 = NULL;
    ImplTraits::CommonTokenType const* PERIOD1012 = NULL;
    ImplTraits::CommonTokenType const* LEFT_PAREN1015 = NULL;
    ImplTraits::CommonTokenType const* COMMA1018 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN1020 = NULL;
    ImplTraits::CommonTokenType const* PERIOD1021 = NULL;
    ImplTraits::CommonTokenType const* LEFT_PAREN1024 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN1036 = NULL;
    ImplTraits::CommonTokenType const* PERIOD1037 = NULL;
    ImplTraits::CommonTokenType const* LEFT_PAREN1040 = NULL;
    ImplTraits::CommonTokenType const* COMMA1046 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN1048 = NULL;
    ImplTraits::CommonTokenType const* PERIOD1049 = NULL;
    OracleDML::stantard_function_enabling_over_return stantard_function_enabling_over851;
    ImplTraits::TreeTypePtr::pointer stantard_function_enabling_over851_last = NULL;
    OracleDML_OracleDMLCommons::function_argument_analytic_return function_argument_analytic852;
    ImplTraits::TreeTypePtr::pointer function_argument_analytic852_last = NULL;
    OracleDML::over_clause_return over_clause853;
    ImplTraits::TreeTypePtr::pointer over_clause853_last = NULL;
    OracleDML::stantard_function_enabling_using_return stantard_function_enabling_using854;
    ImplTraits::TreeTypePtr::pointer stantard_function_enabling_using854_last = NULL;
    OracleDML_OracleDMLCommons::function_argument_modeling_return function_argument_modeling855;
    ImplTraits::TreeTypePtr::pointer function_argument_modeling855_last = NULL;
    OracleDML::using_clause_return using_clause856;
    ImplTraits::TreeTypePtr::pointer using_clause856_last = NULL;
    OracleDML_OracleDMLKeys::count_key_return count_key857;
    ImplTraits::TreeTypePtr::pointer count_key857_last = NULL;
    OracleDML_OracleDMLKeys::distinct_key_return distinct_key860;
    ImplTraits::TreeTypePtr::pointer distinct_key860_last = NULL;
    OracleDML_OracleDMLKeys::unique_key_return unique_key861;
    ImplTraits::TreeTypePtr::pointer unique_key861_last = NULL;
    OracleDML_OracleDMLKeys::all_key_return all_key862;
    ImplTraits::TreeTypePtr::pointer all_key862_last = NULL;
    OracleDML::concatenation_wrapper_return concatenation_wrapper863;
    ImplTraits::TreeTypePtr::pointer concatenation_wrapper863_last = NULL;
    OracleDML::over_clause_return over_clause865;
    ImplTraits::TreeTypePtr::pointer over_clause865_last = NULL;
    OracleDML_OracleDMLKeys::cast_key_return cast_key866;
    ImplTraits::TreeTypePtr::pointer cast_key866_last = NULL;
    OracleDML_OracleDMLKeys::xmlcast_key_return xmlcast_key867;
    ImplTraits::TreeTypePtr::pointer xmlcast_key867_last = NULL;
    OracleDML_OracleDMLKeys::multiset_key_return multiset_key869;
    ImplTraits::TreeTypePtr::pointer multiset_key869_last = NULL;
    OracleDML::subquery_return subquery871;
    ImplTraits::TreeTypePtr::pointer subquery871_last = NULL;
    OracleDML::order_by_clause_return order_by_clause872;
    ImplTraits::TreeTypePtr::pointer order_by_clause872_last = NULL;
    OracleDML_OracleDMLKeys::as_key_return as_key874;
    ImplTraits::TreeTypePtr::pointer as_key874_last = NULL;
    OracleDML_OracleDMLCommons::type_spec_return type_spec875;
    ImplTraits::TreeTypePtr::pointer type_spec875_last = NULL;
    OracleDML::concatenation_wrapper_return concatenation_wrapper876;
    ImplTraits::TreeTypePtr::pointer concatenation_wrapper876_last = NULL;
    OracleDML_OracleDMLKeys::as_key_return as_key877;
    ImplTraits::TreeTypePtr::pointer as_key877_last = NULL;
    OracleDML_OracleDMLCommons::type_spec_return type_spec878;
    ImplTraits::TreeTypePtr::pointer type_spec878_last = NULL;
    OracleDML_OracleDMLKeys::chr_key_return chr_key880;
    ImplTraits::TreeTypePtr::pointer chr_key880_last = NULL;
    OracleDML::concatenation_wrapper_return concatenation_wrapper882;
    ImplTraits::TreeTypePtr::pointer concatenation_wrapper882_last = NULL;
    OracleDML_OracleDMLKeys::using_key_return using_key883;
    ImplTraits::TreeTypePtr::pointer using_key883_last = NULL;
    OracleDML_OracleDMLKeys::nchar_cs_key_return nchar_cs_key884;
    ImplTraits::TreeTypePtr::pointer nchar_cs_key884_last = NULL;
    OracleDML_OracleDMLKeys::collect_key_return collect_key886;
    ImplTraits::TreeTypePtr::pointer collect_key886_last = NULL;
    OracleDML_OracleDMLKeys::distinct_key_return distinct_key888;
    ImplTraits::TreeTypePtr::pointer distinct_key888_last = NULL;
    OracleDML_OracleDMLKeys::unique_key_return unique_key889;
    ImplTraits::TreeTypePtr::pointer unique_key889_last = NULL;
    OracleDML::concatenation_wrapper_return concatenation_wrapper890;
    ImplTraits::TreeTypePtr::pointer concatenation_wrapper890_last = NULL;
    OracleDML::collect_order_by_part_return collect_order_by_part891;
    ImplTraits::TreeTypePtr::pointer collect_order_by_part891_last = NULL;
    OracleDML::stantard_function_enabling_within_or_over_return stantard_function_enabling_within_or_over893;
    ImplTraits::TreeTypePtr::pointer stantard_function_enabling_within_or_over893_last = NULL;
    OracleDML_OracleDMLCommons::function_argument_return function_argument894;
    ImplTraits::TreeTypePtr::pointer function_argument894_last = NULL;
    OracleDML::within_or_over_part_return within_or_over_part895;
    ImplTraits::TreeTypePtr::pointer within_or_over_part895_last = NULL;
    OracleDML_OracleDMLKeys::decompose_key_return decompose_key896;
    ImplTraits::TreeTypePtr::pointer decompose_key896_last = NULL;
    OracleDML::concatenation_wrapper_return concatenation_wrapper898;
    ImplTraits::TreeTypePtr::pointer concatenation_wrapper898_last = NULL;
    OracleDML_OracleDMLKeys::canonical_key_return canonical_key899;
    ImplTraits::TreeTypePtr::pointer canonical_key899_last = NULL;
    OracleDML_OracleDMLKeys::compatibility_key_return compatibility_key900;
    ImplTraits::TreeTypePtr::pointer compatibility_key900_last = NULL;
    OracleDML_OracleDMLKeys::extract_key_return extract_key902;
    ImplTraits::TreeTypePtr::pointer extract_key902_last = NULL;
    OracleDML_OracleDMLKeys::from_key_return from_key905;
    ImplTraits::TreeTypePtr::pointer from_key905_last = NULL;
    OracleDML::concatenation_wrapper_return concatenation_wrapper906;
    ImplTraits::TreeTypePtr::pointer concatenation_wrapper906_last = NULL;
    OracleDML_OracleDMLKeys::first_value_key_return first_value_key908;
    ImplTraits::TreeTypePtr::pointer first_value_key908_last = NULL;
    OracleDML_OracleDMLKeys::last_value_key_return last_value_key909;
    ImplTraits::TreeTypePtr::pointer last_value_key909_last = NULL;
    OracleDML_OracleDMLCommons::function_argument_analytic_return function_argument_analytic910;
    ImplTraits::TreeTypePtr::pointer function_argument_analytic910_last = NULL;
    OracleDML_OracleDMLCommons::respect_or_ignore_nulls_return respect_or_ignore_nulls911;
    ImplTraits::TreeTypePtr::pointer respect_or_ignore_nulls911_last = NULL;
    OracleDML::over_clause_return over_clause912;
    ImplTraits::TreeTypePtr::pointer over_clause912_last = NULL;
    OracleDML::stantard_function_pedictions_return stantard_function_pedictions913;
    ImplTraits::TreeTypePtr::pointer stantard_function_pedictions913_last = NULL;
    OracleDML::expression_wrapper_return expression_wrapper915;
    ImplTraits::TreeTypePtr::pointer expression_wrapper915_last = NULL;
    OracleDML::expression_wrapper_return expression_wrapper917;
    ImplTraits::TreeTypePtr::pointer expression_wrapper917_last = NULL;
    OracleDML::cost_matrix_clause_return cost_matrix_clause918;
    ImplTraits::TreeTypePtr::pointer cost_matrix_clause918_last = NULL;
    OracleDML::using_clause_return using_clause919;
    ImplTraits::TreeTypePtr::pointer using_clause919_last = NULL;
    OracleDML_OracleDMLKeys::translate_key_return translate_key921;
    ImplTraits::TreeTypePtr::pointer translate_key921_last = NULL;
    OracleDML::expression_wrapper_return expression_wrapper923;
    ImplTraits::TreeTypePtr::pointer expression_wrapper923_last = NULL;
    OracleDML_OracleDMLKeys::using_key_return using_key924;
    ImplTraits::TreeTypePtr::pointer using_key924_last = NULL;
    OracleDML_OracleDMLKeys::char_cs_key_return char_cs_key925;
    ImplTraits::TreeTypePtr::pointer char_cs_key925_last = NULL;
    OracleDML_OracleDMLKeys::nchar_cs_key_return nchar_cs_key926;
    ImplTraits::TreeTypePtr::pointer nchar_cs_key926_last = NULL;
    OracleDML::expression_wrapper_return expression_wrapper928;
    ImplTraits::TreeTypePtr::pointer expression_wrapper928_last = NULL;
    OracleDML_OracleDMLKeys::treat_key_return treat_key930;
    ImplTraits::TreeTypePtr::pointer treat_key930_last = NULL;
    OracleDML::expression_wrapper_return expression_wrapper932;
    ImplTraits::TreeTypePtr::pointer expression_wrapper932_last = NULL;
    OracleDML_OracleDMLKeys::as_key_return as_key933;
    ImplTraits::TreeTypePtr::pointer as_key933_last = NULL;
    OracleDML_OracleDMLKeys::ref_key_return ref_key934;
    ImplTraits::TreeTypePtr::pointer ref_key934_last = NULL;
    OracleDML_OracleDMLCommons::type_spec_return type_spec935;
    ImplTraits::TreeTypePtr::pointer type_spec935_last = NULL;
    OracleDML_OracleDMLKeys::trim_key_return trim_key937;
    ImplTraits::TreeTypePtr::pointer trim_key937_last = NULL;
    OracleDML_OracleDMLKeys::leading_key_return leading_key939;
    ImplTraits::TreeTypePtr::pointer leading_key939_last = NULL;
    OracleDML_OracleDMLKeys::trailing_key_return trailing_key940;
    ImplTraits::TreeTypePtr::pointer trailing_key940_last = NULL;
    OracleDML_OracleDMLKeys::both_key_return both_key941;
    ImplTraits::TreeTypePtr::pointer both_key941_last = NULL;
    OracleDML_OracleDMLCommons::quoted_string_return quoted_string942;
    ImplTraits::TreeTypePtr::pointer quoted_string942_last = NULL;
    OracleDML_OracleDMLKeys::from_key_return from_key943;
    ImplTraits::TreeTypePtr::pointer from_key943_last = NULL;
    OracleDML::concatenation_wrapper_return concatenation_wrapper944;
    ImplTraits::TreeTypePtr::pointer concatenation_wrapper944_last = NULL;
    OracleDML_OracleDMLKeys::xmlagg_key_return xmlagg_key946;
    ImplTraits::TreeTypePtr::pointer xmlagg_key946_last = NULL;
    OracleDML::expression_wrapper_return expression_wrapper948;
    ImplTraits::TreeTypePtr::pointer expression_wrapper948_last = NULL;
    OracleDML::order_by_clause_return order_by_clause949;
    ImplTraits::TreeTypePtr::pointer order_by_clause949_last = NULL;
    OracleDML_OracleDMLCommons::general_element_part_return general_element_part952;
    ImplTraits::TreeTypePtr::pointer general_element_part952_last = NULL;
    OracleDML_OracleDMLKeys::xmlcolattval_key_return xmlcolattval_key953;
    ImplTraits::TreeTypePtr::pointer xmlcolattval_key953_last = NULL;
    OracleDML_OracleDMLKeys::xmlforest_key_return xmlforest_key954;
    ImplTraits::TreeTypePtr::pointer xmlforest_key954_last = NULL;
    OracleDML::xml_multiuse_expression_element_return xml_multiuse_expression_element956;
    ImplTraits::TreeTypePtr::pointer xml_multiuse_expression_element956_last = NULL;
    OracleDML::xml_multiuse_expression_element_return xml_multiuse_expression_element958;
    ImplTraits::TreeTypePtr::pointer xml_multiuse_expression_element958_last = NULL;
    OracleDML_OracleDMLCommons::general_element_part_return general_element_part961;
    ImplTraits::TreeTypePtr::pointer general_element_part961_last = NULL;
    OracleDML_OracleDMLKeys::xmlelement_key_return xmlelement_key962;
    ImplTraits::TreeTypePtr::pointer xmlelement_key962_last = NULL;
    OracleDML_OracleDMLKeys::entityescaping_key_return entityescaping_key964;
    ImplTraits::TreeTypePtr::pointer entityescaping_key964_last = NULL;
    OracleDML_OracleDMLKeys::noentityescaping_key_return noentityescaping_key965;
    ImplTraits::TreeTypePtr::pointer noentityescaping_key965_last = NULL;
    OracleDML_OracleDMLKeys::name_key_return name_key966;
    ImplTraits::TreeTypePtr::pointer name_key966_last = NULL;
    OracleDML_OracleDMLKeys::evalname_key_return evalname_key967;
    ImplTraits::TreeTypePtr::pointer evalname_key967_last = NULL;
    OracleDML::expression_wrapper_return expression_wrapper968;
    ImplTraits::TreeTypePtr::pointer expression_wrapper968_last = NULL;
    OracleDML::xml_attributes_clause_return xml_attributes_clause970;
    ImplTraits::TreeTypePtr::pointer xml_attributes_clause970_last = NULL;
    OracleDML::expression_wrapper_return expression_wrapper972;
    ImplTraits::TreeTypePtr::pointer expression_wrapper972_last = NULL;
    OracleDML_OracleDMLCommons::column_alias_return column_alias973;
    ImplTraits::TreeTypePtr::pointer column_alias973_last = NULL;
    OracleDML_OracleDMLCommons::general_element_part_return general_element_part976;
    ImplTraits::TreeTypePtr::pointer general_element_part976_last = NULL;
    OracleDML_OracleDMLKeys::xmlexists_key_return xmlexists_key977;
    ImplTraits::TreeTypePtr::pointer xmlexists_key977_last = NULL;
    OracleDML::expression_wrapper_return expression_wrapper979;
    ImplTraits::TreeTypePtr::pointer expression_wrapper979_last = NULL;
    OracleDML::xml_passing_clause_return xml_passing_clause980;
    ImplTraits::TreeTypePtr::pointer xml_passing_clause980_last = NULL;
    OracleDML_OracleDMLKeys::xmlparse_key_return xmlparse_key982;
    ImplTraits::TreeTypePtr::pointer xmlparse_key982_last = NULL;
    OracleDML_OracleDMLKeys::document_key_return document_key984;
    ImplTraits::TreeTypePtr::pointer document_key984_last = NULL;
    OracleDML_OracleDMLKeys::content_key_return content_key985;
    ImplTraits::TreeTypePtr::pointer content_key985_last = NULL;
    OracleDML::concatenation_wrapper_return concatenation_wrapper986;
    ImplTraits::TreeTypePtr::pointer concatenation_wrapper986_last = NULL;
    OracleDML_OracleDMLKeys::wellformed_key_return wellformed_key987;
    ImplTraits::TreeTypePtr::pointer wellformed_key987_last = NULL;
    OracleDML_OracleDMLCommons::general_element_part_return general_element_part990;
    ImplTraits::TreeTypePtr::pointer general_element_part990_last = NULL;
    OracleDML_OracleDMLKeys::xmlpi_key_return xmlpi_key991;
    ImplTraits::TreeTypePtr::pointer xmlpi_key991_last = NULL;
    OracleDML_OracleDMLKeys::name_key_return name_key993;
    ImplTraits::TreeTypePtr::pointer name_key993_last = NULL;
    OracleDML_OracleDMLCommons::id_return id994;
    ImplTraits::TreeTypePtr::pointer id994_last = NULL;
    OracleDML_OracleDMLKeys::evalname_key_return evalname_key995;
    ImplTraits::TreeTypePtr::pointer evalname_key995_last = NULL;
    OracleDML::concatenation_wrapper_return concatenation_wrapper996;
    ImplTraits::TreeTypePtr::pointer concatenation_wrapper996_last = NULL;
    OracleDML::concatenation_wrapper_return concatenation_wrapper998;
    ImplTraits::TreeTypePtr::pointer concatenation_wrapper998_last = NULL;
    OracleDML_OracleDMLCommons::general_element_part_return general_element_part1001;
    ImplTraits::TreeTypePtr::pointer general_element_part1001_last = NULL;
    OracleDML_OracleDMLKeys::xmlquery_key_return xmlquery_key1002;
    ImplTraits::TreeTypePtr::pointer xmlquery_key1002_last = NULL;
    OracleDML::concatenation_wrapper_return concatenation_wrapper1004;
    ImplTraits::TreeTypePtr::pointer concatenation_wrapper1004_last = NULL;
    OracleDML::xml_passing_clause_return xml_passing_clause1005;
    ImplTraits::TreeTypePtr::pointer xml_passing_clause1005_last = NULL;
    OracleDML_OracleDMLKeys::returning_key_return returning_key1006;
    ImplTraits::TreeTypePtr::pointer returning_key1006_last = NULL;
    OracleDML_OracleDMLKeys::content_key_return content_key1007;
    ImplTraits::TreeTypePtr::pointer content_key1007_last = NULL;
    OracleDML_OracleDMLKeys::null_key_return null_key1008;
    ImplTraits::TreeTypePtr::pointer null_key1008_last = NULL;
    OracleDML_OracleDMLKeys::on_key_return on_key1009;
    ImplTraits::TreeTypePtr::pointer on_key1009_last = NULL;
    OracleDML_OracleDMLKeys::empty_key_return empty_key1010;
    ImplTraits::TreeTypePtr::pointer empty_key1010_last = NULL;
    OracleDML_OracleDMLCommons::general_element_part_return general_element_part1013;
    ImplTraits::TreeTypePtr::pointer general_element_part1013_last = NULL;
    OracleDML_OracleDMLKeys::xmlroot_key_return xmlroot_key1014;
    ImplTraits::TreeTypePtr::pointer xmlroot_key1014_last = NULL;
    OracleDML::concatenation_wrapper_return concatenation_wrapper1016;
    ImplTraits::TreeTypePtr::pointer concatenation_wrapper1016_last = NULL;
    OracleDML::xmlroot_param_version_part_return xmlroot_param_version_part1017;
    ImplTraits::TreeTypePtr::pointer xmlroot_param_version_part1017_last = NULL;
    OracleDML::xmlroot_param_standalone_part_return xmlroot_param_standalone_part1019;
    ImplTraits::TreeTypePtr::pointer xmlroot_param_standalone_part1019_last = NULL;
    OracleDML_OracleDMLCommons::general_element_part_return general_element_part1022;
    ImplTraits::TreeTypePtr::pointer general_element_part1022_last = NULL;
    OracleDML_OracleDMLKeys::xmlserialize_key_return xmlserialize_key1023;
    ImplTraits::TreeTypePtr::pointer xmlserialize_key1023_last = NULL;
    OracleDML_OracleDMLKeys::document_key_return document_key1025;
    ImplTraits::TreeTypePtr::pointer document_key1025_last = NULL;
    OracleDML_OracleDMLKeys::content_key_return content_key1026;
    ImplTraits::TreeTypePtr::pointer content_key1026_last = NULL;
    OracleDML::concatenation_wrapper_return concatenation_wrapper1027;
    ImplTraits::TreeTypePtr::pointer concatenation_wrapper1027_last = NULL;
    OracleDML_OracleDMLKeys::as_key_return as_key1028;
    ImplTraits::TreeTypePtr::pointer as_key1028_last = NULL;
    OracleDML_OracleDMLCommons::type_spec_return type_spec1029;
    ImplTraits::TreeTypePtr::pointer type_spec1029_last = NULL;
    OracleDML::xmlserialize_param_enconding_part_return xmlserialize_param_enconding_part1030;
    ImplTraits::TreeTypePtr::pointer xmlserialize_param_enconding_part1030_last = NULL;
    OracleDML::xmlserialize_param_version_part_return xmlserialize_param_version_part1031;
    ImplTraits::TreeTypePtr::pointer xmlserialize_param_version_part1031_last = NULL;
    OracleDML::xmlserialize_param_ident_part_return xmlserialize_param_ident_part1032;
    ImplTraits::TreeTypePtr::pointer xmlserialize_param_ident_part1032_last = NULL;
    OracleDML_OracleDMLKeys::hide_key_return hide_key1033;
    ImplTraits::TreeTypePtr::pointer hide_key1033_last = NULL;
    OracleDML_OracleDMLKeys::show_key_return show_key1034;
    ImplTraits::TreeTypePtr::pointer show_key1034_last = NULL;
    OracleDML_OracleDMLKeys::defaults_key_return defaults_key1035;
    ImplTraits::TreeTypePtr::pointer defaults_key1035_last = NULL;
    OracleDML_OracleDMLCommons::general_element_part_return general_element_part1038;
    ImplTraits::TreeTypePtr::pointer general_element_part1038_last = NULL;
    OracleDML_OracleDMLKeys::xmltable_key_return xmltable_key1039;
    ImplTraits::TreeTypePtr::pointer xmltable_key1039_last = NULL;
    OracleDML::xml_namespaces_clause_return xml_namespaces_clause1041;
    ImplTraits::TreeTypePtr::pointer xml_namespaces_clause1041_last = NULL;
    OracleDML::concatenation_wrapper_return concatenation_wrapper1042;
    ImplTraits::TreeTypePtr::pointer concatenation_wrapper1042_last = NULL;
    OracleDML::xml_passing_clause_return xml_passing_clause1043;
    ImplTraits::TreeTypePtr::pointer xml_passing_clause1043_last = NULL;
    OracleDML_OracleDMLKeys::columns_key_return columns_key1044;
    ImplTraits::TreeTypePtr::pointer columns_key1044_last = NULL;
    OracleDML::xml_table_column_return xml_table_column1045;
    ImplTraits::TreeTypePtr::pointer xml_table_column1045_last = NULL;
    OracleDML::xml_table_column_return xml_table_column1047;
    ImplTraits::TreeTypePtr::pointer xml_table_column1047_last = NULL;
    OracleDML_OracleDMLCommons::general_element_part_return general_element_part1050;
    ImplTraits::TreeTypePtr::pointer general_element_part1050_last = NULL;
    ImplTraits::TreeTypePtr LEFT_PAREN858_tree;
    ImplTraits::TreeTypePtr ASTERISK859_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN864_tree;
    ImplTraits::TreeTypePtr LEFT_PAREN868_tree;
    ImplTraits::TreeTypePtr LEFT_PAREN870_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN873_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN879_tree;
    ImplTraits::TreeTypePtr LEFT_PAREN881_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN885_tree;
    ImplTraits::TreeTypePtr LEFT_PAREN887_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN892_tree;
    ImplTraits::TreeTypePtr LEFT_PAREN897_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN901_tree;
    ImplTraits::TreeTypePtr LEFT_PAREN903_tree;
    ImplTraits::TreeTypePtr REGULAR_ID904_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN907_tree;
    ImplTraits::TreeTypePtr LEFT_PAREN914_tree;
    ImplTraits::TreeTypePtr COMMA916_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN920_tree;
    ImplTraits::TreeTypePtr LEFT_PAREN922_tree;
    ImplTraits::TreeTypePtr COMMA927_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN929_tree;
    ImplTraits::TreeTypePtr LEFT_PAREN931_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN936_tree;
    ImplTraits::TreeTypePtr LEFT_PAREN938_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN945_tree;
    ImplTraits::TreeTypePtr LEFT_PAREN947_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN950_tree;
    ImplTraits::TreeTypePtr PERIOD951_tree;
    ImplTraits::TreeTypePtr LEFT_PAREN955_tree;
    ImplTraits::TreeTypePtr COMMA957_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN959_tree;
    ImplTraits::TreeTypePtr PERIOD960_tree;
    ImplTraits::TreeTypePtr LEFT_PAREN963_tree;
    ImplTraits::TreeTypePtr COMMA969_tree;
    ImplTraits::TreeTypePtr COMMA971_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN974_tree;
    ImplTraits::TreeTypePtr PERIOD975_tree;
    ImplTraits::TreeTypePtr LEFT_PAREN978_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN981_tree;
    ImplTraits::TreeTypePtr LEFT_PAREN983_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN988_tree;
    ImplTraits::TreeTypePtr PERIOD989_tree;
    ImplTraits::TreeTypePtr LEFT_PAREN992_tree;
    ImplTraits::TreeTypePtr COMMA997_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN999_tree;
    ImplTraits::TreeTypePtr PERIOD1000_tree;
    ImplTraits::TreeTypePtr LEFT_PAREN1003_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN1011_tree;
    ImplTraits::TreeTypePtr PERIOD1012_tree;
    ImplTraits::TreeTypePtr LEFT_PAREN1015_tree;
    ImplTraits::TreeTypePtr COMMA1018_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN1020_tree;
    ImplTraits::TreeTypePtr PERIOD1021_tree;
    ImplTraits::TreeTypePtr LEFT_PAREN1024_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN1036_tree;
    ImplTraits::TreeTypePtr PERIOD1037_tree;
    ImplTraits::TreeTypePtr LEFT_PAREN1040_tree;
    ImplTraits::TreeTypePtr COMMA1046_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN1048_tree;
    ImplTraits::TreeTypePtr PERIOD1049_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        {
            //  OracleDML.g:1166:5: ( stantard_function_enabling_over ^ function_argument_analytic ( over_clause )? | stantard_function_enabling_using ^ function_argument_modeling ( using_clause )? | count_key ^ LEFT_PAREN ( ASTERISK | ( distinct_key | unique_key | all_key )? concatenation_wrapper ) RIGHT_PAREN ( over_clause )? | ( cast_key ^| xmlcast_key ^) LEFT_PAREN ( ( multiset_key ( LEFT_PAREN )+ ( select_key | with_key ) )=> ( multiset_key ! LEFT_PAREN subquery ( order_by_clause )? RIGHT_PAREN ) ( as_key ! type_spec )? | concatenation_wrapper as_key ! type_spec ) RIGHT_PAREN | chr_key ^ LEFT_PAREN concatenation_wrapper using_key ! nchar_cs_key RIGHT_PAREN | collect_key ^ LEFT_PAREN ( distinct_key | unique_key )? concatenation_wrapper ( collect_order_by_part )? RIGHT_PAREN | stantard_function_enabling_within_or_over ^ function_argument ( within_or_over_part )+ | decompose_key ^ LEFT_PAREN concatenation_wrapper ( canonical_key | compatibility_key )? RIGHT_PAREN | extract_key ^ LEFT_PAREN REGULAR_ID from_key ! concatenation_wrapper RIGHT_PAREN | ( first_value_key ^| last_value_key ^) function_argument_analytic ( respect_or_ignore_nulls )? over_clause | stantard_function_pedictions ^ LEFT_PAREN expression_wrapper ( COMMA expression_wrapper )* ( cost_matrix_clause )? ( using_clause )? RIGHT_PAREN | translate_key ^ LEFT_PAREN expression_wrapper ( using_key ! ( char_cs_key | nchar_cs_key ) )? ( COMMA expression_wrapper )* RIGHT_PAREN | treat_key ^ LEFT_PAREN expression_wrapper as_key ! ( ref_key )? type_spec RIGHT_PAREN | trim_key ^ LEFT_PAREN ( ( leading_key | trailing_key | both_key )? ( quoted_string )? from_key )? concatenation_wrapper RIGHT_PAREN | xmlagg_key ^ LEFT_PAREN expression_wrapper ( order_by_clause )? RIGHT_PAREN ( PERIOD general_element_part )? | ( xmlcolattval_key ^| xmlforest_key ^) LEFT_PAREN xml_multiuse_expression_element ( COMMA ! xml_multiuse_expression_element )* RIGHT_PAREN ( PERIOD general_element_part )? | xmlelement_key ^ LEFT_PAREN ( entityescaping_key | noentityescaping_key )? ( name_key | evalname_key )? expression_wrapper ({...}? COMMA ! xml_attributes_clause )? ( COMMA ! expression_wrapper ( column_alias )? )* RIGHT_PAREN ( PERIOD general_element_part )? | xmlexists_key ^ LEFT_PAREN expression_wrapper ( xml_passing_clause )? RIGHT_PAREN | xmlparse_key ^ LEFT_PAREN ( document_key | content_key ) concatenation_wrapper ( wellformed_key )? RIGHT_PAREN ( PERIOD general_element_part )? | xmlpi_key ^ LEFT_PAREN ( name_key id[T_UNKNOWN,T_USE] | evalname_key concatenation_wrapper ) ( COMMA ! concatenation_wrapper )? RIGHT_PAREN ( PERIOD general_element_part )? | xmlquery_key ^ LEFT_PAREN concatenation_wrapper ( xml_passing_clause )? returning_key ! content_key ! ( null_key on_key ! empty_key !)? RIGHT_PAREN ( PERIOD general_element_part )? | xmlroot_key ^ LEFT_PAREN concatenation_wrapper xmlroot_param_version_part ( COMMA ! xmlroot_param_standalone_part )? RIGHT_PAREN ( PERIOD general_element_part )? | xmlserialize_key ^ LEFT_PAREN ( document_key | content_key ) concatenation_wrapper ( as_key ! type_spec )? ( xmlserialize_param_enconding_part )? ( xmlserialize_param_version_part )? ( xmlserialize_param_ident_part )? ( ( hide_key | show_key ) defaults_key )? RIGHT_PAREN ( PERIOD general_element_part )? | xmltable_key ^ LEFT_PAREN ( xml_namespaces_clause )? concatenation_wrapper ( xml_passing_clause )? ( columns_key ! xml_table_column ( COMMA ! xml_table_column ) )? RIGHT_PAREN ( PERIOD general_element_part )? )

            ANTLR_UINT32 alt343;

            alt343=24;

            switch ( this->LA(1) )
            {
            case REGULAR_ID:
            	{
            		{
            		    ANTLR_UINT32 LA343_1 = this->LA(2);
            		    if ( ((enablesOverClause(LT(1)->getText()))))
            		    {
            		        alt343=1;
            		    }
            		    else if ( ((enablesUsingClause(LT(1)->getText()))))
            		    {
            		        alt343=2;
            		    }
            		    else if ( ((toUpper(LT(1)->getText()) == "COUNT" )))
            		    {
            		        alt343=3;
            		    }
            		    else if ( ((toUpper(LT(1)->getText()) == "XMLCAST")))
            		    {
            		        alt343=4;
            		    }
            		    else if ( ((toUpper(LT(1)->getText()) == "CHR")))
            		    {
            		        alt343=5;
            		    }
            		    else if ( ((toUpper(LT(1)->getText()) == "COLLECT")))
            		    {
            		        alt343=6;
            		    }
            		    else if ( ((enablesWithinOrOverClause(LT(1)->getText()))))
            		    {
            		        alt343=7;
            		    }
            		    else if ( ((toUpper(LT(1)->getText()) == "DECOMPOSE")))
            		    {
            		        alt343=8;
            		    }
            		    else if ( ((toUpper(LT(1)->getText()) == "EXTRACT")))
            		    {
            		        alt343=9;
            		    }
            		    else if ( ((((toUpper(LT(1)->getText()) == "LAST_VALUE"))||((toUpper(LT(1)->getText()) == "FIRST_VALUE")))))
            		    {
            		        alt343=10;
            		    }
            		    else if ( ((isStandardPredictionFunction(LT(1)->getText()))))
            		    {
            		        alt343=11;
            		    }
            		    else if ( ((toUpper(LT(1)->getText()) == "TRANSLATE")))
            		    {
            		        alt343=12;
            		    }
            		    else if ( ((toUpper(LT(1)->getText()) == "TREAT")))
            		    {
            		        alt343=13;
            		    }
            		    else if ( ((toUpper(LT(1)->getText()) == "TRIM")))
            		    {
            		        alt343=14;
            		    }
            		    else if ( ((toUpper(LT(1)->getText()) == "XMLAGG")))
            		    {
            		        alt343=15;
            		    }
            		    else if ( ((((toUpper(LT(1)->getText()) == "XMLCOLATTVAL"))||((toUpper(LT(1)->getText()) == "XMLFOREST")))))
            		    {
            		        alt343=16;
            		    }
            		    else if ( ((toUpper(LT(1)->getText()) == "XMLELEMENT")))
            		    {
            		        alt343=17;
            		    }
            		    else if ( ((toUpper(LT(1)->getText()) == "XMLEXISTS")))
            		    {
            		        alt343=18;
            		    }
            		    else if ( ((toUpper(LT(1)->getText()) == "XMLPARSE")))
            		    {
            		        alt343=19;
            		    }
            		    else if ( ((toUpper(LT(1)->getText()) == "XMLPI")))
            		    {
            		        alt343=20;
            		    }
            		    else if ( ((toUpper(LT(1)->getText()) == "XMLQUERY")))
            		    {
            		        alt343=21;
            		    }
            		    else if ( ((toUpper(LT(1)->getText()) == "XMLROOT")))
            		    {
            		        alt343=22;
            		    }
            		    else if ( ((toUpper(LT(1)->getText()) == "XMLSERIALIZE")))
            		    {
            		        alt343=23;
            		    }
            		    else if ( ((toUpper(LT(1)->getText()) == "XMLTABLE")))
            		    {
            		        alt343=24;
            		    }
            		    else
            		    {
            		        if (this->get_backtracking()>0)
            		        {
            		            this->set_failedflag( true );
            		            return retval;
            		        }


            		        ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 343 );
            		        ex->set_state( 1 );


            		        goto rulestandard_functionEx;

            		    }
            		}
            	}
                break;
            case PLSQL_NON_RESERVED_CAST:
            	{
            		alt343=4;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 343 );
                ex->set_state( 0 );


                goto rulestandard_functionEx;

            }

            switch (alt343)
            {
        	case 1:
        	    // OracleDML.g:1166:10: stantard_function_enabling_over ^ function_argument_analytic ( over_clause )?
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_stantard_function_enabling_over_in_standard_function12129);
        	        stantard_function_enabling_over851=stantard_function_enabling_over();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(stantard_function_enabling_over851.tree, root_0);

        	        this->followPush(FOLLOW_function_argument_analytic_in_standard_function12132);
        	        function_argument_analytic852=function_argument_analytic();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, function_argument_analytic852.tree);


        	        // OracleDML.g:1166:70: ( over_clause )?
        	        {
        	            ANTLR_UINT32 alt283=2;
        	            switch ( this->LA(1) )
        	            {
        	                case REGULAR_ID:
        	                	{
        	                		switch ( this->LA(2) )
        	                		{
        	                		    case LEFT_PAREN:
        	                		    	{
        	                		    		{
        	                		    		    ANTLR_UINT32 LA283_3 = this->LA(3);
        	                		    		    if ( (LA283_3 == REGULAR_ID))
        	                		    		    {
        	                		    		        {
        	                		    		            ANTLR_UINT32 LA283_6 = this->LA(4);
        	                		    		            if ( (LA283_6 == SQL92_RESERVED_BY) && ((toUpper(LT(1)->getText()) == "OVER")))
        	                		    		            {
        	                		    		                alt283=1;
        	                		    		            }
        	                		    		        }
        	                		    		    }
        	                		    		    else if ( (LA283_3 == RIGHT_PAREN || LA283_3 == SQL92_RESERVED_ORDER) && ((toUpper(LT(1)->getText()) == "OVER")))
        	                		    		    {
        	                		    		        alt283=1;
        	                		    		    }
        	                		    		}
        	                		    	}
        	                		        break;
        	                		}

        	                	}
        	                    break;
        	            }

        	            switch (alt283)
        	            {
        	        	case 1:
        	        	    // OracleDML.g:1166:70: over_clause
        	        	    {
        	        	        this->followPush(FOLLOW_over_clause_in_standard_function12134);
        	        	        over_clause853=over_clause();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, over_clause853.tree);


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 2:
        	    // OracleDML.g:1167:10: stantard_function_enabling_using ^ function_argument_modeling ( using_clause )?
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_stantard_function_enabling_using_in_standard_function12146);
        	        stantard_function_enabling_using854=stantard_function_enabling_using();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(stantard_function_enabling_using854.tree, root_0);

        	        this->followPush(FOLLOW_function_argument_modeling_in_standard_function12149);
        	        function_argument_modeling855=function_argument_modeling();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, function_argument_modeling855.tree);


        	        // OracleDML.g:1167:71: ( using_clause )?
        	        {
        	            ANTLR_UINT32 alt284=2;
        	            switch ( this->LA(1) )
        	            {
        	                case PLSQL_NON_RESERVED_USING:
        	                	{
        	                		alt284=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt284)
        	            {
        	        	case 1:
        	        	    // OracleDML.g:1167:71: using_clause
        	        	    {
        	        	        this->followPush(FOLLOW_using_clause_in_standard_function12151);
        	        	        using_clause856=using_clause();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, using_clause856.tree);


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 3:
        	    // OracleDML.g:1168:10: count_key ^ LEFT_PAREN ( ASTERISK | ( distinct_key | unique_key | all_key )? concatenation_wrapper ) RIGHT_PAREN ( over_clause )?
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_count_key_in_standard_function12163);
        	        count_key857=count_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(count_key857.tree, root_0);

        	        LEFT_PAREN858 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_standard_function12178);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) {
        	        LEFT_PAREN858_tree = std::move(get_psrstate()->get_treeAdaptor()->create(LEFT_PAREN858));
        	        get_psrstate()->get_treeAdaptor()->addChild(root_0, LEFT_PAREN858_tree);
        	        }


        	        // OracleDML.g:1170:17: ( ASTERISK | ( distinct_key | unique_key | all_key )? concatenation_wrapper )
        	        {
        	            ANTLR_UINT32 alt286=2;
        	            switch ( this->LA(1) )
        	            {
        	            case ASTERISK:
        	            	{
        	            		alt286=1;
        	            	}
        	                break;
        	            case APPROXIMATE_NUM_LIT:
        	            case BINDVAR:
        	            case CHAR_STRING:
        	            case CHAR_STRING_PERL:
        	            case COLON:
        	            case DELIMITED_ID:
        	            case EXACT_NUM_LIT:
        	            case INTRODUCER:
        	            case LEFT_PAREN:
        	            case MINUS_SIGN:
        	            case NATIONAL_CHAR_STRING_LIT:
        	            case PLSQL_NON_RESERVED_CAST:
        	            case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
        	            case PLUS_SIGN:
        	            case REGULAR_ID:
        	            case SQL92_RESERVED_ALL:
        	            case SQL92_RESERVED_ANY:
        	            case SQL92_RESERVED_CASE:
        	            case SQL92_RESERVED_DATE:
        	            case SQL92_RESERVED_DEFAULT:
        	            case SQL92_RESERVED_DISTINCT:
        	            case SQL92_RESERVED_EXISTS:
        	            case SQL92_RESERVED_FALSE:
        	            case SQL92_RESERVED_NULL:
        	            case SQL92_RESERVED_PRIOR:
        	            case SQL92_RESERVED_TRUE:
        	            case SQL92_RESERVED_UNIQUE:
        	            case UNSIGNED_INTEGER:
        	            	{
        	            		alt286=2;
        	            	}
        	                break;

        	            default:
        	                if (this->get_backtracking()>0)
        	                {
        	                    this->set_failedflag( true );
        	                    return retval;
        	                }

        	                ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                ex->set_decisionNum( 286 );
        	                ex->set_state( 0 );


        	                goto rulestandard_functionEx;

        	            }

        	            switch (alt286)
        	            {
        	        	case 1:
        	        	    // OracleDML.g:1170:19: ASTERISK
        	        	    {
        	        	        ASTERISK859 =  this->matchToken(ASTERISK, &FOLLOW_ASTERISK_in_standard_function12198);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) {
        	        	        ASTERISK859_tree = std::move(get_psrstate()->get_treeAdaptor()->create(ASTERISK859));
        	        	        get_psrstate()->get_treeAdaptor()->addChild(root_0, ASTERISK859_tree);
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // OracleDML.g:1170:30: ( distinct_key | unique_key | all_key )? concatenation_wrapper
        	        	    {
        	        	        // OracleDML.g:1170:30: ( distinct_key | unique_key | all_key )?
        	        	        {
        	        	            ANTLR_UINT32 alt285=4;
        	        	            switch ( this->LA(1) )
        	        	            {
        	        	                case SQL92_RESERVED_DISTINCT:
        	        	                	{
        	        	                		alt285=1;
        	        	                	}
        	        	                    break;
        	        	                case SQL92_RESERVED_UNIQUE:
        	        	                	{
        	        	                		alt285=2;
        	        	                	}
        	        	                    break;
        	        	                case SQL92_RESERVED_ALL:
        	        	                	{
        	        	                		alt285=3;
        	        	                	}
        	        	                    break;
        	        	            }

        	        	            switch (alt285)
        	        	            {
        	        	        	case 1:
        	        	        	    // OracleDML.g:1170:31: distinct_key
        	        	        	    {
        	        	        	        this->followPush(FOLLOW_distinct_key_in_standard_function12203);
        	        	        	        distinct_key860=distinct_key();

        	        	        	        this->followPop();
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto rulestandard_functionEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return retval;
        	        	        	        }

        	        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, distinct_key860.tree);


        	        	        	    }
        	        	        	    break;
        	        	        	case 2:
        	        	        	    // OracleDML.g:1170:44: unique_key
        	        	        	    {
        	        	        	        this->followPush(FOLLOW_unique_key_in_standard_function12205);
        	        	        	        unique_key861=unique_key();

        	        	        	        this->followPop();
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto rulestandard_functionEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return retval;
        	        	        	        }

        	        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, unique_key861.tree);


        	        	        	    }
        	        	        	    break;
        	        	        	case 3:
        	        	        	    // OracleDML.g:1170:55: all_key
        	        	        	    {
        	        	        	        this->followPush(FOLLOW_all_key_in_standard_function12207);
        	        	        	        all_key862=all_key();

        	        	        	        this->followPop();
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto rulestandard_functionEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return retval;
        	        	        	        }

        	        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, all_key862.tree);


        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	        this->followPush(FOLLOW_concatenation_wrapper_in_standard_function12211);
        	        	        concatenation_wrapper863=concatenation_wrapper();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, concatenation_wrapper863.tree);


        	        	    }
        	        	    break;

        	            }
        	        }

        	        RIGHT_PAREN864 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_standard_function12227);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) {
        	        RIGHT_PAREN864_tree = std::move(get_psrstate()->get_treeAdaptor()->create(RIGHT_PAREN864));
        	        get_psrstate()->get_treeAdaptor()->addChild(root_0, RIGHT_PAREN864_tree);
        	        }


        	        // OracleDML.g:1171:25: ( over_clause )?
        	        {
        	            ANTLR_UINT32 alt287=2;
        	            switch ( this->LA(1) )
        	            {
        	                case REGULAR_ID:
        	                	{
        	                		switch ( this->LA(2) )
        	                		{
        	                		    case LEFT_PAREN:
        	                		    	{
        	                		    		{
        	                		    		    ANTLR_UINT32 LA287_3 = this->LA(3);
        	                		    		    if ( (LA287_3 == REGULAR_ID))
        	                		    		    {
        	                		    		        {
        	                		    		            ANTLR_UINT32 LA287_6 = this->LA(4);
        	                		    		            if ( (LA287_6 == SQL92_RESERVED_BY) && ((toUpper(LT(1)->getText()) == "OVER")))
        	                		    		            {
        	                		    		                alt287=1;
        	                		    		            }
        	                		    		        }
        	                		    		    }
        	                		    		    else if ( (LA287_3 == RIGHT_PAREN || LA287_3 == SQL92_RESERVED_ORDER) && ((toUpper(LT(1)->getText()) == "OVER")))
        	                		    		    {
        	                		    		        alt287=1;
        	                		    		    }
        	                		    		}
        	                		    	}
        	                		        break;
        	                		}

        	                	}
        	                    break;
        	            }

        	            switch (alt287)
        	            {
        	        	case 1:
        	        	    // OracleDML.g:1171:25: over_clause
        	        	    {
        	        	        this->followPush(FOLLOW_over_clause_in_standard_function12229);
        	        	        over_clause865=over_clause();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, over_clause865.tree);


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 4:
        	    // OracleDML.g:1172:10: ( cast_key ^| xmlcast_key ^) LEFT_PAREN ( ( multiset_key ( LEFT_PAREN )+ ( select_key | with_key ) )=> ( multiset_key ! LEFT_PAREN subquery ( order_by_clause )? RIGHT_PAREN ) ( as_key ! type_spec )? | concatenation_wrapper as_key ! type_spec ) RIGHT_PAREN
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        // OracleDML.g:1172:10: ( cast_key ^| xmlcast_key ^)
        	        {
        	            ANTLR_UINT32 alt288=2;
        	            {
        	                ANTLR_UINT32 LA288_0 = this->LA(1);
        	                if ( (LA288_0 == PLSQL_NON_RESERVED_CAST))
        	                {
        	                    alt288=1;
        	                }
        	                else if ( (LA288_0 == REGULAR_ID) && ((toUpper(LT(1)->getText()) == "XMLCAST")))
        	                {
        	                    alt288=2;
        	                }
        	                else
        	                {
        	                    if (this->get_backtracking()>0)
        	                    {
        	                        this->set_failedflag( true );
        	                        return retval;
        	                    }


        	                    ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                    ex->set_decisionNum( 288 );
        	                    ex->set_state( 0 );


        	                    goto rulestandard_functionEx;

        	                }
        	            }
        	            switch (alt288)
        	            {
        	        	case 1:
        	        	    // OracleDML.g:1172:11: cast_key ^
        	        	    {
        	        	        this->followPush(FOLLOW_cast_key_in_standard_function12242);
        	        	        cast_key866=cast_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(cast_key866.tree, root_0);

        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // OracleDML.g:1172:21: xmlcast_key ^
        	        	    {
        	        	        this->followPush(FOLLOW_xmlcast_key_in_standard_function12245);
        	        	        xmlcast_key867=xmlcast_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(xmlcast_key867.tree, root_0);

        	        	    }
        	        	    break;

        	            }
        	        }

        	        LEFT_PAREN868 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_standard_function12262);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) {
        	        LEFT_PAREN868_tree = std::move(get_psrstate()->get_treeAdaptor()->create(LEFT_PAREN868));
        	        get_psrstate()->get_treeAdaptor()->addChild(root_0, LEFT_PAREN868_tree);
        	        }


        	        // OracleDML.g:1174:13: ( ( multiset_key ( LEFT_PAREN )+ ( select_key | with_key ) )=> ( multiset_key ! LEFT_PAREN subquery ( order_by_clause )? RIGHT_PAREN ) ( as_key ! type_spec )? | concatenation_wrapper as_key ! type_spec )
        	        {
        	            ANTLR_UINT32 alt291=2;
        	            {
        	                ANTLR_UINT32 LA291_0 = this->LA(1);
        	                if ( (LA291_0 == PLSQL_NON_RESERVED_MULTISET) && (this->msynpred( antlr3::ClassForwarder<synpred52_OracleDML>() )))
        	                {
        	                    alt291=1;
        	                }
        	                else if ( (LA291_0 == APPROXIMATE_NUM_LIT || LA291_0 == BINDVAR || ((LA291_0 >= CHAR_STRING) && (LA291_0 <= CHAR_STRING_PERL)) || LA291_0 == COLON || LA291_0 == DELIMITED_ID || LA291_0 == EXACT_NUM_LIT || LA291_0 == INTRODUCER || LA291_0 == LEFT_PAREN || LA291_0 == MINUS_SIGN || LA291_0 == NATIONAL_CHAR_STRING_LIT || ((LA291_0 >= PLSQL_NON_RESERVED_CAST) && (LA291_0 <= PLSQL_NON_RESERVED_CONNECT_BY_ROOT)) || LA291_0 == PLUS_SIGN || LA291_0 == REGULAR_ID || LA291_0 == SQL92_RESERVED_ALL || LA291_0 == SQL92_RESERVED_ANY || LA291_0 == SQL92_RESERVED_CASE || LA291_0 == SQL92_RESERVED_DATE || LA291_0 == SQL92_RESERVED_DEFAULT || LA291_0 == SQL92_RESERVED_DISTINCT || ((LA291_0 >= SQL92_RESERVED_EXISTS) && (LA291_0 <= SQL92_RESERVED_FALSE)) || LA291_0 == SQL92_RESERVED_NULL || LA291_0 == SQL92_RESERVED_PRIOR || LA291_0 == SQL92_RESERVED_TRUE || LA291_0 == UNSIGNED_INTEGER))
        	                {
        	                    alt291=2;
        	                }
        	                else
        	                {
        	                    if (this->get_backtracking()>0)
        	                    {
        	                        this->set_failedflag( true );
        	                        return retval;
        	                    }


        	                    ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                    ex->set_decisionNum( 291 );
        	                    ex->set_state( 0 );


        	                    goto rulestandard_functionEx;

        	                }
        	            }
        	            switch (alt291)
        	            {
        	        	case 1:
        	        	    // OracleDML.g:1174:15: ( multiset_key ( LEFT_PAREN )+ ( select_key | with_key ) )=> ( multiset_key ! LEFT_PAREN subquery ( order_by_clause )? RIGHT_PAREN ) ( as_key ! type_spec )?
        	        	    {
        	        	        // OracleDML.g:1174:67: ( multiset_key ! LEFT_PAREN subquery ( order_by_clause )? RIGHT_PAREN )
        	        	        // OracleDML.g:1174:68: multiset_key ! LEFT_PAREN subquery ( order_by_clause )? RIGHT_PAREN
        	        	        {
        	        	            this->followPush(FOLLOW_multiset_key_in_standard_function12294);
        	        	            multiset_key869=multiset_key();

        	        	            this->followPop();
        	        	            if  (this->hasException())
        	        	            {
        	        	                goto rulestandard_functionEx;
        	        	            }
        	        	            if (this->hasFailed())
        	        	            {
        	        	                return retval;
        	        	            }


        	        	            LEFT_PAREN870 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_standard_function12297);
        	        	            if  (this->hasException())
        	        	            {
        	        	                goto rulestandard_functionEx;
        	        	            }
        	        	            if (this->hasFailed())
        	        	            {
        	        	                return retval;
        	        	            }

        	        	            if ( this->get_backtracking()==0 ) {
        	        	            LEFT_PAREN870_tree = std::move(get_psrstate()->get_treeAdaptor()->create(LEFT_PAREN870));
        	        	            get_psrstate()->get_treeAdaptor()->addChild(root_0, LEFT_PAREN870_tree);
        	        	            }


        	        	            this->followPush(FOLLOW_subquery_in_standard_function12299);
        	        	            subquery871=subquery();

        	        	            this->followPop();
        	        	            if  (this->hasException())
        	        	            {
        	        	                goto rulestandard_functionEx;
        	        	            }
        	        	            if (this->hasFailed())
        	        	            {
        	        	                return retval;
        	        	            }

        	        	            if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, subquery871.tree);


        	        	            // OracleDML.g:1174:102: ( order_by_clause )?
        	        	            {
        	        	                ANTLR_UINT32 alt289=2;
        	        	                switch ( this->LA(1) )
        	        	                {
        	        	                    case SQL92_RESERVED_ORDER:
        	        	                    	{
        	        	                    		alt289=1;
        	        	                    	}
        	        	                        break;
        	        	                }

        	        	                switch (alt289)
        	        	                {
        	        	            	case 1:
        	        	            	    // OracleDML.g:1174:102: order_by_clause
        	        	            	    {
        	        	            	        this->followPush(FOLLOW_order_by_clause_in_standard_function12301);
        	        	            	        order_by_clause872=order_by_clause();

        	        	            	        this->followPop();
        	        	            	        if  (this->hasException())
        	        	            	        {
        	        	            	            goto rulestandard_functionEx;
        	        	            	        }
        	        	            	        if (this->hasFailed())
        	        	            	        {
        	        	            	            return retval;
        	        	            	        }

        	        	            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, order_by_clause872.tree);


        	        	            	    }
        	        	            	    break;

        	        	                }
        	        	            }

        	        	            RIGHT_PAREN873 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_standard_function12304);
        	        	            if  (this->hasException())
        	        	            {
        	        	                goto rulestandard_functionEx;
        	        	            }
        	        	            if (this->hasFailed())
        	        	            {
        	        	                return retval;
        	        	            }

        	        	            if ( this->get_backtracking()==0 ) {
        	        	            RIGHT_PAREN873_tree = std::move(get_psrstate()->get_treeAdaptor()->create(RIGHT_PAREN873));
        	        	            get_psrstate()->get_treeAdaptor()->addChild(root_0, RIGHT_PAREN873_tree);
        	        	            }


        	        	        }


        	        	        // OracleDML.g:1175:15: ( as_key ! type_spec )?
        	        	        {
        	        	            ANTLR_UINT32 alt290=2;
        	        	            switch ( this->LA(1) )
        	        	            {
        	        	                case SQL92_RESERVED_AS:
        	        	                	{
        	        	                		alt290=1;
        	        	                	}
        	        	                    break;
        	        	            }

        	        	            switch (alt290)
        	        	            {
        	        	        	case 1:
        	        	        	    // OracleDML.g:1175:16: as_key ! type_spec
        	        	        	    {
        	        	        	        this->followPush(FOLLOW_as_key_in_standard_function12322);
        	        	        	        as_key874=as_key();

        	        	        	        this->followPop();
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto rulestandard_functionEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return retval;
        	        	        	        }


        	        	        	        this->followPush(FOLLOW_type_spec_in_standard_function12325);
        	        	        	        type_spec875=type_spec();

        	        	        	        this->followPop();
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto rulestandard_functionEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return retval;
        	        	        	        }

        	        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, type_spec875.tree);


        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // OracleDML.g:1176:15: concatenation_wrapper as_key ! type_spec
        	        	    {
        	        	        this->followPush(FOLLOW_concatenation_wrapper_in_standard_function12343);
        	        	        concatenation_wrapper876=concatenation_wrapper();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, concatenation_wrapper876.tree);


        	        	        this->followPush(FOLLOW_as_key_in_standard_function12345);
        	        	        as_key877=as_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }


        	        	        this->followPush(FOLLOW_type_spec_in_standard_function12348);
        	        	        type_spec878=type_spec();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, type_spec878.tree);


        	        	    }
        	        	    break;

        	            }
        	        }

        	        RIGHT_PAREN879 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_standard_function12376);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) {
        	        RIGHT_PAREN879_tree = std::move(get_psrstate()->get_treeAdaptor()->create(RIGHT_PAREN879));
        	        get_psrstate()->get_treeAdaptor()->addChild(root_0, RIGHT_PAREN879_tree);
        	        }


        	    }
        	    break;
        	case 5:
        	    // OracleDML.g:1179:10: chr_key ^ LEFT_PAREN concatenation_wrapper using_key ! nchar_cs_key RIGHT_PAREN
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_chr_key_in_standard_function12387);
        	        chr_key880=chr_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(chr_key880.tree, root_0);

        	        LEFT_PAREN881 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_standard_function12402);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) {
        	        LEFT_PAREN881_tree = std::move(get_psrstate()->get_treeAdaptor()->create(LEFT_PAREN881));
        	        get_psrstate()->get_treeAdaptor()->addChild(root_0, LEFT_PAREN881_tree);
        	        }


        	        this->followPush(FOLLOW_concatenation_wrapper_in_standard_function12421);
        	        concatenation_wrapper882=concatenation_wrapper();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, concatenation_wrapper882.tree);


        	        this->followPush(FOLLOW_using_key_in_standard_function12423);
        	        using_key883=using_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }


        	        this->followPush(FOLLOW_nchar_cs_key_in_standard_function12426);
        	        nchar_cs_key884=nchar_cs_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, nchar_cs_key884.tree);


        	        RIGHT_PAREN885 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_standard_function12441);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) {
        	        RIGHT_PAREN885_tree = std::move(get_psrstate()->get_treeAdaptor()->create(RIGHT_PAREN885));
        	        get_psrstate()->get_treeAdaptor()->addChild(root_0, RIGHT_PAREN885_tree);
        	        }


        	    }
        	    break;
        	case 6:
        	    // OracleDML.g:1183:10: collect_key ^ LEFT_PAREN ( distinct_key | unique_key )? concatenation_wrapper ( collect_order_by_part )? RIGHT_PAREN
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_collect_key_in_standard_function12452);
        	        collect_key886=collect_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(collect_key886.tree, root_0);

        	        LEFT_PAREN887 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_standard_function12467);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) {
        	        LEFT_PAREN887_tree = std::move(get_psrstate()->get_treeAdaptor()->create(LEFT_PAREN887));
        	        get_psrstate()->get_treeAdaptor()->addChild(root_0, LEFT_PAREN887_tree);
        	        }


        	        // OracleDML.g:1185:17: ( distinct_key | unique_key )?
        	        {
        	            ANTLR_UINT32 alt292=3;
        	            switch ( this->LA(1) )
        	            {
        	                case SQL92_RESERVED_DISTINCT:
        	                	{
        	                		alt292=1;
        	                	}
        	                    break;
        	                case SQL92_RESERVED_UNIQUE:
        	                	{
        	                		alt292=2;
        	                	}
        	                    break;
        	            }

        	            switch (alt292)
        	            {
        	        	case 1:
        	        	    // OracleDML.g:1185:18: distinct_key
        	        	    {
        	        	        this->followPush(FOLLOW_distinct_key_in_standard_function12487);
        	        	        distinct_key888=distinct_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, distinct_key888.tree);


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // OracleDML.g:1185:31: unique_key
        	        	    {
        	        	        this->followPush(FOLLOW_unique_key_in_standard_function12489);
        	        	        unique_key889=unique_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, unique_key889.tree);


        	        	    }
        	        	    break;

        	            }
        	        }

        	        this->followPush(FOLLOW_concatenation_wrapper_in_standard_function12493);
        	        concatenation_wrapper890=concatenation_wrapper();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, concatenation_wrapper890.tree);


        	        // OracleDML.g:1185:66: ( collect_order_by_part )?
        	        {
        	            ANTLR_UINT32 alt293=2;
        	            switch ( this->LA(1) )
        	            {
        	                case SQL92_RESERVED_ORDER:
        	                	{
        	                		alt293=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt293)
        	            {
        	        	case 1:
        	        	    // OracleDML.g:1185:66: collect_order_by_part
        	        	    {
        	        	        this->followPush(FOLLOW_collect_order_by_part_in_standard_function12495);
        	        	        collect_order_by_part891=collect_order_by_part();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, collect_order_by_part891.tree);


        	        	    }
        	        	    break;

        	            }
        	        }

        	        RIGHT_PAREN892 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_standard_function12510);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) {
        	        RIGHT_PAREN892_tree = std::move(get_psrstate()->get_treeAdaptor()->create(RIGHT_PAREN892));
        	        get_psrstate()->get_treeAdaptor()->addChild(root_0, RIGHT_PAREN892_tree);
        	        }


        	    }
        	    break;
        	case 7:
        	    // OracleDML.g:1187:10: stantard_function_enabling_within_or_over ^ function_argument ( within_or_over_part )+
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_stantard_function_enabling_within_or_over_in_standard_function12521);
        	        stantard_function_enabling_within_or_over893=stantard_function_enabling_within_or_over();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(stantard_function_enabling_within_or_over893.tree, root_0);

        	        this->followPush(FOLLOW_function_argument_in_standard_function12537);
        	        function_argument894=function_argument();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, function_argument894.tree);


        	        // OracleDML.g:1188:31: ( within_or_over_part )+
        	        {
        	            int cnt294=0;

        	            for (;;)
        	            {
        	                ANTLR_UINT32 alt294=2;
        	        	switch ( this->LA(1) )
        	        	{
        	        	case REGULAR_ID:
        	        		{
        	        			switch ( this->LA(2) )
        	        			{
        	        			case LEFT_PAREN:
        	        				{
        	        					{
        	        					   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
        	        					    */
        	        					    ANTLR_UINT32 LA294_3 = this->LA(3);
        	        					    if ( (LA294_3 == REGULAR_ID))
        	        					    {
        	        					        {
        	        					           /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
        	        					            */
        	        					            ANTLR_UINT32 LA294_8 = this->LA(4);
        	        					            if ( (LA294_8 == SQL92_RESERVED_BY) && ((toUpper(LT(1)->getText()) == "OVER")))
        	        					            {
        	        					                alt294=1;
        	        					            }

        	        					        }
        	        					    }
        	        					    else if ( (LA294_3 == RIGHT_PAREN || LA294_3 == SQL92_RESERVED_ORDER) && ((toUpper(LT(1)->getText()) == "OVER")))
        	        					    {
        	        					        alt294=1;
        	        					    }

        	        					}
        	        				}
        	        			    break;
        	        			case SQL92_RESERVED_GROUP:
        	        				{
        	        					{
        	        					   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
        	        					    */
        	        					    ANTLR_UINT32 LA294_4 = this->LA(3);
        	        					    if ( (LA294_4 == LEFT_PAREN) && ((toUpper(LT(1)->getText()) == "WITHIN")))
        	        					    {
        	        					        alt294=1;
        	        					    }

        	        					}
        	        				}
        	        			    break;

        	        			}

        	        		}
        	        	    break;

        	        	}

        	        	switch (alt294)
        	        	{
        	        	    case 1:
        	        	        // OracleDML.g:1188:31: within_or_over_part
        	        	        {
        	        	            this->followPush(FOLLOW_within_or_over_part_in_standard_function12539);
        	        	            within_or_over_part895=within_or_over_part();

        	        	            this->followPop();
        	        	            if  (this->hasException())
        	        	            {
        	        	                goto rulestandard_functionEx;
        	        	            }
        	        	            if (this->hasFailed())
        	        	            {
        	        	                return retval;
        	        	            }

        	        	            if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, within_or_over_part895.tree);


        	        	        }
        	        	        break;

        	        	    default:

        	        		if ( cnt294 >= 1 )
        	        		{
        	        		    goto loop294;
        	        		}
        	        		if (this->get_backtracking()>0)
        	        		{
        	        		    this->set_failedflag( true );
        	        		    return retval;
        	        		}

        	        		/* mismatchedSetEx()
        	        		 */
        	        		new ANTLR_Exception< OracleDMLImplTraits, EARLY_EXIT_EXCEPTION, StreamType>( this->get_rec(), "" );


        	        		goto rulestandard_functionEx;
        	        	}
        	        	cnt294++;
        	            }
        	            loop294: ;	/* Jump to here if this rule does not match */
        	        }

        	    }
        	    break;
        	case 8:
        	    // OracleDML.g:1189:10: decompose_key ^ LEFT_PAREN concatenation_wrapper ( canonical_key | compatibility_key )? RIGHT_PAREN
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_decompose_key_in_standard_function12551);
        	        decompose_key896=decompose_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(decompose_key896.tree, root_0);

        	        LEFT_PAREN897 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_standard_function12566);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) {
        	        LEFT_PAREN897_tree = std::move(get_psrstate()->get_treeAdaptor()->create(LEFT_PAREN897));
        	        get_psrstate()->get_treeAdaptor()->addChild(root_0, LEFT_PAREN897_tree);
        	        }


        	        this->followPush(FOLLOW_concatenation_wrapper_in_standard_function12585);
        	        concatenation_wrapper898=concatenation_wrapper();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, concatenation_wrapper898.tree);


        	        // OracleDML.g:1191:39: ( canonical_key | compatibility_key )?
        	        {
        	            ANTLR_UINT32 alt295=3;
        	            {
        	                ANTLR_UINT32 LA295_0 = this->LA(1);
        	                if ( (LA295_0 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "COMPATIBILITY"))||((toUpper(LT(1)->getText()) == "CANONICAL")))))
        	                {
        	                    {
        	                        ANTLR_UINT32 LA295_1 = this->LA(2);
        	                        if ( ((toUpper(LT(1)->getText()) == "CANONICAL")))
        	                        {
        	                            alt295=1;
        	                        }
        	                        else if ( ((toUpper(LT(1)->getText()) == "COMPATIBILITY")))
        	                        {
        	                            alt295=2;
        	                        }
        	                    }
        	                }
        	            }
        	            switch (alt295)
        	            {
        	        	case 1:
        	        	    // OracleDML.g:1191:40: canonical_key
        	        	    {
        	        	        this->followPush(FOLLOW_canonical_key_in_standard_function12588);
        	        	        canonical_key899=canonical_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, canonical_key899.tree);


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // OracleDML.g:1191:54: compatibility_key
        	        	    {
        	        	        this->followPush(FOLLOW_compatibility_key_in_standard_function12590);
        	        	        compatibility_key900=compatibility_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, compatibility_key900.tree);


        	        	    }
        	        	    break;

        	            }
        	        }

        	        RIGHT_PAREN901 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_standard_function12607);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) {
        	        RIGHT_PAREN901_tree = std::move(get_psrstate()->get_treeAdaptor()->create(RIGHT_PAREN901));
        	        get_psrstate()->get_treeAdaptor()->addChild(root_0, RIGHT_PAREN901_tree);
        	        }


        	    }
        	    break;
        	case 9:
        	    // OracleDML.g:1193:10: extract_key ^ LEFT_PAREN REGULAR_ID from_key ! concatenation_wrapper RIGHT_PAREN
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_extract_key_in_standard_function12618);
        	        extract_key902=extract_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(extract_key902.tree, root_0);

        	        LEFT_PAREN903 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_standard_function12633);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) {
        	        LEFT_PAREN903_tree = std::move(get_psrstate()->get_treeAdaptor()->create(LEFT_PAREN903));
        	        get_psrstate()->get_treeAdaptor()->addChild(root_0, LEFT_PAREN903_tree);
        	        }


        	        REGULAR_ID904 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_standard_function12651);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) {
        	        REGULAR_ID904_tree = std::move(get_psrstate()->get_treeAdaptor()->create(REGULAR_ID904));
        	        get_psrstate()->get_treeAdaptor()->addChild(root_0, REGULAR_ID904_tree);
        	        }


        	        this->followPush(FOLLOW_from_key_in_standard_function12653);
        	        from_key905=from_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }


        	        this->followPush(FOLLOW_concatenation_wrapper_in_standard_function12656);
        	        concatenation_wrapper906=concatenation_wrapper();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, concatenation_wrapper906.tree);


        	        RIGHT_PAREN907 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_standard_function12671);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) {
        	        RIGHT_PAREN907_tree = std::move(get_psrstate()->get_treeAdaptor()->create(RIGHT_PAREN907));
        	        get_psrstate()->get_treeAdaptor()->addChild(root_0, RIGHT_PAREN907_tree);
        	        }


        	    }
        	    break;
        	case 10:
        	    // OracleDML.g:1197:10: ( first_value_key ^| last_value_key ^) function_argument_analytic ( respect_or_ignore_nulls )? over_clause
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        // OracleDML.g:1197:10: ( first_value_key ^| last_value_key ^)
        	        {
        	            ANTLR_UINT32 alt296=2;
        	            {
        	                ANTLR_UINT32 LA296_0 = this->LA(1);
        	                if ( (LA296_0 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "LAST_VALUE"))||((toUpper(LT(1)->getText()) == "FIRST_VALUE")))))
        	                {
        	                    {
        	                        ANTLR_UINT32 LA296_1 = this->LA(2);
        	                        if ( ((toUpper(LT(1)->getText()) == "FIRST_VALUE")))
        	                        {
        	                            alt296=1;
        	                        }
        	                        else if ( ((toUpper(LT(1)->getText()) == "LAST_VALUE")))
        	                        {
        	                            alt296=2;
        	                        }
        	                        else
        	                        {
        	                            if (this->get_backtracking()>0)
        	                            {
        	                                this->set_failedflag( true );
        	                                return retval;
        	                            }


        	                            ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                            ex->set_decisionNum( 296 );
        	                            ex->set_state( 1 );


        	                            goto rulestandard_functionEx;

        	                        }
        	                    }
        	                }
        	                else
        	                {
        	                    if (this->get_backtracking()>0)
        	                    {
        	                        this->set_failedflag( true );
        	                        return retval;
        	                    }


        	                    ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                    ex->set_decisionNum( 296 );
        	                    ex->set_state( 0 );


        	                    goto rulestandard_functionEx;

        	                }
        	            }
        	            switch (alt296)
        	            {
        	        	case 1:
        	        	    // OracleDML.g:1197:11: first_value_key ^
        	        	    {
        	        	        this->followPush(FOLLOW_first_value_key_in_standard_function12683);
        	        	        first_value_key908=first_value_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(first_value_key908.tree, root_0);

        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // OracleDML.g:1197:28: last_value_key ^
        	        	    {
        	        	        this->followPush(FOLLOW_last_value_key_in_standard_function12686);
        	        	        last_value_key909=last_value_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(last_value_key909.tree, root_0);

        	        	    }
        	        	    break;

        	            }
        	        }

        	        this->followPush(FOLLOW_function_argument_analytic_in_standard_function12690);
        	        function_argument_analytic910=function_argument_analytic();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, function_argument_analytic910.tree);


        	        // OracleDML.g:1198:14: ( respect_or_ignore_nulls )?
        	        {
        	            ANTLR_UINT32 alt297=2;
        	            {
        	                ANTLR_UINT32 LA297_0 = this->LA(1);
        	                if ( (LA297_0 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "OVER"))||((toUpper(LT(1)->getText()) == "IGNORE"))||((toUpper(LT(1)->getText()) == "RESPECT")))))
        	                {
        	                    {
        	                        ANTLR_UINT32 LA297_1 = this->LA(2);
        	                        if ( (LA297_1 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "IGNORE"))||((toUpper(LT(1)->getText()) == "RESPECT")))))
        	                        {
        	                            alt297=1;
        	                        }
        	                    }
        	                }
        	            }
        	            switch (alt297)
        	            {
        	        	case 1:
        	        	    // OracleDML.g:1198:14: respect_or_ignore_nulls
        	        	    {
        	        	        this->followPush(FOLLOW_respect_or_ignore_nulls_in_standard_function12705);
        	        	        respect_or_ignore_nulls911=respect_or_ignore_nulls();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, respect_or_ignore_nulls911.tree);


        	        	    }
        	        	    break;

        	            }
        	        }

        	        this->followPush(FOLLOW_over_clause_in_standard_function12708);
        	        over_clause912=over_clause();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, over_clause912.tree);


        	    }
        	    break;
        	case 11:
        	    // OracleDML.g:1199:10: stantard_function_pedictions ^ LEFT_PAREN expression_wrapper ( COMMA expression_wrapper )* ( cost_matrix_clause )? ( using_clause )? RIGHT_PAREN
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_stantard_function_pedictions_in_standard_function12719);
        	        stantard_function_pedictions913=stantard_function_pedictions();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(stantard_function_pedictions913.tree, root_0);

        	        LEFT_PAREN914 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_standard_function12734);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) {
        	        LEFT_PAREN914_tree = std::move(get_psrstate()->get_treeAdaptor()->create(LEFT_PAREN914));
        	        get_psrstate()->get_treeAdaptor()->addChild(root_0, LEFT_PAREN914_tree);
        	        }


        	        this->followPush(FOLLOW_expression_wrapper_in_standard_function12752);
        	        expression_wrapper915=expression_wrapper();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, expression_wrapper915.tree);


        	        // OracleDML.g:1201:36: ( COMMA expression_wrapper )*

        	        for (;;)
        	        {
        	            ANTLR_UINT32 alt298=2;
        	            switch ( this->LA(1) )
        	            {
        	            case COMMA:
        	            	{
        	            		alt298=1;
        	            	}
        	                break;

        	            }

        	            switch (alt298)
        	            {
        	        	case 1:
        	        	    // OracleDML.g:1201:37: COMMA expression_wrapper
        	        	    {
        	        	        COMMA916 =  this->matchToken(COMMA, &FOLLOW_COMMA_in_standard_function12755);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) {
        	        	        COMMA916_tree = std::move(get_psrstate()->get_treeAdaptor()->create(COMMA916));
        	        	        get_psrstate()->get_treeAdaptor()->addChild(root_0, COMMA916_tree);
        	        	        }


        	        	        this->followPush(FOLLOW_expression_wrapper_in_standard_function12757);
        	        	        expression_wrapper917=expression_wrapper();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, expression_wrapper917.tree);


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop298;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop298: ; /* Jump out to here if this rule does not match */


        	        // OracleDML.g:1201:64: ( cost_matrix_clause )?
        	        {
        	            ANTLR_UINT32 alt299=2;
        	            {
        	                ANTLR_UINT32 LA299_0 = this->LA(1);
        	                if ( (LA299_0 == REGULAR_ID) && ((toUpper(LT(1)->getText()) == "COST")))
        	                {
        	                    alt299=1;
        	                }
        	            }
        	            switch (alt299)
        	            {
        	        	case 1:
        	        	    // OracleDML.g:1201:64: cost_matrix_clause
        	        	    {
        	        	        this->followPush(FOLLOW_cost_matrix_clause_in_standard_function12761);
        	        	        cost_matrix_clause918=cost_matrix_clause();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, cost_matrix_clause918.tree);


        	        	    }
        	        	    break;

        	            }
        	        }

        	        // OracleDML.g:1201:84: ( using_clause )?
        	        {
        	            ANTLR_UINT32 alt300=2;
        	            switch ( this->LA(1) )
        	            {
        	                case PLSQL_NON_RESERVED_USING:
        	                	{
        	                		alt300=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt300)
        	            {
        	        	case 1:
        	        	    // OracleDML.g:1201:84: using_clause
        	        	    {
        	        	        this->followPush(FOLLOW_using_clause_in_standard_function12764);
        	        	        using_clause919=using_clause();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, using_clause919.tree);


        	        	    }
        	        	    break;

        	            }
        	        }

        	        RIGHT_PAREN920 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_standard_function12780);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) {
        	        RIGHT_PAREN920_tree = std::move(get_psrstate()->get_treeAdaptor()->create(RIGHT_PAREN920));
        	        get_psrstate()->get_treeAdaptor()->addChild(root_0, RIGHT_PAREN920_tree);
        	        }


        	    }
        	    break;
        	case 12:
        	    // OracleDML.g:1203:10: translate_key ^ LEFT_PAREN expression_wrapper ( using_key ! ( char_cs_key | nchar_cs_key ) )? ( COMMA expression_wrapper )* RIGHT_PAREN
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_translate_key_in_standard_function12791);
        	        translate_key921=translate_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(translate_key921.tree, root_0);

        	        LEFT_PAREN922 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_standard_function12806);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) {
        	        LEFT_PAREN922_tree = std::move(get_psrstate()->get_treeAdaptor()->create(LEFT_PAREN922));
        	        get_psrstate()->get_treeAdaptor()->addChild(root_0, LEFT_PAREN922_tree);
        	        }


        	        this->followPush(FOLLOW_expression_wrapper_in_standard_function12825);
        	        expression_wrapper923=expression_wrapper();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, expression_wrapper923.tree);


        	        // OracleDML.g:1205:36: ( using_key ! ( char_cs_key | nchar_cs_key ) )?
        	        {
        	            ANTLR_UINT32 alt302=2;
        	            switch ( this->LA(1) )
        	            {
        	                case PLSQL_NON_RESERVED_USING:
        	                	{
        	                		alt302=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt302)
        	            {
        	        	case 1:
        	        	    // OracleDML.g:1205:37: using_key ! ( char_cs_key | nchar_cs_key )
        	        	    {
        	        	        this->followPush(FOLLOW_using_key_in_standard_function12828);
        	        	        using_key924=using_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }


        	        	        // OracleDML.g:1205:48: ( char_cs_key | nchar_cs_key )
        	        	        {
        	        	            ANTLR_UINT32 alt301=2;
        	        	            {
        	        	                ANTLR_UINT32 LA301_0 = this->LA(1);
        	        	                if ( (LA301_0 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "NCHAR_CS"))||((toUpper(LT(1)->getText()) == "CHAR_CS")))))
        	        	                {
        	        	                    {
        	        	                        ANTLR_UINT32 LA301_1 = this->LA(2);
        	        	                        if ( ((toUpper(LT(1)->getText()) == "CHAR_CS")))
        	        	                        {
        	        	                            alt301=1;
        	        	                        }
        	        	                        else if ( ((toUpper(LT(1)->getText()) == "NCHAR_CS")))
        	        	                        {
        	        	                            alt301=2;
        	        	                        }
        	        	                        else
        	        	                        {
        	        	                            if (this->get_backtracking()>0)
        	        	                            {
        	        	                                this->set_failedflag( true );
        	        	                                return retval;
        	        	                            }


        	        	                            ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	        	                            ex->set_decisionNum( 301 );
        	        	                            ex->set_state( 1 );


        	        	                            goto rulestandard_functionEx;

        	        	                        }
        	        	                    }
        	        	                }
        	        	                else
        	        	                {
        	        	                    if (this->get_backtracking()>0)
        	        	                    {
        	        	                        this->set_failedflag( true );
        	        	                        return retval;
        	        	                    }


        	        	                    ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	        	                    ex->set_decisionNum( 301 );
        	        	                    ex->set_state( 0 );


        	        	                    goto rulestandard_functionEx;

        	        	                }
        	        	            }
        	        	            switch (alt301)
        	        	            {
        	        	        	case 1:
        	        	        	    // OracleDML.g:1205:49: char_cs_key
        	        	        	    {
        	        	        	        this->followPush(FOLLOW_char_cs_key_in_standard_function12832);
        	        	        	        char_cs_key925=char_cs_key();

        	        	        	        this->followPop();
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto rulestandard_functionEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return retval;
        	        	        	        }

        	        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, char_cs_key925.tree);


        	        	        	    }
        	        	        	    break;
        	        	        	case 2:
        	        	        	    // OracleDML.g:1205:61: nchar_cs_key
        	        	        	    {
        	        	        	        this->followPush(FOLLOW_nchar_cs_key_in_standard_function12834);
        	        	        	        nchar_cs_key926=nchar_cs_key();

        	        	        	        this->followPop();
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto rulestandard_functionEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return retval;
        	        	        	        }

        	        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, nchar_cs_key926.tree);


        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	    }
        	        	    break;

        	            }
        	        }

        	        // OracleDML.g:1206:21: ( COMMA expression_wrapper )*

        	        for (;;)
        	        {
        	            ANTLR_UINT32 alt303=2;
        	            switch ( this->LA(1) )
        	            {
        	            case COMMA:
        	            	{
        	            		alt303=1;
        	            	}
        	                break;

        	            }

        	            switch (alt303)
        	            {
        	        	case 1:
        	        	    // OracleDML.g:1206:22: COMMA expression_wrapper
        	        	    {
        	        	        COMMA927 =  this->matchToken(COMMA, &FOLLOW_COMMA_in_standard_function12861);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) {
        	        	        COMMA927_tree = std::move(get_psrstate()->get_treeAdaptor()->create(COMMA927));
        	        	        get_psrstate()->get_treeAdaptor()->addChild(root_0, COMMA927_tree);
        	        	        }


        	        	        this->followPush(FOLLOW_expression_wrapper_in_standard_function12863);
        	        	        expression_wrapper928=expression_wrapper();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, expression_wrapper928.tree);


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop303;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop303: ; /* Jump out to here if this rule does not match */


        	        RIGHT_PAREN929 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_standard_function12880);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) {
        	        RIGHT_PAREN929_tree = std::move(get_psrstate()->get_treeAdaptor()->create(RIGHT_PAREN929));
        	        get_psrstate()->get_treeAdaptor()->addChild(root_0, RIGHT_PAREN929_tree);
        	        }


        	    }
        	    break;
        	case 13:
        	    // OracleDML.g:1208:10: treat_key ^ LEFT_PAREN expression_wrapper as_key ! ( ref_key )? type_spec RIGHT_PAREN
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_treat_key_in_standard_function12891);
        	        treat_key930=treat_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(treat_key930.tree, root_0);

        	        LEFT_PAREN931 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_standard_function12906);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) {
        	        LEFT_PAREN931_tree = std::move(get_psrstate()->get_treeAdaptor()->create(LEFT_PAREN931));
        	        get_psrstate()->get_treeAdaptor()->addChild(root_0, LEFT_PAREN931_tree);
        	        }


        	        this->followPush(FOLLOW_expression_wrapper_in_standard_function12924);
        	        expression_wrapper932=expression_wrapper();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, expression_wrapper932.tree);


        	        this->followPush(FOLLOW_as_key_in_standard_function12926);
        	        as_key933=as_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }


        	        // OracleDML.g:1210:44: ( ref_key )?
        	        {
        	            ANTLR_UINT32 alt304=2;
        	            switch ( this->LA(1) )
        	            {
        	                case REGULAR_ID:
        	                	{
        	                		{
        	                		    ANTLR_UINT32 LA304_1 = this->LA(2);
        	                		    if ( ((toUpper(LT(1)->getText()) == "REF")))
        	                		    {
        	                		        alt304=1;
        	                		    }
        	                		}
        	                	}
        	                    break;
        	            }

        	            switch (alt304)
        	            {
        	        	case 1:
        	        	    // OracleDML.g:1210:44: ref_key
        	        	    {
        	        	        this->followPush(FOLLOW_ref_key_in_standard_function12929);
        	        	        ref_key934=ref_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, ref_key934.tree);


        	        	    }
        	        	    break;

        	            }
        	        }

        	        this->followPush(FOLLOW_type_spec_in_standard_function12932);
        	        type_spec935=type_spec();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, type_spec935.tree);


        	        RIGHT_PAREN936 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_standard_function12947);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) {
        	        RIGHT_PAREN936_tree = std::move(get_psrstate()->get_treeAdaptor()->create(RIGHT_PAREN936));
        	        get_psrstate()->get_treeAdaptor()->addChild(root_0, RIGHT_PAREN936_tree);
        	        }


        	    }
        	    break;
        	case 14:
        	    // OracleDML.g:1212:10: trim_key ^ LEFT_PAREN ( ( leading_key | trailing_key | both_key )? ( quoted_string )? from_key )? concatenation_wrapper RIGHT_PAREN
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_trim_key_in_standard_function12958);
        	        trim_key937=trim_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(trim_key937.tree, root_0);

        	        LEFT_PAREN938 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_standard_function12973);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) {
        	        LEFT_PAREN938_tree = std::move(get_psrstate()->get_treeAdaptor()->create(LEFT_PAREN938));
        	        get_psrstate()->get_treeAdaptor()->addChild(root_0, LEFT_PAREN938_tree);
        	        }


        	        // OracleDML.g:1214:17: ( ( leading_key | trailing_key | both_key )? ( quoted_string )? from_key )?
        	        {
        	            ANTLR_UINT32 alt307=2;
        	            switch ( this->LA(1) )
        	            {
        	                case REGULAR_ID:
        	                	{
        	                		switch ( this->LA(2) )
        	                		{
        	                		    case CHAR_STRING:
        	                		    case CHAR_STRING_PERL:
        	                		    case NATIONAL_CHAR_STRING_LIT:
        	                		    	{
        	                		    		switch ( this->LA(3) )
        	                		    		{
        	                		    		    case SQL92_RESERVED_FROM:
        	                		    		    	{
        	                		    		    		alt307=1;
        	                		    		    	}
        	                		    		        break;
        	                		    		}

        	                		    	}
        	                		        break;
        	                		    case SQL92_RESERVED_FROM:
        	                		    	{
        	                		    		alt307=1;
        	                		    	}
        	                		        break;
        	                		}

        	                	}
        	                    break;
        	                case CHAR_STRING:
        	                case CHAR_STRING_PERL:
        	                case NATIONAL_CHAR_STRING_LIT:
        	                	{
        	                		switch ( this->LA(2) )
        	                		{
        	                		    case SQL92_RESERVED_FROM:
        	                		    	{
        	                		    		alt307=1;
        	                		    	}
        	                		        break;
        	                		}

        	                	}
        	                    break;
        	                case SQL92_RESERVED_FROM:
        	                	{
        	                		alt307=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt307)
        	            {
        	        	case 1:
        	        	    // OracleDML.g:1214:18: ( leading_key | trailing_key | both_key )? ( quoted_string )? from_key
        	        	    {
        	        	        // OracleDML.g:1214:18: ( leading_key | trailing_key | both_key )?
        	        	        {
        	        	            ANTLR_UINT32 alt305=4;
        	        	            switch ( this->LA(1) )
        	        	            {
        	        	                case REGULAR_ID:
        	        	                	{
        	        	                		{
        	        	                		    ANTLR_UINT32 LA305_1 = this->LA(2);
        	        	                		    if ( ((toUpper(LT(1)->getText()) == "LEADING")))
        	        	                		    {
        	        	                		        alt305=1;
        	        	                		    }
        	        	                		    else if ( ((toUpper(LT(1)->getText()) == "TRAILING")))
        	        	                		    {
        	        	                		        alt305=2;
        	        	                		    }
        	        	                		    else if ( ((toUpper(LT(1)->getText()) == "BOTH")))
        	        	                		    {
        	        	                		        alt305=3;
        	        	                		    }
        	        	                		}
        	        	                	}
        	        	                    break;
        	        	            }

        	        	            switch (alt305)
        	        	            {
        	        	        	case 1:
        	        	        	    // OracleDML.g:1214:19: leading_key
        	        	        	    {
        	        	        	        this->followPush(FOLLOW_leading_key_in_standard_function12993);
        	        	        	        leading_key939=leading_key();

        	        	        	        this->followPop();
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto rulestandard_functionEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return retval;
        	        	        	        }

        	        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, leading_key939.tree);


        	        	        	    }
        	        	        	    break;
        	        	        	case 2:
        	        	        	    // OracleDML.g:1214:31: trailing_key
        	        	        	    {
        	        	        	        this->followPush(FOLLOW_trailing_key_in_standard_function12995);
        	        	        	        trailing_key940=trailing_key();

        	        	        	        this->followPop();
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto rulestandard_functionEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return retval;
        	        	        	        }

        	        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, trailing_key940.tree);


        	        	        	    }
        	        	        	    break;
        	        	        	case 3:
        	        	        	    // OracleDML.g:1214:44: both_key
        	        	        	    {
        	        	        	        this->followPush(FOLLOW_both_key_in_standard_function12997);
        	        	        	        both_key941=both_key();

        	        	        	        this->followPop();
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto rulestandard_functionEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return retval;
        	        	        	        }

        	        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, both_key941.tree);


        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	        // OracleDML.g:1214:55: ( quoted_string )?
        	        	        {
        	        	            ANTLR_UINT32 alt306=2;
        	        	            switch ( this->LA(1) )
        	        	            {
        	        	                case CHAR_STRING:
        	        	                case CHAR_STRING_PERL:
        	        	                case NATIONAL_CHAR_STRING_LIT:
        	        	                	{
        	        	                		alt306=1;
        	        	                	}
        	        	                    break;
        	        	            }

        	        	            switch (alt306)
        	        	            {
        	        	        	case 1:
        	        	        	    // OracleDML.g:1214:55: quoted_string
        	        	        	    {
        	        	        	        this->followPush(FOLLOW_quoted_string_in_standard_function13001);
        	        	        	        quoted_string942=quoted_string();

        	        	        	        this->followPop();
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto rulestandard_functionEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return retval;
        	        	        	        }

        	        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, quoted_string942.tree);


        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	        this->followPush(FOLLOW_from_key_in_standard_function13004);
        	        	        from_key943=from_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, from_key943.tree);


        	        	    }
        	        	    break;

        	            }
        	        }

        	        this->followPush(FOLLOW_concatenation_wrapper_in_standard_function13024);
        	        concatenation_wrapper944=concatenation_wrapper();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, concatenation_wrapper944.tree);


        	        RIGHT_PAREN945 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_standard_function13038);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) {
        	        RIGHT_PAREN945_tree = std::move(get_psrstate()->get_treeAdaptor()->create(RIGHT_PAREN945));
        	        get_psrstate()->get_treeAdaptor()->addChild(root_0, RIGHT_PAREN945_tree);
        	        }


        	    }
        	    break;
        	case 15:
        	    // OracleDML.g:1217:10: xmlagg_key ^ LEFT_PAREN expression_wrapper ( order_by_clause )? RIGHT_PAREN ( PERIOD general_element_part )?
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_xmlagg_key_in_standard_function13049);
        	        xmlagg_key946=xmlagg_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(xmlagg_key946.tree, root_0);

        	        LEFT_PAREN947 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_standard_function13064);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) {
        	        LEFT_PAREN947_tree = std::move(get_psrstate()->get_treeAdaptor()->create(LEFT_PAREN947));
        	        get_psrstate()->get_treeAdaptor()->addChild(root_0, LEFT_PAREN947_tree);
        	        }


        	        this->followPush(FOLLOW_expression_wrapper_in_standard_function13083);
        	        expression_wrapper948=expression_wrapper();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, expression_wrapper948.tree);


        	        // OracleDML.g:1219:36: ( order_by_clause )?
        	        {
        	            ANTLR_UINT32 alt308=2;
        	            switch ( this->LA(1) )
        	            {
        	                case SQL92_RESERVED_ORDER:
        	                	{
        	                		alt308=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt308)
        	            {
        	        	case 1:
        	        	    // OracleDML.g:1219:36: order_by_clause
        	        	    {
        	        	        this->followPush(FOLLOW_order_by_clause_in_standard_function13085);
        	        	        order_by_clause949=order_by_clause();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, order_by_clause949.tree);


        	        	    }
        	        	    break;

        	            }
        	        }

        	        RIGHT_PAREN950 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_standard_function13101);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) {
        	        RIGHT_PAREN950_tree = std::move(get_psrstate()->get_treeAdaptor()->create(RIGHT_PAREN950));
        	        get_psrstate()->get_treeAdaptor()->addChild(root_0, RIGHT_PAREN950_tree);
        	        }


        	        // OracleDML.g:1221:13: ( PERIOD general_element_part )?
        	        {
        	            ANTLR_UINT32 alt309=2;
        	            switch ( this->LA(1) )
        	            {
        	                case PERIOD:
        	                	{
        	                		alt309=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt309)
        	            {
        	        	case 1:
        	        	    // OracleDML.g:1221:14: PERIOD general_element_part
        	        	    {
        	        	        PERIOD951 =  this->matchToken(PERIOD, &FOLLOW_PERIOD_in_standard_function13116);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) {
        	        	        PERIOD951_tree = std::move(get_psrstate()->get_treeAdaptor()->create(PERIOD951));
        	        	        get_psrstate()->get_treeAdaptor()->addChild(root_0, PERIOD951_tree);
        	        	        }


        	        	        this->followPush(FOLLOW_general_element_part_in_standard_function13118);
        	        	        general_element_part952=general_element_part();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, general_element_part952.tree);


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 16:
        	    // OracleDML.g:1222:10: ( xmlcolattval_key ^| xmlforest_key ^) LEFT_PAREN xml_multiuse_expression_element ( COMMA ! xml_multiuse_expression_element )* RIGHT_PAREN ( PERIOD general_element_part )?
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        // OracleDML.g:1222:10: ( xmlcolattval_key ^| xmlforest_key ^)
        	        {
        	            ANTLR_UINT32 alt310=2;
        	            {
        	                ANTLR_UINT32 LA310_0 = this->LA(1);
        	                if ( (LA310_0 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "XMLCOLATTVAL"))||((toUpper(LT(1)->getText()) == "XMLFOREST")))))
        	                {
        	                    {
        	                        ANTLR_UINT32 LA310_1 = this->LA(2);
        	                        if ( ((toUpper(LT(1)->getText()) == "XMLCOLATTVAL")))
        	                        {
        	                            alt310=1;
        	                        }
        	                        else if ( ((toUpper(LT(1)->getText()) == "XMLFOREST")))
        	                        {
        	                            alt310=2;
        	                        }
        	                        else
        	                        {
        	                            if (this->get_backtracking()>0)
        	                            {
        	                                this->set_failedflag( true );
        	                                return retval;
        	                            }


        	                            ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                            ex->set_decisionNum( 310 );
        	                            ex->set_state( 1 );


        	                            goto rulestandard_functionEx;

        	                        }
        	                    }
        	                }
        	                else
        	                {
        	                    if (this->get_backtracking()>0)
        	                    {
        	                        this->set_failedflag( true );
        	                        return retval;
        	                    }


        	                    ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                    ex->set_decisionNum( 310 );
        	                    ex->set_state( 0 );


        	                    goto rulestandard_functionEx;

        	                }
        	            }
        	            switch (alt310)
        	            {
        	        	case 1:
        	        	    // OracleDML.g:1222:11: xmlcolattval_key ^
        	        	    {
        	        	        this->followPush(FOLLOW_xmlcolattval_key_in_standard_function13132);
        	        	        xmlcolattval_key953=xmlcolattval_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(xmlcolattval_key953.tree, root_0);

        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // OracleDML.g:1222:29: xmlforest_key ^
        	        	    {
        	        	        this->followPush(FOLLOW_xmlforest_key_in_standard_function13135);
        	        	        xmlforest_key954=xmlforest_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(xmlforest_key954.tree, root_0);

        	        	    }
        	        	    break;

        	            }
        	        }

        	        LEFT_PAREN955 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_standard_function13152);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) {
        	        LEFT_PAREN955_tree = std::move(get_psrstate()->get_treeAdaptor()->create(LEFT_PAREN955));
        	        get_psrstate()->get_treeAdaptor()->addChild(root_0, LEFT_PAREN955_tree);
        	        }


        	        this->followPush(FOLLOW_xml_multiuse_expression_element_in_standard_function13170);
        	        xml_multiuse_expression_element956=xml_multiuse_expression_element();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, xml_multiuse_expression_element956.tree);


        	        // OracleDML.g:1224:49: ( COMMA ! xml_multiuse_expression_element )*

        	        for (;;)
        	        {
        	            ANTLR_UINT32 alt311=2;
        	            switch ( this->LA(1) )
        	            {
        	            case COMMA:
        	            	{
        	            		alt311=1;
        	            	}
        	                break;

        	            }

        	            switch (alt311)
        	            {
        	        	case 1:
        	        	    // OracleDML.g:1224:50: COMMA ! xml_multiuse_expression_element
        	        	    {
        	        	        COMMA957 =  this->matchToken(COMMA, &FOLLOW_COMMA_in_standard_function13173);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }


        	        	        this->followPush(FOLLOW_xml_multiuse_expression_element_in_standard_function13176);
        	        	        xml_multiuse_expression_element958=xml_multiuse_expression_element();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, xml_multiuse_expression_element958.tree);


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop311;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop311: ; /* Jump out to here if this rule does not match */


        	        RIGHT_PAREN959 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_standard_function13192);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) {
        	        RIGHT_PAREN959_tree = std::move(get_psrstate()->get_treeAdaptor()->create(RIGHT_PAREN959));
        	        get_psrstate()->get_treeAdaptor()->addChild(root_0, RIGHT_PAREN959_tree);
        	        }


        	        // OracleDML.g:1226:13: ( PERIOD general_element_part )?
        	        {
        	            ANTLR_UINT32 alt312=2;
        	            switch ( this->LA(1) )
        	            {
        	                case PERIOD:
        	                	{
        	                		alt312=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt312)
        	            {
        	        	case 1:
        	        	    // OracleDML.g:1226:14: PERIOD general_element_part
        	        	    {
        	        	        PERIOD960 =  this->matchToken(PERIOD, &FOLLOW_PERIOD_in_standard_function13207);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) {
        	        	        PERIOD960_tree = std::move(get_psrstate()->get_treeAdaptor()->create(PERIOD960));
        	        	        get_psrstate()->get_treeAdaptor()->addChild(root_0, PERIOD960_tree);
        	        	        }


        	        	        this->followPush(FOLLOW_general_element_part_in_standard_function13209);
        	        	        general_element_part961=general_element_part();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, general_element_part961.tree);


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 17:
        	    // OracleDML.g:1227:10: xmlelement_key ^ LEFT_PAREN ( entityescaping_key | noentityescaping_key )? ( name_key | evalname_key )? expression_wrapper ({...}? COMMA ! xml_attributes_clause )? ( COMMA ! expression_wrapper ( column_alias )? )* RIGHT_PAREN ( PERIOD general_element_part )?
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_xmlelement_key_in_standard_function13222);
        	        xmlelement_key962=xmlelement_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(xmlelement_key962.tree, root_0);

        	        LEFT_PAREN963 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_standard_function13237);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) {
        	        LEFT_PAREN963_tree = std::move(get_psrstate()->get_treeAdaptor()->create(LEFT_PAREN963));
        	        get_psrstate()->get_treeAdaptor()->addChild(root_0, LEFT_PAREN963_tree);
        	        }


        	        // OracleDML.g:1229:17: ( entityescaping_key | noentityescaping_key )?
        	        {
        	            ANTLR_UINT32 alt313=3;
        	            switch ( this->LA(1) )
        	            {
        	                case REGULAR_ID:
        	                	{
        	                		{
        	                		    ANTLR_UINT32 LA313_1 = this->LA(2);
        	                		    if ( ((toUpper(LT(1)->getText()) == "ENTITYESCAPING")))
        	                		    {
        	                		        alt313=1;
        	                		    }
        	                		    else if ( ((toUpper(LT(1)->getText()) == "NOENTITYESCAPING")))
        	                		    {
        	                		        alt313=2;
        	                		    }
        	                		}
        	                	}
        	                    break;
        	            }

        	            switch (alt313)
        	            {
        	        	case 1:
        	        	    // OracleDML.g:1229:18: entityescaping_key
        	        	    {
        	        	        this->followPush(FOLLOW_entityescaping_key_in_standard_function13256);
        	        	        entityescaping_key964=entityescaping_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, entityescaping_key964.tree);


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // OracleDML.g:1229:37: noentityescaping_key
        	        	    {
        	        	        this->followPush(FOLLOW_noentityescaping_key_in_standard_function13258);
        	        	        noentityescaping_key965=noentityescaping_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, noentityescaping_key965.tree);


        	        	    }
        	        	    break;

        	            }
        	        }

        	        // OracleDML.g:1230:17: ( name_key | evalname_key )?
        	        {
        	            ANTLR_UINT32 alt314=3;
        	            switch ( this->LA(1) )
        	            {
        	                case REGULAR_ID:
        	                	{
        	                		{
        	                		    ANTLR_UINT32 LA314_1 = this->LA(2);
        	                		    if ( ((toUpper(LT(1)->getText()) == "NAME")))
        	                		    {
        	                		        alt314=1;
        	                		    }
        	                		    else if ( ((toUpper(LT(1)->getText()) == "EVALNAME")))
        	                		    {
        	                		        alt314=2;
        	                		    }
        	                		}
        	                	}
        	                    break;
        	            }

        	            switch (alt314)
        	            {
        	        	case 1:
        	        	    // OracleDML.g:1230:18: name_key
        	        	    {
        	        	        this->followPush(FOLLOW_name_key_in_standard_function13279);
        	        	        name_key966=name_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, name_key966.tree);


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // OracleDML.g:1230:27: evalname_key
        	        	    {
        	        	        this->followPush(FOLLOW_evalname_key_in_standard_function13281);
        	        	        evalname_key967=evalname_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, evalname_key967.tree);


        	        	    }
        	        	    break;

        	            }
        	        }

        	        this->followPush(FOLLOW_expression_wrapper_in_standard_function13285);
        	        expression_wrapper968=expression_wrapper();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, expression_wrapper968.tree);


        	        // OracleDML.g:1231:17: ({...}? COMMA ! xml_attributes_clause )?
        	        {
        	            ANTLR_UINT32 alt315=2;
        	            switch ( this->LA(1) )
        	            {
        	                case COMMA:
        	                	{
        	                		{
        	                		    ANTLR_UINT32 LA315_1 = this->LA(2);
        	                		    if ( ((LT(2)->getText() == "XMLATTRIBUTES")))
        	                		    {
        	                		        alt315=1;
        	                		    }
        	                		}
        	                	}
        	                    break;
        	            }

        	            switch (alt315)
        	            {
        	        	case 1:
        	        	    // OracleDML.g:1231:18: {...}? COMMA ! xml_attributes_clause
        	        	    {
        	        	        if ( !((LT(2)->getText() == "XMLATTRIBUTES")) )
        	        	        {
        	        	            if (this->get_backtracking()>0)
        	        	            {
        	        	                this->set_failedflag( true );
        	        	                return retval;
        	        	            }

        	        	            	ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "LT(2)->getText() == \"XMLATTRIBUTES\"" );
        	        	                ex->set_ruleName( "standard_function" );


        	        	        }

        	        	        COMMA969 =  this->matchToken(COMMA, &FOLLOW_COMMA_in_standard_function13306);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }


        	        	        this->followPush(FOLLOW_xml_attributes_clause_in_standard_function13309);
        	        	        xml_attributes_clause970=xml_attributes_clause();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, xml_attributes_clause970.tree);


        	        	    }
        	        	    break;

        	            }
        	        }

        	        // OracleDML.g:1232:17: ( COMMA ! expression_wrapper ( column_alias )? )*

        	        for (;;)
        	        {
        	            ANTLR_UINT32 alt317=2;
        	            switch ( this->LA(1) )
        	            {
        	            case COMMA:
        	            	{
        	            		alt317=1;
        	            	}
        	                break;

        	            }

        	            switch (alt317)
        	            {
        	        	case 1:
        	        	    // OracleDML.g:1232:18: COMMA ! expression_wrapper ( column_alias )?
        	        	    {
        	        	        COMMA971 =  this->matchToken(COMMA, &FOLLOW_COMMA_in_standard_function13330);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }


        	        	        this->followPush(FOLLOW_expression_wrapper_in_standard_function13333);
        	        	        expression_wrapper972=expression_wrapper();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, expression_wrapper972.tree);


        	        	        // OracleDML.g:1232:44: ( column_alias )?
        	        	        {
        	        	            ANTLR_UINT32 alt316=2;
        	        	            switch ( this->LA(1) )
        	        	            {
        	        	                case CHAR_STRING:
        	        	                case CHAR_STRING_PERL:
        	        	                case DELIMITED_ID:
        	        	                case INTRODUCER:
        	        	                case NATIONAL_CHAR_STRING_LIT:
        	        	                case REGULAR_ID:
        	        	                case SQL92_RESERVED_AS:
        	        	                	{
        	        	                		alt316=1;
        	        	                	}
        	        	                    break;
        	        	            }

        	        	            switch (alt316)
        	        	            {
        	        	        	case 1:
        	        	        	    // OracleDML.g:1232:44: column_alias
        	        	        	    {
        	        	        	        this->followPush(FOLLOW_column_alias_in_standard_function13335);
        	        	        	        column_alias973=column_alias();

        	        	        	        this->followPop();
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto rulestandard_functionEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return retval;
        	        	        	        }

        	        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, column_alias973.tree);


        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop317;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop317: ; /* Jump out to here if this rule does not match */


        	        RIGHT_PAREN974 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_standard_function13352);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) {
        	        RIGHT_PAREN974_tree = std::move(get_psrstate()->get_treeAdaptor()->create(RIGHT_PAREN974));
        	        get_psrstate()->get_treeAdaptor()->addChild(root_0, RIGHT_PAREN974_tree);
        	        }


        	        // OracleDML.g:1234:13: ( PERIOD general_element_part )?
        	        {
        	            ANTLR_UINT32 alt318=2;
        	            switch ( this->LA(1) )
        	            {
        	                case PERIOD:
        	                	{
        	                		alt318=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt318)
        	            {
        	        	case 1:
        	        	    // OracleDML.g:1234:14: PERIOD general_element_part
        	        	    {
        	        	        PERIOD975 =  this->matchToken(PERIOD, &FOLLOW_PERIOD_in_standard_function13367);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) {
        	        	        PERIOD975_tree = std::move(get_psrstate()->get_treeAdaptor()->create(PERIOD975));
        	        	        get_psrstate()->get_treeAdaptor()->addChild(root_0, PERIOD975_tree);
        	        	        }


        	        	        this->followPush(FOLLOW_general_element_part_in_standard_function13369);
        	        	        general_element_part976=general_element_part();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, general_element_part976.tree);


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 18:
        	    // OracleDML.g:1235:10: xmlexists_key ^ LEFT_PAREN expression_wrapper ( xml_passing_clause )? RIGHT_PAREN
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_xmlexists_key_in_standard_function13382);
        	        xmlexists_key977=xmlexists_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(xmlexists_key977.tree, root_0);

        	        LEFT_PAREN978 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_standard_function13397);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) {
        	        LEFT_PAREN978_tree = std::move(get_psrstate()->get_treeAdaptor()->create(LEFT_PAREN978));
        	        get_psrstate()->get_treeAdaptor()->addChild(root_0, LEFT_PAREN978_tree);
        	        }


        	        this->followPush(FOLLOW_expression_wrapper_in_standard_function13415);
        	        expression_wrapper979=expression_wrapper();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, expression_wrapper979.tree);


        	        // OracleDML.g:1238:17: ( xml_passing_clause )?
        	        {
        	            ANTLR_UINT32 alt319=2;
        	            {
        	                ANTLR_UINT32 LA319_0 = this->LA(1);
        	                if ( (LA319_0 == REGULAR_ID) && ((toUpper(LT(1)->getText()) == "PASSING")))
        	                {
        	                    alt319=1;
        	                }
        	            }
        	            switch (alt319)
        	            {
        	        	case 1:
        	        	    // OracleDML.g:1238:17: xml_passing_clause
        	        	    {
        	        	        this->followPush(FOLLOW_xml_passing_clause_in_standard_function13433);
        	        	        xml_passing_clause980=xml_passing_clause();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, xml_passing_clause980.tree);


        	        	    }
        	        	    break;

        	            }
        	        }

        	        RIGHT_PAREN981 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_standard_function13448);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) {
        	        RIGHT_PAREN981_tree = std::move(get_psrstate()->get_treeAdaptor()->create(RIGHT_PAREN981));
        	        get_psrstate()->get_treeAdaptor()->addChild(root_0, RIGHT_PAREN981_tree);
        	        }


        	    }
        	    break;
        	case 19:
        	    // OracleDML.g:1240:10: xmlparse_key ^ LEFT_PAREN ( document_key | content_key ) concatenation_wrapper ( wellformed_key )? RIGHT_PAREN ( PERIOD general_element_part )?
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_xmlparse_key_in_standard_function13459);
        	        xmlparse_key982=xmlparse_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(xmlparse_key982.tree, root_0);

        	        LEFT_PAREN983 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_standard_function13474);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) {
        	        LEFT_PAREN983_tree = std::move(get_psrstate()->get_treeAdaptor()->create(LEFT_PAREN983));
        	        get_psrstate()->get_treeAdaptor()->addChild(root_0, LEFT_PAREN983_tree);
        	        }


        	        // OracleDML.g:1242:17: ( document_key | content_key )
        	        {
        	            ANTLR_UINT32 alt320=2;
        	            {
        	                ANTLR_UINT32 LA320_0 = this->LA(1);
        	                if ( (LA320_0 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "CONTENT"))||((toUpper(LT(1)->getText()) == "DOCUMENT")))))
        	                {
        	                    {
        	                        ANTLR_UINT32 LA320_1 = this->LA(2);
        	                        if ( ((toUpper(LT(1)->getText()) == "DOCUMENT")))
        	                        {
        	                            alt320=1;
        	                        }
        	                        else if ( ((toUpper(LT(1)->getText()) == "CONTENT")))
        	                        {
        	                            alt320=2;
        	                        }
        	                        else
        	                        {
        	                            if (this->get_backtracking()>0)
        	                            {
        	                                this->set_failedflag( true );
        	                                return retval;
        	                            }


        	                            ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                            ex->set_decisionNum( 320 );
        	                            ex->set_state( 1 );


        	                            goto rulestandard_functionEx;

        	                        }
        	                    }
        	                }
        	                else
        	                {
        	                    if (this->get_backtracking()>0)
        	                    {
        	                        this->set_failedflag( true );
        	                        return retval;
        	                    }


        	                    ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                    ex->set_decisionNum( 320 );
        	                    ex->set_state( 0 );


        	                    goto rulestandard_functionEx;

        	                }
        	            }
        	            switch (alt320)
        	            {
        	        	case 1:
        	        	    // OracleDML.g:1242:18: document_key
        	        	    {
        	        	        this->followPush(FOLLOW_document_key_in_standard_function13494);
        	        	        document_key984=document_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, document_key984.tree);


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // OracleDML.g:1242:31: content_key
        	        	    {
        	        	        this->followPush(FOLLOW_content_key_in_standard_function13496);
        	        	        content_key985=content_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, content_key985.tree);


        	        	    }
        	        	    break;

        	            }
        	        }

        	        this->followPush(FOLLOW_concatenation_wrapper_in_standard_function13499);
        	        concatenation_wrapper986=concatenation_wrapper();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, concatenation_wrapper986.tree);


        	        // OracleDML.g:1242:66: ( wellformed_key )?
        	        {
        	            ANTLR_UINT32 alt321=2;
        	            {
        	                ANTLR_UINT32 LA321_0 = this->LA(1);
        	                if ( (LA321_0 == REGULAR_ID) && ((toUpper(LT(1)->getText()) == "WELLFORMED")))
        	                {
        	                    alt321=1;
        	                }
        	            }
        	            switch (alt321)
        	            {
        	        	case 1:
        	        	    // OracleDML.g:1242:66: wellformed_key
        	        	    {
        	        	        this->followPush(FOLLOW_wellformed_key_in_standard_function13501);
        	        	        wellformed_key987=wellformed_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, wellformed_key987.tree);


        	        	    }
        	        	    break;

        	            }
        	        }

        	        RIGHT_PAREN988 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_standard_function13516);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) {
        	        RIGHT_PAREN988_tree = std::move(get_psrstate()->get_treeAdaptor()->create(RIGHT_PAREN988));
        	        get_psrstate()->get_treeAdaptor()->addChild(root_0, RIGHT_PAREN988_tree);
        	        }


        	        // OracleDML.g:1244:13: ( PERIOD general_element_part )?
        	        {
        	            ANTLR_UINT32 alt322=2;
        	            switch ( this->LA(1) )
        	            {
        	                case PERIOD:
        	                	{
        	                		alt322=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt322)
        	            {
        	        	case 1:
        	        	    // OracleDML.g:1244:14: PERIOD general_element_part
        	        	    {
        	        	        PERIOD989 =  this->matchToken(PERIOD, &FOLLOW_PERIOD_in_standard_function13531);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) {
        	        	        PERIOD989_tree = std::move(get_psrstate()->get_treeAdaptor()->create(PERIOD989));
        	        	        get_psrstate()->get_treeAdaptor()->addChild(root_0, PERIOD989_tree);
        	        	        }


        	        	        this->followPush(FOLLOW_general_element_part_in_standard_function13533);
        	        	        general_element_part990=general_element_part();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, general_element_part990.tree);


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 20:
        	    // OracleDML.g:1245:10: xmlpi_key ^ LEFT_PAREN ( name_key id[T_UNKNOWN,T_USE] | evalname_key concatenation_wrapper ) ( COMMA ! concatenation_wrapper )? RIGHT_PAREN ( PERIOD general_element_part )?
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_xmlpi_key_in_standard_function13546);
        	        xmlpi_key991=xmlpi_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(xmlpi_key991.tree, root_0);

        	        LEFT_PAREN992 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_standard_function13561);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) {
        	        LEFT_PAREN992_tree = std::move(get_psrstate()->get_treeAdaptor()->create(LEFT_PAREN992));
        	        get_psrstate()->get_treeAdaptor()->addChild(root_0, LEFT_PAREN992_tree);
        	        }


        	        // OracleDML.g:1247:17: ( name_key id[T_UNKNOWN,T_USE] | evalname_key concatenation_wrapper )
        	        {
        	            ANTLR_UINT32 alt323=2;
        	            alt323 = cdfa323.predict(this, this->get_rec(), this->get_istream(), cdfa323 );
        	            if  (this->hasException())
        	            {
        	                goto rulestandard_functionEx;
        	            }
        	            if (this->hasFailed())
        	            {
        	                return retval;
        	            }

        	            switch (alt323)
        	            {
        	        	case 1:
        	        	    // OracleDML.g:1247:22: name_key id[T_UNKNOWN,T_USE]
        	        	    {
        	        	        this->followPush(FOLLOW_name_key_in_standard_function13585);
        	        	        name_key993=name_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, name_key993.tree);


        	        	        this->followPush(FOLLOW_id_in_standard_function13587);
        	        	        id994=id(T_UNKNOWN, T_USE);

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, id994.tree);


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // OracleDML.g:1248:22: evalname_key concatenation_wrapper
        	        	    {
        	        	        this->followPush(FOLLOW_evalname_key_in_standard_function13611);
        	        	        evalname_key995=evalname_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, evalname_key995.tree);


        	        	        this->followPush(FOLLOW_concatenation_wrapper_in_standard_function13613);
        	        	        concatenation_wrapper996=concatenation_wrapper();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, concatenation_wrapper996.tree);


        	        	    }
        	        	    break;

        	            }
        	        }

        	        // OracleDML.g:1250:17: ( COMMA ! concatenation_wrapper )?
        	        {
        	            ANTLR_UINT32 alt324=2;
        	            switch ( this->LA(1) )
        	            {
        	                case COMMA:
        	                	{
        	                		alt324=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt324)
        	            {
        	        	case 1:
        	        	    // OracleDML.g:1250:18: COMMA ! concatenation_wrapper
        	        	    {
        	        	        COMMA997 =  this->matchToken(COMMA, &FOLLOW_COMMA_in_standard_function13650);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }


        	        	        this->followPush(FOLLOW_concatenation_wrapper_in_standard_function13653);
        	        	        concatenation_wrapper998=concatenation_wrapper();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, concatenation_wrapper998.tree);


        	        	    }
        	        	    break;

        	            }
        	        }

        	        RIGHT_PAREN999 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_standard_function13669);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) {
        	        RIGHT_PAREN999_tree = std::move(get_psrstate()->get_treeAdaptor()->create(RIGHT_PAREN999));
        	        get_psrstate()->get_treeAdaptor()->addChild(root_0, RIGHT_PAREN999_tree);
        	        }


        	        // OracleDML.g:1252:13: ( PERIOD general_element_part )?
        	        {
        	            ANTLR_UINT32 alt325=2;
        	            switch ( this->LA(1) )
        	            {
        	                case PERIOD:
        	                	{
        	                		alt325=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt325)
        	            {
        	        	case 1:
        	        	    // OracleDML.g:1252:14: PERIOD general_element_part
        	        	    {
        	        	        PERIOD1000 =  this->matchToken(PERIOD, &FOLLOW_PERIOD_in_standard_function13684);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) {
        	        	        PERIOD1000_tree = std::move(get_psrstate()->get_treeAdaptor()->create(PERIOD1000));
        	        	        get_psrstate()->get_treeAdaptor()->addChild(root_0, PERIOD1000_tree);
        	        	        }


        	        	        this->followPush(FOLLOW_general_element_part_in_standard_function13686);
        	        	        general_element_part1001=general_element_part();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, general_element_part1001.tree);


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 21:
        	    // OracleDML.g:1253:10: xmlquery_key ^ LEFT_PAREN concatenation_wrapper ( xml_passing_clause )? returning_key ! content_key ! ( null_key on_key ! empty_key !)? RIGHT_PAREN ( PERIOD general_element_part )?
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_xmlquery_key_in_standard_function13699);
        	        xmlquery_key1002=xmlquery_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(xmlquery_key1002.tree, root_0);

        	        LEFT_PAREN1003 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_standard_function13714);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) {
        	        LEFT_PAREN1003_tree = std::move(get_psrstate()->get_treeAdaptor()->create(LEFT_PAREN1003));
        	        get_psrstate()->get_treeAdaptor()->addChild(root_0, LEFT_PAREN1003_tree);
        	        }


        	        this->followPush(FOLLOW_concatenation_wrapper_in_standard_function13733);
        	        concatenation_wrapper1004=concatenation_wrapper();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, concatenation_wrapper1004.tree);


        	        // OracleDML.g:1255:39: ( xml_passing_clause )?
        	        {
        	            ANTLR_UINT32 alt326=2;
        	            {
        	                ANTLR_UINT32 LA326_0 = this->LA(1);
        	                if ( (LA326_0 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "PASSING"))||((toUpper(LT(1)->getText()) == "RETURNING")))))
        	                {
        	                    {
        	                        ANTLR_UINT32 LA326_1 = this->LA(2);
        	                        if ( (LA326_1 == APPROXIMATE_NUM_LIT || LA326_1 == BINDVAR || ((LA326_1 >= CHAR_STRING) && (LA326_1 <= CHAR_STRING_PERL)) || LA326_1 == COLON || LA326_1 == DELIMITED_ID || LA326_1 == EXACT_NUM_LIT || LA326_1 == INTRODUCER || LA326_1 == LEFT_PAREN || LA326_1 == MINUS_SIGN || LA326_1 == NATIONAL_CHAR_STRING_LIT || ((LA326_1 >= PLSQL_NON_RESERVED_CAST) && (LA326_1 <= PLSQL_NON_RESERVED_CONNECT_BY_ROOT)) || LA326_1 == PLUS_SIGN || LA326_1 == SQL92_RESERVED_ALL || LA326_1 == SQL92_RESERVED_ANY || ((LA326_1 >= SQL92_RESERVED_BY) && (LA326_1 <= SQL92_RESERVED_CASE)) || ((LA326_1 >= SQL92_RESERVED_CURSOR) && (LA326_1 <= SQL92_RESERVED_DATE)) || LA326_1 == SQL92_RESERVED_DEFAULT || LA326_1 == SQL92_RESERVED_DISTINCT || ((LA326_1 >= SQL92_RESERVED_EXISTS) && (LA326_1 <= SQL92_RESERVED_FALSE)) || ((LA326_1 >= SQL92_RESERVED_NOT) && (LA326_1 <= SQL92_RESERVED_NULL)) || LA326_1 == SQL92_RESERVED_PRIOR || LA326_1 == SQL92_RESERVED_TRUE || LA326_1 == UNSIGNED_INTEGER) && ((toUpper(LT(1)->getText()) == "PASSING")))
        	                        {
        	                            alt326=1;
        	                        }
        	                        else if ( (LA326_1 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "PASSING"))||((toUpper(LT(1)->getText()) == "RETURNING")))))
        	                        {
        	                            {
        	                                ANTLR_UINT32 LA326_3 = this->LA(3);
        	                                if ( (LA326_3 == APPROXIMATE_NUM_LIT || LA326_3 == ASTERISK || LA326_3 == BINDVAR || LA326_3 == CARRET_OPERATOR_PART || ((LA326_3 >= CHAR_STRING) && (LA326_3 <= CHAR_STRING_PERL)) || LA326_3 == COLON || LA326_3 == COMMA || LA326_3 == CONCATENATION_OP || LA326_3 == DELIMITED_ID || LA326_3 == EQUALS_OP || LA326_3 == EXACT_NUM_LIT || LA326_3 == EXCLAMATION_OPERATOR_PART || ((LA326_3 >= GREATER_THAN_OP) && (LA326_3 <= GREATER_THAN_OR_EQUALS_OP)) || LA326_3 == INTRODUCER || ((LA326_3 >= LEFT_BRACKET) && (LA326_3 <= LEFT_PAREN)) || ((LA326_3 >= LESS_THAN_OP) && (LA326_3 <= LESS_THAN_OR_EQUALS_OP)) || LA326_3 == MINUS_SIGN || LA326_3 == NATIONAL_CHAR_STRING_LIT || LA326_3 == NOT_EQUAL_OP || LA326_3 == PERIOD || ((LA326_3 >= PLSQL_NON_RESERVED_CAST) && (LA326_3 <= PLSQL_NON_RESERVED_CONNECT_BY_ROOT)) || LA326_3 == PLSQL_NON_RESERVED_MULTISET || LA326_3 == PLUS_SIGN || LA326_3 == REGULAR_ID || LA326_3 == SOLIDUS || LA326_3 == SQL92_RESERVED_ALL || ((LA326_3 >= SQL92_RESERVED_AND) && (LA326_3 <= SQL92_RESERVED_AS)) || LA326_3 == SQL92_RESERVED_BETWEEN || LA326_3 == SQL92_RESERVED_CASE || LA326_3 == SQL92_RESERVED_DATE || LA326_3 == SQL92_RESERVED_DEFAULT || LA326_3 == SQL92_RESERVED_DISTINCT || ((LA326_3 >= SQL92_RESERVED_EXISTS) && (LA326_3 <= SQL92_RESERVED_FALSE)) || LA326_3 == SQL92_RESERVED_IN || ((LA326_3 >= SQL92_RESERVED_IS) && (LA326_3 <= SQL92_RESERVED_NOT)) || LA326_3 == SQL92_RESERVED_OR || LA326_3 == SQL92_RESERVED_PRIOR || LA326_3 == SQL92_RESERVED_TRUE || LA326_3 == UNSIGNED_INTEGER || LA326_3 == VERTICAL_BAR) && ((toUpper(LT(1)->getText()) == "PASSING")))
        	                                {
        	                                    alt326=1;
        	                                }
        	                                else if ( (LA326_3 == SQL92_RESERVED_NULL) && ((((toUpper(LT(1)->getText()) == "PASSING"))||((toUpper(LT(1)->getText()) == "RETURNING")))))
        	                                {
        	                                    {
        	                                        ANTLR_UINT32 LA326_4 = this->LA(4);
        	                                        if ( (LA326_4 == ASTERISK || LA326_4 == CARRET_OPERATOR_PART || ((LA326_4 >= CHAR_STRING) && (LA326_4 <= CHAR_STRING_PERL)) || LA326_4 == COMMA || LA326_4 == CONCATENATION_OP || LA326_4 == DELIMITED_ID || LA326_4 == EQUALS_OP || LA326_4 == EXCLAMATION_OPERATOR_PART || ((LA326_4 >= GREATER_THAN_OP) && (LA326_4 <= GREATER_THAN_OR_EQUALS_OP)) || LA326_4 == INTRODUCER || LA326_4 == LEFT_BRACKET || ((LA326_4 >= LESS_THAN_OP) && (LA326_4 <= LESS_THAN_OR_EQUALS_OP)) || LA326_4 == MINUS_SIGN || LA326_4 == NATIONAL_CHAR_STRING_LIT || LA326_4 == NOT_EQUAL_OP || LA326_4 == PLSQL_NON_RESERVED_MULTISET || LA326_4 == PLUS_SIGN || LA326_4 == REGULAR_ID || LA326_4 == SOLIDUS || LA326_4 == SQL92_RESERVED_AND || LA326_4 == SQL92_RESERVED_AS || LA326_4 == SQL92_RESERVED_BETWEEN || LA326_4 == SQL92_RESERVED_IN || ((LA326_4 >= SQL92_RESERVED_IS) && (LA326_4 <= SQL92_RESERVED_NOT)) || LA326_4 == SQL92_RESERVED_OR || LA326_4 == VERTICAL_BAR) && ((toUpper(LT(1)->getText()) == "PASSING")))
        	                                        {
        	                                            alt326=1;
        	                                        }
        	                                    }
        	                                }
        	                            }
        	                        }
        	                    }
        	                }
        	            }
        	            switch (alt326)
        	            {
        	        	case 1:
        	        	    // OracleDML.g:1255:39: xml_passing_clause
        	        	    {
        	        	        this->followPush(FOLLOW_xml_passing_clause_in_standard_function13735);
        	        	        xml_passing_clause1005=xml_passing_clause();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, xml_passing_clause1005.tree);


        	        	    }
        	        	    break;

        	            }
        	        }

        	        this->followPush(FOLLOW_returning_key_in_standard_function13754);
        	        returning_key1006=returning_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }


        	        this->followPush(FOLLOW_content_key_in_standard_function13757);
        	        content_key1007=content_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }


        	        // OracleDML.g:1256:45: ( null_key on_key ! empty_key !)?
        	        {
        	            ANTLR_UINT32 alt327=2;
        	            switch ( this->LA(1) )
        	            {
        	                case SQL92_RESERVED_NULL:
        	                	{
        	                		alt327=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt327)
        	            {
        	        	case 1:
        	        	    // OracleDML.g:1256:46: null_key on_key ! empty_key !
        	        	    {
        	        	        this->followPush(FOLLOW_null_key_in_standard_function13761);
        	        	        null_key1008=null_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, null_key1008.tree);


        	        	        this->followPush(FOLLOW_on_key_in_standard_function13763);
        	        	        on_key1009=on_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }


        	        	        this->followPush(FOLLOW_empty_key_in_standard_function13766);
        	        	        empty_key1010=empty_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        RIGHT_PAREN1011 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_standard_function13783);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) {
        	        RIGHT_PAREN1011_tree = std::move(get_psrstate()->get_treeAdaptor()->create(RIGHT_PAREN1011));
        	        get_psrstate()->get_treeAdaptor()->addChild(root_0, RIGHT_PAREN1011_tree);
        	        }


        	        // OracleDML.g:1258:13: ( PERIOD general_element_part )?
        	        {
        	            ANTLR_UINT32 alt328=2;
        	            switch ( this->LA(1) )
        	            {
        	                case PERIOD:
        	                	{
        	                		alt328=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt328)
        	            {
        	        	case 1:
        	        	    // OracleDML.g:1258:14: PERIOD general_element_part
        	        	    {
        	        	        PERIOD1012 =  this->matchToken(PERIOD, &FOLLOW_PERIOD_in_standard_function13798);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) {
        	        	        PERIOD1012_tree = std::move(get_psrstate()->get_treeAdaptor()->create(PERIOD1012));
        	        	        get_psrstate()->get_treeAdaptor()->addChild(root_0, PERIOD1012_tree);
        	        	        }


        	        	        this->followPush(FOLLOW_general_element_part_in_standard_function13800);
        	        	        general_element_part1013=general_element_part();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, general_element_part1013.tree);


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 22:
        	    // OracleDML.g:1259:10: xmlroot_key ^ LEFT_PAREN concatenation_wrapper xmlroot_param_version_part ( COMMA ! xmlroot_param_standalone_part )? RIGHT_PAREN ( PERIOD general_element_part )?
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_xmlroot_key_in_standard_function13813);
        	        xmlroot_key1014=xmlroot_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(xmlroot_key1014.tree, root_0);

        	        LEFT_PAREN1015 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_standard_function13828);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) {
        	        LEFT_PAREN1015_tree = std::move(get_psrstate()->get_treeAdaptor()->create(LEFT_PAREN1015));
        	        get_psrstate()->get_treeAdaptor()->addChild(root_0, LEFT_PAREN1015_tree);
        	        }


        	        this->followPush(FOLLOW_concatenation_wrapper_in_standard_function13846);
        	        concatenation_wrapper1016=concatenation_wrapper();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, concatenation_wrapper1016.tree);


        	        this->followPush(FOLLOW_xmlroot_param_version_part_in_standard_function13868);
        	        xmlroot_param_version_part1017=xmlroot_param_version_part();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, xmlroot_param_version_part1017.tree);


        	        // OracleDML.g:1263:21: ( COMMA ! xmlroot_param_standalone_part )?
        	        {
        	            ANTLR_UINT32 alt329=2;
        	            switch ( this->LA(1) )
        	            {
        	                case COMMA:
        	                	{
        	                		alt329=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt329)
        	            {
        	        	case 1:
        	        	    // OracleDML.g:1263:22: COMMA ! xmlroot_param_standalone_part
        	        	    {
        	        	        COMMA1018 =  this->matchToken(COMMA, &FOLLOW_COMMA_in_standard_function13891);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }


        	        	        this->followPush(FOLLOW_xmlroot_param_standalone_part_in_standard_function13894);
        	        	        xmlroot_param_standalone_part1019=xmlroot_param_standalone_part();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, xmlroot_param_standalone_part1019.tree);


        	        	    }
        	        	    break;

        	            }
        	        }

        	        RIGHT_PAREN1020 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_standard_function13910);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) {
        	        RIGHT_PAREN1020_tree = std::move(get_psrstate()->get_treeAdaptor()->create(RIGHT_PAREN1020));
        	        get_psrstate()->get_treeAdaptor()->addChild(root_0, RIGHT_PAREN1020_tree);
        	        }


        	        // OracleDML.g:1265:13: ( PERIOD general_element_part )?
        	        {
        	            ANTLR_UINT32 alt330=2;
        	            switch ( this->LA(1) )
        	            {
        	                case PERIOD:
        	                	{
        	                		alt330=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt330)
        	            {
        	        	case 1:
        	        	    // OracleDML.g:1265:14: PERIOD general_element_part
        	        	    {
        	        	        PERIOD1021 =  this->matchToken(PERIOD, &FOLLOW_PERIOD_in_standard_function13925);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) {
        	        	        PERIOD1021_tree = std::move(get_psrstate()->get_treeAdaptor()->create(PERIOD1021));
        	        	        get_psrstate()->get_treeAdaptor()->addChild(root_0, PERIOD1021_tree);
        	        	        }


        	        	        this->followPush(FOLLOW_general_element_part_in_standard_function13927);
        	        	        general_element_part1022=general_element_part();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, general_element_part1022.tree);


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 23:
        	    // OracleDML.g:1266:10: xmlserialize_key ^ LEFT_PAREN ( document_key | content_key ) concatenation_wrapper ( as_key ! type_spec )? ( xmlserialize_param_enconding_part )? ( xmlserialize_param_version_part )? ( xmlserialize_param_ident_part )? ( ( hide_key | show_key ) defaults_key )? RIGHT_PAREN ( PERIOD general_element_part )?
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_xmlserialize_key_in_standard_function13940);
        	        xmlserialize_key1023=xmlserialize_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(xmlserialize_key1023.tree, root_0);

        	        LEFT_PAREN1024 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_standard_function13955);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) {
        	        LEFT_PAREN1024_tree = std::move(get_psrstate()->get_treeAdaptor()->create(LEFT_PAREN1024));
        	        get_psrstate()->get_treeAdaptor()->addChild(root_0, LEFT_PAREN1024_tree);
        	        }


        	        // OracleDML.g:1268:17: ( document_key | content_key )
        	        {
        	            ANTLR_UINT32 alt331=2;
        	            {
        	                ANTLR_UINT32 LA331_0 = this->LA(1);
        	                if ( (LA331_0 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "CONTENT"))||((toUpper(LT(1)->getText()) == "DOCUMENT")))))
        	                {
        	                    {
        	                        ANTLR_UINT32 LA331_1 = this->LA(2);
        	                        if ( ((toUpper(LT(1)->getText()) == "DOCUMENT")))
        	                        {
        	                            alt331=1;
        	                        }
        	                        else if ( ((toUpper(LT(1)->getText()) == "CONTENT")))
        	                        {
        	                            alt331=2;
        	                        }
        	                        else
        	                        {
        	                            if (this->get_backtracking()>0)
        	                            {
        	                                this->set_failedflag( true );
        	                                return retval;
        	                            }


        	                            ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                            ex->set_decisionNum( 331 );
        	                            ex->set_state( 1 );


        	                            goto rulestandard_functionEx;

        	                        }
        	                    }
        	                }
        	                else
        	                {
        	                    if (this->get_backtracking()>0)
        	                    {
        	                        this->set_failedflag( true );
        	                        return retval;
        	                    }


        	                    ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                    ex->set_decisionNum( 331 );
        	                    ex->set_state( 0 );


        	                    goto rulestandard_functionEx;

        	                }
        	            }
        	            switch (alt331)
        	            {
        	        	case 1:
        	        	    // OracleDML.g:1268:18: document_key
        	        	    {
        	        	        this->followPush(FOLLOW_document_key_in_standard_function13974);
        	        	        document_key1025=document_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, document_key1025.tree);


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // OracleDML.g:1268:31: content_key
        	        	    {
        	        	        this->followPush(FOLLOW_content_key_in_standard_function13976);
        	        	        content_key1026=content_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, content_key1026.tree);


        	        	    }
        	        	    break;

        	            }
        	        }

        	        this->followPush(FOLLOW_concatenation_wrapper_in_standard_function13995);
        	        concatenation_wrapper1027=concatenation_wrapper();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, concatenation_wrapper1027.tree);


        	        // OracleDML.g:1269:39: ( as_key ! type_spec )?
        	        {
        	            ANTLR_UINT32 alt332=2;
        	            switch ( this->LA(1) )
        	            {
        	                case SQL92_RESERVED_AS:
        	                	{
        	                		alt332=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt332)
        	            {
        	        	case 1:
        	        	    // OracleDML.g:1269:40: as_key ! type_spec
        	        	    {
        	        	        this->followPush(FOLLOW_as_key_in_standard_function13998);
        	        	        as_key1028=as_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }


        	        	        this->followPush(FOLLOW_type_spec_in_standard_function14001);
        	        	        type_spec1029=type_spec();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, type_spec1029.tree);


        	        	    }
        	        	    break;

        	            }
        	        }

        	        // OracleDML.g:1270:17: ( xmlserialize_param_enconding_part )?
        	        {
        	            ANTLR_UINT32 alt333=2;
        	            {
        	                ANTLR_UINT32 LA333_0 = this->LA(1);
        	                if ( (LA333_0 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "HIDE"))||((toUpper(LT(1)->getText()) == "INDENT"))||((toUpper(LT(1)->getText()) == "SHOW"))||((toUpper(LT(1)->getText()) == "VERSION"))||((toUpper(LT(1)->getText()) == "ENCODING"))||((toUpper(LT(1)->getText()) == "NO")))))
        	                {
        	                    {
        	                        ANTLR_UINT32 LA333_1 = this->LA(2);
        	                        if ( ((toUpper(LT(1)->getText()) == "ENCODING")))
        	                        {
        	                            alt333=1;
        	                        }
        	                    }
        	                }
        	            }
        	            switch (alt333)
        	            {
        	        	case 1:
        	        	    // OracleDML.g:1270:17: xmlserialize_param_enconding_part
        	        	    {
        	        	        this->followPush(FOLLOW_xmlserialize_param_enconding_part_in_standard_function14021);
        	        	        xmlserialize_param_enconding_part1030=xmlserialize_param_enconding_part();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, xmlserialize_param_enconding_part1030.tree);


        	        	    }
        	        	    break;

        	            }
        	        }

        	        // OracleDML.g:1271:17: ( xmlserialize_param_version_part )?
        	        {
        	            ANTLR_UINT32 alt334=2;
        	            {
        	                ANTLR_UINT32 LA334_0 = this->LA(1);
        	                if ( (LA334_0 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "INDENT"))||((toUpper(LT(1)->getText()) == "HIDE"))||((toUpper(LT(1)->getText()) == "SHOW"))||((toUpper(LT(1)->getText()) == "VERSION"))||((toUpper(LT(1)->getText()) == "NO")))))
        	                {
        	                    {
        	                        ANTLR_UINT32 LA334_1 = this->LA(2);
        	                        if ( (LA334_1 == APPROXIMATE_NUM_LIT || LA334_1 == BINDVAR || ((LA334_1 >= CHAR_STRING) && (LA334_1 <= CHAR_STRING_PERL)) || LA334_1 == COLON || LA334_1 == DELIMITED_ID || LA334_1 == EXACT_NUM_LIT || LA334_1 == INTRODUCER || LA334_1 == LEFT_PAREN || LA334_1 == MINUS_SIGN || LA334_1 == NATIONAL_CHAR_STRING_LIT || ((LA334_1 >= PLSQL_NON_RESERVED_CAST) && (LA334_1 <= PLSQL_NON_RESERVED_CONNECT_BY_ROOT)) || LA334_1 == PLUS_SIGN || LA334_1 == SQL92_RESERVED_ALL || LA334_1 == SQL92_RESERVED_ANY || LA334_1 == SQL92_RESERVED_CASE || LA334_1 == SQL92_RESERVED_DATE || LA334_1 == SQL92_RESERVED_DEFAULT || LA334_1 == SQL92_RESERVED_DISTINCT || ((LA334_1 >= SQL92_RESERVED_EXISTS) && (LA334_1 <= SQL92_RESERVED_FALSE)) || LA334_1 == SQL92_RESERVED_NULL || LA334_1 == SQL92_RESERVED_PRIOR || LA334_1 == SQL92_RESERVED_TRUE || LA334_1 == UNSIGNED_INTEGER) && ((toUpper(LT(1)->getText()) == "VERSION")))
        	                        {
        	                            alt334=1;
        	                        }
        	                        else if ( (LA334_1 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "INDENT"))||((toUpper(LT(1)->getText()) == "HIDE"))||((toUpper(LT(1)->getText()) == "SHOW"))||((toUpper(LT(1)->getText()) == "VERSION"))||((toUpper(LT(1)->getText()) == "NO")))))
        	                        {
        	                            {
        	                                ANTLR_UINT32 LA334_4 = this->LA(3);
        	                                if ( ((toUpper(LT(1)->getText()) == "VERSION")))
        	                                {
        	                                    alt334=1;
        	                                }
        	                            }
        	                        }
        	                    }
        	                }
        	            }
        	            switch (alt334)
        	            {
        	        	case 1:
        	        	    // OracleDML.g:1271:17: xmlserialize_param_version_part
        	        	    {
        	        	        this->followPush(FOLLOW_xmlserialize_param_version_part_in_standard_function14040);
        	        	        xmlserialize_param_version_part1031=xmlserialize_param_version_part();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, xmlserialize_param_version_part1031.tree);


        	        	    }
        	        	    break;

        	            }
        	        }

        	        // OracleDML.g:1272:17: ( xmlserialize_param_ident_part )?
        	        {
        	            ANTLR_UINT32 alt335=2;
        	            {
        	                ANTLR_UINT32 LA335_0 = this->LA(1);
        	                if ( (LA335_0 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "INDENT"))||((toUpper(LT(1)->getText()) == "HIDE"))||((toUpper(LT(1)->getText()) == "SHOW"))||((toUpper(LT(1)->getText()) == "NO")))))
        	                {
        	                    {
        	                        ANTLR_UINT32 LA335_1 = this->LA(2);
        	                        if ( (LA335_1 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "INDENT"))||((toUpper(LT(1)->getText()) == "HIDE"))||((toUpper(LT(1)->getText()) == "SHOW"))||((toUpper(LT(1)->getText()) == "NO")))))
        	                        {
        	                            {
        	                                ANTLR_UINT32 LA335_3 = this->LA(3);
        	                                if ( ((((toUpper(LT(1)->getText()) == "INDENT"))||((toUpper(LT(1)->getText()) == "NO")))))
        	                                {
        	                                    alt335=1;
        	                                }
        	                            }
        	                        }
        	                        else if ( (LA335_1 == RIGHT_PAREN || LA335_1 == SQL92_RESERVED_SIZE) && ((toUpper(LT(1)->getText()) == "INDENT")))
        	                        {
        	                            alt335=1;
        	                        }
        	                    }
        	                }
        	            }
        	            switch (alt335)
        	            {
        	        	case 1:
        	        	    // OracleDML.g:1272:17: xmlserialize_param_ident_part
        	        	    {
        	        	        this->followPush(FOLLOW_xmlserialize_param_ident_part_in_standard_function14059);
        	        	        xmlserialize_param_ident_part1032=xmlserialize_param_ident_part();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, xmlserialize_param_ident_part1032.tree);


        	        	    }
        	        	    break;

        	            }
        	        }

        	        // OracleDML.g:1273:17: ( ( hide_key | show_key ) defaults_key )?
        	        {
        	            ANTLR_UINT32 alt337=2;
        	            {
        	                ANTLR_UINT32 LA337_0 = this->LA(1);
        	                if ( (LA337_0 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "HIDE"))||((toUpper(LT(1)->getText()) == "SHOW")))))
        	                {
        	                    alt337=1;
        	                }
        	            }
        	            switch (alt337)
        	            {
        	        	case 1:
        	        	    // OracleDML.g:1273:18: ( hide_key | show_key ) defaults_key
        	        	    {
        	        	        // OracleDML.g:1273:18: ( hide_key | show_key )
        	        	        {
        	        	            ANTLR_UINT32 alt336=2;
        	        	            {
        	        	                ANTLR_UINT32 LA336_0 = this->LA(1);
        	        	                if ( (LA336_0 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "HIDE"))||((toUpper(LT(1)->getText()) == "SHOW")))))
        	        	                {
        	        	                    {
        	        	                        ANTLR_UINT32 LA336_1 = this->LA(2);
        	        	                        if ( ((toUpper(LT(1)->getText()) == "HIDE")))
        	        	                        {
        	        	                            alt336=1;
        	        	                        }
        	        	                        else if ( ((toUpper(LT(1)->getText()) == "SHOW")))
        	        	                        {
        	        	                            alt336=2;
        	        	                        }
        	        	                        else
        	        	                        {
        	        	                            if (this->get_backtracking()>0)
        	        	                            {
        	        	                                this->set_failedflag( true );
        	        	                                return retval;
        	        	                            }


        	        	                            ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	        	                            ex->set_decisionNum( 336 );
        	        	                            ex->set_state( 1 );


        	        	                            goto rulestandard_functionEx;

        	        	                        }
        	        	                    }
        	        	                }
        	        	                else
        	        	                {
        	        	                    if (this->get_backtracking()>0)
        	        	                    {
        	        	                        this->set_failedflag( true );
        	        	                        return retval;
        	        	                    }


        	        	                    ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	        	                    ex->set_decisionNum( 336 );
        	        	                    ex->set_state( 0 );


        	        	                    goto rulestandard_functionEx;

        	        	                }
        	        	            }
        	        	            switch (alt336)
        	        	            {
        	        	        	case 1:
        	        	        	    // OracleDML.g:1273:19: hide_key
        	        	        	    {
        	        	        	        this->followPush(FOLLOW_hide_key_in_standard_function14080);
        	        	        	        hide_key1033=hide_key();

        	        	        	        this->followPop();
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto rulestandard_functionEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return retval;
        	        	        	        }

        	        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, hide_key1033.tree);


        	        	        	    }
        	        	        	    break;
        	        	        	case 2:
        	        	        	    // OracleDML.g:1273:28: show_key
        	        	        	    {
        	        	        	        this->followPush(FOLLOW_show_key_in_standard_function14082);
        	        	        	        show_key1034=show_key();

        	        	        	        this->followPop();
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto rulestandard_functionEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return retval;
        	        	        	        }

        	        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, show_key1034.tree);


        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	        this->followPush(FOLLOW_defaults_key_in_standard_function14085);
        	        	        defaults_key1035=defaults_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, defaults_key1035.tree);


        	        	    }
        	        	    break;

        	            }
        	        }

        	        RIGHT_PAREN1036 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_standard_function14101);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) {
        	        RIGHT_PAREN1036_tree = std::move(get_psrstate()->get_treeAdaptor()->create(RIGHT_PAREN1036));
        	        get_psrstate()->get_treeAdaptor()->addChild(root_0, RIGHT_PAREN1036_tree);
        	        }


        	        // OracleDML.g:1275:13: ( PERIOD general_element_part )?
        	        {
        	            ANTLR_UINT32 alt338=2;
        	            switch ( this->LA(1) )
        	            {
        	                case PERIOD:
        	                	{
        	                		alt338=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt338)
        	            {
        	        	case 1:
        	        	    // OracleDML.g:1275:14: PERIOD general_element_part
        	        	    {
        	        	        PERIOD1037 =  this->matchToken(PERIOD, &FOLLOW_PERIOD_in_standard_function14116);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) {
        	        	        PERIOD1037_tree = std::move(get_psrstate()->get_treeAdaptor()->create(PERIOD1037));
        	        	        get_psrstate()->get_treeAdaptor()->addChild(root_0, PERIOD1037_tree);
        	        	        }


        	        	        this->followPush(FOLLOW_general_element_part_in_standard_function14118);
        	        	        general_element_part1038=general_element_part();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, general_element_part1038.tree);


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 24:
        	    // OracleDML.g:1276:10: xmltable_key ^ LEFT_PAREN ( xml_namespaces_clause )? concatenation_wrapper ( xml_passing_clause )? ( columns_key ! xml_table_column ( COMMA ! xml_table_column ) )? RIGHT_PAREN ( PERIOD general_element_part )?
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_xmltable_key_in_standard_function14131);
        	        xmltable_key1039=xmltable_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(xmltable_key1039.tree, root_0);

        	        LEFT_PAREN1040 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_standard_function14146);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) {
        	        LEFT_PAREN1040_tree = std::move(get_psrstate()->get_treeAdaptor()->create(LEFT_PAREN1040));
        	        get_psrstate()->get_treeAdaptor()->addChild(root_0, LEFT_PAREN1040_tree);
        	        }


        	        // OracleDML.g:1278:17: ( xml_namespaces_clause )?
        	        {
        	            ANTLR_UINT32 alt339=2;
        	            switch ( this->LA(1) )
        	            {
        	                case REGULAR_ID:
        	                	{
        	                		{
        	                		    ANTLR_UINT32 LA339_1 = this->LA(2);
        	                		    if ( ((toUpper(LT(1)->getText()) == "XMLNAMESPACES")))
        	                		    {
        	                		        alt339=1;
        	                		    }
        	                		}
        	                	}
        	                    break;
        	            }

        	            switch (alt339)
        	            {
        	        	case 1:
        	        	    // OracleDML.g:1278:17: xml_namespaces_clause
        	        	    {
        	        	        this->followPush(FOLLOW_xml_namespaces_clause_in_standard_function14164);
        	        	        xml_namespaces_clause1041=xml_namespaces_clause();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, xml_namespaces_clause1041.tree);


        	        	    }
        	        	    break;

        	            }
        	        }

        	        this->followPush(FOLLOW_concatenation_wrapper_in_standard_function14183);
        	        concatenation_wrapper1042=concatenation_wrapper();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, concatenation_wrapper1042.tree);


        	        // OracleDML.g:1280:17: ( xml_passing_clause )?
        	        {
        	            ANTLR_UINT32 alt340=2;
        	            {
        	                ANTLR_UINT32 LA340_0 = this->LA(1);
        	                if ( (LA340_0 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "PASSING"))||((toUpper(LT(1)->getText()) == "COLUMNS")))))
        	                {
        	                    {
        	                        ANTLR_UINT32 LA340_1 = this->LA(2);
        	                        if ( ((toUpper(LT(1)->getText()) == "PASSING")))
        	                        {
        	                            alt340=1;
        	                        }
        	                    }
        	                }
        	            }
        	            switch (alt340)
        	            {
        	        	case 1:
        	        	    // OracleDML.g:1280:17: xml_passing_clause
        	        	    {
        	        	        this->followPush(FOLLOW_xml_passing_clause_in_standard_function14201);
        	        	        xml_passing_clause1043=xml_passing_clause();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, xml_passing_clause1043.tree);


        	        	    }
        	        	    break;

        	            }
        	        }

        	        // OracleDML.g:1281:17: ( columns_key ! xml_table_column ( COMMA ! xml_table_column ) )?
        	        {
        	            ANTLR_UINT32 alt341=2;
        	            {
        	                ANTLR_UINT32 LA341_0 = this->LA(1);
        	                if ( (LA341_0 == REGULAR_ID) && ((toUpper(LT(1)->getText()) == "COLUMNS")))
        	                {
        	                    alt341=1;
        	                }
        	            }
        	            switch (alt341)
        	            {
        	        	case 1:
        	        	    // OracleDML.g:1281:18: columns_key ! xml_table_column ( COMMA ! xml_table_column )
        	        	    {
        	        	        this->followPush(FOLLOW_columns_key_in_standard_function14221);
        	        	        columns_key1044=columns_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }


        	        	        this->followPush(FOLLOW_xml_table_column_in_standard_function14224);
        	        	        xml_table_column1045=xml_table_column();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, xml_table_column1045.tree);


        	        	        // OracleDML.g:1281:48: ( COMMA ! xml_table_column )
        	        	        // OracleDML.g:1281:49: COMMA ! xml_table_column
        	        	        {
        	        	            COMMA1046 =  this->matchToken(COMMA, &FOLLOW_COMMA_in_standard_function14227);
        	        	            if  (this->hasException())
        	        	            {
        	        	                goto rulestandard_functionEx;
        	        	            }
        	        	            if (this->hasFailed())
        	        	            {
        	        	                return retval;
        	        	            }


        	        	            this->followPush(FOLLOW_xml_table_column_in_standard_function14230);
        	        	            xml_table_column1047=xml_table_column();

        	        	            this->followPop();
        	        	            if  (this->hasException())
        	        	            {
        	        	                goto rulestandard_functionEx;
        	        	            }
        	        	            if (this->hasFailed())
        	        	            {
        	        	                return retval;
        	        	            }

        	        	            if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, xml_table_column1047.tree);


        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        RIGHT_PAREN1048 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_standard_function14247);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) {
        	        RIGHT_PAREN1048_tree = std::move(get_psrstate()->get_treeAdaptor()->create(RIGHT_PAREN1048));
        	        get_psrstate()->get_treeAdaptor()->addChild(root_0, RIGHT_PAREN1048_tree);
        	        }


        	        // OracleDML.g:1283:13: ( PERIOD general_element_part )?
        	        {
        	            ANTLR_UINT32 alt342=2;
        	            switch ( this->LA(1) )
        	            {
        	                case PERIOD:
        	                	{
        	                		alt342=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt342)
        	            {
        	        	case 1:
        	        	    // OracleDML.g:1283:14: PERIOD general_element_part
        	        	    {
        	        	        PERIOD1049 =  this->matchToken(PERIOD, &FOLLOW_PERIOD_in_standard_function14262);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) {
        	        	        PERIOD1049_tree = std::move(get_psrstate()->get_treeAdaptor()->create(PERIOD1049));
        	        	        get_psrstate()->get_treeAdaptor()->addChild(root_0, PERIOD1049_tree);
        	        	        }


        	        	        this->followPush(FOLLOW_general_element_part_in_standard_function14264);
        	        	        general_element_part1050=general_element_part();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, general_element_part1050.tree);


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;

            }
        }
    }//...
    // This is where rules clean up and exit
    //
    goto rulestandard_functionEx; /* Prevent compiler warnings */
    rulestandard_functionEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end standard_function */

/**
 * $ANTLR start stantard_function_enabling_over
 * OracleDML.g:1286:1: stantard_function_enabling_over :{...}? => REGULAR_ID -> FUNCTION_ENABLING_OVER[$REGULAR_ID] ;
 */
OracleDML::stantard_function_enabling_over_return
OracleDML::stantard_function_enabling_over()
{
    OracleDML::stantard_function_enabling_over_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID1051 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID1051_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:1287:5: ({...}? => REGULAR_ID -> FUNCTION_ENABLING_OVER[$REGULAR_ID] )
        // OracleDML.g:1287:10: {...}? => REGULAR_ID
        {
            if ( !((enablesOverClause(LT(1)->getText()))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "enablesOverClause(LT(1)->getText())" );
                    ex->set_ruleName( "stantard_function_enabling_over" );


            }

            REGULAR_ID1051 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_stantard_function_enabling_over14289);
            if  (this->hasException())
            {
                goto rulestantard_function_enabling_overEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID1051);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1287:62: -> FUNCTION_ENABLING_OVER[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(FUNCTION_ENABLING_OVER, REGULAR_ID1051));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulestantard_function_enabling_overEx; /* Prevent compiler warnings */
    rulestantard_function_enabling_overEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end stantard_function_enabling_over */

/**
 * $ANTLR start stantard_function_enabling_using
 * OracleDML.g:1290:1: stantard_function_enabling_using :{...}? => REGULAR_ID -> FUNCTION_ENABLING_USING[$REGULAR_ID] ;
 */
OracleDML::stantard_function_enabling_using_return
OracleDML::stantard_function_enabling_using()
{
    OracleDML::stantard_function_enabling_using_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID1052 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID1052_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:1291:5: ({...}? => REGULAR_ID -> FUNCTION_ENABLING_USING[$REGULAR_ID] )
        // OracleDML.g:1291:10: {...}? => REGULAR_ID
        {
            if ( !((enablesUsingClause(LT(1)->getText()))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "enablesUsingClause(LT(1)->getText())" );
                    ex->set_ruleName( "stantard_function_enabling_using" );


            }

            REGULAR_ID1052 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_stantard_function_enabling_using14317);
            if  (this->hasException())
            {
                goto rulestantard_function_enabling_usingEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID1052);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1291:63: -> FUNCTION_ENABLING_USING[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(FUNCTION_ENABLING_USING, REGULAR_ID1052));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulestantard_function_enabling_usingEx; /* Prevent compiler warnings */
    rulestantard_function_enabling_usingEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end stantard_function_enabling_using */

/**
 * $ANTLR start stantard_function_enabling_within_or_over
 * OracleDML.g:1294:1: stantard_function_enabling_within_or_over :{...}? => REGULAR_ID -> FUNCTION_ENABLING_WITHIN_OR_OVER[$REGULAR_ID] ;
 */
OracleDML::stantard_function_enabling_within_or_over_return
OracleDML::stantard_function_enabling_within_or_over()
{
    OracleDML::stantard_function_enabling_within_or_over_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID1053 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID1053_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:1295:5: ({...}? => REGULAR_ID -> FUNCTION_ENABLING_WITHIN_OR_OVER[$REGULAR_ID] )
        // OracleDML.g:1295:10: {...}? => REGULAR_ID
        {
            if ( !((enablesWithinOrOverClause(LT(1)->getText()))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "enablesWithinOrOverClause(LT(1)->getText())" );
                    ex->set_ruleName( "stantard_function_enabling_within_or_over" );


            }

            REGULAR_ID1053 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_stantard_function_enabling_within_or_over14345);
            if  (this->hasException())
            {
                goto rulestantard_function_enabling_within_or_overEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID1053);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1295:70: -> FUNCTION_ENABLING_WITHIN_OR_OVER[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(FUNCTION_ENABLING_WITHIN_OR_OVER, REGULAR_ID1053));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulestantard_function_enabling_within_or_overEx; /* Prevent compiler warnings */
    rulestantard_function_enabling_within_or_overEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end stantard_function_enabling_within_or_over */

/**
 * $ANTLR start stantard_function_pedictions
 * OracleDML.g:1298:1: stantard_function_pedictions :{...}? => REGULAR_ID -> PREDICTION_FUNCTION[$REGULAR_ID] ;
 */
OracleDML::stantard_function_pedictions_return
OracleDML::stantard_function_pedictions()
{
    OracleDML::stantard_function_pedictions_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* REGULAR_ID1054 = NULL;

    ImplTraits::TreeTypePtr REGULAR_ID1054_tree;
    RewriteRuleTokenStream<ImplTraits> stream_REGULAR_ID(get_psrstate()->get_treeAdaptor(), "token REGULAR_ID");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:1299:5: ({...}? => REGULAR_ID -> PREDICTION_FUNCTION[$REGULAR_ID] )
        // OracleDML.g:1299:10: {...}? => REGULAR_ID
        {
            if ( !((isStandardPredictionFunction(LT(1)->getText()))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "isStandardPredictionFunction(LT(1)->getText())" );
                    ex->set_ruleName( "stantard_function_pedictions" );


            }

            REGULAR_ID1054 =  this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_stantard_function_pedictions14373);
            if  (this->hasException())
            {
                goto rulestantard_function_pedictionsEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }
             
            if ( this->get_backtracking()==0 ) stream_REGULAR_ID.add(REGULAR_ID1054);


            // AST REWRITE
            // elements: 
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1299:73: -> PREDICTION_FUNCTION[$REGULAR_ID]
            {
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, get_psrstate()->get_treeAdaptor()->create(PREDICTION_FUNCTION, REGULAR_ID1054));
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulestantard_function_pedictionsEx; /* Prevent compiler warnings */
    rulestantard_function_pedictionsEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end stantard_function_pedictions */

/**
 * $ANTLR start over_clause
 * OracleDML.g:1302:1: over_clause : over_key ^ LEFT_PAREN ( query_partition_clause )? ( order_by_clause ( windowing_clause )? )? RIGHT_PAREN ;
 */
OracleDML::over_clause_return
OracleDML::over_clause()
{
    OracleDML::over_clause_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* LEFT_PAREN1056 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN1060 = NULL;
    OracleDML_OracleDMLKeys::over_key_return over_key1055;
    ImplTraits::TreeTypePtr::pointer over_key1055_last = NULL;
    OracleDML::query_partition_clause_return query_partition_clause1057;
    ImplTraits::TreeTypePtr::pointer query_partition_clause1057_last = NULL;
    OracleDML::order_by_clause_return order_by_clause1058;
    ImplTraits::TreeTypePtr::pointer order_by_clause1058_last = NULL;
    OracleDML::windowing_clause_return windowing_clause1059;
    ImplTraits::TreeTypePtr::pointer windowing_clause1059_last = NULL;
    ImplTraits::TreeTypePtr LEFT_PAREN1056_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN1060_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:1303:5: ( over_key ^ LEFT_PAREN ( query_partition_clause )? ( order_by_clause ( windowing_clause )? )? RIGHT_PAREN )
        // OracleDML.g:1303:10: over_key ^ LEFT_PAREN ( query_partition_clause )? ( order_by_clause ( windowing_clause )? )? RIGHT_PAREN
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            this->followPush(FOLLOW_over_key_in_over_clause14398);
            over_key1055=over_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleover_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(over_key1055.tree, root_0);

            LEFT_PAREN1056 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_over_clause14409);
            if  (this->hasException())
            {
                goto ruleover_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            LEFT_PAREN1056_tree = std::move(get_psrstate()->get_treeAdaptor()->create(LEFT_PAREN1056));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, LEFT_PAREN1056_tree);
            }


            // OracleDML.g:1305:13: ( query_partition_clause )?
            {
                ANTLR_UINT32 alt344=2;
                {
                    ANTLR_UINT32 LA344_0 = this->LA(1);
                    if ( (LA344_0 == REGULAR_ID) && ((toUpper(LT(1)->getText()) == "PARTITION")))
                    {
                        alt344=1;
                    }
                }
                switch (alt344)
                {
            	case 1:
            	    // OracleDML.g:1305:13: query_partition_clause
            	    {
            	        this->followPush(FOLLOW_query_partition_clause_in_over_clause14423);
            	        query_partition_clause1057=query_partition_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleover_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, query_partition_clause1057.tree);


            	    }
            	    break;

                }
            }

            // OracleDML.g:1306:13: ( order_by_clause ( windowing_clause )? )?
            {
                ANTLR_UINT32 alt346=2;
                switch ( this->LA(1) )
                {
                    case SQL92_RESERVED_ORDER:
                    	{
                    		alt346=1;
                    	}
                        break;
                }

                switch (alt346)
                {
            	case 1:
            	    // OracleDML.g:1306:14: order_by_clause ( windowing_clause )?
            	    {
            	        this->followPush(FOLLOW_order_by_clause_in_over_clause14439);
            	        order_by_clause1058=order_by_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleover_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, order_by_clause1058.tree);


            	        // OracleDML.g:1306:30: ( windowing_clause )?
            	        {
            	            ANTLR_UINT32 alt345=2;
            	            {
            	                ANTLR_UINT32 LA345_0 = this->LA(1);
            	                if ( (LA345_0 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "RANGE"))||((toUpper(LT(1)->getText()) == "ROWS")))))
            	                {
            	                    alt345=1;
            	                }
            	            }
            	            switch (alt345)
            	            {
            	        	case 1:
            	        	    // OracleDML.g:1306:30: windowing_clause
            	        	    {
            	        	        this->followPush(FOLLOW_windowing_clause_in_over_clause14441);
            	        	        windowing_clause1059=windowing_clause();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleover_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, windowing_clause1059.tree);


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

                }
            }

            RIGHT_PAREN1060 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_over_clause14454);
            if  (this->hasException())
            {
                goto ruleover_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            RIGHT_PAREN1060_tree = std::move(get_psrstate()->get_treeAdaptor()->create(RIGHT_PAREN1060));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, RIGHT_PAREN1060_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleover_clauseEx; /* Prevent compiler warnings */
    ruleover_clauseEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end over_clause */

/**
 * $ANTLR start windowing_clause
 * OracleDML.g:1310:1: windowing_clause : windowing_type ( between_key windowing_elements and_key windowing_elements | windowing_elements ) -> {mode == 1}? ^( windowing_type ^( between_key ( windowing_elements )+ ) ) -> ^( windowing_type ( windowing_elements )+ ) ;
 */
OracleDML::windowing_clause_return
OracleDML::windowing_clause()
{
    OracleDML::windowing_clause_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML::windowing_type_return windowing_type1061;
    ImplTraits::TreeTypePtr::pointer windowing_type1061_last = NULL;
    OracleDML_OracleDMLKeys::between_key_return between_key1062;
    ImplTraits::TreeTypePtr::pointer between_key1062_last = NULL;
    OracleDML::windowing_elements_return windowing_elements1063;
    ImplTraits::TreeTypePtr::pointer windowing_elements1063_last = NULL;
    OracleDML_OracleDMLKeys::and_key_return and_key1064;
    ImplTraits::TreeTypePtr::pointer and_key1064_last = NULL;
    OracleDML::windowing_elements_return windowing_elements1065;
    ImplTraits::TreeTypePtr::pointer windowing_elements1065_last = NULL;
    OracleDML::windowing_elements_return windowing_elements1066;
    ImplTraits::TreeTypePtr::pointer windowing_elements1066_last = NULL;
    RewriteRuleSubtreeStream<ImplTraits> stream_windowing_type(get_psrstate()->get_treeAdaptor(), "rule windowing_type");
    RewriteRuleSubtreeStream<ImplTraits> stream_between_key(get_psrstate()->get_treeAdaptor(), "rule between_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_and_key(get_psrstate()->get_treeAdaptor(), "rule and_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_windowing_elements(get_psrstate()->get_treeAdaptor(), "rule windowing_elements");

    /* Initialize rule variables
     */

        int mode = 0;    
    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:1312:5: ( windowing_type ( between_key windowing_elements and_key windowing_elements | windowing_elements ) -> {mode == 1}? ^( windowing_type ^( between_key ( windowing_elements )+ ) ) -> ^( windowing_type ( windowing_elements )+ ) )
        // OracleDML.g:1312:10: windowing_type ( between_key windowing_elements and_key windowing_elements | windowing_elements )
        {
            this->followPush(FOLLOW_windowing_type_in_windowing_clause14482);
            windowing_type1061=windowing_type();

            this->followPop();
            if  (this->hasException())
            {
                goto rulewindowing_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                windowing_type1061_last = windowing_type1061.tree.get();
                stream_windowing_type.add(windowing_type1061.tree);
            }

            // OracleDML.g:1313:5: ( between_key windowing_elements and_key windowing_elements | windowing_elements )
            {
                ANTLR_UINT32 alt347=2;
                switch ( this->LA(1) )
                {
                case SQL92_RESERVED_BETWEEN:
                	{
                		alt347=1;
                	}
                    break;
                case APPROXIMATE_NUM_LIT:
                case BINDVAR:
                case CHAR_STRING:
                case CHAR_STRING_PERL:
                case COLON:
                case DELIMITED_ID:
                case EXACT_NUM_LIT:
                case INTRODUCER:
                case LEFT_PAREN:
                case MINUS_SIGN:
                case NATIONAL_CHAR_STRING_LIT:
                case PLSQL_NON_RESERVED_CAST:
                case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
                case PLUS_SIGN:
                case REGULAR_ID:
                case SQL92_RESERVED_ALL:
                case SQL92_RESERVED_ANY:
                case SQL92_RESERVED_CASE:
                case SQL92_RESERVED_CURRENT:
                case SQL92_RESERVED_DATE:
                case SQL92_RESERVED_DEFAULT:
                case SQL92_RESERVED_DISTINCT:
                case SQL92_RESERVED_EXISTS:
                case SQL92_RESERVED_FALSE:
                case SQL92_RESERVED_NULL:
                case SQL92_RESERVED_PRIOR:
                case SQL92_RESERVED_TRUE:
                case UNSIGNED_INTEGER:
                	{
                		alt347=2;
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return retval;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 347 );
                    ex->set_state( 0 );


                    goto rulewindowing_clauseEx;

                }

                switch (alt347)
                {
            	case 1:
            	    // OracleDML.g:1313:10: between_key windowing_elements and_key windowing_elements
            	    {
            	        this->followPush(FOLLOW_between_key_in_windowing_clause14493);
            	        between_key1062=between_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulewindowing_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            between_key1062_last = between_key1062.tree.get();
            	            stream_between_key.add(between_key1062.tree);
            	        }

            	        this->followPush(FOLLOW_windowing_elements_in_windowing_clause14495);
            	        windowing_elements1063=windowing_elements();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulewindowing_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            windowing_elements1063_last = windowing_elements1063.tree.get();
            	            stream_windowing_elements.add(windowing_elements1063.tree);
            	        }

            	        this->followPush(FOLLOW_and_key_in_windowing_clause14497);
            	        and_key1064=and_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulewindowing_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            and_key1064_last = and_key1064.tree.get();
            	            stream_and_key.add(and_key1064.tree);
            	        }

            	        this->followPush(FOLLOW_windowing_elements_in_windowing_clause14499);
            	        windowing_elements1065=windowing_elements();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulewindowing_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            windowing_elements1065_last = windowing_elements1065.tree.get();
            	            stream_windowing_elements.add(windowing_elements1065.tree);
            	        }

            	        if ( this->get_backtracking()==0 )
            	        {
            	            mode = 1;
            	        }


            	    }
            	    break;
            	case 2:
            	    // OracleDML.g:1314:10: windowing_elements
            	    {
            	        this->followPush(FOLLOW_windowing_elements_in_windowing_clause14512);
            	        windowing_elements1066=windowing_elements();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulewindowing_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            windowing_elements1066_last = windowing_elements1066.tree.get();
            	            stream_windowing_elements.add(windowing_elements1066.tree);
            	        }

            	    }
            	    break;

                }
            }

            // AST REWRITE
            // elements: windowing_elements, between_key, windowing_type, windowing_elements, windowing_type
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1315:5: -> {mode == 1}? ^( windowing_type ^( between_key ( windowing_elements )+ ) )
            if (mode == 1) {
            	// OracleDML.g:1315:20: ^( windowing_type ^( between_key ( windowing_elements )+ ) )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(stream_windowing_type.nextNode(), root_1);
            	// OracleDML.g:1315:37: ^( between_key ( windowing_elements )+ )
            	{
            	ImplTraits::TreeTypePtr root_2 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_2 = get_psrstate()->get_treeAdaptor()->becomeRoot(stream_between_key.nextNode(), root_2);
            	if ( !(stream_windowing_elements.hasNext()) ) {
            		ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, REWRITE_EARLY_EXCEPTION, StreamType>( this->get_rec(), "windowing_elements empty" );
            		goto rulewindowing_clauseEx;
            	}
            	while ( stream_windowing_elements.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_2, stream_windowing_elements.nextTree());
            	}
            	stream_windowing_elements.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_1, root_2);
            	}
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }

            else // 1316:5: -> ^( windowing_type ( windowing_elements )+ )
            {
            	// OracleDML.g:1316:8: ^( windowing_type ( windowing_elements )+ )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(stream_windowing_type.nextNode(), root_1);
            	if ( !(stream_windowing_elements.hasNext()) ) {
            		ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, REWRITE_EARLY_EXCEPTION, StreamType>( this->get_rec(), "windowing_elements empty" );
            		goto rulewindowing_clauseEx;
            	}
            	while ( stream_windowing_elements.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_windowing_elements.nextTree());
            	}
            	stream_windowing_elements.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulewindowing_clauseEx; /* Prevent compiler warnings */
    rulewindowing_clauseEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end windowing_clause */

/**
 * $ANTLR start windowing_type
 * OracleDML.g:1319:1: windowing_type : ( rows_key | range_key );
 */
OracleDML::windowing_type_return
OracleDML::windowing_type()
{
    OracleDML::windowing_type_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML_OracleDMLKeys::rows_key_return rows_key1067;
    ImplTraits::TreeTypePtr::pointer rows_key1067_last = NULL;
    OracleDML_OracleDMLKeys::range_key_return range_key1068;
    ImplTraits::TreeTypePtr::pointer range_key1068_last = NULL;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        {
            //  OracleDML.g:1320:5: ( rows_key | range_key )

            ANTLR_UINT32 alt348;

            alt348=2;

            {
                ANTLR_UINT32 LA348_0 = this->LA(1);
                if ( (LA348_0 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "RANGE"))||((toUpper(LT(1)->getText()) == "ROWS")))))
                {
                    {
                        ANTLR_UINT32 LA348_1 = this->LA(2);
                        if ( ((toUpper(LT(1)->getText()) == "ROWS")))
                        {
                            alt348=1;
                        }
                        else if ( ((toUpper(LT(1)->getText()) == "RANGE")))
                        {
                            alt348=2;
                        }
                        else
                        {
                            if (this->get_backtracking()>0)
                            {
                                this->set_failedflag( true );
                                return retval;
                            }


                            ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                            ex->set_decisionNum( 348 );
                            ex->set_state( 1 );


                            goto rulewindowing_typeEx;

                        }
                    }
                }
                else
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return retval;
                    }


                    ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 348 );
                    ex->set_state( 0 );


                    goto rulewindowing_typeEx;

                }
            }
            switch (alt348)
            {
        	case 1:
        	    // OracleDML.g:1320:10: rows_key
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_rows_key_in_windowing_type14571);
        	        rows_key1067=rows_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulewindowing_typeEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, rows_key1067.tree);


        	    }
        	    break;
        	case 2:
        	    // OracleDML.g:1321:10: range_key
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_range_key_in_windowing_type14582);
        	        range_key1068=range_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulewindowing_typeEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, range_key1068.tree);


        	    }
        	    break;

            }
        }
    }//...
    // This is where rules clean up and exit
    //
    goto rulewindowing_typeEx; /* Prevent compiler warnings */
    rulewindowing_typeEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end windowing_type */

/**
 * $ANTLR start windowing_elements
 * OracleDML.g:1324:1: windowing_elements : ( unbounded_key ^ preceding_key | current_key ^ row_key | concatenation_wrapper ( preceding_key ^| following_key ^) );
 */
OracleDML::windowing_elements_return
OracleDML::windowing_elements()
{
    OracleDML::windowing_elements_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML_OracleDMLKeys::unbounded_key_return unbounded_key1069;
    ImplTraits::TreeTypePtr::pointer unbounded_key1069_last = NULL;
    OracleDML_OracleDMLKeys::preceding_key_return preceding_key1070;
    ImplTraits::TreeTypePtr::pointer preceding_key1070_last = NULL;
    OracleDML_OracleDMLKeys::current_key_return current_key1071;
    ImplTraits::TreeTypePtr::pointer current_key1071_last = NULL;
    OracleDML_OracleDMLKeys::row_key_return row_key1072;
    ImplTraits::TreeTypePtr::pointer row_key1072_last = NULL;
    OracleDML::concatenation_wrapper_return concatenation_wrapper1073;
    ImplTraits::TreeTypePtr::pointer concatenation_wrapper1073_last = NULL;
    OracleDML_OracleDMLKeys::preceding_key_return preceding_key1074;
    ImplTraits::TreeTypePtr::pointer preceding_key1074_last = NULL;
    OracleDML_OracleDMLKeys::following_key_return following_key1075;
    ImplTraits::TreeTypePtr::pointer following_key1075_last = NULL;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        {
            //  OracleDML.g:1325:5: ( unbounded_key ^ preceding_key | current_key ^ row_key | concatenation_wrapper ( preceding_key ^| following_key ^) )

            ANTLR_UINT32 alt350;

            alt350=3;

            switch ( this->LA(1) )
            {
            case REGULAR_ID:
            	{
            		{
            		    ANTLR_UINT32 LA350_1 = this->LA(2);
            		    if ( (LA350_1 == REGULAR_ID))
            		    {
            		        {
            		            ANTLR_UINT32 LA350_4 = this->LA(3);
            		            if ( ((toUpper(LT(1)->getText()) == "UNBOUNDED")))
            		            {
            		                alt350=1;
            		            }
            		            else if ( (true))
            		            {
            		                alt350=3;
            		            }
            		            else
            		            {
            		                if (this->get_backtracking()>0)
            		                {
            		                    this->set_failedflag( true );
            		                    return retval;
            		                }


            		                ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		                ex->set_decisionNum( 350 );
            		                ex->set_state( 4 );


            		                goto rulewindowing_elementsEx;

            		            }
            		        }
            		    }
            		    else if ( (LA350_1 == MINUS_SIGN || LA350_1 == PLUS_SIGN))
            		    {
            		        alt350=3;
            		    }
            		    else if ( (LA350_1 == PLSQL_NON_RESERVED_CONNECT_BY_ROOT || LA350_1 == SQL92_RESERVED_ALL || LA350_1 == SQL92_RESERVED_DISTINCT || LA350_1 == SQL92_RESERVED_PRIOR) && (( ((LT(1)->getText() == "NEW" && LT(2)->getText() != ".")) && ((toUpper(LT(1)->getText()) == "NEW")) )))
            		    {
            		        alt350=3;
            		    }
            		    else if ( (LA350_1 == DELIMITED_ID) && ((((toUpper(LT(1)->getText()) == "INTERVAL"))||(( ((LT(1)->getText() == "NEW" && LT(2)->getText() != ".")) && ((toUpper(LT(1)->getText()) == "NEW")) )))))
            		    {
            		        alt350=3;
            		    }
            		    else if ( (LA350_1 == SQL92_RESERVED_CASE))
            		    {
            		        alt350=3;
            		    }
            		    else if ( (LA350_1 == PLSQL_NON_RESERVED_CAST || LA350_1 == SQL92_RESERVED_ANY || LA350_1 == SQL92_RESERVED_EXISTS) && (( ((LT(1)->getText() == "NEW" && LT(2)->getText() != ".")) && ((toUpper(LT(1)->getText()) == "NEW")) )))
            		    {
            		        alt350=3;
            		    }
            		    else if ( (LA350_1 == INTRODUCER) && ((((toUpper(LT(1)->getText()) == "INTERVAL"))||(( ((LT(1)->getText() == "NEW" && LT(2)->getText() != ".")) && ((toUpper(LT(1)->getText()) == "NEW")) )))))
            		    {
            		        alt350=3;
            		    }
            		    else if ( (LA350_1 == BINDVAR || LA350_1 == COLON))
            		    {
            		        alt350=3;
            		    }
            		    else if ( (LA350_1 == APPROXIMATE_NUM_LIT || LA350_1 == EXACT_NUM_LIT || LA350_1 == SQL92_RESERVED_DATE || LA350_1 == UNSIGNED_INTEGER) && (( ((LT(1)->getText() == "NEW" && LT(2)->getText() != ".")) && ((toUpper(LT(1)->getText()) == "NEW")) )))
            		    {
            		        alt350=3;
            		    }
            		    else if ( (((LA350_1 >= CHAR_STRING) && (LA350_1 <= CHAR_STRING_PERL)) || LA350_1 == NATIONAL_CHAR_STRING_LIT))
            		    {
            		        alt350=3;
            		    }
            		    else if ( (LA350_1 == SQL92_RESERVED_DEFAULT || LA350_1 == SQL92_RESERVED_FALSE || LA350_1 == SQL92_RESERVED_NULL || LA350_1 == SQL92_RESERVED_TRUE) && (( ((LT(1)->getText() == "NEW" && LT(2)->getText() != ".")) && ((toUpper(LT(1)->getText()) == "NEW")) )))
            		    {
            		        alt350=3;
            		    }
            		    else if ( (LA350_1 == ASTERISK || LA350_1 == CONCATENATION_OP || ((LA350_1 >= LEFT_BRACKET) && (LA350_1 <= LEFT_PAREN)) || LA350_1 == PERIOD || LA350_1 == PLSQL_NON_RESERVED_MULTISET || LA350_1 == SOLIDUS || LA350_1 == VERTICAL_BAR))
            		    {
            		        alt350=3;
            		    }
            		    else
            		    {
            		        if (this->get_backtracking()>0)
            		        {
            		            this->set_failedflag( true );
            		            return retval;
            		        }


            		        ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 350 );
            		        ex->set_state( 1 );


            		        goto rulewindowing_elementsEx;

            		    }
            		}
            	}
                break;
            case SQL92_RESERVED_CURRENT:
            	{
            		alt350=2;
            	}
                break;
            case APPROXIMATE_NUM_LIT:
            case BINDVAR:
            case CHAR_STRING:
            case CHAR_STRING_PERL:
            case COLON:
            case DELIMITED_ID:
            case EXACT_NUM_LIT:
            case INTRODUCER:
            case LEFT_PAREN:
            case MINUS_SIGN:
            case NATIONAL_CHAR_STRING_LIT:
            case PLSQL_NON_RESERVED_CAST:
            case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
            case PLUS_SIGN:
            case SQL92_RESERVED_ALL:
            case SQL92_RESERVED_ANY:
            case SQL92_RESERVED_CASE:
            case SQL92_RESERVED_DATE:
            case SQL92_RESERVED_DEFAULT:
            case SQL92_RESERVED_DISTINCT:
            case SQL92_RESERVED_EXISTS:
            case SQL92_RESERVED_FALSE:
            case SQL92_RESERVED_NULL:
            case SQL92_RESERVED_PRIOR:
            case SQL92_RESERVED_TRUE:
            case UNSIGNED_INTEGER:
            	{
            		alt350=3;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 350 );
                ex->set_state( 0 );


                goto rulewindowing_elementsEx;

            }

            switch (alt350)
            {
        	case 1:
        	    // OracleDML.g:1325:10: unbounded_key ^ preceding_key
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_unbounded_key_in_windowing_elements14602);
        	        unbounded_key1069=unbounded_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulewindowing_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(unbounded_key1069.tree, root_0);

        	        this->followPush(FOLLOW_preceding_key_in_windowing_elements14605);
        	        preceding_key1070=preceding_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulewindowing_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, preceding_key1070.tree);


        	    }
        	    break;
        	case 2:
        	    // OracleDML.g:1326:10: current_key ^ row_key
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_current_key_in_windowing_elements14616);
        	        current_key1071=current_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulewindowing_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(current_key1071.tree, root_0);

        	        this->followPush(FOLLOW_row_key_in_windowing_elements14619);
        	        row_key1072=row_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulewindowing_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, row_key1072.tree);


        	    }
        	    break;
        	case 3:
        	    // OracleDML.g:1327:10: concatenation_wrapper ( preceding_key ^| following_key ^)
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_concatenation_wrapper_in_windowing_elements14630);
        	        concatenation_wrapper1073=concatenation_wrapper();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulewindowing_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, concatenation_wrapper1073.tree);


        	        // OracleDML.g:1327:32: ( preceding_key ^| following_key ^)
        	        {
        	            ANTLR_UINT32 alt349=2;
        	            {
        	                ANTLR_UINT32 LA349_0 = this->LA(1);
        	                if ( (LA349_0 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "FOLLOWING"))||((toUpper(LT(1)->getText()) == "PRECEDING")))))
        	                {
        	                    {
        	                        ANTLR_UINT32 LA349_1 = this->LA(2);
        	                        if ( ((toUpper(LT(1)->getText()) == "PRECEDING")))
        	                        {
        	                            alt349=1;
        	                        }
        	                        else if ( ((toUpper(LT(1)->getText()) == "FOLLOWING")))
        	                        {
        	                            alt349=2;
        	                        }
        	                        else
        	                        {
        	                            if (this->get_backtracking()>0)
        	                            {
        	                                this->set_failedflag( true );
        	                                return retval;
        	                            }


        	                            ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                            ex->set_decisionNum( 349 );
        	                            ex->set_state( 1 );


        	                            goto rulewindowing_elementsEx;

        	                        }
        	                    }
        	                }
        	                else
        	                {
        	                    if (this->get_backtracking()>0)
        	                    {
        	                        this->set_failedflag( true );
        	                        return retval;
        	                    }


        	                    ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                    ex->set_decisionNum( 349 );
        	                    ex->set_state( 0 );


        	                    goto rulewindowing_elementsEx;

        	                }
        	            }
        	            switch (alt349)
        	            {
        	        	case 1:
        	        	    // OracleDML.g:1327:33: preceding_key ^
        	        	    {
        	        	        this->followPush(FOLLOW_preceding_key_in_windowing_elements14633);
        	        	        preceding_key1074=preceding_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulewindowing_elementsEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(preceding_key1074.tree, root_0);

        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // OracleDML.g:1327:48: following_key ^
        	        	    {
        	        	        this->followPush(FOLLOW_following_key_in_windowing_elements14636);
        	        	        following_key1075=following_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulewindowing_elementsEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(following_key1075.tree, root_0);

        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;

            }
        }
    }//...
    // This is where rules clean up and exit
    //
    goto rulewindowing_elementsEx; /* Prevent compiler warnings */
    rulewindowing_elementsEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end windowing_elements */

/**
 * $ANTLR start using_clause
 * OracleDML.g:1330:1: using_clause : using_key ^ ( ASTERISK | using_element ( COMMA ! using_element )* ) ;
 */
OracleDML::using_clause_return
OracleDML::using_clause()
{
    OracleDML::using_clause_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* ASTERISK1077 = NULL;
    ImplTraits::CommonTokenType const* COMMA1079 = NULL;
    OracleDML_OracleDMLKeys::using_key_return using_key1076;
    ImplTraits::TreeTypePtr::pointer using_key1076_last = NULL;
    OracleDML::using_element_return using_element1078;
    ImplTraits::TreeTypePtr::pointer using_element1078_last = NULL;
    OracleDML::using_element_return using_element1080;
    ImplTraits::TreeTypePtr::pointer using_element1080_last = NULL;
    ImplTraits::TreeTypePtr ASTERISK1077_tree;
    ImplTraits::TreeTypePtr COMMA1079_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:1331:5: ( using_key ^ ( ASTERISK | using_element ( COMMA ! using_element )* ) )
        // OracleDML.g:1331:10: using_key ^ ( ASTERISK | using_element ( COMMA ! using_element )* )
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            this->followPush(FOLLOW_using_key_in_using_clause14658);
            using_key1076=using_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleusing_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(using_key1076.tree, root_0);

            // OracleDML.g:1332:5: ( ASTERISK | using_element ( COMMA ! using_element )* )
            {
                ANTLR_UINT32 alt352=2;
                switch ( this->LA(1) )
                {
                case ASTERISK:
                	{
                		alt352=1;
                	}
                    break;
                case APPROXIMATE_NUM_LIT:
                case BINDVAR:
                case CHAR_STRING:
                case CHAR_STRING_PERL:
                case COLON:
                case DELIMITED_ID:
                case EXACT_NUM_LIT:
                case INTRODUCER:
                case LEFT_PAREN:
                case MINUS_SIGN:
                case NATIONAL_CHAR_STRING_LIT:
                case PLSQL_NON_RESERVED_CAST:
                case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
                case PLUS_SIGN:
                case REGULAR_ID:
                case SQL92_RESERVED_ALL:
                case SQL92_RESERVED_ANY:
                case SQL92_RESERVED_CASE:
                case SQL92_RESERVED_CURSOR:
                case SQL92_RESERVED_DATE:
                case SQL92_RESERVED_DEFAULT:
                case SQL92_RESERVED_DISTINCT:
                case SQL92_RESERVED_EXISTS:
                case SQL92_RESERVED_FALSE:
                case SQL92_RESERVED_IN:
                case SQL92_RESERVED_NOT:
                case SQL92_RESERVED_NULL:
                case SQL92_RESERVED_PRIOR:
                case SQL92_RESERVED_TRUE:
                case UNSIGNED_INTEGER:
                	{
                		alt352=2;
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return retval;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 352 );
                    ex->set_state( 0 );


                    goto ruleusing_clauseEx;

                }

                switch (alt352)
                {
            	case 1:
            	    // OracleDML.g:1332:10: ASTERISK
            	    {
            	        ASTERISK1077 =  this->matchToken(ASTERISK, &FOLLOW_ASTERISK_in_using_clause14670);
            	        if  (this->hasException())
            	        {
            	            goto ruleusing_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) {
            	        ASTERISK1077_tree = std::move(get_psrstate()->get_treeAdaptor()->create(ASTERISK1077));
            	        get_psrstate()->get_treeAdaptor()->addChild(root_0, ASTERISK1077_tree);
            	        }


            	    }
            	    break;
            	case 2:
            	    // OracleDML.g:1333:10: using_element ( COMMA ! using_element )*
            	    {
            	        this->followPush(FOLLOW_using_element_in_using_clause14681);
            	        using_element1078=using_element();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleusing_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, using_element1078.tree);


            	        // OracleDML.g:1333:24: ( COMMA ! using_element )*

            	        for (;;)
            	        {
            	            ANTLR_UINT32 alt351=2;
            	            switch ( this->LA(1) )
            	            {
            	            case COMMA:
            	            	{
            	            		alt351=1;
            	            	}
            	                break;

            	            }

            	            switch (alt351)
            	            {
            	        	case 1:
            	        	    // OracleDML.g:1333:25: COMMA ! using_element
            	        	    {
            	        	        COMMA1079 =  this->matchToken(COMMA, &FOLLOW_COMMA_in_using_clause14684);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleusing_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }


            	        	        this->followPush(FOLLOW_using_element_in_using_clause14687);
            	        	        using_element1080=using_element();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleusing_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, using_element1080.tree);


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop351;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop351: ; /* Jump out to here if this rule does not match */


            	    }
            	    break;

                }
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleusing_clauseEx; /* Prevent compiler warnings */
    ruleusing_clauseEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end using_clause */

/**
 * $ANTLR start using_element
 * OracleDML.g:1337:1: using_element : ( in_key ( out_key )? | out_key )? select_list_elements ( column_alias )? -> ^( ELEMENT ( in_key )? ( out_key )? select_list_elements ( column_alias )? ) ;
 */
OracleDML::using_element_return
OracleDML::using_element()
{
    OracleDML::using_element_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML_OracleDMLKeys::in_key_return in_key1081;
    ImplTraits::TreeTypePtr::pointer in_key1081_last = NULL;
    OracleDML_OracleDMLKeys::out_key_return out_key1082;
    ImplTraits::TreeTypePtr::pointer out_key1082_last = NULL;
    OracleDML_OracleDMLKeys::out_key_return out_key1083;
    ImplTraits::TreeTypePtr::pointer out_key1083_last = NULL;
    OracleDML::select_list_elements_return select_list_elements1084;
    ImplTraits::TreeTypePtr::pointer select_list_elements1084_last = NULL;
    OracleDML_OracleDMLCommons::column_alias_return column_alias1085;
    ImplTraits::TreeTypePtr::pointer column_alias1085_last = NULL;
    RewriteRuleSubtreeStream<ImplTraits> stream_column_alias(get_psrstate()->get_treeAdaptor(), "rule column_alias");
    RewriteRuleSubtreeStream<ImplTraits> stream_out_key(get_psrstate()->get_treeAdaptor(), "rule out_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_select_list_elements(get_psrstate()->get_treeAdaptor(), "rule select_list_elements");
    RewriteRuleSubtreeStream<ImplTraits> stream_in_key(get_psrstate()->get_treeAdaptor(), "rule in_key");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:1338:5: ( ( in_key ( out_key )? | out_key )? select_list_elements ( column_alias )? -> ^( ELEMENT ( in_key )? ( out_key )? select_list_elements ( column_alias )? ) )
        // OracleDML.g:1338:10: ( in_key ( out_key )? | out_key )? select_list_elements ( column_alias )?
        {
            // OracleDML.g:1338:10: ( in_key ( out_key )? | out_key )?
            {
                ANTLR_UINT32 alt354=3;
                switch ( this->LA(1) )
                {
                    case SQL92_RESERVED_IN:
                    	{
                    		alt354=1;
                    	}
                        break;
                    case REGULAR_ID:
                    	{
                    		{
                    		    ANTLR_UINT32 LA354_2 = this->LA(2);
                    		    if ( ((toUpper(LT(1)->getText()) == "OUT")))
                    		    {
                    		        alt354=2;
                    		    }
                    		}
                    	}
                        break;
                }

                switch (alt354)
                {
            	case 1:
            	    // OracleDML.g:1338:11: in_key ( out_key )?
            	    {
            	        this->followPush(FOLLOW_in_key_in_using_element14716);
            	        in_key1081=in_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleusing_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            in_key1081_last = in_key1081.tree.get();
            	            stream_in_key.add(in_key1081.tree);
            	        }

            	        // OracleDML.g:1338:18: ( out_key )?
            	        {
            	            ANTLR_UINT32 alt353=2;
            	            switch ( this->LA(1) )
            	            {
            	                case REGULAR_ID:
            	                	{
            	                		{
            	                		    ANTLR_UINT32 LA353_1 = this->LA(2);
            	                		    if ( ((toUpper(LT(1)->getText()) == "OUT")))
            	                		    {
            	                		        alt353=1;
            	                		    }
            	                		}
            	                	}
            	                    break;
            	            }

            	            switch (alt353)
            	            {
            	        	case 1:
            	        	    // OracleDML.g:1338:18: out_key
            	        	    {
            	        	        this->followPush(FOLLOW_out_key_in_using_element14718);
            	        	        out_key1082=out_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleusing_elementEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) 
            	        	        {
            	        	            out_key1082_last = out_key1082.tree.get();
            	        	            stream_out_key.add(out_key1082.tree);
            	        	        }

            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;
            	case 2:
            	    // OracleDML.g:1338:27: out_key
            	    {
            	        this->followPush(FOLLOW_out_key_in_using_element14721);
            	        out_key1083=out_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleusing_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            out_key1083_last = out_key1083.tree.get();
            	            stream_out_key.add(out_key1083.tree);
            	        }

            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_select_list_elements_in_using_element14725);
            select_list_elements1084=select_list_elements();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleusing_elementEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                select_list_elements1084_last = select_list_elements1084.tree.get();
                stream_select_list_elements.add(select_list_elements1084.tree);
            }

            // OracleDML.g:1338:58: ( column_alias )?
            {
                ANTLR_UINT32 alt355=2;
                switch ( this->LA(1) )
                {
                    case SQL92_RESERVED_AS:
                    	{
                    		alt355=1;
                    	}
                        break;
                    case INTRODUCER:
                    	{
                    		alt355=1;
                    	}
                        break;
                    case REGULAR_ID:
                    	{
                    		alt355=1;
                    	}
                        break;
                    case DELIMITED_ID:
                    	{
                    		alt355=1;
                    	}
                        break;
                    case CHAR_STRING:
                    case CHAR_STRING_PERL:
                    case NATIONAL_CHAR_STRING_LIT:
                    	{
                    		alt355=1;
                    	}
                        break;
                }

                switch (alt355)
                {
            	case 1:
            	    // OracleDML.g:1338:58: column_alias
            	    {
            	        this->followPush(FOLLOW_column_alias_in_using_element14727);
            	        column_alias1085=column_alias();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleusing_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            column_alias1085_last = column_alias1085.tree.get();
            	            stream_column_alias.add(column_alias1085.tree);
            	        }

            	    }
            	    break;

                }
            }

            // AST REWRITE
            // elements: column_alias, select_list_elements, in_key, out_key
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1339:9: -> ^( ELEMENT ( in_key )? ( out_key )? select_list_elements ( column_alias )? )
            {
            	// OracleDML.g:1339:12: ^( ELEMENT ( in_key )? ( out_key )? select_list_elements ( column_alias )? )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(ELEMENT, "ELEMENT"), root_1);
            	// OracleDML.g:1339:22: ( in_key )?
            	if ( stream_in_key.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_in_key.nextTree());
            	}
            	stream_in_key.reset();

            	// OracleDML.g:1339:30: ( out_key )?
            	if ( stream_out_key.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_out_key.nextTree());
            	}
            	stream_out_key.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_select_list_elements.nextTree());
            	// OracleDML.g:1339:60: ( column_alias )?
            	if ( stream_column_alias.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_column_alias.nextTree());
            	}
            	stream_column_alias.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto ruleusing_elementEx; /* Prevent compiler warnings */
    ruleusing_elementEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end using_element */

/**
 * $ANTLR start collect_order_by_part
 * OracleDML.g:1342:1: collect_order_by_part : order_key ^ by_key ! concatenation_wrapper ;
 */
OracleDML::collect_order_by_part_return
OracleDML::collect_order_by_part()
{
    OracleDML::collect_order_by_part_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML_OracleDMLKeys::order_key_return order_key1086;
    ImplTraits::TreeTypePtr::pointer order_key1086_last = NULL;
    OracleDML_OracleDMLKeys::by_key_return by_key1087;
    ImplTraits::TreeTypePtr::pointer by_key1087_last = NULL;
    OracleDML::concatenation_wrapper_return concatenation_wrapper1088;
    ImplTraits::TreeTypePtr::pointer concatenation_wrapper1088_last = NULL;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:1343:5: ( order_key ^ by_key ! concatenation_wrapper )
        // OracleDML.g:1343:10: order_key ^ by_key ! concatenation_wrapper
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            this->followPush(FOLLOW_order_key_in_collect_order_by_part14773);
            order_key1086=order_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecollect_order_by_partEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(order_key1086.tree, root_0);

            this->followPush(FOLLOW_by_key_in_collect_order_by_part14776);
            by_key1087=by_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecollect_order_by_partEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }


            this->followPush(FOLLOW_concatenation_wrapper_in_collect_order_by_part14779);
            concatenation_wrapper1088=concatenation_wrapper();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecollect_order_by_partEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, concatenation_wrapper1088.tree);


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulecollect_order_by_partEx; /* Prevent compiler warnings */
    rulecollect_order_by_partEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end collect_order_by_part */

/**
 * $ANTLR start within_or_over_part
 * OracleDML.g:1346:1: within_or_over_part : ( within_key ^ group_key ! LEFT_PAREN order_by_clause RIGHT_PAREN | over_clause );
 */
OracleDML::within_or_over_part_return
OracleDML::within_or_over_part()
{
    OracleDML::within_or_over_part_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* LEFT_PAREN1091 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN1093 = NULL;
    OracleDML_OracleDMLKeys::within_key_return within_key1089;
    ImplTraits::TreeTypePtr::pointer within_key1089_last = NULL;
    OracleDML_OracleDMLKeys::group_key_return group_key1090;
    ImplTraits::TreeTypePtr::pointer group_key1090_last = NULL;
    OracleDML::order_by_clause_return order_by_clause1092;
    ImplTraits::TreeTypePtr::pointer order_by_clause1092_last = NULL;
    OracleDML::over_clause_return over_clause1094;
    ImplTraits::TreeTypePtr::pointer over_clause1094_last = NULL;
    ImplTraits::TreeTypePtr LEFT_PAREN1091_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN1093_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        {
            //  OracleDML.g:1347:5: ( within_key ^ group_key ! LEFT_PAREN order_by_clause RIGHT_PAREN | over_clause )

            ANTLR_UINT32 alt356;

            alt356=2;

            {
                ANTLR_UINT32 LA356_0 = this->LA(1);
                if ( (LA356_0 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "OVER"))||((toUpper(LT(1)->getText()) == "WITHIN")))))
                {
                    {
                        ANTLR_UINT32 LA356_1 = this->LA(2);
                        if ( (LA356_1 == SQL92_RESERVED_GROUP) && ((toUpper(LT(1)->getText()) == "WITHIN")))
                        {
                            alt356=1;
                        }
                        else if ( (LA356_1 == LEFT_PAREN) && ((toUpper(LT(1)->getText()) == "OVER")))
                        {
                            alt356=2;
                        }
                        else
                        {
                            if (this->get_backtracking()>0)
                            {
                                this->set_failedflag( true );
                                return retval;
                            }


                            ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                            ex->set_decisionNum( 356 );
                            ex->set_state( 1 );


                            goto rulewithin_or_over_partEx;

                        }
                    }
                }
                else
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return retval;
                    }


                    ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 356 );
                    ex->set_state( 0 );


                    goto rulewithin_or_over_partEx;

                }
            }
            switch (alt356)
            {
        	case 1:
        	    // OracleDML.g:1347:10: within_key ^ group_key ! LEFT_PAREN order_by_clause RIGHT_PAREN
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_within_key_in_within_or_over_part14799);
        	        within_key1089=within_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulewithin_or_over_partEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(within_key1089.tree, root_0);

        	        this->followPush(FOLLOW_group_key_in_within_or_over_part14802);
        	        group_key1090=group_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulewithin_or_over_partEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }


        	        LEFT_PAREN1091 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_within_or_over_part14805);
        	        if  (this->hasException())
        	        {
        	            goto rulewithin_or_over_partEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) {
        	        LEFT_PAREN1091_tree = std::move(get_psrstate()->get_treeAdaptor()->create(LEFT_PAREN1091));
        	        get_psrstate()->get_treeAdaptor()->addChild(root_0, LEFT_PAREN1091_tree);
        	        }


        	        this->followPush(FOLLOW_order_by_clause_in_within_or_over_part14807);
        	        order_by_clause1092=order_by_clause();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulewithin_or_over_partEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, order_by_clause1092.tree);


        	        RIGHT_PAREN1093 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_within_or_over_part14809);
        	        if  (this->hasException())
        	        {
        	            goto rulewithin_or_over_partEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) {
        	        RIGHT_PAREN1093_tree = std::move(get_psrstate()->get_treeAdaptor()->create(RIGHT_PAREN1093));
        	        get_psrstate()->get_treeAdaptor()->addChild(root_0, RIGHT_PAREN1093_tree);
        	        }


        	    }
        	    break;
        	case 2:
        	    // OracleDML.g:1348:10: over_clause
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_over_clause_in_within_or_over_part14820);
        	        over_clause1094=over_clause();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulewithin_or_over_partEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, over_clause1094.tree);


        	    }
        	    break;

            }
        }
    }//...
    // This is where rules clean up and exit
    //
    goto rulewithin_or_over_partEx; /* Prevent compiler warnings */
    rulewithin_or_over_partEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end within_or_over_part */

/**
 * $ANTLR start cost_matrix_clause
 * OracleDML.g:1351:1: cost_matrix_clause : cost_key ^ ( model_key ( auto_key )? | LEFT_PAREN cost_class_name ( COMMA ! cost_class_name )* RIGHT_PAREN values_key ! expression_list ) ;
 */
OracleDML::cost_matrix_clause_return
OracleDML::cost_matrix_clause()
{
    OracleDML::cost_matrix_clause_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* LEFT_PAREN1098 = NULL;
    ImplTraits::CommonTokenType const* COMMA1100 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN1102 = NULL;
    OracleDML_OracleDMLKeys::cost_key_return cost_key1095;
    ImplTraits::TreeTypePtr::pointer cost_key1095_last = NULL;
    OracleDML_OracleDMLKeys::model_key_return model_key1096;
    ImplTraits::TreeTypePtr::pointer model_key1096_last = NULL;
    OracleDML_OracleDMLKeys::auto_key_return auto_key1097;
    ImplTraits::TreeTypePtr::pointer auto_key1097_last = NULL;
    OracleDML_OracleDMLCommons::cost_class_name_return cost_class_name1099;
    ImplTraits::TreeTypePtr::pointer cost_class_name1099_last = NULL;
    OracleDML_OracleDMLCommons::cost_class_name_return cost_class_name1101;
    ImplTraits::TreeTypePtr::pointer cost_class_name1101_last = NULL;
    OracleDML_OracleDMLKeys::values_key_return values_key1103;
    ImplTraits::TreeTypePtr::pointer values_key1103_last = NULL;
    OracleDML::expression_list_return expression_list1104;
    ImplTraits::TreeTypePtr::pointer expression_list1104_last = NULL;
    ImplTraits::TreeTypePtr LEFT_PAREN1098_tree;
    ImplTraits::TreeTypePtr COMMA1100_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN1102_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:1352:5: ( cost_key ^ ( model_key ( auto_key )? | LEFT_PAREN cost_class_name ( COMMA ! cost_class_name )* RIGHT_PAREN values_key ! expression_list ) )
        // OracleDML.g:1352:10: cost_key ^ ( model_key ( auto_key )? | LEFT_PAREN cost_class_name ( COMMA ! cost_class_name )* RIGHT_PAREN values_key ! expression_list )
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            this->followPush(FOLLOW_cost_key_in_cost_matrix_clause14840);
            cost_key1095=cost_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecost_matrix_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(cost_key1095.tree, root_0);

            // OracleDML.g:1353:5: ( model_key ( auto_key )? | LEFT_PAREN cost_class_name ( COMMA ! cost_class_name )* RIGHT_PAREN values_key ! expression_list )
            {
                ANTLR_UINT32 alt359=2;
                switch ( this->LA(1) )
                {
                case PLSQL_NON_RESERVED_MODEL:
                	{
                		alt359=1;
                	}
                    break;
                case LEFT_PAREN:
                	{
                		alt359=2;
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return retval;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 359 );
                    ex->set_state( 0 );


                    goto rulecost_matrix_clauseEx;

                }

                switch (alt359)
                {
            	case 1:
            	    // OracleDML.g:1353:10: model_key ( auto_key )?
            	    {
            	        this->followPush(FOLLOW_model_key_in_cost_matrix_clause14852);
            	        model_key1096=model_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecost_matrix_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, model_key1096.tree);


            	        // OracleDML.g:1353:20: ( auto_key )?
            	        {
            	            ANTLR_UINT32 alt357=2;
            	            {
            	                ANTLR_UINT32 LA357_0 = this->LA(1);
            	                if ( (LA357_0 == REGULAR_ID) && ((toUpper(LT(1)->getText()) == "AUTO")))
            	                {
            	                    alt357=1;
            	                }
            	            }
            	            switch (alt357)
            	            {
            	        	case 1:
            	        	    // OracleDML.g:1353:20: auto_key
            	        	    {
            	        	        this->followPush(FOLLOW_auto_key_in_cost_matrix_clause14854);
            	        	        auto_key1097=auto_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulecost_matrix_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, auto_key1097.tree);


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;
            	case 2:
            	    // OracleDML.g:1354:10: LEFT_PAREN cost_class_name ( COMMA ! cost_class_name )* RIGHT_PAREN values_key ! expression_list
            	    {
            	        LEFT_PAREN1098 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_cost_matrix_clause14866);
            	        if  (this->hasException())
            	        {
            	            goto rulecost_matrix_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) {
            	        LEFT_PAREN1098_tree = std::move(get_psrstate()->get_treeAdaptor()->create(LEFT_PAREN1098));
            	        get_psrstate()->get_treeAdaptor()->addChild(root_0, LEFT_PAREN1098_tree);
            	        }


            	        this->followPush(FOLLOW_cost_class_name_in_cost_matrix_clause14868);
            	        cost_class_name1099=cost_class_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecost_matrix_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, cost_class_name1099.tree);


            	        // OracleDML.g:1354:37: ( COMMA ! cost_class_name )*

            	        for (;;)
            	        {
            	            ANTLR_UINT32 alt358=2;
            	            switch ( this->LA(1) )
            	            {
            	            case COMMA:
            	            	{
            	            		alt358=1;
            	            	}
            	                break;

            	            }

            	            switch (alt358)
            	            {
            	        	case 1:
            	        	    // OracleDML.g:1354:38: COMMA ! cost_class_name
            	        	    {
            	        	        COMMA1100 =  this->matchToken(COMMA, &FOLLOW_COMMA_in_cost_matrix_clause14871);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulecost_matrix_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }


            	        	        this->followPush(FOLLOW_cost_class_name_in_cost_matrix_clause14874);
            	        	        cost_class_name1101=cost_class_name();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulecost_matrix_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, cost_class_name1101.tree);


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop358;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop358: ; /* Jump out to here if this rule does not match */


            	        RIGHT_PAREN1102 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_cost_matrix_clause14878);
            	        if  (this->hasException())
            	        {
            	            goto rulecost_matrix_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) {
            	        RIGHT_PAREN1102_tree = std::move(get_psrstate()->get_treeAdaptor()->create(RIGHT_PAREN1102));
            	        get_psrstate()->get_treeAdaptor()->addChild(root_0, RIGHT_PAREN1102_tree);
            	        }


            	        this->followPush(FOLLOW_values_key_in_cost_matrix_clause14880);
            	        values_key1103=values_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecost_matrix_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }


            	        this->followPush(FOLLOW_expression_list_in_cost_matrix_clause14896);
            	        expression_list1104=expression_list();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecost_matrix_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, expression_list1104.tree);


            	    }
            	    break;

                }
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulecost_matrix_clauseEx; /* Prevent compiler warnings */
    rulecost_matrix_clauseEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end cost_matrix_clause */

/**
 * $ANTLR start xml_passing_clause
 * OracleDML.g:1359:1: xml_passing_clause : passing_key ^ ( by_key ! value_key )? expression_wrapper ( column_alias )? ( COMMA ! expression_wrapper ( column_alias )? ) ;
 */
OracleDML::xml_passing_clause_return
OracleDML::xml_passing_clause()
{
    OracleDML::xml_passing_clause_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* COMMA1110 = NULL;
    OracleDML_OracleDMLKeys::passing_key_return passing_key1105;
    ImplTraits::TreeTypePtr::pointer passing_key1105_last = NULL;
    OracleDML_OracleDMLKeys::by_key_return by_key1106;
    ImplTraits::TreeTypePtr::pointer by_key1106_last = NULL;
    OracleDML_OracleDMLKeys::value_key_return value_key1107;
    ImplTraits::TreeTypePtr::pointer value_key1107_last = NULL;
    OracleDML::expression_wrapper_return expression_wrapper1108;
    ImplTraits::TreeTypePtr::pointer expression_wrapper1108_last = NULL;
    OracleDML_OracleDMLCommons::column_alias_return column_alias1109;
    ImplTraits::TreeTypePtr::pointer column_alias1109_last = NULL;
    OracleDML::expression_wrapper_return expression_wrapper1111;
    ImplTraits::TreeTypePtr::pointer expression_wrapper1111_last = NULL;
    OracleDML_OracleDMLCommons::column_alias_return column_alias1112;
    ImplTraits::TreeTypePtr::pointer column_alias1112_last = NULL;
    ImplTraits::TreeTypePtr COMMA1110_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:1360:5: ( passing_key ^ ( by_key ! value_key )? expression_wrapper ( column_alias )? ( COMMA ! expression_wrapper ( column_alias )? ) )
        // OracleDML.g:1360:10: passing_key ^ ( by_key ! value_key )? expression_wrapper ( column_alias )? ( COMMA ! expression_wrapper ( column_alias )? )
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            this->followPush(FOLLOW_passing_key_in_xml_passing_clause14922);
            passing_key1105=passing_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulexml_passing_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(passing_key1105.tree, root_0);

            // OracleDML.g:1360:23: ( by_key ! value_key )?
            {
                ANTLR_UINT32 alt360=2;
                switch ( this->LA(1) )
                {
                    case SQL92_RESERVED_BY:
                    	{
                    		alt360=1;
                    	}
                        break;
                }

                switch (alt360)
                {
            	case 1:
            	    // OracleDML.g:1360:24: by_key ! value_key
            	    {
            	        this->followPush(FOLLOW_by_key_in_xml_passing_clause14926);
            	        by_key1106=by_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulexml_passing_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }


            	        this->followPush(FOLLOW_value_key_in_xml_passing_clause14929);
            	        value_key1107=value_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulexml_passing_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, value_key1107.tree);


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_expression_wrapper_in_xml_passing_clause14945);
            expression_wrapper1108=expression_wrapper();

            this->followPop();
            if  (this->hasException())
            {
                goto rulexml_passing_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, expression_wrapper1108.tree);


            // OracleDML.g:1361:32: ( column_alias )?
            {
                ANTLR_UINT32 alt361=2;
                switch ( this->LA(1) )
                {
                    case CHAR_STRING:
                    case CHAR_STRING_PERL:
                    case DELIMITED_ID:
                    case INTRODUCER:
                    case NATIONAL_CHAR_STRING_LIT:
                    case REGULAR_ID:
                    case SQL92_RESERVED_AS:
                    	{
                    		alt361=1;
                    	}
                        break;
                }

                switch (alt361)
                {
            	case 1:
            	    // OracleDML.g:1361:32: column_alias
            	    {
            	        this->followPush(FOLLOW_column_alias_in_xml_passing_clause14947);
            	        column_alias1109=column_alias();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulexml_passing_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, column_alias1109.tree);


            	    }
            	    break;

                }
            }

            // OracleDML.g:1361:46: ( COMMA ! expression_wrapper ( column_alias )? )
            // OracleDML.g:1361:47: COMMA ! expression_wrapper ( column_alias )?
            {
                COMMA1110 =  this->matchToken(COMMA, &FOLLOW_COMMA_in_xml_passing_clause14951);
                if  (this->hasException())
                {
                    goto rulexml_passing_clauseEx;
                }
                if (this->hasFailed())
                {
                    return retval;
                }


                this->followPush(FOLLOW_expression_wrapper_in_xml_passing_clause14954);
                expression_wrapper1111=expression_wrapper();

                this->followPop();
                if  (this->hasException())
                {
                    goto rulexml_passing_clauseEx;
                }
                if (this->hasFailed())
                {
                    return retval;
                }

                if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, expression_wrapper1111.tree);


                // OracleDML.g:1361:73: ( column_alias )?
                {
                    ANTLR_UINT32 alt362=2;
                    switch ( this->LA(1) )
                    {
                        case CHAR_STRING:
                        case CHAR_STRING_PERL:
                        case DELIMITED_ID:
                        case INTRODUCER:
                        case NATIONAL_CHAR_STRING_LIT:
                        case SQL92_RESERVED_AS:
                        	{
                        		alt362=1;
                        	}
                            break;
                        case REGULAR_ID:
                        	{
                        		{
                        		    ANTLR_UINT32 LA362_3 = this->LA(2);
                        		    if ( (!( ((((toUpper(LT(1)->getText()) == "RETURNING"))||((toUpper(LT(1)->getText()) == "COLUMNS")))) )))
                        		    {
                        		        alt362=1;
                        		    }
                        		}
                        	}
                            break;
                    }

                    switch (alt362)
                    {
                	case 1:
                	    // OracleDML.g:1361:73: column_alias
                	    {
                	        this->followPush(FOLLOW_column_alias_in_xml_passing_clause14956);
                	        column_alias1112=column_alias();

                	        this->followPop();
                	        if  (this->hasException())
                	        {
                	            goto rulexml_passing_clauseEx;
                	        }
                	        if (this->hasFailed())
                	        {
                	            return retval;
                	        }

                	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, column_alias1112.tree);


                	    }
                	    break;

                    }
                }

            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulexml_passing_clauseEx; /* Prevent compiler warnings */
    rulexml_passing_clauseEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end xml_passing_clause */

/**
 * $ANTLR start xml_attributes_clause
 * OracleDML.g:1364:1: xml_attributes_clause : xmlattributes_key ^ LEFT_PAREN ( entityescaping_key | noentityescaping_key )? ( schemacheck_key | noschemacheck_key )? xml_multiuse_expression_element ( COMMA ! xml_multiuse_expression_element )* RIGHT_PAREN ;
 */
OracleDML::xml_attributes_clause_return
OracleDML::xml_attributes_clause()
{
    OracleDML::xml_attributes_clause_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* LEFT_PAREN1114 = NULL;
    ImplTraits::CommonTokenType const* COMMA1120 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN1122 = NULL;
    OracleDML_OracleDMLKeys::xmlattributes_key_return xmlattributes_key1113;
    ImplTraits::TreeTypePtr::pointer xmlattributes_key1113_last = NULL;
    OracleDML_OracleDMLKeys::entityescaping_key_return entityescaping_key1115;
    ImplTraits::TreeTypePtr::pointer entityescaping_key1115_last = NULL;
    OracleDML_OracleDMLKeys::noentityescaping_key_return noentityescaping_key1116;
    ImplTraits::TreeTypePtr::pointer noentityescaping_key1116_last = NULL;
    OracleDML_OracleDMLKeys::schemacheck_key_return schemacheck_key1117;
    ImplTraits::TreeTypePtr::pointer schemacheck_key1117_last = NULL;
    OracleDML_OracleDMLKeys::noschemacheck_key_return noschemacheck_key1118;
    ImplTraits::TreeTypePtr::pointer noschemacheck_key1118_last = NULL;
    OracleDML::xml_multiuse_expression_element_return xml_multiuse_expression_element1119;
    ImplTraits::TreeTypePtr::pointer xml_multiuse_expression_element1119_last = NULL;
    OracleDML::xml_multiuse_expression_element_return xml_multiuse_expression_element1121;
    ImplTraits::TreeTypePtr::pointer xml_multiuse_expression_element1121_last = NULL;
    ImplTraits::TreeTypePtr LEFT_PAREN1114_tree;
    ImplTraits::TreeTypePtr COMMA1120_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN1122_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:1365:5: ( xmlattributes_key ^ LEFT_PAREN ( entityescaping_key | noentityescaping_key )? ( schemacheck_key | noschemacheck_key )? xml_multiuse_expression_element ( COMMA ! xml_multiuse_expression_element )* RIGHT_PAREN )
        // OracleDML.g:1365:10: xmlattributes_key ^ LEFT_PAREN ( entityescaping_key | noentityescaping_key )? ( schemacheck_key | noschemacheck_key )? xml_multiuse_expression_element ( COMMA ! xml_multiuse_expression_element )* RIGHT_PAREN
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            this->followPush(FOLLOW_xmlattributes_key_in_xml_attributes_clause14978);
            xmlattributes_key1113=xmlattributes_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulexml_attributes_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(xmlattributes_key1113.tree, root_0);

            LEFT_PAREN1114 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_xml_attributes_clause14989);
            if  (this->hasException())
            {
                goto rulexml_attributes_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            LEFT_PAREN1114_tree = std::move(get_psrstate()->get_treeAdaptor()->create(LEFT_PAREN1114));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, LEFT_PAREN1114_tree);
            }


            // OracleDML.g:1367:13: ( entityescaping_key | noentityescaping_key )?
            {
                ANTLR_UINT32 alt363=3;
                switch ( this->LA(1) )
                {
                    case REGULAR_ID:
                    	{
                    		{
                    		    ANTLR_UINT32 LA363_1 = this->LA(2);
                    		    if ( ((toUpper(LT(1)->getText()) == "ENTITYESCAPING")))
                    		    {
                    		        alt363=1;
                    		    }
                    		    else if ( ((toUpper(LT(1)->getText()) == "NOENTITYESCAPING")))
                    		    {
                    		        alt363=2;
                    		    }
                    		}
                    	}
                        break;
                }

                switch (alt363)
                {
            	case 1:
            	    // OracleDML.g:1367:14: entityescaping_key
            	    {
            	        this->followPush(FOLLOW_entityescaping_key_in_xml_attributes_clause15004);
            	        entityescaping_key1115=entityescaping_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulexml_attributes_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, entityescaping_key1115.tree);


            	    }
            	    break;
            	case 2:
            	    // OracleDML.g:1367:33: noentityescaping_key
            	    {
            	        this->followPush(FOLLOW_noentityescaping_key_in_xml_attributes_clause15006);
            	        noentityescaping_key1116=noentityescaping_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulexml_attributes_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, noentityescaping_key1116.tree);


            	    }
            	    break;

                }
            }

            // OracleDML.g:1368:13: ( schemacheck_key | noschemacheck_key )?
            {
                ANTLR_UINT32 alt364=3;
                switch ( this->LA(1) )
                {
                    case REGULAR_ID:
                    	{
                    		{
                    		    ANTLR_UINT32 LA364_1 = this->LA(2);
                    		    if ( ((toUpper(LT(1)->getText()) == "SCHEMACHECK")))
                    		    {
                    		        alt364=1;
                    		    }
                    		    else if ( ((toUpper(LT(1)->getText()) == "NOSCHEMACHECK")))
                    		    {
                    		        alt364=2;
                    		    }
                    		}
                    	}
                        break;
                }

                switch (alt364)
                {
            	case 1:
            	    // OracleDML.g:1368:14: schemacheck_key
            	    {
            	        this->followPush(FOLLOW_schemacheck_key_in_xml_attributes_clause15023);
            	        schemacheck_key1117=schemacheck_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulexml_attributes_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, schemacheck_key1117.tree);


            	    }
            	    break;
            	case 2:
            	    // OracleDML.g:1368:30: noschemacheck_key
            	    {
            	        this->followPush(FOLLOW_noschemacheck_key_in_xml_attributes_clause15025);
            	        noschemacheck_key1118=noschemacheck_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulexml_attributes_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, noschemacheck_key1118.tree);


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_xml_multiuse_expression_element_in_xml_attributes_clause15041);
            xml_multiuse_expression_element1119=xml_multiuse_expression_element();

            this->followPop();
            if  (this->hasException())
            {
                goto rulexml_attributes_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, xml_multiuse_expression_element1119.tree);


            // OracleDML.g:1369:45: ( COMMA ! xml_multiuse_expression_element )*

            for (;;)
            {
                ANTLR_UINT32 alt365=2;
                switch ( this->LA(1) )
                {
                case COMMA:
                	{
                		alt365=1;
                	}
                    break;

                }

                switch (alt365)
                {
            	case 1:
            	    // OracleDML.g:1369:46: COMMA ! xml_multiuse_expression_element
            	    {
            	        COMMA1120 =  this->matchToken(COMMA, &FOLLOW_COMMA_in_xml_attributes_clause15044);
            	        if  (this->hasException())
            	        {
            	            goto rulexml_attributes_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }


            	        this->followPush(FOLLOW_xml_multiuse_expression_element_in_xml_attributes_clause15047);
            	        xml_multiuse_expression_element1121=xml_multiuse_expression_element();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulexml_attributes_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, xml_multiuse_expression_element1121.tree);


            	    }
            	    break;

            	default:
            	    goto loop365;	/* break out of the loop */
            	    break;
                }
            }
            loop365: ; /* Jump out to here if this rule does not match */


            RIGHT_PAREN1122 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_xml_attributes_clause15059);
            if  (this->hasException())
            {
                goto rulexml_attributes_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            RIGHT_PAREN1122_tree = std::move(get_psrstate()->get_treeAdaptor()->create(RIGHT_PAREN1122));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, RIGHT_PAREN1122_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulexml_attributes_clauseEx; /* Prevent compiler warnings */
    rulexml_attributes_clauseEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end xml_attributes_clause */

/**
 * $ANTLR start xml_namespaces_clause
 * OracleDML.g:1373:1: xml_namespaces_clause : xmlnamespaces_key ^ LEFT_PAREN ( concatenation_wrapper column_alias )? ( COMMA ! concatenation_wrapper column_alias )* ( ( default_key )=> xml_general_default_part )? RIGHT_PAREN ;
 */
OracleDML::xml_namespaces_clause_return
OracleDML::xml_namespaces_clause()
{
    OracleDML::xml_namespaces_clause_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* LEFT_PAREN1124 = NULL;
    ImplTraits::CommonTokenType const* COMMA1127 = NULL;
    ImplTraits::CommonTokenType const* RIGHT_PAREN1131 = NULL;
    OracleDML_OracleDMLKeys::xmlnamespaces_key_return xmlnamespaces_key1123;
    ImplTraits::TreeTypePtr::pointer xmlnamespaces_key1123_last = NULL;
    OracleDML::concatenation_wrapper_return concatenation_wrapper1125;
    ImplTraits::TreeTypePtr::pointer concatenation_wrapper1125_last = NULL;
    OracleDML_OracleDMLCommons::column_alias_return column_alias1126;
    ImplTraits::TreeTypePtr::pointer column_alias1126_last = NULL;
    OracleDML::concatenation_wrapper_return concatenation_wrapper1128;
    ImplTraits::TreeTypePtr::pointer concatenation_wrapper1128_last = NULL;
    OracleDML_OracleDMLCommons::column_alias_return column_alias1129;
    ImplTraits::TreeTypePtr::pointer column_alias1129_last = NULL;
    OracleDML::xml_general_default_part_return xml_general_default_part1130;
    ImplTraits::TreeTypePtr::pointer xml_general_default_part1130_last = NULL;
    ImplTraits::TreeTypePtr LEFT_PAREN1124_tree;
    ImplTraits::TreeTypePtr COMMA1127_tree;
    ImplTraits::TreeTypePtr RIGHT_PAREN1131_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:1374:5: ( xmlnamespaces_key ^ LEFT_PAREN ( concatenation_wrapper column_alias )? ( COMMA ! concatenation_wrapper column_alias )* ( ( default_key )=> xml_general_default_part )? RIGHT_PAREN )
        // OracleDML.g:1374:10: xmlnamespaces_key ^ LEFT_PAREN ( concatenation_wrapper column_alias )? ( COMMA ! concatenation_wrapper column_alias )* ( ( default_key )=> xml_general_default_part )? RIGHT_PAREN
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            this->followPush(FOLLOW_xmlnamespaces_key_in_xml_namespaces_clause15079);
            xmlnamespaces_key1123=xmlnamespaces_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulexml_namespaces_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(xmlnamespaces_key1123.tree, root_0);

            LEFT_PAREN1124 =  this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_xml_namespaces_clause15090);
            if  (this->hasException())
            {
                goto rulexml_namespaces_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            LEFT_PAREN1124_tree = std::move(get_psrstate()->get_treeAdaptor()->create(LEFT_PAREN1124));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, LEFT_PAREN1124_tree);
            }


            // OracleDML.g:1376:13: ( concatenation_wrapper column_alias )?
            {
                ANTLR_UINT32 alt366=2;
                switch ( this->LA(1) )
                {
                    case APPROXIMATE_NUM_LIT:
                    case BINDVAR:
                    case CHAR_STRING:
                    case CHAR_STRING_PERL:
                    case COLON:
                    case DELIMITED_ID:
                    case EXACT_NUM_LIT:
                    case INTRODUCER:
                    case LEFT_PAREN:
                    case MINUS_SIGN:
                    case NATIONAL_CHAR_STRING_LIT:
                    case PLSQL_NON_RESERVED_CAST:
                    case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
                    case PLUS_SIGN:
                    case REGULAR_ID:
                    case SQL92_RESERVED_ALL:
                    case SQL92_RESERVED_ANY:
                    case SQL92_RESERVED_CASE:
                    case SQL92_RESERVED_DATE:
                    case SQL92_RESERVED_DISTINCT:
                    case SQL92_RESERVED_EXISTS:
                    case SQL92_RESERVED_FALSE:
                    case SQL92_RESERVED_NULL:
                    case SQL92_RESERVED_PRIOR:
                    case SQL92_RESERVED_TRUE:
                    case UNSIGNED_INTEGER:
                    	{
                    		alt366=1;
                    	}
                        break;
                    case SQL92_RESERVED_DEFAULT:
                    	{
                    		alt366=1;
                    	}
                        break;
                }

                switch (alt366)
                {
            	case 1:
            	    // OracleDML.g:1376:14: concatenation_wrapper column_alias
            	    {
            	        this->followPush(FOLLOW_concatenation_wrapper_in_xml_namespaces_clause15105);
            	        concatenation_wrapper1125=concatenation_wrapper();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulexml_namespaces_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, concatenation_wrapper1125.tree);


            	        this->followPush(FOLLOW_column_alias_in_xml_namespaces_clause15107);
            	        column_alias1126=column_alias();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulexml_namespaces_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, column_alias1126.tree);


            	    }
            	    break;

                }
            }

            // OracleDML.g:1377:17: ( COMMA ! concatenation_wrapper column_alias )*

            for (;;)
            {
                ANTLR_UINT32 alt367=2;
                switch ( this->LA(1) )
                {
                case COMMA:
                	{
                		alt367=1;
                	}
                    break;

                }

                switch (alt367)
                {
            	case 1:
            	    // OracleDML.g:1377:18: COMMA ! concatenation_wrapper column_alias
            	    {
            	        COMMA1127 =  this->matchToken(COMMA, &FOLLOW_COMMA_in_xml_namespaces_clause15128);
            	        if  (this->hasException())
            	        {
            	            goto rulexml_namespaces_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }


            	        this->followPush(FOLLOW_concatenation_wrapper_in_xml_namespaces_clause15131);
            	        concatenation_wrapper1128=concatenation_wrapper();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulexml_namespaces_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, concatenation_wrapper1128.tree);


            	        this->followPush(FOLLOW_column_alias_in_xml_namespaces_clause15133);
            	        column_alias1129=column_alias();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulexml_namespaces_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, column_alias1129.tree);


            	    }
            	    break;

            	default:
            	    goto loop367;	/* break out of the loop */
            	    break;
                }
            }
            loop367: ; /* Jump out to here if this rule does not match */


            // OracleDML.g:1378:13: ( ( default_key )=> xml_general_default_part )?
            {
                ANTLR_UINT32 alt368=2;
                {
                    ANTLR_UINT32 LA368_0 = this->LA(1);
                    if ( (LA368_0 == SQL92_RESERVED_DEFAULT) && (this->msynpred( antlr3::ClassForwarder<synpred53_OracleDML>() )))
                    {
                        alt368=1;
                    }
                }
                switch (alt368)
                {
            	case 1:
            	    // OracleDML.g:1378:14: ( default_key )=> xml_general_default_part
            	    {
            	        this->followPush(FOLLOW_xml_general_default_part_in_xml_namespaces_clause15155);
            	        xml_general_default_part1130=xml_general_default_part();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulexml_namespaces_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, xml_general_default_part1130.tree);


            	    }
            	    break;

                }
            }

            RIGHT_PAREN1131 =  this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_xml_namespaces_clause15167);
            if  (this->hasException())
            {
                goto rulexml_namespaces_clauseEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) {
            RIGHT_PAREN1131_tree = std::move(get_psrstate()->get_treeAdaptor()->create(RIGHT_PAREN1131));
            get_psrstate()->get_treeAdaptor()->addChild(root_0, RIGHT_PAREN1131_tree);
            }


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulexml_namespaces_clauseEx; /* Prevent compiler warnings */
    rulexml_namespaces_clauseEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end xml_namespaces_clause */

/**
 * $ANTLR start xml_table_column
 * OracleDML.g:1382:1: xml_table_column : xml_column_name ( for_key ordinality_key | type_spec ( path_key concatenation_wrapper )? ( ( default_key )=> xml_general_default_part )? ) -> ^( XML_COLUMN xml_column_name ( ordinality_key )? ( type_spec )? ( concatenation_wrapper )? ( xml_general_default_part )? ) ;
 */
OracleDML::xml_table_column_return
OracleDML::xml_table_column()
{
    OracleDML::xml_table_column_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML_OracleDMLCommons::xml_column_name_return xml_column_name1132;
    ImplTraits::TreeTypePtr::pointer xml_column_name1132_last = NULL;
    OracleDML_OracleDMLKeys::for_key_return for_key1133;
    ImplTraits::TreeTypePtr::pointer for_key1133_last = NULL;
    OracleDML_OracleDMLKeys::ordinality_key_return ordinality_key1134;
    ImplTraits::TreeTypePtr::pointer ordinality_key1134_last = NULL;
    OracleDML_OracleDMLCommons::type_spec_return type_spec1135;
    ImplTraits::TreeTypePtr::pointer type_spec1135_last = NULL;
    OracleDML_OracleDMLKeys::path_key_return path_key1136;
    ImplTraits::TreeTypePtr::pointer path_key1136_last = NULL;
    OracleDML::concatenation_wrapper_return concatenation_wrapper1137;
    ImplTraits::TreeTypePtr::pointer concatenation_wrapper1137_last = NULL;
    OracleDML::xml_general_default_part_return xml_general_default_part1138;
    ImplTraits::TreeTypePtr::pointer xml_general_default_part1138_last = NULL;
    RewriteRuleSubtreeStream<ImplTraits> stream_type_spec(get_psrstate()->get_treeAdaptor(), "rule type_spec");
    RewriteRuleSubtreeStream<ImplTraits> stream_concatenation_wrapper(get_psrstate()->get_treeAdaptor(), "rule concatenation_wrapper");
    RewriteRuleSubtreeStream<ImplTraits> stream_xml_column_name(get_psrstate()->get_treeAdaptor(), "rule xml_column_name");
    RewriteRuleSubtreeStream<ImplTraits> stream_path_key(get_psrstate()->get_treeAdaptor(), "rule path_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_ordinality_key(get_psrstate()->get_treeAdaptor(), "rule ordinality_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_xml_general_default_part(get_psrstate()->get_treeAdaptor(), "rule xml_general_default_part");
    RewriteRuleSubtreeStream<ImplTraits> stream_for_key(get_psrstate()->get_treeAdaptor(), "rule for_key");

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:1383:5: ( xml_column_name ( for_key ordinality_key | type_spec ( path_key concatenation_wrapper )? ( ( default_key )=> xml_general_default_part )? ) -> ^( XML_COLUMN xml_column_name ( ordinality_key )? ( type_spec )? ( concatenation_wrapper )? ( xml_general_default_part )? ) )
        // OracleDML.g:1383:10: xml_column_name ( for_key ordinality_key | type_spec ( path_key concatenation_wrapper )? ( ( default_key )=> xml_general_default_part )? )
        {
            this->followPush(FOLLOW_xml_column_name_in_xml_table_column15187);
            xml_column_name1132=xml_column_name();

            this->followPop();
            if  (this->hasException())
            {
                goto rulexml_table_columnEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                xml_column_name1132_last = xml_column_name1132.tree.get();
                stream_xml_column_name.add(xml_column_name1132.tree);
            }

            // OracleDML.g:1384:5: ( for_key ordinality_key | type_spec ( path_key concatenation_wrapper )? ( ( default_key )=> xml_general_default_part )? )
            {
                ANTLR_UINT32 alt371=2;
                switch ( this->LA(1) )
                {
                case SQL92_RESERVED_FOR:
                	{
                		alt371=1;
                	}
                    break;
                case DELIMITED_ID:
                case REGULAR_ID:
                case SQL92_RESERVED_DATE:
                	{
                		alt371=2;
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return retval;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 371 );
                    ex->set_state( 0 );


                    goto rulexml_table_columnEx;

                }

                switch (alt371)
                {
            	case 1:
            	    // OracleDML.g:1384:10: for_key ordinality_key
            	    {
            	        this->followPush(FOLLOW_for_key_in_xml_table_column15198);
            	        for_key1133=for_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulexml_table_columnEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            for_key1133_last = for_key1133.tree.get();
            	            stream_for_key.add(for_key1133.tree);
            	        }

            	        this->followPush(FOLLOW_ordinality_key_in_xml_table_column15200);
            	        ordinality_key1134=ordinality_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulexml_table_columnEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            ordinality_key1134_last = ordinality_key1134.tree.get();
            	            stream_ordinality_key.add(ordinality_key1134.tree);
            	        }

            	    }
            	    break;
            	case 2:
            	    // OracleDML.g:1385:10: type_spec ( path_key concatenation_wrapper )? ( ( default_key )=> xml_general_default_part )?
            	    {
            	        this->followPush(FOLLOW_type_spec_in_xml_table_column15211);
            	        type_spec1135=type_spec();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulexml_table_columnEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            type_spec1135_last = type_spec1135.tree.get();
            	            stream_type_spec.add(type_spec1135.tree);
            	        }

            	        // OracleDML.g:1385:20: ( path_key concatenation_wrapper )?
            	        {
            	            ANTLR_UINT32 alt369=2;
            	            {
            	                ANTLR_UINT32 LA369_0 = this->LA(1);
            	                if ( (LA369_0 == REGULAR_ID) && ((toUpper(LT(1)->getText()) == "PATH")))
            	                {
            	                    alt369=1;
            	                }
            	            }
            	            switch (alt369)
            	            {
            	        	case 1:
            	        	    // OracleDML.g:1385:21: path_key concatenation_wrapper
            	        	    {
            	        	        this->followPush(FOLLOW_path_key_in_xml_table_column15214);
            	        	        path_key1136=path_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulexml_table_columnEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) 
            	        	        {
            	        	            path_key1136_last = path_key1136.tree.get();
            	        	            stream_path_key.add(path_key1136.tree);
            	        	        }

            	        	        this->followPush(FOLLOW_concatenation_wrapper_in_xml_table_column15216);
            	        	        concatenation_wrapper1137=concatenation_wrapper();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulexml_table_columnEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) 
            	        	        {
            	        	            concatenation_wrapper1137_last = concatenation_wrapper1137.tree.get();
            	        	            stream_concatenation_wrapper.add(concatenation_wrapper1137.tree);
            	        	        }

            	        	    }
            	        	    break;

            	            }
            	        }

            	        // OracleDML.g:1385:54: ( ( default_key )=> xml_general_default_part )?
            	        {
            	            ANTLR_UINT32 alt370=2;
            	            {
            	                ANTLR_UINT32 LA370_0 = this->LA(1);
            	                if ( (LA370_0 == SQL92_RESERVED_DEFAULT) && (this->msynpred( antlr3::ClassForwarder<synpred54_OracleDML>() )))
            	                {
            	                    alt370=1;
            	                }
            	            }
            	            switch (alt370)
            	            {
            	        	case 1:
            	        	    // OracleDML.g:1385:55: ( default_key )=> xml_general_default_part
            	        	    {
            	        	        this->followPush(FOLLOW_xml_general_default_part_in_xml_table_column15226);
            	        	        xml_general_default_part1138=xml_general_default_part();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulexml_table_columnEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) 
            	        	        {
            	        	            xml_general_default_part1138_last = xml_general_default_part1138.tree.get();
            	        	            stream_xml_general_default_part.add(xml_general_default_part1138.tree);
            	        	        }

            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

                }
            }

            // AST REWRITE
            // elements: concatenation_wrapper, type_spec, xml_general_default_part, ordinality_key, xml_column_name
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1387:9: -> ^( XML_COLUMN xml_column_name ( ordinality_key )? ( type_spec )? ( concatenation_wrapper )? ( xml_general_default_part )? )
            {
            	// OracleDML.g:1387:12: ^( XML_COLUMN xml_column_name ( ordinality_key )? ( type_spec )? ( concatenation_wrapper )? ( xml_general_default_part )? )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(XML_COLUMN, "XML_COLUMN"), root_1);
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_xml_column_name.nextTree());
            	// OracleDML.g:1387:41: ( ordinality_key )?
            	if ( stream_ordinality_key.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_ordinality_key.nextTree());
            	}
            	stream_ordinality_key.reset();

            	// OracleDML.g:1387:57: ( type_spec )?
            	if ( stream_type_spec.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_type_spec.nextTree());
            	}
            	stream_type_spec.reset();

            	// OracleDML.g:1387:68: ( concatenation_wrapper )?
            	if ( stream_concatenation_wrapper.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_concatenation_wrapper.nextTree());
            	}
            	stream_concatenation_wrapper.reset();

            	// OracleDML.g:1387:91: ( xml_general_default_part )?
            	if ( stream_xml_general_default_part.hasNext() ) {
            		get_psrstate()->get_treeAdaptor()->addChild(root_1, stream_xml_general_default_part.nextTree());
            	}
            	stream_xml_general_default_part.reset();

            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulexml_table_columnEx; /* Prevent compiler warnings */
    rulexml_table_columnEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end xml_table_column */

/**
 * $ANTLR start xml_general_default_part
 * OracleDML.g:1390:1: xml_general_default_part : default_key ^ concatenation_wrapper ;
 */
OracleDML::xml_general_default_part_return
OracleDML::xml_general_default_part()
{
    OracleDML::xml_general_default_part_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML_OracleDMLKeys::default_key_return default_key1139;
    ImplTraits::TreeTypePtr::pointer default_key1139_last = NULL;
    OracleDML::concatenation_wrapper_return concatenation_wrapper1140;
    ImplTraits::TreeTypePtr::pointer concatenation_wrapper1140_last = NULL;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:1391:5: ( default_key ^ concatenation_wrapper )
        // OracleDML.g:1391:10: default_key ^ concatenation_wrapper
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            this->followPush(FOLLOW_default_key_in_xml_general_default_part15282);
            default_key1139=default_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulexml_general_default_partEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(default_key1139.tree, root_0);

            this->followPush(FOLLOW_concatenation_wrapper_in_xml_general_default_part15285);
            concatenation_wrapper1140=concatenation_wrapper();

            this->followPop();
            if  (this->hasException())
            {
                goto rulexml_general_default_partEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, concatenation_wrapper1140.tree);


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulexml_general_default_partEx; /* Prevent compiler warnings */
    rulexml_general_default_partEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end xml_general_default_part */

/**
 * $ANTLR start xml_multiuse_expression_element
 * OracleDML.g:1394:1: xml_multiuse_expression_element : expression ( as_key ( id_expression[T_UNKNOWN,T_USE] | evalname_key concatenation ) )? -> {mode == 1}? ^( XML_ELEMENT ^( EXPR expression ) ^( XML_ALIAS[$as_key.start] id_expression ) ) -> {mode == 2}? ^( XML_ELEMENT ^( EXPR expression ) ^( XML_ALIAS[$as_key.start] ^( evalname_key ^( EXPR concatenation ) ) ) ) -> ^( XML_ELEMENT ^( EXPR expression ) ) ;
 */
OracleDML::xml_multiuse_expression_element_return
OracleDML::xml_multiuse_expression_element()
{
    OracleDML::xml_multiuse_expression_element_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML::expression_return expression1141;
    ImplTraits::TreeTypePtr::pointer expression1141_last = NULL;
    OracleDML_OracleDMLKeys::as_key_return as_key1142;
    ImplTraits::TreeTypePtr::pointer as_key1142_last = NULL;
    OracleDML_OracleDMLCommons::id_expression_return id_expression1143;
    ImplTraits::TreeTypePtr::pointer id_expression1143_last = NULL;
    OracleDML_OracleDMLKeys::evalname_key_return evalname_key1144;
    ImplTraits::TreeTypePtr::pointer evalname_key1144_last = NULL;
    OracleDML::concatenation_return concatenation1145;
    ImplTraits::TreeTypePtr::pointer concatenation1145_last = NULL;
    RewriteRuleSubtreeStream<ImplTraits> stream_expression(get_psrstate()->get_treeAdaptor(), "rule expression");
    RewriteRuleSubtreeStream<ImplTraits> stream_evalname_key(get_psrstate()->get_treeAdaptor(), "rule evalname_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_id_expression(get_psrstate()->get_treeAdaptor(), "rule id_expression");
    RewriteRuleSubtreeStream<ImplTraits> stream_as_key(get_psrstate()->get_treeAdaptor(), "rule as_key");
    RewriteRuleSubtreeStream<ImplTraits> stream_concatenation(get_psrstate()->get_treeAdaptor(), "rule concatenation");

    /* Initialize rule variables
     */

        int mode = 0;    
    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:1396:5: ( expression ( as_key ( id_expression[T_UNKNOWN,T_USE] | evalname_key concatenation ) )? -> {mode == 1}? ^( XML_ELEMENT ^( EXPR expression ) ^( XML_ALIAS[$as_key.start] id_expression ) ) -> {mode == 2}? ^( XML_ELEMENT ^( EXPR expression ) ^( XML_ALIAS[$as_key.start] ^( evalname_key ^( EXPR concatenation ) ) ) ) -> ^( XML_ELEMENT ^( EXPR expression ) ) )
        // OracleDML.g:1396:10: expression ( as_key ( id_expression[T_UNKNOWN,T_USE] | evalname_key concatenation ) )?
        {
            this->followPush(FOLLOW_expression_in_xml_multiuse_expression_element15313);
            expression1141=expression();

            this->followPop();
            if  (this->hasException())
            {
                goto rulexml_multiuse_expression_elementEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) 
            {
                expression1141_last = expression1141.tree.get();
                stream_expression.add(expression1141.tree);
            }

            // OracleDML.g:1396:21: ( as_key ( id_expression[T_UNKNOWN,T_USE] | evalname_key concatenation ) )?
            {
                ANTLR_UINT32 alt373=2;
                switch ( this->LA(1) )
                {
                    case SQL92_RESERVED_AS:
                    	{
                    		alt373=1;
                    	}
                        break;
                }

                switch (alt373)
                {
            	case 1:
            	    // OracleDML.g:1396:22: as_key ( id_expression[T_UNKNOWN,T_USE] | evalname_key concatenation )
            	    {
            	        this->followPush(FOLLOW_as_key_in_xml_multiuse_expression_element15316);
            	        as_key1142=as_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulexml_multiuse_expression_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) 
            	        {
            	            as_key1142_last = as_key1142.tree.get();
            	            stream_as_key.add(as_key1142.tree);
            	        }

            	        // OracleDML.g:1396:29: ( id_expression[T_UNKNOWN,T_USE] | evalname_key concatenation )
            	        {
            	            ANTLR_UINT32 alt372=2;
            	            switch ( this->LA(1) )
            	            {
            	            case REGULAR_ID:
            	            	{
            	            		{
            	            		    ANTLR_UINT32 LA372_1 = this->LA(2);
            	            		    if ( (LA372_1 == COMMA || LA372_1 == RIGHT_PAREN))
            	            		    {
            	            		        alt372=1;
            	            		    }
            	            		    else if ( (LA372_1 == APPROXIMATE_NUM_LIT || LA372_1 == BINDVAR || ((LA372_1 >= CHAR_STRING) && (LA372_1 <= CHAR_STRING_PERL)) || LA372_1 == COLON || LA372_1 == DELIMITED_ID || LA372_1 == EXACT_NUM_LIT || LA372_1 == INTRODUCER || LA372_1 == LEFT_PAREN || LA372_1 == MINUS_SIGN || LA372_1 == NATIONAL_CHAR_STRING_LIT || ((LA372_1 >= PLSQL_NON_RESERVED_CAST) && (LA372_1 <= PLSQL_NON_RESERVED_CONNECT_BY_ROOT)) || LA372_1 == PLUS_SIGN || LA372_1 == REGULAR_ID || LA372_1 == SQL92_RESERVED_ALL || LA372_1 == SQL92_RESERVED_ANY || LA372_1 == SQL92_RESERVED_CASE || LA372_1 == SQL92_RESERVED_DATE || LA372_1 == SQL92_RESERVED_DEFAULT || LA372_1 == SQL92_RESERVED_DISTINCT || ((LA372_1 >= SQL92_RESERVED_EXISTS) && (LA372_1 <= SQL92_RESERVED_FALSE)) || LA372_1 == SQL92_RESERVED_NULL || LA372_1 == SQL92_RESERVED_PRIOR || LA372_1 == SQL92_RESERVED_TRUE || LA372_1 == UNSIGNED_INTEGER) && ((toUpper(LT(1)->getText()) == "EVALNAME")))
            	            		    {
            	            		        alt372=2;
            	            		    }
            	            		    else
            	            		    {
            	            		        if (this->get_backtracking()>0)
            	            		        {
            	            		            this->set_failedflag( true );
            	            		            return retval;
            	            		        }


            	            		        ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	            		        ex->set_decisionNum( 372 );
            	            		        ex->set_state( 1 );


            	            		        goto rulexml_multiuse_expression_elementEx;

            	            		    }
            	            		}
            	            	}
            	                break;
            	            case DELIMITED_ID:
            	            	{
            	            		alt372=1;
            	            	}
            	                break;

            	            default:
            	                if (this->get_backtracking()>0)
            	                {
            	                    this->set_failedflag( true );
            	                    return retval;
            	                }

            	                ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                ex->set_decisionNum( 372 );
            	                ex->set_state( 0 );


            	                goto rulexml_multiuse_expression_elementEx;

            	            }

            	            switch (alt372)
            	            {
            	        	case 1:
            	        	    // OracleDML.g:1396:30: id_expression[T_UNKNOWN,T_USE]
            	        	    {
            	        	        this->followPush(FOLLOW_id_expression_in_xml_multiuse_expression_element15319);
            	        	        id_expression1143=id_expression(T_UNKNOWN, T_USE);

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulexml_multiuse_expression_elementEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) 
            	        	        {
            	        	            id_expression1143_last = id_expression1143.tree.get();
            	        	            stream_id_expression.add(id_expression1143.tree);
            	        	        }

            	        	        if ( this->get_backtracking()==0 )
            	        	        {
            	        	            mode = 1;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // OracleDML.g:1396:73: evalname_key concatenation
            	        	    {
            	        	        this->followPush(FOLLOW_evalname_key_in_xml_multiuse_expression_element15324);
            	        	        evalname_key1144=evalname_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulexml_multiuse_expression_elementEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) 
            	        	        {
            	        	            evalname_key1144_last = evalname_key1144.tree.get();
            	        	            stream_evalname_key.add(evalname_key1144.tree);
            	        	        }

            	        	        this->followPush(FOLLOW_concatenation_in_xml_multiuse_expression_element15326);
            	        	        concatenation1145=concatenation();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulexml_multiuse_expression_elementEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) 
            	        	        {
            	        	            concatenation1145_last = concatenation1145.tree.get();
            	        	            stream_concatenation.add(concatenation1145.tree);
            	        	        }

            	        	        if ( this->get_backtracking()==0 )
            	        	        {
            	        	            mode = 2;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

                }
            }

            // AST REWRITE
            // elements: id_expression, evalname_key, expression, concatenation, expression, expression
            // token labels: 
            // rule labels: retval
            // token list labels: 
            // rule list labels: 
            // wildcard labels: 
            if ( this->get_backtracking()==0 ) {
            retval.tree = std::move(root_0);
            RewriteRuleSubtreeStream<ImplTraits> stream_retval(get_psrstate()->get_treeAdaptor(), "rule retval",retval.tree); // retval

            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());
            // 1397:9: -> {mode == 1}? ^( XML_ELEMENT ^( EXPR expression ) ^( XML_ALIAS[$as_key.start] id_expression ) )
            if (mode == 1) {
            	// OracleDML.g:1397:25: ^( XML_ELEMENT ^( EXPR expression ) ^( XML_ALIAS[$as_key.start] id_expression ) )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(XML_ELEMENT, "XML_ELEMENT"), root_1);
            	// OracleDML.g:1397:39: ^( EXPR expression )
            	{
            	ImplTraits::TreeTypePtr root_2 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_2 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(EXPR, "EXPR"), root_2);
            	get_psrstate()->get_treeAdaptor()->addChild(root_2, stream_expression.nextTree());
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, root_2);
            	}
            	// OracleDML.g:1397:58: ^( XML_ALIAS[$as_key.start] id_expression )
            	{
            	ImplTraits::TreeTypePtr root_2 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_2 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(XML_ALIAS, (as_key1142.start)), root_2);
            	get_psrstate()->get_treeAdaptor()->addChild(root_2, stream_id_expression.nextTree());
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, root_2);
            	}
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }

            else // 1398:9: -> {mode == 2}? ^( XML_ELEMENT ^( EXPR expression ) ^( XML_ALIAS[$as_key.start] ^( evalname_key ^( EXPR concatenation ) ) ) )
            if (mode == 2) {
            	// OracleDML.g:1398:25: ^( XML_ELEMENT ^( EXPR expression ) ^( XML_ALIAS[$as_key.start] ^( evalname_key ^( EXPR concatenation ) ) ) )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(XML_ELEMENT, "XML_ELEMENT"), root_1);
            	// OracleDML.g:1398:39: ^( EXPR expression )
            	{
            	ImplTraits::TreeTypePtr root_2 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_2 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(EXPR, "EXPR"), root_2);
            	get_psrstate()->get_treeAdaptor()->addChild(root_2, stream_expression.nextTree());
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, root_2);
            	}
            	// OracleDML.g:1398:58: ^( XML_ALIAS[$as_key.start] ^( evalname_key ^( EXPR concatenation ) ) )
            	{
            	ImplTraits::TreeTypePtr root_2 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_2 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(XML_ALIAS, (as_key1142.start)), root_2);
            	// OracleDML.g:1398:85: ^( evalname_key ^( EXPR concatenation ) )
            	{
            	ImplTraits::TreeTypePtr root_3 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_3 = get_psrstate()->get_treeAdaptor()->becomeRoot(stream_evalname_key.nextNode(), root_3);
            	// OracleDML.g:1398:100: ^( EXPR concatenation )
            	{
            	ImplTraits::TreeTypePtr root_4 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_4 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(EXPR, "EXPR"), root_4);
            	get_psrstate()->get_treeAdaptor()->addChild(root_4, stream_concatenation.nextTree());
            	get_psrstate()->get_treeAdaptor()->addChild(root_3, root_4);
            	}
            	get_psrstate()->get_treeAdaptor()->addChild(root_2, root_3);
            	}
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, root_2);
            	}
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }

            else // 1399:9: -> ^( XML_ELEMENT ^( EXPR expression ) )
            {
            	// OracleDML.g:1399:12: ^( XML_ELEMENT ^( EXPR expression ) )
            	{
            	ImplTraits::TreeTypePtr root_1 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_1 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(XML_ELEMENT, "XML_ELEMENT"), root_1);
            	// OracleDML.g:1399:26: ^( EXPR expression )
            	{
            	ImplTraits::TreeTypePtr root_2 = get_psrstate()->get_treeAdaptor()->nilNode();
            	root_2 = get_psrstate()->get_treeAdaptor()->becomeRoot(get_psrstate()->get_treeAdaptor()->create(EXPR, "EXPR"), root_2);
            	get_psrstate()->get_treeAdaptor()->addChild(root_2, stream_expression.nextTree());
            	get_psrstate()->get_treeAdaptor()->addChild(root_1, root_2);
            	}
            	get_psrstate()->get_treeAdaptor()->addChild(root_0, root_1);
            	}
            }


            //retval.tree = std::move(root_0);
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulexml_multiuse_expression_elementEx; /* Prevent compiler warnings */
    rulexml_multiuse_expression_elementEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end xml_multiuse_expression_element */

/**
 * $ANTLR start xmlroot_param_version_part
 * OracleDML.g:1402:1: xmlroot_param_version_part : version_key ^ ( no_key value_key | expression_wrapper ) ;
 */
OracleDML::xmlroot_param_version_part_return
OracleDML::xmlroot_param_version_part()
{
    OracleDML::xmlroot_param_version_part_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML_OracleDMLKeys::version_key_return version_key1146;
    ImplTraits::TreeTypePtr::pointer version_key1146_last = NULL;
    OracleDML_OracleDMLKeys::no_key_return no_key1147;
    ImplTraits::TreeTypePtr::pointer no_key1147_last = NULL;
    OracleDML_OracleDMLKeys::value_key_return value_key1148;
    ImplTraits::TreeTypePtr::pointer value_key1148_last = NULL;
    OracleDML::expression_wrapper_return expression_wrapper1149;
    ImplTraits::TreeTypePtr::pointer expression_wrapper1149_last = NULL;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:1403:5: ( version_key ^ ( no_key value_key | expression_wrapper ) )
        // OracleDML.g:1403:10: version_key ^ ( no_key value_key | expression_wrapper )
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            this->followPush(FOLLOW_version_key_in_xmlroot_param_version_part15437);
            version_key1146=version_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulexmlroot_param_version_partEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(version_key1146.tree, root_0);

            // OracleDML.g:1403:23: ( no_key value_key | expression_wrapper )
            {
                ANTLR_UINT32 alt374=2;
                switch ( this->LA(1) )
                {
                case REGULAR_ID:
                	{
                		{
                		    ANTLR_UINT32 LA374_1 = this->LA(2);
                		    if ( (LA374_1 == REGULAR_ID))
                		    {
                		        {
                		            ANTLR_UINT32 LA374_3 = this->LA(3);
                		            if ( ((toUpper(LT(1)->getText()) == "NO")))
                		            {
                		                alt374=1;
                		            }
                		            else if ( (true))
                		            {
                		                alt374=2;
                		            }
                		            else
                		            {
                		                if (this->get_backtracking()>0)
                		                {
                		                    this->set_failedflag( true );
                		                    return retval;
                		                }


                		                ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		                ex->set_decisionNum( 374 );
                		                ex->set_state( 3 );


                		                goto rulexmlroot_param_version_partEx;

                		            }
                		        }
                		    }
                		    else if ( (LA374_1 == MINUS_SIGN || LA374_1 == PLUS_SIGN))
                		    {
                		        alt374=2;
                		    }
                		    else if ( (LA374_1 == PLSQL_NON_RESERVED_CONNECT_BY_ROOT || LA374_1 == SQL92_RESERVED_ALL || LA374_1 == SQL92_RESERVED_DISTINCT || LA374_1 == SQL92_RESERVED_PRIOR) && (( ((LT(1)->getText() == "NEW" && LT(2)->getText() != ".")) && ((toUpper(LT(1)->getText()) == "NEW")) )))
                		    {
                		        alt374=2;
                		    }
                		    else if ( (LA374_1 == DELIMITED_ID) && ((((toUpper(LT(1)->getText()) == "INTERVAL"))||(( ((LT(1)->getText() == "NEW" && LT(2)->getText() != ".")) && ((toUpper(LT(1)->getText()) == "NEW")) )))))
                		    {
                		        alt374=2;
                		    }
                		    else if ( (LA374_1 == SQL92_RESERVED_CASE))
                		    {
                		        alt374=2;
                		    }
                		    else if ( (LA374_1 == PLSQL_NON_RESERVED_CAST || LA374_1 == SQL92_RESERVED_ANY || LA374_1 == SQL92_RESERVED_EXISTS) && (( ((LT(1)->getText() == "NEW" && LT(2)->getText() != ".")) && ((toUpper(LT(1)->getText()) == "NEW")) )))
                		    {
                		        alt374=2;
                		    }
                		    else if ( (LA374_1 == INTRODUCER) && ((((toUpper(LT(1)->getText()) == "INTERVAL"))||(( ((LT(1)->getText() == "NEW" && LT(2)->getText() != ".")) && ((toUpper(LT(1)->getText()) == "NEW")) )))))
                		    {
                		        alt374=2;
                		    }
                		    else if ( (LA374_1 == BINDVAR || LA374_1 == COLON))
                		    {
                		        alt374=2;
                		    }
                		    else if ( (LA374_1 == APPROXIMATE_NUM_LIT || LA374_1 == EXACT_NUM_LIT || LA374_1 == SQL92_RESERVED_DATE || LA374_1 == UNSIGNED_INTEGER) && (( ((LT(1)->getText() == "NEW" && LT(2)->getText() != ".")) && ((toUpper(LT(1)->getText()) == "NEW")) )))
                		    {
                		        alt374=2;
                		    }
                		    else if ( (((LA374_1 >= CHAR_STRING) && (LA374_1 <= CHAR_STRING_PERL)) || LA374_1 == NATIONAL_CHAR_STRING_LIT))
                		    {
                		        alt374=2;
                		    }
                		    else if ( (LA374_1 == SQL92_RESERVED_DEFAULT || LA374_1 == SQL92_RESERVED_FALSE || LA374_1 == SQL92_RESERVED_NULL || LA374_1 == SQL92_RESERVED_TRUE) && (( ((LT(1)->getText() == "NEW" && LT(2)->getText() != ".")) && ((toUpper(LT(1)->getText()) == "NEW")) )))
                		    {
                		        alt374=2;
                		    }
                		    else if ( (LA374_1 == ASTERISK || LA374_1 == CARRET_OPERATOR_PART || LA374_1 == COMMA || LA374_1 == CONCATENATION_OP || LA374_1 == EQUALS_OP || LA374_1 == EXCLAMATION_OPERATOR_PART || ((LA374_1 >= GREATER_THAN_OP) && (LA374_1 <= GREATER_THAN_OR_EQUALS_OP)) || ((LA374_1 >= LEFT_BRACKET) && (LA374_1 <= LEFT_PAREN)) || ((LA374_1 >= LESS_THAN_OP) && (LA374_1 <= LESS_THAN_OR_EQUALS_OP)) || LA374_1 == NOT_EQUAL_OP || LA374_1 == PERIOD || LA374_1 == PLSQL_NON_RESERVED_MULTISET || LA374_1 == RIGHT_PAREN || LA374_1 == SOLIDUS || LA374_1 == SQL92_RESERVED_AND || LA374_1 == SQL92_RESERVED_BETWEEN || LA374_1 == SQL92_RESERVED_IN || ((LA374_1 >= SQL92_RESERVED_IS) && (LA374_1 <= SQL92_RESERVED_NOT)) || LA374_1 == SQL92_RESERVED_OR || LA374_1 == VERTICAL_BAR))
                		    {
                		        alt374=2;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return retval;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 374 );
                		        ex->set_state( 1 );


                		        goto rulexmlroot_param_version_partEx;

                		    }
                		}
                	}
                    break;
                case APPROXIMATE_NUM_LIT:
                case BINDVAR:
                case CHAR_STRING:
                case CHAR_STRING_PERL:
                case COLON:
                case DELIMITED_ID:
                case EXACT_NUM_LIT:
                case INTRODUCER:
                case LEFT_PAREN:
                case MINUS_SIGN:
                case NATIONAL_CHAR_STRING_LIT:
                case PLSQL_NON_RESERVED_CAST:
                case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
                case PLUS_SIGN:
                case SQL92_RESERVED_ALL:
                case SQL92_RESERVED_ANY:
                case SQL92_RESERVED_CASE:
                case SQL92_RESERVED_CURSOR:
                case SQL92_RESERVED_DATE:
                case SQL92_RESERVED_DEFAULT:
                case SQL92_RESERVED_DISTINCT:
                case SQL92_RESERVED_EXISTS:
                case SQL92_RESERVED_FALSE:
                case SQL92_RESERVED_NOT:
                case SQL92_RESERVED_NULL:
                case SQL92_RESERVED_PRIOR:
                case SQL92_RESERVED_TRUE:
                case UNSIGNED_INTEGER:
                	{
                		alt374=2;
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return retval;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 374 );
                    ex->set_state( 0 );


                    goto rulexmlroot_param_version_partEx;

                }

                switch (alt374)
                {
            	case 1:
            	    // OracleDML.g:1403:24: no_key value_key
            	    {
            	        this->followPush(FOLLOW_no_key_in_xmlroot_param_version_part15441);
            	        no_key1147=no_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulexmlroot_param_version_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, no_key1147.tree);


            	        this->followPush(FOLLOW_value_key_in_xmlroot_param_version_part15443);
            	        value_key1148=value_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulexmlroot_param_version_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, value_key1148.tree);


            	    }
            	    break;
            	case 2:
            	    // OracleDML.g:1403:41: expression_wrapper
            	    {
            	        this->followPush(FOLLOW_expression_wrapper_in_xmlroot_param_version_part15445);
            	        expression_wrapper1149=expression_wrapper();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulexmlroot_param_version_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, expression_wrapper1149.tree);


            	    }
            	    break;

                }
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulexmlroot_param_version_partEx; /* Prevent compiler warnings */
    rulexmlroot_param_version_partEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end xmlroot_param_version_part */

/**
 * $ANTLR start xmlroot_param_standalone_part
 * OracleDML.g:1406:1: xmlroot_param_standalone_part : standalone_key ^ ( yes_key | no_key ( value_key )? ) ;
 */
OracleDML::xmlroot_param_standalone_part_return
OracleDML::xmlroot_param_standalone_part()
{
    OracleDML::xmlroot_param_standalone_part_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML_OracleDMLKeys::standalone_key_return standalone_key1150;
    ImplTraits::TreeTypePtr::pointer standalone_key1150_last = NULL;
    OracleDML_OracleDMLKeys::yes_key_return yes_key1151;
    ImplTraits::TreeTypePtr::pointer yes_key1151_last = NULL;
    OracleDML_OracleDMLKeys::no_key_return no_key1152;
    ImplTraits::TreeTypePtr::pointer no_key1152_last = NULL;
    OracleDML_OracleDMLKeys::value_key_return value_key1153;
    ImplTraits::TreeTypePtr::pointer value_key1153_last = NULL;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:1407:5: ( standalone_key ^ ( yes_key | no_key ( value_key )? ) )
        // OracleDML.g:1407:10: standalone_key ^ ( yes_key | no_key ( value_key )? )
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            this->followPush(FOLLOW_standalone_key_in_xmlroot_param_standalone_part15466);
            standalone_key1150=standalone_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulexmlroot_param_standalone_partEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(standalone_key1150.tree, root_0);

            // OracleDML.g:1407:26: ( yes_key | no_key ( value_key )? )
            {
                ANTLR_UINT32 alt376=2;
                {
                    ANTLR_UINT32 LA376_0 = this->LA(1);
                    if ( (LA376_0 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "NO"))||((toUpper(LT(1)->getText()) == "YES")))))
                    {
                        {
                            ANTLR_UINT32 LA376_1 = this->LA(2);
                            if ( ((toUpper(LT(1)->getText()) == "YES")))
                            {
                                alt376=1;
                            }
                            else if ( ((toUpper(LT(1)->getText()) == "NO")))
                            {
                                alt376=2;
                            }
                            else
                            {
                                if (this->get_backtracking()>0)
                                {
                                    this->set_failedflag( true );
                                    return retval;
                                }


                                ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                ex->set_decisionNum( 376 );
                                ex->set_state( 1 );


                                goto rulexmlroot_param_standalone_partEx;

                            }
                        }
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return retval;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 376 );
                        ex->set_state( 0 );


                        goto rulexmlroot_param_standalone_partEx;

                    }
                }
                switch (alt376)
                {
            	case 1:
            	    // OracleDML.g:1407:27: yes_key
            	    {
            	        this->followPush(FOLLOW_yes_key_in_xmlroot_param_standalone_part15470);
            	        yes_key1151=yes_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulexmlroot_param_standalone_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, yes_key1151.tree);


            	    }
            	    break;
            	case 2:
            	    // OracleDML.g:1407:35: no_key ( value_key )?
            	    {
            	        this->followPush(FOLLOW_no_key_in_xmlroot_param_standalone_part15472);
            	        no_key1152=no_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulexmlroot_param_standalone_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retval;
            	        }

            	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, no_key1152.tree);


            	        // OracleDML.g:1407:42: ( value_key )?
            	        {
            	            ANTLR_UINT32 alt375=2;
            	            switch ( this->LA(1) )
            	            {
            	                case REGULAR_ID:
            	                	{
            	                		alt375=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt375)
            	            {
            	        	case 1:
            	        	    // OracleDML.g:1407:42: value_key
            	        	    {
            	        	        this->followPush(FOLLOW_value_key_in_xmlroot_param_standalone_part15474);
            	        	        value_key1153=value_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulexmlroot_param_standalone_partEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, value_key1153.tree);


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

                }
            }

        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulexmlroot_param_standalone_partEx; /* Prevent compiler warnings */
    rulexmlroot_param_standalone_partEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end xmlroot_param_standalone_part */

/**
 * $ANTLR start xmlserialize_param_enconding_part
 * OracleDML.g:1410:1: xmlserialize_param_enconding_part : encoding_key ^ concatenation_wrapper ;
 */
OracleDML::xmlserialize_param_enconding_part_return
OracleDML::xmlserialize_param_enconding_part()
{
    OracleDML::xmlserialize_param_enconding_part_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML_OracleDMLKeys::encoding_key_return encoding_key1154;
    ImplTraits::TreeTypePtr::pointer encoding_key1154_last = NULL;
    OracleDML::concatenation_wrapper_return concatenation_wrapper1155;
    ImplTraits::TreeTypePtr::pointer concatenation_wrapper1155_last = NULL;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:1411:5: ( encoding_key ^ concatenation_wrapper )
        // OracleDML.g:1411:10: encoding_key ^ concatenation_wrapper
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            this->followPush(FOLLOW_encoding_key_in_xmlserialize_param_enconding_part15496);
            encoding_key1154=encoding_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulexmlserialize_param_enconding_partEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(encoding_key1154.tree, root_0);

            this->followPush(FOLLOW_concatenation_wrapper_in_xmlserialize_param_enconding_part15499);
            concatenation_wrapper1155=concatenation_wrapper();

            this->followPop();
            if  (this->hasException())
            {
                goto rulexmlserialize_param_enconding_partEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, concatenation_wrapper1155.tree);


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulexmlserialize_param_enconding_partEx; /* Prevent compiler warnings */
    rulexmlserialize_param_enconding_partEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end xmlserialize_param_enconding_part */

/**
 * $ANTLR start xmlserialize_param_version_part
 * OracleDML.g:1414:1: xmlserialize_param_version_part : version_key ^ concatenation_wrapper ;
 */
OracleDML::xmlserialize_param_version_part_return
OracleDML::xmlserialize_param_version_part()
{
    OracleDML::xmlserialize_param_version_part_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    OracleDML_OracleDMLKeys::version_key_return version_key1156;
    ImplTraits::TreeTypePtr::pointer version_key1156_last = NULL;
    OracleDML::concatenation_wrapper_return concatenation_wrapper1157;
    ImplTraits::TreeTypePtr::pointer concatenation_wrapper1157_last = NULL;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        // OracleDML.g:1415:5: ( version_key ^ concatenation_wrapper )
        // OracleDML.g:1415:10: version_key ^ concatenation_wrapper
        {
            root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


            this->followPush(FOLLOW_version_key_in_xmlserialize_param_version_part15519);
            version_key1156=version_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulexmlserialize_param_version_partEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(version_key1156.tree, root_0);

            this->followPush(FOLLOW_concatenation_wrapper_in_xmlserialize_param_version_part15522);
            concatenation_wrapper1157=concatenation_wrapper();

            this->followPop();
            if  (this->hasException())
            {
                goto rulexmlserialize_param_version_partEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }

            if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, concatenation_wrapper1157.tree);


        }

    }//...
    // This is where rules clean up and exit
    //
    goto rulexmlserialize_param_version_partEx; /* Prevent compiler warnings */
    rulexmlserialize_param_version_partEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end xmlserialize_param_version_part */

/**
 * $ANTLR start xmlserialize_param_ident_part
 * OracleDML.g:1418:1: xmlserialize_param_ident_part : ( no_key indent_key | indent_key ^ ( size_key ! EQUALS_OP ! concatenation_wrapper )? );
 */
OracleDML::xmlserialize_param_ident_part_return
OracleDML::xmlserialize_param_ident_part()
{
    OracleDML::xmlserialize_param_ident_part_return retval(this);


    ImplTraits::TreeTypePtr root_0;

    ImplTraits::CommonTokenType const* EQUALS_OP1162 = NULL;
    OracleDML_OracleDMLKeys::no_key_return no_key1158;
    ImplTraits::TreeTypePtr::pointer no_key1158_last = NULL;
    OracleDML_OracleDMLKeys::indent_key_return indent_key1159;
    ImplTraits::TreeTypePtr::pointer indent_key1159_last = NULL;
    OracleDML_OracleDMLKeys::indent_key_return indent_key1160;
    ImplTraits::TreeTypePtr::pointer indent_key1160_last = NULL;
    OracleDML_OracleDMLKeys::size_key_return size_key1161;
    ImplTraits::TreeTypePtr::pointer size_key1161_last = NULL;
    OracleDML::concatenation_wrapper_return concatenation_wrapper1163;
    ImplTraits::TreeTypePtr::pointer concatenation_wrapper1163_last = NULL;
    ImplTraits::TreeTypePtr EQUALS_OP1162_tree;

    /* Initialize rule variables
     */

    retval.call_start_placeholder(this);


 
    {
        {
            //  OracleDML.g:1419:5: ( no_key indent_key | indent_key ^ ( size_key ! EQUALS_OP ! concatenation_wrapper )? )

            ANTLR_UINT32 alt378;

            alt378=2;

            {
                ANTLR_UINT32 LA378_0 = this->LA(1);
                if ( (LA378_0 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "INDENT"))||((toUpper(LT(1)->getText()) == "NO")))))
                {
                    {
                        ANTLR_UINT32 LA378_1 = this->LA(2);
                        if ( (LA378_1 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "INDENT"))||((toUpper(LT(1)->getText()) == "NO")))))
                        {
                            {
                                ANTLR_UINT32 LA378_2 = this->LA(3);
                                if ( (LA378_2 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "INDENT"))||((toUpper(LT(1)->getText()) == "NO")))))
                                {
                                    {
                                        ANTLR_UINT32 LA378_4 = this->LA(4);
                                        if ( (LA378_4 == REGULAR_ID) && ((toUpper(LT(1)->getText()) == "NO")))
                                        {
                                            alt378=1;
                                        }
                                        else if ( (LA378_4 == RIGHT_PAREN) && ((toUpper(LT(1)->getText()) == "INDENT")))
                                        {
                                            alt378=2;
                                        }
                                        else
                                        {
                                            if (this->get_backtracking()>0)
                                            {
                                                this->set_failedflag( true );
                                                return retval;
                                            }


                                            ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                            ex->set_decisionNum( 378 );
                                            ex->set_state( 4 );


                                            goto rulexmlserialize_param_ident_partEx;

                                        }
                                    }
                                }
                                else if ( (LA378_2 == RIGHT_PAREN) && ((toUpper(LT(1)->getText()) == "NO")))
                                {
                                    alt378=1;
                                }
                                else
                                {
                                    if (this->get_backtracking()>0)
                                    {
                                        this->set_failedflag( true );
                                        return retval;
                                    }


                                    ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                    ex->set_decisionNum( 378 );
                                    ex->set_state( 2 );


                                    goto rulexmlserialize_param_ident_partEx;

                                }
                            }
                        }
                        else if ( (LA378_1 == RIGHT_PAREN || LA378_1 == SQL92_RESERVED_SIZE) && ((toUpper(LT(1)->getText()) == "INDENT")))
                        {
                            alt378=2;
                        }
                        else
                        {
                            if (this->get_backtracking()>0)
                            {
                                this->set_failedflag( true );
                                return retval;
                            }


                            ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                            ex->set_decisionNum( 378 );
                            ex->set_state( 1 );


                            goto rulexmlserialize_param_ident_partEx;

                        }
                    }
                }
                else
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return retval;
                    }


                    ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 378 );
                    ex->set_state( 0 );


                    goto rulexmlserialize_param_ident_partEx;

                }
            }
            switch (alt378)
            {
        	case 1:
        	    // OracleDML.g:1419:10: no_key indent_key
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_no_key_in_xmlserialize_param_ident_part15542);
        	        no_key1158=no_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulexmlserialize_param_ident_partEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, no_key1158.tree);


        	        this->followPush(FOLLOW_indent_key_in_xmlserialize_param_ident_part15544);
        	        indent_key1159=indent_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulexmlserialize_param_ident_partEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, indent_key1159.tree);


        	    }
        	    break;
        	case 2:
        	    // OracleDML.g:1420:10: indent_key ^ ( size_key ! EQUALS_OP ! concatenation_wrapper )?
        	    {
        	        root_0 = std::move(get_psrstate()->get_treeAdaptor()->nilNode());


        	        this->followPush(FOLLOW_indent_key_in_xmlserialize_param_ident_part15555);
        	        indent_key1160=indent_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulexmlserialize_param_ident_partEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }

        	        if ( this->get_backtracking()==0 ) root_0 = get_psrstate()->get_treeAdaptor()->becomeRoot(indent_key1160.tree, root_0);

        	        // OracleDML.g:1420:22: ( size_key ! EQUALS_OP ! concatenation_wrapper )?
        	        {
        	            ANTLR_UINT32 alt377=2;
        	            switch ( this->LA(1) )
        	            {
        	                case SQL92_RESERVED_SIZE:
        	                	{
        	                		alt377=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt377)
        	            {
        	        	case 1:
        	        	    // OracleDML.g:1420:23: size_key ! EQUALS_OP ! concatenation_wrapper
        	        	    {
        	        	        this->followPush(FOLLOW_size_key_in_xmlserialize_param_ident_part15559);
        	        	        size_key1161=size_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulexmlserialize_param_ident_partEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }


        	        	        EQUALS_OP1162 =  this->matchToken(EQUALS_OP, &FOLLOW_EQUALS_OP_in_xmlserialize_param_ident_part15562);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulexmlserialize_param_ident_partEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }


        	        	        this->followPush(FOLLOW_concatenation_wrapper_in_xmlserialize_param_ident_part15565);
        	        	        concatenation_wrapper1163=concatenation_wrapper();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulexmlserialize_param_ident_partEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( this->get_backtracking()==0 ) get_psrstate()->get_treeAdaptor()->addChild(root_0, concatenation_wrapper1163.tree);


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;

            }
        }
    }//...
    // This is where rules clean up and exit
    //
    goto rulexmlserialize_param_ident_partEx; /* Prevent compiler warnings */
    rulexmlserialize_param_ident_partEx: ;
    retval.call_stop_placeholder(this);


    if ( this->get_backtracking()==0 ) {
    retval.tree = get_psrstate()->get_treeAdaptor()->rulePostProcessing(root_0);
    get_psrstate()->get_treeAdaptor()->setTokenBoundaries(retval.tree, retval.start, retval.stop);
    }

    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
            //TODO
            //retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(input, retval.start, input.LT(-1));
            retval.tree = get_psrstate()->get_treeAdaptor()->errorNode(NULL, retval.start, LT(-1));
        }
    return retval;
}
/* $ANTLR end xmlserialize_param_ident_part */

// $ANTLR start synpredRule synpred1_OracleDML
void OracleDML::msynpred1_OracleDML_fragment(  )
{
    // OracleDML.g:156:28: ( order_key ( siblings_key )? by_key )
    // OracleDML.g:156:29: order_key ( siblings_key )? by_key
    {
        this->followPush(FOLLOW_order_key_in_synpred1_OracleDML1009);
        order_key();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred1_OracleDMLEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



        // OracleDML.g:156:39: ( siblings_key )?
        {
            ANTLR_UINT32 alt379=2;
            {
                ANTLR_UINT32 LA379_0 = this->LA(1);
                if ( (LA379_0 == REGULAR_ID) && ((toUpper(LT(1)->getText()) == "SIBLINGS")))
                {
                    alt379=1;
                }
            }
            switch (alt379)
            {
        	case 1:
        	    // OracleDML.g:156:39: siblings_key
        	    {
        	        this->followPush(FOLLOW_siblings_key_in_synpred1_OracleDML1011);
        	        siblings_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesynpred1_OracleDMLEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }



        	    }
        	    break;

            }
        }

        this->followPush(FOLLOW_by_key_in_synpred1_OracleDML1014);
        by_key();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred1_OracleDMLEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



    }


goto rulesynpred1_OracleDMLEx; /* Prevent compiler warnings */
rulesynpred1_OracleDMLEx: ;
}
// $ANTLR end synpred1_OracleDML

// $ANTLR start synpredRule synpred2_OracleDML
void OracleDML::msynpred2_OracleDML_fragment(  )
{
    {
        //  OracleDML.g:212:10: ( distinct_key | unique_key | all_key )

        ANTLR_UINT32 alt380;

        alt380=3;

        switch ( this->LA(1) )
        {
        case SQL92_RESERVED_DISTINCT:
        	{
        		alt380=1;
        	}
            break;
        case SQL92_RESERVED_UNIQUE:
        	{
        		alt380=2;
        	}
            break;
        case SQL92_RESERVED_ALL:
        	{
        		alt380=3;
        	}
            break;

        default:
            if (this->get_backtracking()>0)
            {
                this->set_failedflag( true );
                return ;
            }

            ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            ex->set_decisionNum( 380 );
            ex->set_state( 0 );


            goto rulesynpred2_OracleDMLEx;

        }

        switch (alt380)
        {
    	case 1:
    	    // OracleDML.g:212:11: distinct_key
    	    {
    	        this->followPush(FOLLOW_distinct_key_in_synpred2_OracleDML1628);
    	        distinct_key();

    	        this->followPop();
    	        if  (this->hasException())
    	        {
    	            goto rulesynpred2_OracleDMLEx;
    	        }
    	        if (this->hasFailed())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 2:
    	    // OracleDML.g:212:24: unique_key
    	    {
    	        this->followPush(FOLLOW_unique_key_in_synpred2_OracleDML1630);
    	        unique_key();

    	        this->followPop();
    	        if  (this->hasException())
    	        {
    	            goto rulesynpred2_OracleDMLEx;
    	        }
    	        if (this->hasFailed())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 3:
    	    // OracleDML.g:212:35: all_key
    	    {
    	        this->followPush(FOLLOW_all_key_in_synpred2_OracleDML1632);
    	        all_key();

    	        this->followPop();
    	        if  (this->hasException())
    	        {
    	            goto rulesynpred2_OracleDMLEx;
    	        }
    	        if (this->hasFailed())
    	        {
    	            return ;
    	        }



    	    }
    	    break;

        }
    }

goto rulesynpred2_OracleDMLEx; /* Prevent compiler warnings */
rulesynpred2_OracleDMLEx: ;
}
// $ANTLR end synpred2_OracleDML

// $ANTLR start synpredRule synpred3_OracleDML
void OracleDML::msynpred3_OracleDML_fragment(  )
{
    // OracleDML.g:235:10: ( tableview_name PERIOD ASTERISK )
    // OracleDML.g:235:11: tableview_name PERIOD ASTERISK
    {
        this->followPush(FOLLOW_tableview_name_in_synpred3_OracleDML1869);
        tableview_name();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred3_OracleDMLEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_synpred3_OracleDML1871);
        if  (this->hasException())
        {
            goto rulesynpred3_OracleDMLEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



         this->matchToken(ASTERISK, &FOLLOW_ASTERISK_in_synpred3_OracleDML1873);
        if  (this->hasException())
        {
            goto rulesynpred3_OracleDMLEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



    }


goto rulesynpred3_OracleDMLEx; /* Prevent compiler warnings */
rulesynpred3_OracleDMLEx: ;
}
// $ANTLR end synpred3_OracleDML

// $ANTLR start synpredRule synpred4_OracleDML
void OracleDML::msynpred4_OracleDML_fragment(  )
{
    // OracleDML.g:272:10: ( LEFT_PAREN ( select_key | with_key ) )
    // OracleDML.g:272:11: LEFT_PAREN ( select_key | with_key )
    {
         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_synpred4_OracleDML2081);
        if  (this->hasException())
        {
            goto rulesynpred4_OracleDMLEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



        // OracleDML.g:272:22: ( select_key | with_key )
        {
            ANTLR_UINT32 alt381=2;
            switch ( this->LA(1) )
            {
            case SQL92_RESERVED_SELECT:
            	{
            		alt381=1;
            	}
                break;
            case SQL92_RESERVED_WITH:
            	{
            		alt381=2;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 381 );
                ex->set_state( 0 );


                goto rulesynpred4_OracleDMLEx;

            }

            switch (alt381)
            {
        	case 1:
        	    // OracleDML.g:272:23: select_key
        	    {
        	        this->followPush(FOLLOW_select_key_in_synpred4_OracleDML2084);
        	        select_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesynpred4_OracleDMLEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }



        	    }
        	    break;
        	case 2:
        	    // OracleDML.g:272:34: with_key
        	    {
        	        this->followPush(FOLLOW_with_key_in_synpred4_OracleDML2086);
        	        with_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesynpred4_OracleDMLEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }



        	    }
        	    break;

            }
        }

    }


goto rulesynpred4_OracleDMLEx; /* Prevent compiler warnings */
rulesynpred4_OracleDMLEx: ;
}
// $ANTLR end synpred4_OracleDML

// $ANTLR start synpredRule synpred5_OracleDML
void OracleDML::msynpred5_OracleDML_fragment(  )
{
    // OracleDML.g:273:10: ( LEFT_PAREN )
    // OracleDML.g:273:11: LEFT_PAREN
    {
         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_synpred5_OracleDML2104);
        if  (this->hasException())
        {
            goto rulesynpred5_OracleDMLEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



    }


goto rulesynpred5_OracleDMLEx; /* Prevent compiler warnings */
rulesynpred5_OracleDMLEx: ;
}
// $ANTLR end synpred5_OracleDML

// $ANTLR start synpredRule synpred6_OracleDML
void OracleDML::msynpred6_OracleDML_fragment(  )
{
    // OracleDML.g:274:10: ( only_key LEFT_PAREN )
    // OracleDML.g:274:11: only_key LEFT_PAREN
    {
        this->followPush(FOLLOW_only_key_in_synpred6_OracleDML2121);
        only_key();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred6_OracleDMLEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_synpred6_OracleDML2123);
        if  (this->hasException())
        {
            goto rulesynpred6_OracleDMLEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



    }


goto rulesynpred6_OracleDMLEx; /* Prevent compiler warnings */
rulesynpred6_OracleDMLEx: ;
}
// $ANTLR end synpred6_OracleDML

// $ANTLR start synpredRule synpred10_OracleDML
void OracleDML::msynpred10_OracleDML_fragment(  )
{
    // OracleDML.g:340:10: ( LEFT_PAREN ( select_key | with_key ) )
    // OracleDML.g:340:11: LEFT_PAREN ( select_key | with_key )
    {
         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_synpred10_OracleDML2837);
        if  (this->hasException())
        {
            goto rulesynpred10_OracleDMLEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



        // OracleDML.g:340:22: ( select_key | with_key )
        {
            ANTLR_UINT32 alt383=2;
            switch ( this->LA(1) )
            {
            case SQL92_RESERVED_SELECT:
            	{
            		alt383=1;
            	}
                break;
            case SQL92_RESERVED_WITH:
            	{
            		alt383=2;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 383 );
                ex->set_state( 0 );


                goto rulesynpred10_OracleDMLEx;

            }

            switch (alt383)
            {
        	case 1:
        	    // OracleDML.g:340:23: select_key
        	    {
        	        this->followPush(FOLLOW_select_key_in_synpred10_OracleDML2840);
        	        select_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesynpred10_OracleDMLEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }



        	    }
        	    break;
        	case 2:
        	    // OracleDML.g:340:34: with_key
        	    {
        	        this->followPush(FOLLOW_with_key_in_synpred10_OracleDML2842);
        	        with_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesynpred10_OracleDMLEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }



        	    }
        	    break;

            }
        }

    }


goto rulesynpred10_OracleDMLEx; /* Prevent compiler warnings */
rulesynpred10_OracleDMLEx: ;
}
// $ANTLR end synpred10_OracleDML

// $ANTLR start synpredRule synpred11_OracleDML
void OracleDML::msynpred11_OracleDML_fragment(  )
{
    // OracleDML.g:341:10: ( LEFT_PAREN )
    // OracleDML.g:341:11: LEFT_PAREN
    {
         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_synpred11_OracleDML2864);
        if  (this->hasException())
        {
            goto rulesynpred11_OracleDMLEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



    }


goto rulesynpred11_OracleDMLEx; /* Prevent compiler warnings */
rulesynpred11_OracleDMLEx: ;
}
// $ANTLR end synpred11_OracleDML

// $ANTLR start synpredRule synpred12_OracleDML
void OracleDML::msynpred12_OracleDML_fragment(  )
{
    // OracleDML.g:379:18: ( select_key )
    // OracleDML.g:379:19: select_key
    {
        this->followPush(FOLLOW_select_key_in_synpred12_OracleDML3352);
        select_key();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred12_OracleDMLEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



    }


goto rulesynpred12_OracleDMLEx; /* Prevent compiler warnings */
rulesynpred12_OracleDMLEx: ;
}
// $ANTLR end synpred12_OracleDML

// $ANTLR start synpredRule synpred13_OracleDML
void OracleDML::msynpred13_OracleDML_fragment(  )
{
    // OracleDML.g:380:18: ( any_key )
    // OracleDML.g:380:19: any_key
    {
        this->followPush(FOLLOW_any_key_in_synpred13_OracleDML3378);
        any_key();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred13_OracleDMLEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



    }


goto rulesynpred13_OracleDMLEx; /* Prevent compiler warnings */
rulesynpred13_OracleDMLEx: ;
}
// $ANTLR end synpred13_OracleDML

// $ANTLR start synpredRule synpred14_OracleDML
void OracleDML::msynpred14_OracleDML_fragment(  )
{
    // OracleDML.g:396:10: ( LEFT_PAREN )
    // OracleDML.g:396:11: LEFT_PAREN
    {
         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_synpred14_OracleDML3583);
        if  (this->hasException())
        {
            goto rulesynpred14_OracleDMLEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



    }


goto rulesynpred14_OracleDMLEx; /* Prevent compiler warnings */
rulesynpred14_OracleDMLEx: ;
}
// $ANTLR end synpred14_OracleDML

// $ANTLR start synpredRule synpred15_OracleDML
void OracleDML::msynpred15_OracleDML_fragment(  )
{
    // OracleDML.g:426:14: ( LEFT_PAREN )
    // OracleDML.g:426:15: LEFT_PAREN
    {
         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_synpred15_OracleDML3956);
        if  (this->hasException())
        {
            goto rulesynpred15_OracleDMLEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



    }


goto rulesynpred15_OracleDMLEx; /* Prevent compiler warnings */
rulesynpred15_OracleDMLEx: ;
}
// $ANTLR end synpred15_OracleDML

// $ANTLR start synpredRule synpred16_OracleDML
void OracleDML::msynpred16_OracleDML_fragment(  )
{
    // OracleDML.g:445:9: ( group_key )
    // OracleDML.g:445:10: group_key
    {
        this->followPush(FOLLOW_group_key_in_synpred16_OracleDML4187);
        group_key();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred16_OracleDMLEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



    }


goto rulesynpred16_OracleDMLEx; /* Prevent compiler warnings */
rulesynpred16_OracleDMLEx: ;
}
// $ANTLR end synpred16_OracleDML

// $ANTLR start synpredRule synpred17_OracleDML
void OracleDML::msynpred17_OracleDML_fragment(  )
{
    // OracleDML.g:447:25: ( COMMA group_by_elements )
    // OracleDML.g:447:26: COMMA group_by_elements
    {
         this->matchToken(COMMA, &FOLLOW_COMMA_in_synpred17_OracleDML4213);
        if  (this->hasException())
        {
            goto rulesynpred17_OracleDMLEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



        this->followPush(FOLLOW_group_by_elements_in_synpred17_OracleDML4215);
        group_by_elements();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred17_OracleDMLEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



    }


goto rulesynpred17_OracleDMLEx; /* Prevent compiler warnings */
rulesynpred17_OracleDMLEx: ;
}
// $ANTLR end synpred17_OracleDML

// $ANTLR start synpredRule synpred18_OracleDML
void OracleDML::msynpred18_OracleDML_fragment(  )
{
    // OracleDML.g:451:9: ( having_key )
    // OracleDML.g:451:10: having_key
    {
        this->followPush(FOLLOW_having_key_in_synpred18_OracleDML4267);
        having_key();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred18_OracleDMLEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



    }


goto rulesynpred18_OracleDMLEx; /* Prevent compiler warnings */
rulesynpred18_OracleDMLEx: ;
}
// $ANTLR end synpred18_OracleDML

// $ANTLR start synpredRule synpred19_OracleDML
void OracleDML::msynpred19_OracleDML_fragment(  )
{
    // OracleDML.g:454:25: ( COMMA group_by_elements )
    // OracleDML.g:454:26: COMMA group_by_elements
    {
         this->matchToken(COMMA, &FOLLOW_COMMA_in_synpred19_OracleDML4298);
        if  (this->hasException())
        {
            goto rulesynpred19_OracleDMLEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



        this->followPush(FOLLOW_group_by_elements_in_synpred19_OracleDML4300);
        group_by_elements();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred19_OracleDMLEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



    }


goto rulesynpred19_OracleDMLEx; /* Prevent compiler warnings */
rulesynpred19_OracleDMLEx: ;
}
// $ANTLR end synpred19_OracleDML

// $ANTLR start synpredRule synpred20_OracleDML
void OracleDML::msynpred20_OracleDML_fragment(  )
{
    {
        //  OracleDML.g:477:10: ( rollup_key | cube_key )

        ANTLR_UINT32 alt384;

        alt384=2;

        {
            ANTLR_UINT32 LA384_0 = this->LA(1);
            if ( (LA384_0 == REGULAR_ID) && ((((toUpper(LT(1)->getText()) == "ROLLUP"))||((toUpper(LT(1)->getText()) == "CUBE")))))
            {
                {
                    ANTLR_UINT32 LA384_1 = this->LA(2);
                    if ( ((toUpper(LT(1)->getText()) == "ROLLUP")))
                    {
                        alt384=1;
                    }
                    else if ( ((toUpper(LT(1)->getText()) == "CUBE")))
                    {
                        alt384=2;
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 384 );
                        ex->set_state( 1 );


                        goto rulesynpred20_OracleDMLEx;

                    }
                }
            }
            else
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }


                ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 384 );
                ex->set_state( 0 );


                goto rulesynpred20_OracleDMLEx;

            }
        }
        switch (alt384)
        {
    	case 1:
    	    // OracleDML.g:477:11: rollup_key
    	    {
    	        this->followPush(FOLLOW_rollup_key_in_synpred20_OracleDML4519);
    	        rollup_key();

    	        this->followPop();
    	        if  (this->hasException())
    	        {
    	            goto rulesynpred20_OracleDMLEx;
    	        }
    	        if (this->hasFailed())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 2:
    	    // OracleDML.g:477:22: cube_key
    	    {
    	        this->followPush(FOLLOW_cube_key_in_synpred20_OracleDML4521);
    	        cube_key();

    	        this->followPop();
    	        if  (this->hasException())
    	        {
    	            goto rulesynpred20_OracleDMLEx;
    	        }
    	        if (this->hasFailed())
    	        {
    	            return ;
    	        }



    	    }
    	    break;

        }
    }

goto rulesynpred20_OracleDMLEx; /* Prevent compiler warnings */
rulesynpred20_OracleDMLEx: ;
}
// $ANTLR end synpred20_OracleDML

// $ANTLR start synpredRule synpred21_OracleDML
void OracleDML::msynpred21_OracleDML_fragment(  )
{
    // OracleDML.g:478:10: ( LEFT_PAREN )
    // OracleDML.g:478:11: LEFT_PAREN
    {
         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_synpred21_OracleDML4537);
        if  (this->hasException())
        {
            goto rulesynpred21_OracleDMLEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



    }


goto rulesynpred21_OracleDMLEx; /* Prevent compiler warnings */
rulesynpred21_OracleDMLEx: ;
}
// $ANTLR end synpred21_OracleDML

// $ANTLR start synpredRule synpred22_OracleDML
void OracleDML::msynpred22_OracleDML_fragment(  )
{
    // OracleDML.g:543:34: ( all_key )
    // OracleDML.g:543:35: all_key
    {
        this->followPush(FOLLOW_all_key_in_synpred22_OracleDML5204);
        all_key();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred22_OracleDMLEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



    }


goto rulesynpred22_OracleDMLEx; /* Prevent compiler warnings */
rulesynpred22_OracleDMLEx: ;
}
// $ANTLR end synpred22_OracleDML

// $ANTLR start synpredRule synpred23_OracleDML
void OracleDML::msynpred23_OracleDML_fragment(  )
{
    // OracleDML.g:688:13: ( when_key matched_key )
    // OracleDML.g:688:14: when_key matched_key
    {
        this->followPush(FOLLOW_when_key_in_synpred23_OracleDML6678);
        when_key();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred23_OracleDMLEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



        this->followPush(FOLLOW_matched_key_in_synpred23_OracleDML6680);
        matched_key();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred23_OracleDMLEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



    }


goto rulesynpred23_OracleDMLEx; /* Prevent compiler warnings */
rulesynpred23_OracleDMLEx: ;
}
// $ANTLR end synpred23_OracleDML

// $ANTLR start synpredRule synpred24_OracleDML
void OracleDML::msynpred24_OracleDML_fragment(  )
{
    // OracleDML.g:690:13: ( when_key not_key matched_key )
    // OracleDML.g:690:14: when_key not_key matched_key
    {
        this->followPush(FOLLOW_when_key_in_synpred24_OracleDML6710);
        when_key();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred24_OracleDMLEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



        this->followPush(FOLLOW_not_key_in_synpred24_OracleDML6712);
        not_key();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred24_OracleDMLEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



        this->followPush(FOLLOW_matched_key_in_synpred24_OracleDML6714);
        matched_key();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred24_OracleDMLEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



    }


goto rulesynpred24_OracleDMLEx; /* Prevent compiler warnings */
rulesynpred24_OracleDMLEx: ;
}
// $ANTLR end synpred24_OracleDML

// $ANTLR start synpredRule synpred25_OracleDML
void OracleDML::msynpred25_OracleDML_fragment(  )
{
    // OracleDML.g:783:10: ( LEFT_PAREN )
    // OracleDML.g:783:11: LEFT_PAREN
    {
         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_synpred25_OracleDML7616);
        if  (this->hasException())
        {
            goto rulesynpred25_OracleDMLEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



    }


goto rulesynpred25_OracleDMLEx; /* Prevent compiler warnings */
rulesynpred25_OracleDMLEx: ;
}
// $ANTLR end synpred25_OracleDML

// $ANTLR start synpredRule synpred26_OracleDML
void OracleDML::msynpred26_OracleDML_fragment(  )
{
    // OracleDML.g:793:34: ( unlimited_key )
    // OracleDML.g:793:35: unlimited_key
    {
        this->followPush(FOLLOW_unlimited_key_in_synpred26_OracleDML7707);
        unlimited_key();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred26_OracleDMLEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



    }


goto rulesynpred26_OracleDMLEx; /* Prevent compiler warnings */
rulesynpred26_OracleDMLEx: ;
}
// $ANTLR end synpred26_OracleDML

// $ANTLR start synpredRule synpred27_OracleDML
void OracleDML::msynpred27_OracleDML_fragment(  )
{
    // OracleDML.g:805:12: ( LEFT_PAREN ( select_key | with_key ) )
    // OracleDML.g:805:13: LEFT_PAREN ( select_key | with_key )
    {
         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_synpred27_OracleDML7864);
        if  (this->hasException())
        {
            goto rulesynpred27_OracleDMLEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



        // OracleDML.g:805:24: ( select_key | with_key )
        {
            ANTLR_UINT32 alt385=2;
            switch ( this->LA(1) )
            {
            case SQL92_RESERVED_SELECT:
            	{
            		alt385=1;
            	}
                break;
            case SQL92_RESERVED_WITH:
            	{
            		alt385=2;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 385 );
                ex->set_state( 0 );


                goto rulesynpred27_OracleDMLEx;

            }

            switch (alt385)
            {
        	case 1:
        	    // OracleDML.g:805:25: select_key
        	    {
        	        this->followPush(FOLLOW_select_key_in_synpred27_OracleDML7867);
        	        select_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesynpred27_OracleDMLEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }



        	    }
        	    break;
        	case 2:
        	    // OracleDML.g:805:38: with_key
        	    {
        	        this->followPush(FOLLOW_with_key_in_synpred27_OracleDML7871);
        	        with_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesynpred27_OracleDMLEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }



        	    }
        	    break;

            }
        }

    }


goto rulesynpred27_OracleDMLEx; /* Prevent compiler warnings */
rulesynpred27_OracleDMLEx: ;
}
// $ANTLR end synpred27_OracleDML

// $ANTLR start synpredRule synpred28_OracleDML
void OracleDML::msynpred28_OracleDML_fragment(  )
{
    // OracleDML.g:858:10: ( cursor_key LEFT_PAREN ( select_key | with_key ) )
    // OracleDML.g:858:11: cursor_key LEFT_PAREN ( select_key | with_key )
    {
        this->followPush(FOLLOW_cursor_key_in_synpred28_OracleDML8351);
        cursor_key();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred28_OracleDMLEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_synpred28_OracleDML8353);
        if  (this->hasException())
        {
            goto rulesynpred28_OracleDMLEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



        // OracleDML.g:858:33: ( select_key | with_key )
        {
            ANTLR_UINT32 alt386=2;
            switch ( this->LA(1) )
            {
            case SQL92_RESERVED_SELECT:
            	{
            		alt386=1;
            	}
                break;
            case SQL92_RESERVED_WITH:
            	{
            		alt386=2;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 386 );
                ex->set_state( 0 );


                goto rulesynpred28_OracleDMLEx;

            }

            switch (alt386)
            {
        	case 1:
        	    // OracleDML.g:858:34: select_key
        	    {
        	        this->followPush(FOLLOW_select_key_in_synpred28_OracleDML8356);
        	        select_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesynpred28_OracleDMLEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }



        	    }
        	    break;
        	case 2:
        	    // OracleDML.g:858:45: with_key
        	    {
        	        this->followPush(FOLLOW_with_key_in_synpred28_OracleDML8358);
        	        with_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesynpred28_OracleDMLEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }



        	    }
        	    break;

            }
        }

    }


goto rulesynpred28_OracleDMLEx; /* Prevent compiler warnings */
rulesynpred28_OracleDMLEx: ;
}
// $ANTLR end synpred28_OracleDML

// $ANTLR start synpredRule synpred29_OracleDML
void OracleDML::msynpred29_OracleDML_fragment(  )
{
    // OracleDML.g:962:10: ( ( LEFT_PAREN )+ ( select_key | with_key ) )
    // OracleDML.g:962:11: ( LEFT_PAREN )+ ( select_key | with_key )
    {
        // OracleDML.g:962:11: ( LEFT_PAREN )+
        {
            int cnt387=0;

            for (;;)
            {
                ANTLR_UINT32 alt387=2;
        	switch ( this->LA(1) )
        	{
        	case LEFT_PAREN:
        		{
        			alt387=1;
        		}
        	    break;

        	}

        	switch (alt387)
        	{
        	    case 1:
        	        // OracleDML.g:962:11: LEFT_PAREN
        	        {
        	             this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_synpred29_OracleDML9738);
        	            if  (this->hasException())
        	            {
        	                goto rulesynpred29_OracleDMLEx;
        	            }
        	            if (this->hasFailed())
        	            {
        	                return ;
        	            }



        	        }
        	        break;

        	    default:

        		if ( cnt387 >= 1 )
        		{
        		    goto loop387;
        		}
        		if (this->get_backtracking()>0)
        		{
        		    this->set_failedflag( true );
        		    return ;
        		}

        		/* mismatchedSetEx()
        		 */
        		new ANTLR_Exception< OracleDMLImplTraits, EARLY_EXIT_EXCEPTION, StreamType>( this->get_rec(), "" );


        		goto rulesynpred29_OracleDMLEx;
        	}
        	cnt387++;
            }
            loop387: ;	/* Jump to here if this rule does not match */
        }

        // OracleDML.g:962:23: ( select_key | with_key )
        {
            ANTLR_UINT32 alt388=2;
            switch ( this->LA(1) )
            {
            case SQL92_RESERVED_SELECT:
            	{
            		alt388=1;
            	}
                break;
            case SQL92_RESERVED_WITH:
            	{
            		alt388=2;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 388 );
                ex->set_state( 0 );


                goto rulesynpred29_OracleDMLEx;

            }

            switch (alt388)
            {
        	case 1:
        	    // OracleDML.g:962:24: select_key
        	    {
        	        this->followPush(FOLLOW_select_key_in_synpred29_OracleDML9742);
        	        select_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesynpred29_OracleDMLEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }



        	    }
        	    break;
        	case 2:
        	    // OracleDML.g:962:35: with_key
        	    {
        	        this->followPush(FOLLOW_with_key_in_synpred29_OracleDML9744);
        	        with_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesynpred29_OracleDMLEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }



        	    }
        	    break;

            }
        }

    }


goto rulesynpred29_OracleDMLEx; /* Prevent compiler warnings */
rulesynpred29_OracleDMLEx: ;
}
// $ANTLR end synpred29_OracleDML

// $ANTLR start synpredRule synpred30_OracleDML
void OracleDML::msynpred30_OracleDML_fragment(  )
{
    // OracleDML.g:1006:10: ( interval_expression )
    // OracleDML.g:1006:11: interval_expression
    {
        this->followPush(FOLLOW_interval_expression_in_synpred30_OracleDML10252);
        interval_expression();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred30_OracleDMLEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



    }


goto rulesynpred30_OracleDMLEx; /* Prevent compiler warnings */
rulesynpred30_OracleDMLEx: ;
}
// $ANTLR end synpred30_OracleDML

// $ANTLR start synpredRule synpred31_OracleDML
void OracleDML::msynpred31_OracleDML_fragment(  )
{
    // OracleDML.g:1025:11: ( any_key )
    // OracleDML.g:1025:12: any_key
    {
        this->followPush(FOLLOW_any_key_in_synpred31_OracleDML10492);
        any_key();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred31_OracleDMLEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



    }


goto rulesynpred31_OracleDMLEx; /* Prevent compiler warnings */
rulesynpred31_OracleDMLEx: ;
}
// $ANTLR end synpred31_OracleDML

// $ANTLR start synpredRule synpred32_OracleDML
void OracleDML::msynpred32_OracleDML_fragment(  )
{
    // OracleDML.g:1025:59: ( any_key )
    // OracleDML.g:1025:60: any_key
    {
        this->followPush(FOLLOW_any_key_in_synpred32_OracleDML10507);
        any_key();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred32_OracleDMLEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



    }


goto rulesynpred32_OracleDMLEx; /* Prevent compiler warnings */
rulesynpred32_OracleDMLEx: ;
}
// $ANTLR end synpred32_OracleDML

// $ANTLR start synpredRule synpred33_OracleDML
void OracleDML::msynpred33_OracleDML_fragment(  )
{
    // OracleDML.g:1054:18: ( select_key )
    // OracleDML.g:1054:19: select_key
    {
        this->followPush(FOLLOW_select_key_in_synpred33_OracleDML10861);
        select_key();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred33_OracleDMLEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



    }


goto rulesynpred33_OracleDMLEx; /* Prevent compiler warnings */
rulesynpred33_OracleDMLEx: ;
}
// $ANTLR end synpred33_OracleDML

// $ANTLR start synpredRule synpred34_OracleDML
void OracleDML::msynpred34_OracleDML_fragment(  )
{
    // OracleDML.g:1055:18: ( LEFT_PAREN )
    // OracleDML.g:1055:19: LEFT_PAREN
    {
         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_synpred34_OracleDML10885);
        if  (this->hasException())
        {
            goto rulesynpred34_OracleDMLEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



    }


goto rulesynpred34_OracleDMLEx; /* Prevent compiler warnings */
rulesynpred34_OracleDMLEx: ;
}
// $ANTLR end synpred34_OracleDML

// $ANTLR start synpredRule synpred39_OracleDML
void OracleDML::msynpred39_OracleDML_fragment(  )
{
    // OracleDML.g:1075:10: ({...}? => new_key unary_expression )
    // OracleDML.g:1075:10: {...}? => new_key unary_expression
    {
        if ( !((LT(1)->getText() == "NEW" && LT(2)->getText() != ".")) )
        {
            if (this->get_backtracking()>0)
            {
                this->set_failedflag( true );
                return ;
            }

            	ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "LT(1)->getText() == \"NEW\" && LT(2)->getText() != \".\"" );
                ex->set_ruleName( "synpred39_OracleDML" );


        }

        this->followPush(FOLLOW_new_key_in_synpred39_OracleDML11095);
        new_key();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred39_OracleDMLEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



        this->followPush(FOLLOW_unary_expression_in_synpred39_OracleDML11098);
        unary_expression();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred39_OracleDMLEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



    }


goto rulesynpred39_OracleDMLEx; /* Prevent compiler warnings */
rulesynpred39_OracleDMLEx: ;
}
// $ANTLR end synpred39_OracleDML

// $ANTLR start synpredRule synpred41_OracleDML
void OracleDML::msynpred41_OracleDML_fragment(  )
{
    // OracleDML.g:1077:10: ( all_key unary_expression )
    // OracleDML.g:1077:10: all_key unary_expression
    {
        this->followPush(FOLLOW_all_key_in_synpred41_OracleDML11123);
        all_key();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred41_OracleDMLEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



        this->followPush(FOLLOW_unary_expression_in_synpred41_OracleDML11126);
        unary_expression();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred41_OracleDMLEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



    }


goto rulesynpred41_OracleDMLEx; /* Prevent compiler warnings */
rulesynpred41_OracleDMLEx: ;
}
// $ANTLR end synpred41_OracleDML

// $ANTLR start synpredRule synpred42_OracleDML
void OracleDML::msynpred42_OracleDML_fragment(  )
{
    // OracleDML.g:1078:10: ({...}? case_statement[false] )
    // OracleDML.g:1078:10: {...}? case_statement[false]
    {
        if ( !(((LA(1) == SQL92_RESERVED_CASE || LA(2) == SQL92_RESERVED_CASE))) )
        {
            if (this->get_backtracking()>0)
            {
                this->set_failedflag( true );
                return ;
            }

            	ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "(LA(1) == SQL92_RESERVED_CASE || LA(2) == SQL92_RESERVED_CASE)" );
                ex->set_ruleName( "synpred42_OracleDML" );


        }

        this->followPush(FOLLOW_case_statement_in_synpred42_OracleDML11139);
        case_statement(false);

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred42_OracleDMLEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



    }


goto rulesynpred42_OracleDMLEx; /* Prevent compiler warnings */
rulesynpred42_OracleDMLEx: ;
}
// $ANTLR end synpred42_OracleDML

// $ANTLR start synpredRule synpred43_OracleDML
void OracleDML::msynpred43_OracleDML_fragment(  )
{
    // OracleDML.g:1079:10: ( quantified_expression )
    // OracleDML.g:1079:10: quantified_expression
    {
        this->followPush(FOLLOW_quantified_expression_in_synpred43_OracleDML11151);
        quantified_expression();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred43_OracleDMLEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



    }


goto rulesynpred43_OracleDMLEx; /* Prevent compiler warnings */
rulesynpred43_OracleDMLEx: ;
}
// $ANTLR end synpred43_OracleDML

// $ANTLR start synpredRule synpred44_OracleDML
void OracleDML::msynpred44_OracleDML_fragment(  )
{
    // OracleDML.g:1080:10: ( standard_function )
    // OracleDML.g:1080:10: standard_function
    {
        this->followPush(FOLLOW_standard_function_in_synpred44_OracleDML11162);
        standard_function();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred44_OracleDMLEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



    }


goto rulesynpred44_OracleDMLEx; /* Prevent compiler warnings */
rulesynpred44_OracleDMLEx: ;
}
// $ANTLR end synpred44_OracleDML

// $ANTLR start synpredRule synpred45_OracleDML
void OracleDML::msynpred45_OracleDML_fragment(  )
{
    // OracleDML.g:1089:10: ( ( label_name )? case_key when_key )
    // OracleDML.g:1089:11: ( label_name )? case_key when_key
    {
        // OracleDML.g:1089:11: ( label_name )?
        {
            ANTLR_UINT32 alt389=2;
            switch ( this->LA(1) )
            {
                case DELIMITED_ID:
                case REGULAR_ID:
                	{
                		alt389=1;
                	}
                    break;
            }

            switch (alt389)
            {
        	case 1:
        	    // OracleDML.g:1089:11: label_name
        	    {
        	        this->followPush(FOLLOW_label_name_in_synpred45_OracleDML11219);
        	        label_name();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesynpred45_OracleDMLEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }



        	    }
        	    break;

            }
        }

        this->followPush(FOLLOW_case_key_in_synpred45_OracleDML11222);
        case_key();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred45_OracleDMLEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



        this->followPush(FOLLOW_when_key_in_synpred45_OracleDML11224);
        when_key();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred45_OracleDMLEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



    }


goto rulesynpred45_OracleDMLEx; /* Prevent compiler warnings */
rulesynpred45_OracleDMLEx: ;
}
// $ANTLR end synpred45_OracleDML

// $ANTLR start synpredRule synpred46_OracleDML
void OracleDML::msynpred46_OracleDML_fragment(  )
{
    // OracleDML.g:1130:10: ( table_element outer_join_sign )
    // OracleDML.g:1130:11: table_element outer_join_sign
    {
        this->followPush(FOLLOW_table_element_in_synpred46_OracleDML11592);
        table_element();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred46_OracleDMLEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



        this->followPush(FOLLOW_outer_join_sign_in_synpred46_OracleDML11594);
        outer_join_sign();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred46_OracleDMLEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



    }


goto rulesynpred46_OracleDMLEx; /* Prevent compiler warnings */
rulesynpred46_OracleDMLEx: ;
}
// $ANTLR end synpred46_OracleDML

// $ANTLR start synpredRule synpred48_OracleDML
void OracleDML::msynpred48_OracleDML_fragment(  )
{
    // OracleDML.g:1132:10: ( constant )
    // OracleDML.g:1132:10: constant
    {
        this->followPush(FOLLOW_constant_in_synpred48_OracleDML11623);
        constant();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred48_OracleDMLEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



    }


goto rulesynpred48_OracleDMLEx; /* Prevent compiler warnings */
rulesynpred48_OracleDMLEx: ;
}
// $ANTLR end synpred48_OracleDML

// $ANTLR start synpredRule synpred49_OracleDML
void OracleDML::msynpred49_OracleDML_fragment(  )
{
    // OracleDML.g:1133:10: ( general_element )
    // OracleDML.g:1133:10: general_element
    {
        this->followPush(FOLLOW_general_element_in_synpred49_OracleDML11634);
        general_element();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred49_OracleDMLEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



    }


goto rulesynpred49_OracleDMLEx; /* Prevent compiler warnings */
rulesynpred49_OracleDMLEx: ;
}
// $ANTLR end synpred49_OracleDML

// $ANTLR start synpredRule synpred50_OracleDML
void OracleDML::msynpred50_OracleDML_fragment(  )
{
    {
        //  OracleDML.g:1136:15: ( select_key | with_key )

        ANTLR_UINT32 alt390;

        alt390=2;

        switch ( this->LA(1) )
        {
        case SQL92_RESERVED_SELECT:
        	{
        		alt390=1;
        	}
            break;
        case SQL92_RESERVED_WITH:
        	{
        		alt390=2;
        	}
            break;

        default:
            if (this->get_backtracking()>0)
            {
                this->set_failedflag( true );
                return ;
            }

            ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            ex->set_decisionNum( 390 );
            ex->set_state( 0 );


            goto rulesynpred50_OracleDMLEx;

        }

        switch (alt390)
        {
    	case 1:
    	    // OracleDML.g:1136:17: select_key
    	    {
    	        this->followPush(FOLLOW_select_key_in_synpred50_OracleDML11674);
    	        select_key();

    	        this->followPop();
    	        if  (this->hasException())
    	        {
    	            goto rulesynpred50_OracleDMLEx;
    	        }
    	        if (this->hasFailed())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 2:
    	    // OracleDML.g:1136:30: with_key
    	    {
    	        this->followPush(FOLLOW_with_key_in_synpred50_OracleDML11678);
    	        with_key();

    	        this->followPop();
    	        if  (this->hasException())
    	        {
    	            goto rulesynpred50_OracleDMLEx;
    	        }
    	        if (this->hasFailed())
    	        {
    	            return ;
    	        }



    	    }
    	    break;

        }
    }

goto rulesynpred50_OracleDMLEx; /* Prevent compiler warnings */
rulesynpred50_OracleDMLEx: ;
}
// $ANTLR end synpred50_OracleDML

// $ANTLR start synpredRule synpred51_OracleDML
void OracleDML::msynpred51_OracleDML_fragment(  )
{
    // OracleDML.g:1158:12: ( LEFT_PAREN ( select_key | with_key ) )
    // OracleDML.g:1158:13: LEFT_PAREN ( select_key | with_key )
    {
         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_synpred51_OracleDML11957);
        if  (this->hasException())
        {
            goto rulesynpred51_OracleDMLEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



        // OracleDML.g:1158:24: ( select_key | with_key )
        {
            ANTLR_UINT32 alt391=2;
            switch ( this->LA(1) )
            {
            case SQL92_RESERVED_SELECT:
            	{
            		alt391=1;
            	}
                break;
            case SQL92_RESERVED_WITH:
            	{
            		alt391=2;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 391 );
                ex->set_state( 0 );


                goto rulesynpred51_OracleDMLEx;

            }

            switch (alt391)
            {
        	case 1:
        	    // OracleDML.g:1158:25: select_key
        	    {
        	        this->followPush(FOLLOW_select_key_in_synpred51_OracleDML11960);
        	        select_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesynpred51_OracleDMLEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }



        	    }
        	    break;
        	case 2:
        	    // OracleDML.g:1158:36: with_key
        	    {
        	        this->followPush(FOLLOW_with_key_in_synpred51_OracleDML11962);
        	        with_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesynpred51_OracleDMLEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }



        	    }
        	    break;

            }
        }

    }


goto rulesynpred51_OracleDMLEx; /* Prevent compiler warnings */
rulesynpred51_OracleDMLEx: ;
}
// $ANTLR end synpred51_OracleDML

// $ANTLR start synpredRule synpred52_OracleDML
void OracleDML::msynpred52_OracleDML_fragment(  )
{
    // OracleDML.g:1174:15: ( multiset_key ( LEFT_PAREN )+ ( select_key | with_key ) )
    // OracleDML.g:1174:16: multiset_key ( LEFT_PAREN )+ ( select_key | with_key )
    {
        this->followPush(FOLLOW_multiset_key_in_synpred52_OracleDML12279);
        multiset_key();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred52_OracleDMLEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



        // OracleDML.g:1174:29: ( LEFT_PAREN )+
        {
            int cnt392=0;

            for (;;)
            {
                ANTLR_UINT32 alt392=2;
        	switch ( this->LA(1) )
        	{
        	case LEFT_PAREN:
        		{
        			alt392=1;
        		}
        	    break;

        	}

        	switch (alt392)
        	{
        	    case 1:
        	        // OracleDML.g:1174:29: LEFT_PAREN
        	        {
        	             this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_synpred52_OracleDML12281);
        	            if  (this->hasException())
        	            {
        	                goto rulesynpred52_OracleDMLEx;
        	            }
        	            if (this->hasFailed())
        	            {
        	                return ;
        	            }



        	        }
        	        break;

        	    default:

        		if ( cnt392 >= 1 )
        		{
        		    goto loop392;
        		}
        		if (this->get_backtracking()>0)
        		{
        		    this->set_failedflag( true );
        		    return ;
        		}

        		/* mismatchedSetEx()
        		 */
        		new ANTLR_Exception< OracleDMLImplTraits, EARLY_EXIT_EXCEPTION, StreamType>( this->get_rec(), "" );


        		goto rulesynpred52_OracleDMLEx;
        	}
        	cnt392++;
            }
            loop392: ;	/* Jump to here if this rule does not match */
        }

        // OracleDML.g:1174:41: ( select_key | with_key )
        {
            ANTLR_UINT32 alt393=2;
            switch ( this->LA(1) )
            {
            case SQL92_RESERVED_SELECT:
            	{
            		alt393=1;
            	}
                break;
            case SQL92_RESERVED_WITH:
            	{
            		alt393=2;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< OracleDMLImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 393 );
                ex->set_state( 0 );


                goto rulesynpred52_OracleDMLEx;

            }

            switch (alt393)
            {
        	case 1:
        	    // OracleDML.g:1174:42: select_key
        	    {
        	        this->followPush(FOLLOW_select_key_in_synpred52_OracleDML12285);
        	        select_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesynpred52_OracleDMLEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }



        	    }
        	    break;
        	case 2:
        	    // OracleDML.g:1174:53: with_key
        	    {
        	        this->followPush(FOLLOW_with_key_in_synpred52_OracleDML12287);
        	        with_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesynpred52_OracleDMLEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }



        	    }
        	    break;

            }
        }

    }


goto rulesynpred52_OracleDMLEx; /* Prevent compiler warnings */
rulesynpred52_OracleDMLEx: ;
}
// $ANTLR end synpred52_OracleDML

// $ANTLR start synpredRule synpred53_OracleDML
void OracleDML::msynpred53_OracleDML_fragment(  )
{
    // OracleDML.g:1378:14: ( default_key )
    // OracleDML.g:1378:15: default_key
    {
        this->followPush(FOLLOW_default_key_in_synpred53_OracleDML15151);
        default_key();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred53_OracleDMLEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



    }


goto rulesynpred53_OracleDMLEx; /* Prevent compiler warnings */
rulesynpred53_OracleDMLEx: ;
}
// $ANTLR end synpred53_OracleDML

// $ANTLR start synpredRule synpred54_OracleDML
void OracleDML::msynpred54_OracleDML_fragment(  )
{
    // OracleDML.g:1385:55: ( default_key )
    // OracleDML.g:1385:56: default_key
    {
        this->followPush(FOLLOW_default_key_in_synpred54_OracleDML15222);
        default_key();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred54_OracleDMLEx;
        }
        if (this->hasFailed())
        {
            return ;
        }



    }


goto rulesynpred54_OracleDMLEx; /* Prevent compiler warnings */
rulesynpred54_OracleDMLEx: ;
}
// $ANTLR end synpred54_OracleDML
	// Delegated methods that appear to be a part of this
	// parser
	//
    OracleDML_OracleDMLKeys::current_user_key_return OracleDML::current_user_key()
    {
        return m_gOracleDMLKeys->current_user_key();
    }

    OracleDML_OracleDMLKeys::sample_key_return OracleDML::sample_key()
    {
        return m_gOracleDMLKeys->sample_key();
    }

    OracleDML_OracleDMLKeys::function_key_return OracleDML::function_key()
    {
        return m_gOracleDMLKeys->function_key();
    }

    OracleDML_OracleDMLKeys::committed_key_return OracleDML::committed_key()
    {
        return m_gOracleDMLKeys->committed_key();
    }

    OracleDML_OracleDMLKeys::exception_init_key_return OracleDML::exception_init_key()
    {
        return m_gOracleDMLKeys->exception_init_key();
    }

    OracleDML_OracleDMLKeys::each_key_return OracleDML::each_key()
    {
        return m_gOracleDMLKeys->each_key();
    }

    OracleDML_OracleDMLKeys::identified_key_return OracleDML::identified_key()
    {
        return m_gOracleDMLKeys->identified_key();
    }

    OracleDML_OracleDMLKeys::nvl_key_return OracleDML::nvl_key()
    {
        return m_gOracleDMLKeys->nvl_key();
    }

    OracleDML_OracleDMLKeys::static_key_return OracleDML::static_key()
    {
        return m_gOracleDMLKeys->static_key();
    }

    OracleDML_OracleDMLKeys::floor_key_return OracleDML::floor_key()
    {
        return m_gOracleDMLKeys->floor_key();
    }

    OracleDML_OracleDMLKeys::character_length_key_return OracleDML::character_length_key()
    {
        return m_gOracleDMLKeys->character_length_key();
    }

    OracleDML_OracleDMLKeys::session_key_return OracleDML::session_key()
    {
        return m_gOracleDMLKeys->session_key();
    }

    OracleDML_OracleDMLKeys::current_timestamp_key_return OracleDML::current_timestamp_key()
    {
        return m_gOracleDMLKeys->current_timestamp_key();
    }

    OracleDML_OracleDMLCommons::general_element_return OracleDML::general_element()
    {
        return m_gOracleDMLCommons->general_element();
    }

    OracleDML_OracleDMLKeys::sum_key_return OracleDML::sum_key()
    {
        return m_gOracleDMLKeys->sum_key();
    }

    OracleDML_OracleDMLCommons::reference_model_name_return OracleDML::reference_model_name()
    {
        return m_gOracleDMLCommons->reference_model_name();
    }

    OracleDML_OracleDMLKeys::errors_key_return OracleDML::errors_key()
    {
        return m_gOracleDMLKeys->errors_key();
    }

    OracleDML_OracleDMLKeys::subpartition_key_return OracleDML::subpartition_key()
    {
        return m_gOracleDMLKeys->subpartition_key();
    }

    OracleDML_OracleDMLKeys::map_key_return OracleDML::map_key()
    {
        return m_gOracleDMLKeys->map_key();
    }

    OracleDML_OracleDMLKeys::ignore_key_return OracleDML::ignore_key()
    {
        return m_gOracleDMLKeys->ignore_key();
    }

    OracleDML_OracleDMLKeys::both_key_return OracleDML::both_key()
    {
        return m_gOracleDMLKeys->both_key();
    }

    OracleDML_OracleDMLKeys::role_key_return OracleDML::role_key()
    {
        return m_gOracleDMLKeys->role_key();
    }

    OracleDML_OracleDMLKeys::lpad_key_return OracleDML::lpad_key()
    {
        return m_gOracleDMLKeys->lpad_key();
    }

    OracleDML_OracleDMLKeys::suspend_key_return OracleDML::suspend_key()
    {
        return m_gOracleDMLKeys->suspend_key();
    }

    OracleDML_OracleDMLKeys::local_key_return OracleDML::local_key()
    {
        return m_gOracleDMLKeys->local_key();
    }

    OracleDML_OracleDMLKeys::bulk_key_return OracleDML::bulk_key()
    {
        return m_gOracleDMLKeys->bulk_key();
    }

    OracleDML_OracleDMLCommons::cursor_name_return OracleDML::cursor_name()
    {
        return m_gOracleDMLCommons->cursor_name();
    }

    OracleDML_OracleDMLCommons::procedure_name_return OracleDML::procedure_name()
    {
        return m_gOracleDMLCommons->procedure_name();
    }

    OracleDML_OracleDMLKeys::seed_key_return OracleDML::seed_key()
    {
        return m_gOracleDMLKeys->seed_key();
    }

    OracleDML_OracleDMLKeys::interval_key_return OracleDML::interval_key()
    {
        return m_gOracleDMLKeys->interval_key();
    }

    OracleDML_OracleDMLKeys::binary_double_min_normal_key_return OracleDML::binary_double_min_normal_key()
    {
        return m_gOracleDMLKeys->binary_double_min_normal_key();
    }

    OracleDML_OracleDMLKeys::select_key_return OracleDML::select_key()
    {
        return m_gOracleDMLKeys->select_key();
    }

    OracleDML_OracleDMLKeys::raise_key_return OracleDML::raise_key()
    {
        return m_gOracleDMLKeys->raise_key();
    }

    OracleDML_OracleDMLKeys::nulls_key_return OracleDML::nulls_key()
    {
        return m_gOracleDMLKeys->nulls_key();
    }

    OracleDML_OracleDMLKeys::intersect_key_return OracleDML::intersect_key()
    {
        return m_gOracleDMLKeys->intersect_key();
    }

    OracleDML_OracleDMLKeys::read_key_return OracleDML::read_key()
    {
        return m_gOracleDMLKeys->read_key();
    }

    OracleDML_OracleDMLKeys::no_key_return OracleDML::no_key()
    {
        return m_gOracleDMLKeys->no_key();
    }

    OracleDML_OracleDMLKeys::power_key_return OracleDML::power_key()
    {
        return m_gOracleDMLKeys->power_key();
    }

    OracleDML_OracleDMLKeys::only_key_return OracleDML::only_key()
    {
        return m_gOracleDMLKeys->only_key();
    }

    OracleDML_OracleDMLKeys::passing_key_return OracleDML::passing_key()
    {
        return m_gOracleDMLKeys->passing_key();
    }

    OracleDML_OracleDMLCommons::aggregate_function_name_return OracleDML::aggregate_function_name()
    {
        return m_gOracleDMLCommons->aggregate_function_name();
    }

    OracleDML_OracleDMLKeys::wait_key_return OracleDML::wait_key()
    {
        return m_gOracleDMLKeys->wait_key();
    }

    OracleDML_OracleDMLKeys::xmlpi_key_return OracleDML::xmlpi_key()
    {
        return m_gOracleDMLKeys->xmlpi_key();
    }

    OracleDML_OracleDMLKeys::serveroutput_key_return OracleDML::serveroutput_key()
    {
        return m_gOracleDMLKeys->serveroutput_key();
    }

    OracleDML_OracleDMLKeys::measures_key_return OracleDML::measures_key()
    {
        return m_gOracleDMLKeys->measures_key();
    }

    OracleDML_OracleDMLKeys::concat_key_return OracleDML::concat_key()
    {
        return m_gOracleDMLKeys->concat_key();
    }

    OracleDML_OracleDMLKeys::deterministic_key_return OracleDML::deterministic_key()
    {
        return m_gOracleDMLKeys->deterministic_key();
    }

    OracleDML_OracleDMLKeys::overriding_key_return OracleDML::overriding_key()
    {
        return m_gOracleDMLKeys->overriding_key();
    }

    OracleDML_OracleDMLCommons::id_expression_return OracleDML::id_expression(int toraTokenType, int usageType)
    {
        return m_gOracleDMLCommons->id_expression(toraTokenType, usageType);
    }

    OracleDML_OracleDMLKeys::null_key_return OracleDML::null_key()
    {
        return m_gOracleDMLKeys->null_key();
    }

    OracleDML_OracleDMLKeys::nextval_key_return OracleDML::nextval_key()
    {
        return m_gOracleDMLKeys->nextval_key();
    }

    OracleDML_OracleDMLKeys::analyze_key_return OracleDML::analyze_key()
    {
        return m_gOracleDMLKeys->analyze_key();
    }

    OracleDML_OracleDMLKeys::end_key_return OracleDML::end_key()
    {
        return m_gOracleDMLKeys->end_key();
    }

    OracleDML_OracleDMLCommons::table_element_return OracleDML::table_element()
    {
        return m_gOracleDMLCommons->table_element();
    }

    OracleDML_OracleDMLKeys::disassociate_key_return OracleDML::disassociate_key()
    {
        return m_gOracleDMLKeys->disassociate_key();
    }

    OracleDML_OracleDMLKeys::grouping_key_return OracleDML::grouping_key()
    {
        return m_gOracleDMLKeys->grouping_key();
    }

    OracleDML_OracleDMLKeys::binary_double_max_normal_key_return OracleDML::binary_double_max_normal_key()
    {
        return m_gOracleDMLKeys->binary_double_max_normal_key();
    }

    OracleDML_OracleDMLKeys::goto_key_return OracleDML::goto_key()
    {
        return m_gOracleDMLKeys->goto_key();
    }

    OracleDML_OracleDMLKeys::declare_key_return OracleDML::declare_key()
    {
        return m_gOracleDMLKeys->declare_key();
    }

    OracleDML_OracleDMLKeys::statistics_key_return OracleDML::statistics_key()
    {
        return m_gOracleDMLKeys->statistics_key();
    }

    OracleDML_OracleDMLKeys::at_key_return OracleDML::at_key()
    {
        return m_gOracleDMLKeys->at_key();
    }

    OracleDML_OracleDMLKeys::default_key_return OracleDML::default_key()
    {
        return m_gOracleDMLKeys->default_key();
    }

    OracleDML_OracleDMLKeys::validate_key_return OracleDML::validate_key()
    {
        return m_gOracleDMLKeys->validate_key();
    }

    OracleDML_OracleDMLKeys::nothing_key_return OracleDML::nothing_key()
    {
        return m_gOracleDMLKeys->nothing_key();
    }

    OracleDML_OracleDMLKeys::noentityescaping_key_return OracleDML::noentityescaping_key()
    {
        return m_gOracleDMLKeys->noentityescaping_key();
    }

    OracleDML_OracleDMLKeys::result_key_return OracleDML::result_key()
    {
        return m_gOracleDMLKeys->result_key();
    }

    OracleDML_OracleDMLKeys::first_value_key_return OracleDML::first_value_key()
    {
        return m_gOracleDMLKeys->first_value_key();
    }

    OracleDML_OracleDMLKeys::exclude_key_return OracleDML::exclude_key()
    {
        return m_gOracleDMLKeys->exclude_key();
    }

    OracleDML_OracleDMLKeys::constraints_key_return OracleDML::constraints_key()
    {
        return m_gOracleDMLKeys->constraints_key();
    }

    OracleDML_OracleDMLKeys::attribute_key_return OracleDML::attribute_key()
    {
        return m_gOracleDMLKeys->attribute_key();
    }

    OracleDML_OracleDMLCommons::link_name_return OracleDML::link_name()
    {
        return m_gOracleDMLCommons->link_name();
    }

    OracleDML_OracleDMLKeys::before_key_return OracleDML::before_key()
    {
        return m_gOracleDMLKeys->before_key();
    }

    OracleDML_OracleDMLKeys::rules_key_return OracleDML::rules_key()
    {
        return m_gOracleDMLKeys->rules_key();
    }

    OracleDML_OracleDMLKeys::procedure_key_return OracleDML::procedure_key()
    {
        return m_gOracleDMLKeys->procedure_key();
    }

    OracleDML_OracleDMLCommons::exception_name_return OracleDML::exception_name()
    {
        return m_gOracleDMLCommons->exception_name();
    }

    OracleDML_OracleDMLKeys::single_key_return OracleDML::single_key()
    {
        return m_gOracleDMLKeys->single_key();
    }

    OracleDML_OracleDMLKeys::nocycle_key_return OracleDML::nocycle_key()
    {
        return m_gOracleDMLKeys->nocycle_key();
    }

    OracleDML_OracleDMLKeys::library_key_return OracleDML::library_key()
    {
        return m_gOracleDMLKeys->library_key();
    }

    OracleDML_OracleDMLKeys::replace_key_return OracleDML::replace_key()
    {
        return m_gOracleDMLKeys->replace_key();
    }

    OracleDML_OracleDMLKeys::parameters_key_return OracleDML::parameters_key()
    {
        return m_gOracleDMLKeys->parameters_key();
    }

    OracleDML_OracleDMLKeys::oradata_key_return OracleDML::oradata_key()
    {
        return m_gOracleDMLKeys->oradata_key();
    }

    OracleDML_OracleDMLKeys::percent_isopen_key_return OracleDML::percent_isopen_key()
    {
        return m_gOracleDMLKeys->percent_isopen_key();
    }

    OracleDML_OracleDMLKeys::rows_key_return OracleDML::rows_key()
    {
        return m_gOracleDMLKeys->rows_key();
    }

    OracleDML_OracleDMLKeys::offset_key_return OracleDML::offset_key()
    {
        return m_gOracleDMLKeys->offset_key();
    }

    OracleDML_OracleDMLKeys::execute_key_return OracleDML::execute_key()
    {
        return m_gOracleDMLKeys->execute_key();
    }

    OracleDML_OracleDMLKeys::desc_key_return OracleDML::desc_key()
    {
        return m_gOracleDMLKeys->desc_key();
    }

    OracleDML_OracleDMLKeys::check_key_return OracleDML::check_key()
    {
        return m_gOracleDMLKeys->check_key();
    }

    OracleDML_OracleDMLKeys::data_key_return OracleDML::data_key()
    {
        return m_gOracleDMLKeys->data_key();
    }

    OracleDML_OracleDMLKeys::maxvalue_key_return OracleDML::maxvalue_key()
    {
        return m_gOracleDMLKeys->maxvalue_key();
    }

    OracleDML_OracleDMLKeys::trunc_key_return OracleDML::trunc_key()
    {
        return m_gOracleDMLKeys->trunc_key();
    }

    OracleDML_OracleDMLKeys::body_key_return OracleDML::body_key()
    {
        return m_gOracleDMLKeys->body_key();
    }

    OracleDML_OracleDMLKeys::asc_key_return OracleDML::asc_key()
    {
        return m_gOracleDMLKeys->asc_key();
    }

    OracleDML_OracleDMLKeys::exit_key_return OracleDML::exit_key()
    {
        return m_gOracleDMLKeys->exit_key();
    }

    OracleDML_OracleDMLCommons::respect_or_ignore_nulls_return OracleDML::respect_or_ignore_nulls()
    {
        return m_gOracleDMLCommons->respect_or_ignore_nulls();
    }

    OracleDML_OracleDMLKeys::national_key_return OracleDML::national_key()
    {
        return m_gOracleDMLKeys->national_key();
    }

    OracleDML_OracleDMLKeys::close_key_return OracleDML::close_key()
    {
        return m_gOracleDMLKeys->close_key();
    }

    OracleDML_OracleDMLKeys::all_key_return OracleDML::all_key()
    {
        return m_gOracleDMLKeys->all_key();
    }

    OracleDML_OracleDMLKeys::advise_key_return OracleDML::advise_key()
    {
        return m_gOracleDMLKeys->advise_key();
    }

    OracleDML_OracleDMLKeys::shutdown_key_return OracleDML::shutdown_key()
    {
        return m_gOracleDMLKeys->shutdown_key();
    }

    OracleDML_OracleDMLKeys::unbounded_key_return OracleDML::unbounded_key()
    {
        return m_gOracleDMLKeys->unbounded_key();
    }

    OracleDML_OracleDMLKeys::option_key_return OracleDML::option_key()
    {
        return m_gOracleDMLKeys->option_key();
    }

    OracleDML_OracleDMLKeys::char_length_key_return OracleDML::char_length_key()
    {
        return m_gOracleDMLKeys->char_length_key();
    }

    OracleDML_OracleDMLKeys::sequence_key_return OracleDML::sequence_key()
    {
        return m_gOracleDMLKeys->sequence_key();
    }

    OracleDML_OracleDMLKeys::decode_key_return OracleDML::decode_key()
    {
        return m_gOracleDMLKeys->decode_key();
    }

    OracleDML_OracleDMLKeys::rename_key_return OracleDML::rename_key()
    {
        return m_gOracleDMLKeys->rename_key();
    }

    OracleDML_OracleDMLKeys::serially_reusable_key_return OracleDML::serially_reusable_key()
    {
        return m_gOracleDMLKeys->serially_reusable_key();
    }

    OracleDML_OracleDMLKeys::any_key_return OracleDML::any_key()
    {
        return m_gOracleDMLKeys->any_key();
    }

    OracleDML_OracleDMLKeys::encoding_key_return OracleDML::encoding_key()
    {
        return m_gOracleDMLKeys->encoding_key();
    }

    OracleDML_OracleDMLCommons::outer_join_sign_return OracleDML::outer_join_sign()
    {
        return m_gOracleDMLCommons->outer_join_sign();
    }

    OracleDML_OracleDMLKeys::respect_key_return OracleDML::respect_key()
    {
        return m_gOracleDMLKeys->respect_key();
    }

    OracleDML_OracleDMLKeys::exceptions_key_return OracleDML::exceptions_key()
    {
        return m_gOracleDMLKeys->exceptions_key();
    }

    OracleDML_OracleDMLKeys::binary_float_max_subnormal_key_return OracleDML::binary_float_max_subnormal_key()
    {
        return m_gOracleDMLKeys->binary_float_max_subnormal_key();
    }

    OracleDML_OracleDMLKeys::standalone_key_return OracleDML::standalone_key()
    {
        return m_gOracleDMLKeys->standalone_key();
    }

    OracleDML_OracleDMLKeys::exclusive_key_return OracleDML::exclusive_key()
    {
        return m_gOracleDMLKeys->exclusive_key();
    }

    OracleDML_OracleDMLKeys::greatest_key_return OracleDML::greatest_key()
    {
        return m_gOracleDMLKeys->greatest_key();
    }

    OracleDML_OracleDMLKeys::leading_key_return OracleDML::leading_key()
    {
        return m_gOracleDMLKeys->leading_key();
    }

    OracleDML_OracleDMLKeys::relies_on_key_return OracleDML::relies_on_key()
    {
        return m_gOracleDMLKeys->relies_on_key();
    }

    OracleDML_OracleDMLKeys::length_key_return OracleDML::length_key()
    {
        return m_gOracleDMLKeys->length_key();
    }

    OracleDML_OracleDMLKeys::global_key_return OracleDML::global_key()
    {
        return m_gOracleDMLKeys->global_key();
    }

    OracleDML_OracleDMLKeys::count_key_return OracleDML::count_key()
    {
        return m_gOracleDMLKeys->count_key();
    }

    OracleDML_OracleDMLKeys::main_key_return OracleDML::main_key()
    {
        return m_gOracleDMLKeys->main_key();
    }

    OracleDML_OracleDMLKeys::debug_key_return OracleDML::debug_key()
    {
        return m_gOracleDMLKeys->debug_key();
    }

    OracleDML_OracleDMLKeys::indicator_key_return OracleDML::indicator_key()
    {
        return m_gOracleDMLKeys->indicator_key();
    }

    OracleDML_OracleDMLKeys::mod_key_return OracleDML::mod_key()
    {
        return m_gOracleDMLKeys->mod_key();
    }

    OracleDML_OracleDMLKeys::cycle_key_return OracleDML::cycle_key()
    {
        return m_gOracleDMLKeys->cycle_key();
    }

    OracleDML_OracleDMLKeys::multiset_key_return OracleDML::multiset_key()
    {
        return m_gOracleDMLKeys->multiset_key();
    }

    OracleDML_OracleDMLKeys::truncate_key_return OracleDML::truncate_key()
    {
        return m_gOracleDMLKeys->truncate_key();
    }

    OracleDML_OracleDMLKeys::share_key_return OracleDML::share_key()
    {
        return m_gOracleDMLKeys->share_key();
    }

    OracleDML_OracleDMLKeys::lock_key_return OracleDML::lock_key()
    {
        return m_gOracleDMLKeys->lock_key();
    }

    OracleDML_OracleDMLKeys::corrupt_xid_key_return OracleDML::corrupt_xid_key()
    {
        return m_gOracleDMLKeys->corrupt_xid_key();
    }

    OracleDML_OracleDMLKeys::authid_key_return OracleDML::authid_key()
    {
        return m_gOracleDMLKeys->authid_key();
    }

    OracleDML_OracleDMLKeys::avg_key_return OracleDML::avg_key()
    {
        return m_gOracleDMLKeys->avg_key();
    }

    OracleDML_OracleDMLKeys::date_key_return OracleDML::date_key()
    {
        return m_gOracleDMLKeys->date_key();
    }

    OracleDML_OracleDMLKeys::raw_key_return OracleDML::raw_key()
    {
        return m_gOracleDMLKeys->raw_key();
    }

    OracleDML_OracleDMLKeys::ordinality_key_return OracleDML::ordinality_key()
    {
        return m_gOracleDMLKeys->ordinality_key();
    }

    OracleDML_OracleDMLCommons::general_element_part_return OracleDML::general_element_part()
    {
        return m_gOracleDMLCommons->general_element_part();
    }

    OracleDML_OracleDMLKeys::add_key_return OracleDML::add_key()
    {
        return m_gOracleDMLKeys->add_key();
    }

    OracleDML_OracleDMLKeys::warning_key_return OracleDML::warning_key()
    {
        return m_gOracleDMLKeys->warning_key();
    }

    OracleDML_OracleDMLKeys::percent_found_key_return OracleDML::percent_found_key()
    {
        return m_gOracleDMLKeys->percent_found_key();
    }

    OracleDML_OracleDMLKeys::ddl_key_return OracleDML::ddl_key()
    {
        return m_gOracleDMLKeys->ddl_key();
    }

    OracleDML_OracleDMLKeys::as_key_return OracleDML::as_key()
    {
        return m_gOracleDMLKeys->as_key();
    }

    OracleDML_OracleDMLCommons::datatype_return OracleDML::datatype()
    {
        return m_gOracleDMLCommons->datatype();
    }

    OracleDML_OracleDMLKeys::next_key_return OracleDML::next_key()
    {
        return m_gOracleDMLKeys->next_key();
    }

    OracleDML_OracleDMLKeys::connect_by_root_key_return OracleDML::connect_by_root_key()
    {
        return m_gOracleDMLKeys->connect_by_root_key();
    }

    OracleDML_OracleDMLKeys::corrupt_xid_all_key_return OracleDML::corrupt_xid_all_key()
    {
        return m_gOracleDMLKeys->corrupt_xid_all_key();
    }

    OracleDML_OracleDMLKeys::outer_key_return OracleDML::outer_key()
    {
        return m_gOracleDMLKeys->outer_key();
    }

    OracleDML_OracleDMLKeys::pipelined_key_return OracleDML::pipelined_key()
    {
        return m_gOracleDMLKeys->pipelined_key();
    }

    OracleDML_OracleDMLKeys::while_key_return OracleDML::while_key()
    {
        return m_gOracleDMLKeys->while_key();
    }

    OracleDML_OracleDMLKeys::system_key_return OracleDML::system_key()
    {
        return m_gOracleDMLKeys->system_key();
    }

    OracleDML_OracleDMLKeys::specification_key_return OracleDML::specification_key()
    {
        return m_gOracleDMLKeys->specification_key();
    }

    OracleDML_OracleDMLKeys::sign_key_return OracleDML::sign_key()
    {
        return m_gOracleDMLKeys->sign_key();
    }

    OracleDML_OracleDMLKeys::audit_key_return OracleDML::audit_key()
    {
        return m_gOracleDMLKeys->audit_key();
    }

    OracleDML_OracleDMLKeys::hextoraw_key_return OracleDML::hextoraw_key()
    {
        return m_gOracleDMLKeys->hextoraw_key();
    }

    OracleDML_OracleDMLKeys::blob_key_return OracleDML::blob_key()
    {
        return m_gOracleDMLKeys->blob_key();
    }

    OracleDML_OracleDMLKeys::sets_key_return OracleDML::sets_key()
    {
        return m_gOracleDMLKeys->sets_key();
    }

    OracleDML_OracleDMLKeys::nested_key_return OracleDML::nested_key()
    {
        return m_gOracleDMLKeys->nested_key();
    }

    OracleDML_OracleDMLKeys::the_key_return OracleDML::the_key()
    {
        return m_gOracleDMLKeys->the_key();
    }

    OracleDML_OracleDMLKeys::defaults_key_return OracleDML::defaults_key()
    {
        return m_gOracleDMLKeys->defaults_key();
    }

    OracleDML_OracleDMLKeys::including_key_return OracleDML::including_key()
    {
        return m_gOracleDMLKeys->including_key();
    }

    OracleDML_OracleDMLKeys::settings_key_return OracleDML::settings_key()
    {
        return m_gOracleDMLKeys->settings_key();
    }

    OracleDML_OracleDMLKeys::variable_key_return OracleDML::variable_key()
    {
        return m_gOracleDMLKeys->variable_key();
    }

    OracleDML_OracleDMLKeys::automatic_key_return OracleDML::automatic_key()
    {
        return m_gOracleDMLKeys->automatic_key();
    }

    OracleDML_OracleDMLKeys::sysdate_key_return OracleDML::sysdate_key()
    {
        return m_gOracleDMLKeys->sysdate_key();
    }

    OracleDML_OracleDMLKeys::timestamp_key_return OracleDML::timestamp_key()
    {
        return m_gOracleDMLKeys->timestamp_key();
    }

    OracleDML_OracleDMLKeys::is_key_return OracleDML::is_key()
    {
        return m_gOracleDMLKeys->is_key();
    }

    OracleDML_OracleDMLKeys::to_char_key_return OracleDML::to_char_key()
    {
        return m_gOracleDMLKeys->to_char_key();
    }

    OracleDML_OracleDMLKeys::force_key_return OracleDML::force_key()
    {
        return m_gOracleDMLKeys->force_key();
    }

    OracleDML_OracleDMLKeys::snapshot_key_return OracleDML::snapshot_key()
    {
        return m_gOracleDMLKeys->snapshot_key();
    }

    OracleDML_OracleDMLKeys::when_key_return OracleDML::when_key()
    {
        return m_gOracleDMLKeys->when_key();
    }

    OracleDML_OracleDMLCommons::id_return OracleDML::id(int toraTokenType, int usageType)
    {
        return m_gOracleDMLCommons->id(toraTokenType, usageType);
    }

    OracleDML_OracleDMLKeys::for_key_return OracleDML::for_key()
    {
        return m_gOracleDMLKeys->for_key();
    }

    OracleDML_OracleDMLKeys::into_key_return OracleDML::into_key()
    {
        return m_gOracleDMLKeys->into_key();
    }

    OracleDML_OracleDMLKeys::treat_key_return OracleDML::treat_key()
    {
        return m_gOracleDMLKeys->treat_key();
    }

    OracleDML_OracleDMLCommons::argument_return OracleDML::argument()
    {
        return m_gOracleDMLCommons->argument();
    }

    OracleDML_OracleDMLKeys::unknown_key_return OracleDML::unknown_key()
    {
        return m_gOracleDMLKeys->unknown_key();
    }

    OracleDML_OracleDMLKeys::timezone_region_key_return OracleDML::timezone_region_key()
    {
        return m_gOracleDMLKeys->timezone_region_key();
    }

    OracleDML_OracleDMLKeys::cluster_key_return OracleDML::cluster_key()
    {
        return m_gOracleDMLKeys->cluster_key();
    }

    OracleDML_OracleDMLKeys::between_key_return OracleDML::between_key()
    {
        return m_gOracleDMLKeys->between_key();
    }

    OracleDML_OracleDMLKeys::external_key_return OracleDML::external_key()
    {
        return m_gOracleDMLKeys->external_key();
    }

    OracleDML_OracleDMLKeys::parent_key_return OracleDML::parent_key()
    {
        return m_gOracleDMLKeys->parent_key();
    }

    OracleDML_OracleDMLKeys::positive_key_return OracleDML::positive_key()
    {
        return m_gOracleDMLKeys->positive_key();
    }

    OracleDML_OracleDMLKeys::cache_key_return OracleDML::cache_key()
    {
        return m_gOracleDMLKeys->cache_key();
    }

    OracleDML_OracleDMLKeys::day_key_return OracleDML::day_key()
    {
        return m_gOracleDMLKeys->day_key();
    }

    OracleDML_OracleDMLCommons::index_name_return OracleDML::index_name()
    {
        return m_gOracleDMLCommons->index_name();
    }

    OracleDML_OracleDMLKeys::columns_key_return OracleDML::columns_key()
    {
        return m_gOracleDMLKeys->columns_key();
    }

    OracleDML_OracleDMLKeys::startup_key_return OracleDML::startup_key()
    {
        return m_gOracleDMLKeys->startup_key();
    }

    OracleDML_OracleDMLKeys::explain_key_return OracleDML::explain_key()
    {
        return m_gOracleDMLKeys->explain_key();
    }

    OracleDML_OracleDMLKeys::percent_rowtype_key_return OracleDML::percent_rowtype_key()
    {
        return m_gOracleDMLKeys->percent_rowtype_key();
    }

    OracleDML_OracleDMLKeys::parallel_enable_key_return OracleDML::parallel_enable_key()
    {
        return m_gOracleDMLKeys->parallel_enable_key();
    }

    OracleDML_OracleDMLKeys::commit_key_return OracleDML::commit_key()
    {
        return m_gOracleDMLKeys->commit_key();
    }

    OracleDML_OracleDMLKeys::scn_key_return OracleDML::scn_key()
    {
        return m_gOracleDMLKeys->scn_key();
    }

    OracleDML_OracleDMLKeys::revoke_key_return OracleDML::revoke_key()
    {
        return m_gOracleDMLKeys->revoke_key();
    }

    OracleDML_OracleDMLKeys::rawtohex_key_return OracleDML::rawtohex_key()
    {
        return m_gOracleDMLKeys->rawtohex_key();
    }

    OracleDML_OracleDMLKeys::dec_key_return OracleDML::dec_key()
    {
        return m_gOracleDMLKeys->dec_key();
    }

    OracleDML_OracleDMLKeys::year_key_return OracleDML::year_key()
    {
        return m_gOracleDMLKeys->year_key();
    }

    OracleDML_OracleDMLKeys::constructor_key_return OracleDML::constructor_key()
    {
        return m_gOracleDMLKeys->constructor_key();
    }

    OracleDML_OracleDMLKeys::float_key_return OracleDML::float_key()
    {
        return m_gOracleDMLKeys->float_key();
    }

    OracleDML_OracleDMLKeys::path_key_return OracleDML::path_key()
    {
        return m_gOracleDMLKeys->path_key();
    }

    OracleDML_OracleDMLKeys::trailing_key_return OracleDML::trailing_key()
    {
        return m_gOracleDMLKeys->trailing_key();
    }

    OracleDML_OracleDMLKeys::clob_key_return OracleDML::clob_key()
    {
        return m_gOracleDMLKeys->clob_key();
    }

    OracleDML_OracleDMLKeys::percent_rowcount_key_return OracleDML::percent_rowcount_key()
    {
        return m_gOracleDMLKeys->percent_rowcount_key();
    }

    OracleDML_OracleDMLCommons::keep_clause_return OracleDML::keep_clause()
    {
        return m_gOracleDMLCommons->keep_clause();
    }

    OracleDML_OracleDMLKeys::java_key_return OracleDML::java_key()
    {
        return m_gOracleDMLKeys->java_key();
    }

    OracleDML_OracleDMLKeys::like2_key_return OracleDML::like2_key()
    {
        return m_gOracleDMLKeys->like2_key();
    }

    OracleDML_OracleDMLKeys::fetch_key_return OracleDML::fetch_key()
    {
        return m_gOracleDMLKeys->fetch_key();
    }

    OracleDML_OracleDMLKeys::open_key_return OracleDML::open_key()
    {
        return m_gOracleDMLKeys->open_key();
    }

    OracleDML_OracleDMLKeys::nvarchar2_key_return OracleDML::nvarchar2_key()
    {
        return m_gOracleDMLKeys->nvarchar2_key();
    }

    OracleDML_OracleDMLKeys::result_cache_key_return OracleDML::result_cache_key()
    {
        return m_gOracleDMLKeys->result_cache_key();
    }

    OracleDML_OracleDMLKeys::name_key_return OracleDML::name_key()
    {
        return m_gOracleDMLKeys->name_key();
    }

    OracleDML_OracleDMLKeys::binary_double_key_return OracleDML::binary_double_key()
    {
        return m_gOracleDMLKeys->binary_double_key();
    }

    OracleDML_OracleDMLKeys::member_key_return OracleDML::member_key()
    {
        return m_gOracleDMLKeys->member_key();
    }

    OracleDML_OracleDMLKeys::xmlattributes_key_return OracleDML::xmlattributes_key()
    {
        return m_gOracleDMLKeys->xmlattributes_key();
    }

    OracleDML_OracleDMLKeys::delete_key_return OracleDML::delete_key()
    {
        return m_gOracleDMLKeys->delete_key();
    }

    OracleDML_OracleDMLKeys::cast_key_return OracleDML::cast_key()
    {
        return m_gOracleDMLKeys->cast_key();
    }

    OracleDML_OracleDMLKeys::deferred_key_return OracleDML::deferred_key()
    {
        return m_gOracleDMLKeys->deferred_key();
    }

    OracleDML_OracleDMLKeys::likec_key_return OracleDML::likec_key()
    {
        return m_gOracleDMLKeys->likec_key();
    }

    OracleDML_OracleDMLKeys::forall_key_return OracleDML::forall_key()
    {
        return m_gOracleDMLKeys->forall_key();
    }

    OracleDML_OracleDMLKeys::canonical_key_return OracleDML::canonical_key()
    {
        return m_gOracleDMLKeys->canonical_key();
    }

    OracleDML_OracleDMLKeys::binary_double_infinity_key_return OracleDML::binary_double_infinity_key()
    {
        return m_gOracleDMLKeys->binary_double_infinity_key();
    }

    OracleDML_OracleDMLKeys::cube_key_return OracleDML::cube_key()
    {
        return m_gOracleDMLKeys->cube_key();
    }

    OracleDML_OracleDMLKeys::bit_key_return OracleDML::bit_key()
    {
        return m_gOracleDMLKeys->bit_key();
    }

    OracleDML_OracleDMLKeys::block_key_return OracleDML::block_key()
    {
        return m_gOracleDMLKeys->block_key();
    }

    OracleDML_OracleDMLKeys::noorder_key_return OracleDML::noorder_key()
    {
        return m_gOracleDMLKeys->noorder_key();
    }

    OracleDML_OracleDMLKeys::extend_key_return OracleDML::extend_key()
    {
        return m_gOracleDMLKeys->extend_key();
    }

    OracleDML_OracleDMLKeys::object_key_return OracleDML::object_key()
    {
        return m_gOracleDMLKeys->object_key();
    }

    OracleDML_OracleDMLKeys::modify_key_return OracleDML::modify_key()
    {
        return m_gOracleDMLKeys->modify_key();
    }

    OracleDML_OracleDMLKeys::segment_key_return OracleDML::segment_key()
    {
        return m_gOracleDMLKeys->segment_key();
    }

    OracleDML_OracleDMLKeys::userenv_key_return OracleDML::userenv_key()
    {
        return m_gOracleDMLKeys->userenv_key();
    }

    OracleDML_OracleDMLKeys::dense_rank_key_return OracleDML::dense_rank_key()
    {
        return m_gOracleDMLKeys->dense_rank_key();
    }

    OracleDML_OracleDMLKeys::yes_key_return OracleDML::yes_key()
    {
        return m_gOracleDMLKeys->yes_key();
    }

    OracleDML_OracleDMLKeys::invalidate_key_return OracleDML::invalidate_key()
    {
        return m_gOracleDMLKeys->invalidate_key();
    }

    OracleDML_OracleDMLKeys::binary_integer_key_return OracleDML::binary_integer_key()
    {
        return m_gOracleDMLKeys->binary_integer_key();
    }

    OracleDML_OracleDMLKeys::subtype_key_return OracleDML::subtype_key()
    {
        return m_gOracleDMLKeys->subtype_key();
    }

    OracleDML_OracleDMLKeys::byte_key_return OracleDML::byte_key()
    {
        return m_gOracleDMLKeys->byte_key();
    }

    OracleDML_OracleDMLKeys::timestamp_tz_unconstrained_key_return OracleDML::timestamp_tz_unconstrained_key()
    {
        return m_gOracleDMLKeys->timestamp_tz_unconstrained_key();
    }

    OracleDML_OracleDMLKeys::submultiset_key_return OracleDML::submultiset_key()
    {
        return m_gOracleDMLKeys->submultiset_key();
    }

    OracleDML_OracleDMLKeys::upsert_key_return OracleDML::upsert_key()
    {
        return m_gOracleDMLKeys->upsert_key();
    }

    OracleDML_OracleDMLKeys::cursor_key_return OracleDML::cursor_key()
    {
        return m_gOracleDMLKeys->cursor_key();
    }

    OracleDML_OracleDMLKeys::then_key_return OracleDML::then_key()
    {
        return m_gOracleDMLKeys->then_key();
    }

    OracleDML_OracleDMLKeys::batch_key_return OracleDML::batch_key()
    {
        return m_gOracleDMLKeys->batch_key();
    }

    OracleDML_OracleDMLKeys::document_key_return OracleDML::document_key()
    {
        return m_gOracleDMLKeys->document_key();
    }

    OracleDML_OracleDMLCommons::trigger_name_return OracleDML::trigger_name()
    {
        return m_gOracleDMLCommons->trigger_name();
    }

    OracleDML_OracleDMLKeys::xmlagg_key_return OracleDML::xmlagg_key()
    {
        return m_gOracleDMLKeys->xmlagg_key();
    }

    OracleDML_OracleDMLKeys::month_key_return OracleDML::month_key()
    {
        return m_gOracleDMLKeys->month_key();
    }

    OracleDML_OracleDMLKeys::and_key_return OracleDML::and_key()
    {
        return m_gOracleDMLKeys->and_key();
    }

    OracleDML_OracleDMLKeys::compound_key_return OracleDML::compound_key()
    {
        return m_gOracleDMLKeys->compound_key();
    }

    OracleDML_OracleDMLKeys::match_key_return OracleDML::match_key()
    {
        return m_gOracleDMLKeys->match_key();
    }

    OracleDML_OracleDMLKeys::char_key_return OracleDML::char_key()
    {
        return m_gOracleDMLKeys->char_key();
    }

    OracleDML_OracleDMLKeys::yminterval_unconstrained_key_return OracleDML::yminterval_unconstrained_key()
    {
        return m_gOracleDMLKeys->yminterval_unconstrained_key();
    }

    OracleDML_OracleDMLKeys::cascade_key_return OracleDML::cascade_key()
    {
        return m_gOracleDMLKeys->cascade_key();
    }

    OracleDML_OracleDMLKeys::session_user_key_return OracleDML::session_user_key()
    {
        return m_gOracleDMLKeys->session_user_key();
    }

    OracleDML_OracleDMLKeys::index_key_return OracleDML::index_key()
    {
        return m_gOracleDMLKeys->index_key();
    }

    OracleDML_OracleDMLKeys::size_key_return OracleDML::size_key()
    {
        return m_gOracleDMLKeys->size_key();
    }

    OracleDML_OracleDMLKeys::follows_key_return OracleDML::follows_key()
    {
        return m_gOracleDMLKeys->follows_key();
    }

    OracleDML_OracleDMLKeys::ceil_key_return OracleDML::ceil_key()
    {
        return m_gOracleDMLKeys->ceil_key();
    }

    OracleDML_OracleDMLKeys::indices_key_return OracleDML::indices_key()
    {
        return m_gOracleDMLKeys->indices_key();
    }

    OracleDML_OracleDMLKeys::nclob_key_return OracleDML::nclob_key()
    {
        return m_gOracleDMLKeys->nclob_key();
    }

    OracleDML_OracleDMLKeys::rowid_key_return OracleDML::rowid_key()
    {
        return m_gOracleDMLKeys->rowid_key();
    }

    OracleDML_OracleDMLKeys::min_key_return OracleDML::min_key()
    {
        return m_gOracleDMLKeys->min_key();
    }

    OracleDML_OracleDMLKeys::percent_notfound_key_return OracleDML::percent_notfound_key()
    {
        return m_gOracleDMLKeys->percent_notfound_key();
    }

    OracleDML_OracleDMLKeys::positiven_key_return OracleDML::positiven_key()
    {
        return m_gOracleDMLKeys->positiven_key();
    }

    OracleDML_OracleDMLKeys::reference_key_return OracleDML::reference_key()
    {
        return m_gOracleDMLKeys->reference_key();
    }

    OracleDML_OracleDMLKeys::timezone_minute_key_return OracleDML::timezone_minute_key()
    {
        return m_gOracleDMLKeys->timezone_minute_key();
    }

    OracleDML_OracleDMLKeys::exists_key_return OracleDML::exists_key()
    {
        return m_gOracleDMLKeys->exists_key();
    }

    OracleDML_OracleDMLKeys::second_key_return OracleDML::second_key()
    {
        return m_gOracleDMLKeys->second_key();
    }

    OracleDML_OracleDMLKeys::translate_key_return OracleDML::translate_key()
    {
        return m_gOracleDMLKeys->translate_key();
    }

    OracleDML_OracleDMLKeys::in_key_return OracleDML::in_key()
    {
        return m_gOracleDMLKeys->in_key();
    }

    OracleDML_OracleDMLKeys::soundex_key_return OracleDML::soundex_key()
    {
        return m_gOracleDMLKeys->soundex_key();
    }

    OracleDML_OracleDMLCommons::less_than_or_equals_op_return OracleDML::less_than_or_equals_op()
    {
        return m_gOracleDMLCommons->less_than_or_equals_op();
    }

    OracleDML_OracleDMLKeys::instr_key_return OracleDML::instr_key()
    {
        return m_gOracleDMLKeys->instr_key();
    }

    OracleDML_OracleDMLKeys::round_key_return OracleDML::round_key()
    {
        return m_gOracleDMLKeys->round_key();
    }

    OracleDML_OracleDMLKeys::decimal_key_return OracleDML::decimal_key()
    {
        return m_gOracleDMLKeys->decimal_key();
    }

    OracleDML_OracleDMLKeys::content_key_return OracleDML::content_key()
    {
        return m_gOracleDMLKeys->content_key();
    }

    OracleDML_OracleDMLKeys::numeric_key_return OracleDML::numeric_key()
    {
        return m_gOracleDMLKeys->numeric_key();
    }

    OracleDML_OracleDMLCommons::not_equal_op_return OracleDML::not_equal_op()
    {
        return m_gOracleDMLCommons->not_equal_op();
    }

    OracleDML_OracleDMLKeys::nav_key_return OracleDML::nav_key()
    {
        return m_gOracleDMLKeys->nav_key();
    }

    OracleDML_OracleDMLKeys::number_key_return OracleDML::number_key()
    {
        return m_gOracleDMLKeys->number_key();
    }

    OracleDML_OracleDMLKeys::chr_key_return OracleDML::chr_key()
    {
        return m_gOracleDMLKeys->chr_key();
    }

    OracleDML_OracleDMLKeys::octet_length_key_return OracleDML::octet_length_key()
    {
        return m_gOracleDMLKeys->octet_length_key();
    }

    OracleDML_OracleDMLCommons::package_name_return OracleDML::package_name()
    {
        return m_gOracleDMLCommons->package_name();
    }

    OracleDML_OracleDMLKeys::lower_key_return OracleDML::lower_key()
    {
        return m_gOracleDMLKeys->lower_key();
    }

    OracleDML_OracleDMLCommons::alias_quoted_string_return OracleDML::alias_quoted_string(int toraTokenType, int usageType)
    {
        return m_gOracleDMLCommons->alias_quoted_string(toraTokenType, usageType);
    }

    OracleDML_OracleDMLKeys::mlslabel_key_return OracleDML::mlslabel_key()
    {
        return m_gOracleDMLKeys->mlslabel_key();
    }

    OracleDML_OracleDMLKeys::false_key_return OracleDML::false_key()
    {
        return m_gOracleDMLKeys->false_key();
    }

    OracleDML_OracleDMLKeys::return_key_return OracleDML::return_key()
    {
        return m_gOracleDMLKeys->return_key();
    }

    OracleDML_OracleDMLKeys::context_key_return OracleDML::context_key()
    {
        return m_gOracleDMLKeys->context_key();
    }

    OracleDML_OracleDMLCommons::where_clause_return OracleDML::where_clause()
    {
        return m_gOracleDMLCommons->where_clause();
    }

    OracleDML_OracleDMLKeys::some_key_return OracleDML::some_key()
    {
        return m_gOracleDMLKeys->some_key();
    }

    OracleDML_OracleDMLKeys::precision_key_return OracleDML::precision_key()
    {
        return m_gOracleDMLKeys->precision_key();
    }

    OracleDML_OracleDMLKeys::database_key_return OracleDML::database_key()
    {
        return m_gOracleDMLKeys->database_key();
    }

    OracleDML_OracleDMLKeys::except_key_return OracleDML::except_key()
    {
        return m_gOracleDMLKeys->except_key();
    }

    OracleDML_OracleDMLKeys::skip_key_return OracleDML::skip_key()
    {
        return m_gOracleDMLKeys->skip_key();
    }

    OracleDML_OracleDMLCommons::function_argument_analytic_return OracleDML::function_argument_analytic()
    {
        return m_gOracleDMLCommons->function_argument_analytic();
    }

    OracleDML_OracleDMLCommons::column_alias_return OracleDML::column_alias()
    {
        return m_gOracleDMLCommons->column_alias();
    }

    OracleDML_OracleDMLKeys::coalesce_key_return OracleDML::coalesce_key()
    {
        return m_gOracleDMLKeys->coalesce_key();
    }

    OracleDML_OracleDMLKeys::partition_key_return OracleDML::partition_key()
    {
        return m_gOracleDMLKeys->partition_key();
    }

    OracleDML_OracleDMLKeys::serializable_key_return OracleDML::serializable_key()
    {
        return m_gOracleDMLKeys->serializable_key();
    }

    OracleDML_OracleDMLKeys::call_key_return OracleDML::call_key()
    {
        return m_gOracleDMLKeys->call_key();
    }

    OracleDML_OracleDMLKeys::if_key_return OracleDML::if_key()
    {
        return m_gOracleDMLKeys->if_key();
    }

    OracleDML_OracleDMLKeys::value_key_return OracleDML::value_key()
    {
        return m_gOracleDMLKeys->value_key();
    }

    OracleDML_OracleDMLKeys::signtype_key_return OracleDML::signtype_key()
    {
        return m_gOracleDMLKeys->signtype_key();
    }

    OracleDML_OracleDMLKeys::new_key_return OracleDML::new_key()
    {
        return m_gOracleDMLKeys->new_key();
    }

    OracleDML_OracleDMLKeys::element_key_return OracleDML::element_key()
    {
        return m_gOracleDMLKeys->element_key();
    }

    OracleDML_OracleDMLKeys::pragma_key_return OracleDML::pragma_key()
    {
        return m_gOracleDMLKeys->pragma_key();
    }

    OracleDML_OracleDMLKeys::long_key_return OracleDML::long_key()
    {
        return m_gOracleDMLKeys->long_key();
    }

    OracleDML_OracleDMLKeys::write_key_return OracleDML::write_key()
    {
        return m_gOracleDMLKeys->write_key();
    }

    OracleDML_OracleDMLKeys::iterate_key_return OracleDML::iterate_key()
    {
        return m_gOracleDMLKeys->iterate_key();
    }

    OracleDML_OracleDMLCommons::function_argument_modeling_return OracleDML::function_argument_modeling()
    {
        return m_gOracleDMLCommons->function_argument_modeling();
    }

    OracleDML_OracleDMLKeys::nocache_key_return OracleDML::nocache_key()
    {
        return m_gOracleDMLKeys->nocache_key();
    }

    OracleDML_OracleDMLKeys::disable_key_return OracleDML::disable_key()
    {
        return m_gOracleDMLKeys->disable_key();
    }

    OracleDML_OracleDMLCommons::precision_part_return OracleDML::precision_part()
    {
        return m_gOracleDMLCommons->precision_part();
    }

    OracleDML_OracleDMLKeys::xmlparse_key_return OracleDML::xmlparse_key()
    {
        return m_gOracleDMLKeys->xmlparse_key();
    }

    OracleDML_OracleDMLKeys::agent_key_return OracleDML::agent_key()
    {
        return m_gOracleDMLKeys->agent_key();
    }

    OracleDML_OracleDMLKeys::nominvalue_key_return OracleDML::nominvalue_key()
    {
        return m_gOracleDMLKeys->nominvalue_key();
    }

    OracleDML_OracleDMLKeys::sqlerror_key_return OracleDML::sqlerror_key()
    {
        return m_gOracleDMLKeys->sqlerror_key();
    }

    OracleDML_OracleDMLKeys::ltrim_key_return OracleDML::ltrim_key()
    {
        return m_gOracleDMLKeys->ltrim_key();
    }

    OracleDML_OracleDMLKeys::dimension_key_return OracleDML::dimension_key()
    {
        return m_gOracleDMLKeys->dimension_key();
    }

    OracleDML_OracleDMLKeys::substr_key_return OracleDML::substr_key()
    {
        return m_gOracleDMLKeys->substr_key();
    }

    OracleDML_OracleDMLKeys::left_key_return OracleDML::left_key()
    {
        return m_gOracleDMLKeys->left_key();
    }

    OracleDML_OracleDMLKeys::nchar_cs_key_return OracleDML::nchar_cs_key()
    {
        return m_gOracleDMLKeys->nchar_cs_key();
    }

    OracleDML_OracleDMLKeys::substitutable_key_return OracleDML::substitutable_key()
    {
        return m_gOracleDMLKeys->substitutable_key();
    }

    OracleDML_OracleDMLKeys::inline_key_return OracleDML::inline_key()
    {
        return m_gOracleDMLKeys->inline_key();
    }

    OracleDML_OracleDMLKeys::instantiable_key_return OracleDML::instantiable_key()
    {
        return m_gOracleDMLKeys->instantiable_key();
    }

    OracleDML_OracleDMLKeys::binary_double_min_subnormal_key_return OracleDML::binary_double_min_subnormal_key()
    {
        return m_gOracleDMLKeys->binary_double_min_subnormal_key();
    }

    OracleDML_OracleDMLKeys::after_key_return OracleDML::after_key()
    {
        return m_gOracleDMLKeys->after_key();
    }

    OracleDML_OracleDMLKeys::xmlcolattval_key_return OracleDML::xmlcolattval_key()
    {
        return m_gOracleDMLKeys->xmlcolattval_key();
    }

    OracleDML_OracleDMLCommons::cost_class_name_return OracleDML::cost_class_name()
    {
        return m_gOracleDMLCommons->cost_class_name();
    }

    OracleDML_OracleDMLKeys::user_key_return OracleDML::user_key()
    {
        return m_gOracleDMLKeys->user_key();
    }

    OracleDML_OracleDMLKeys::transaction_key_return OracleDML::transaction_key()
    {
        return m_gOracleDMLKeys->transaction_key();
    }

    OracleDML_OracleDMLKeys::version_key_return OracleDML::version_key()
    {
        return m_gOracleDMLKeys->version_key();
    }

    OracleDML_OracleDMLKeys::nullif_key_return OracleDML::nullif_key()
    {
        return m_gOracleDMLKeys->nullif_key();
    }

    OracleDML_OracleDMLCommons::into_clause_return OracleDML::into_clause()
    {
        return m_gOracleDMLCommons->into_clause();
    }

    OracleDML_OracleDMLKeys::else_key_return OracleDML::else_key()
    {
        return m_gOracleDMLKeys->else_key();
    }

    OracleDML_OracleDMLKeys::collect_key_return OracleDML::collect_key()
    {
        return m_gOracleDMLKeys->collect_key();
    }

    OracleDML_OracleDMLKeys::abs_key_return OracleDML::abs_key()
    {
        return m_gOracleDMLKeys->abs_key();
    }

    OracleDML_OracleDMLKeys::rollup_key_return OracleDML::rollup_key()
    {
        return m_gOracleDMLKeys->rollup_key();
    }

    OracleDML_OracleDMLKeys::row_key_return OracleDML::row_key()
    {
        return m_gOracleDMLKeys->row_key();
    }

    OracleDML_OracleDMLKeys::dump_key_return OracleDML::dump_key()
    {
        return m_gOracleDMLKeys->dump_key();
    }

    OracleDML_OracleDMLCommons::sequence_name_return OracleDML::sequence_name()
    {
        return m_gOracleDMLCommons->sequence_name();
    }

    OracleDML_OracleDMLKeys::work_key_return OracleDML::work_key()
    {
        return m_gOracleDMLKeys->work_key();
    }

    OracleDML_OracleDMLCommons::query_name_return OracleDML::query_name()
    {
        return m_gOracleDMLCommons->query_name();
    }

    OracleDML_OracleDMLKeys::oserror_key_return OracleDML::oserror_key()
    {
        return m_gOracleDMLKeys->oserror_key();
    }

    OracleDML_OracleDMLKeys::nowait_key_return OracleDML::nowait_key()
    {
        return m_gOracleDMLKeys->nowait_key();
    }

    OracleDML_OracleDMLKeys::dml_key_return OracleDML::dml_key()
    {
        return m_gOracleDMLKeys->dml_key();
    }

    OracleDML_OracleDMLKeys::query_key_return OracleDML::query_key()
    {
        return m_gOracleDMLKeys->query_key();
    }

    OracleDML_OracleDMLKeys::unpivot_key_return OracleDML::unpivot_key()
    {
        return m_gOracleDMLKeys->unpivot_key();
    }

    OracleDML_OracleDMLKeys::within_key_return OracleDML::within_key()
    {
        return m_gOracleDMLKeys->within_key();
    }

    OracleDML_OracleDMLKeys::of_key_return OracleDML::of_key()
    {
        return m_gOracleDMLKeys->of_key();
    }

    OracleDML_OracleDMLCommons::table_alias_return OracleDML::table_alias()
    {
        return m_gOracleDMLCommons->table_alias();
    }

    OracleDML_OracleDMLKeys::upper_key_return OracleDML::upper_key()
    {
        return m_gOracleDMLKeys->upper_key();
    }

    OracleDML_OracleDMLKeys::wellformed_key_return OracleDML::wellformed_key()
    {
        return m_gOracleDMLKeys->wellformed_key();
    }

    OracleDML_OracleDMLKeys::with_key_return OracleDML::with_key()
    {
        return m_gOracleDMLKeys->with_key();
    }

    OracleDML_OracleDMLKeys::schemacheck_key_return OracleDML::schemacheck_key()
    {
        return m_gOracleDMLKeys->schemacheck_key();
    }

    OracleDML_OracleDMLKeys::returning_key_return OracleDML::returning_key()
    {
        return m_gOracleDMLKeys->returning_key();
    }

    OracleDML_OracleDMLKeys::initcap_key_return OracleDML::initcap_key()
    {
        return m_gOracleDMLKeys->initcap_key();
    }

    OracleDML_OracleDMLKeys::timestamp_ltz_unconstrained_key_return OracleDML::timestamp_ltz_unconstrained_key()
    {
        return m_gOracleDMLKeys->timestamp_ltz_unconstrained_key();
    }

    OracleDML_OracleDMLKeys::ref_key_return OracleDML::ref_key()
    {
        return m_gOracleDMLKeys->ref_key();
    }

    OracleDML_OracleDMLKeys::evalname_key_return OracleDML::evalname_key()
    {
        return m_gOracleDMLKeys->evalname_key();
    }

    OracleDML_OracleDMLKeys::boolean_key_return OracleDML::boolean_key()
    {
        return m_gOracleDMLKeys->boolean_key();
    }

    OracleDML_OracleDMLKeys::not_key_return OracleDML::not_key()
    {
        return m_gOracleDMLKeys->not_key();
    }

    OracleDML_OracleDMLKeys::create_key_return OracleDML::create_key()
    {
        return m_gOracleDMLKeys->create_key();
    }

    OracleDML_OracleDMLKeys::none_key_return OracleDML::none_key()
    {
        return m_gOracleDMLKeys->none_key();
    }

    OracleDML_OracleDMLKeys::limit_key_return OracleDML::limit_key()
    {
        return m_gOracleDMLKeys->limit_key();
    }

    OracleDML_OracleDMLKeys::connect_key_return OracleDML::connect_key()
    {
        return m_gOracleDMLKeys->connect_key();
    }

    OracleDML_OracleDMLKeys::table_key_return OracleDML::table_key()
    {
        return m_gOracleDMLKeys->table_key();
    }

    OracleDML_OracleDMLKeys::present_key_return OracleDML::present_key()
    {
        return m_gOracleDMLKeys->present_key();
    }

    OracleDML_OracleDMLKeys::final_key_return OracleDML::final_key()
    {
        return m_gOracleDMLKeys->final_key();
    }

    OracleDML_OracleDMLKeys::comment_key_return OracleDML::comment_key()
    {
        return m_gOracleDMLKeys->comment_key();
    }

    OracleDML_OracleDMLKeys::link_key_return OracleDML::link_key()
    {
        return m_gOracleDMLKeys->link_key();
    }

    OracleDML_OracleDMLKeys::reverse_key_return OracleDML::reverse_key()
    {
        return m_gOracleDMLKeys->reverse_key();
    }

    OracleDML_OracleDMLKeys::extract_key_return OracleDML::extract_key()
    {
        return m_gOracleDMLKeys->extract_key();
    }

    OracleDML_OracleDMLKeys::ties_key_return OracleDML::ties_key()
    {
        return m_gOracleDMLKeys->ties_key();
    }

    OracleDML_OracleDMLKeys::sessiontimezone_key_return OracleDML::sessiontimezone_key()
    {
        return m_gOracleDMLKeys->sessiontimezone_key();
    }

    OracleDML_OracleDMLKeys::a_key_return OracleDML::a_key()
    {
        return m_gOracleDMLKeys->a_key();
    }

    OracleDML_OracleDMLKeys::from_key_return OracleDML::from_key()
    {
        return m_gOracleDMLKeys->from_key();
    }

    OracleDML_OracleDMLKeys::entityescaping_key_return OracleDML::entityescaping_key()
    {
        return m_gOracleDMLKeys->entityescaping_key();
    }

    OracleDML_OracleDMLKeys::breadth_key_return OracleDML::breadth_key()
    {
        return m_gOracleDMLKeys->breadth_key();
    }

    OracleDML_OracleDMLKeys::prior_key_return OracleDML::prior_key()
    {
        return m_gOracleDMLKeys->prior_key();
    }

    OracleDML_OracleDMLKeys::model_key_return OracleDML::model_key()
    {
        return m_gOracleDMLKeys->model_key();
    }

    OracleDML_OracleDMLKeys::join_key_return OracleDML::join_key()
    {
        return m_gOracleDMLKeys->join_key();
    }

    OracleDML_OracleDMLKeys::right_key_return OracleDML::right_key()
    {
        return m_gOracleDMLKeys->right_key();
    }

    OracleDML_OracleDMLKeys::noschemacheck_key_return OracleDML::noschemacheck_key()
    {
        return m_gOracleDMLKeys->noschemacheck_key();
    }

    OracleDML_OracleDMLCommons::tableview_name_return OracleDML::tableview_name()
    {
        return m_gOracleDMLCommons->tableview_name();
    }

    OracleDML_OracleDMLKeys::true_key_return OracleDML::true_key()
    {
        return m_gOracleDMLKeys->true_key();
    }

    OracleDML_OracleDMLKeys::instead_key_return OracleDML::instead_key()
    {
        return m_gOracleDMLKeys->instead_key();
    }

    OracleDML_OracleDMLKeys::continue_key_return OracleDML::continue_key()
    {
        return m_gOracleDMLKeys->continue_key();
    }

    OracleDML_OracleDMLCommons::main_model_name_return OracleDML::main_model_name()
    {
        return m_gOracleDMLCommons->main_model_name();
    }

    OracleDML_OracleDMLCommons::column_name_return OracleDML::column_name()
    {
        return m_gOracleDMLCommons->column_name();
    }

    OracleDML_OracleDMLKeys::minus_key_return OracleDML::minus_key()
    {
        return m_gOracleDMLKeys->minus_key();
    }

    OracleDML_OracleDMLCommons::rollback_segment_name_return OracleDML::rollback_segment_name()
    {
        return m_gOracleDMLCommons->rollback_segment_name();
    }

    OracleDML_OracleDMLKeys::sequential_key_return OracleDML::sequential_key()
    {
        return m_gOracleDMLKeys->sequential_key();
    }

    OracleDML_OracleDMLKeys::set_key_return OracleDML::set_key()
    {
        return m_gOracleDMLKeys->set_key();
    }

    OracleDML_OracleDMLKeys::indexed_key_return OracleDML::indexed_key()
    {
        return m_gOracleDMLKeys->indexed_key();
    }

    OracleDML_OracleDMLKeys::constant_key_return OracleDML::constant_key()
    {
        return m_gOracleDMLKeys->constant_key();
    }

    OracleDML_OracleDMLKeys::time_key_return OracleDML::time_key()
    {
        return m_gOracleDMLKeys->time_key();
    }

    OracleDML_OracleDMLKeys::varray_key_return OracleDML::varray_key()
    {
        return m_gOracleDMLKeys->varray_key();
    }

    OracleDML_OracleDMLKeys::constraint_key_return OracleDML::constraint_key()
    {
        return m_gOracleDMLKeys->constraint_key();
    }

    OracleDML_OracleDMLKeys::empty_key_return OracleDML::empty_key()
    {
        return m_gOracleDMLKeys->empty_key();
    }

    OracleDML_OracleDMLKeys::current_key_return OracleDML::current_key()
    {
        return m_gOracleDMLKeys->current_key();
    }

    OracleDML_OracleDMLKeys::first_key_return OracleDML::first_key()
    {
        return m_gOracleDMLKeys->first_key();
    }

    OracleDML_OracleDMLKeys::reuse_key_return OracleDML::reuse_key()
    {
        return m_gOracleDMLKeys->reuse_key();
    }

    OracleDML_OracleDMLKeys::char_cs_key_return OracleDML::char_cs_key()
    {
        return m_gOracleDMLKeys->char_cs_key();
    }

    OracleDML_OracleDMLKeys::natural_key_return OracleDML::natural_key()
    {
        return m_gOracleDMLKeys->natural_key();
    }

    OracleDML_OracleDMLKeys::unique_key_return OracleDML::unique_key()
    {
        return m_gOracleDMLKeys->unique_key();
    }

    OracleDML_OracleDMLCommons::native_datatype_element_return OracleDML::native_datatype_element()
    {
        return m_gOracleDMLCommons->native_datatype_element();
    }

    OracleDML_OracleDMLKeys::compile_key_return OracleDML::compile_key()
    {
        return m_gOracleDMLKeys->compile_key();
    }

    OracleDML_OracleDMLKeys::record_key_return OracleDML::record_key()
    {
        return m_gOracleDMLKeys->record_key();
    }

    OracleDML_OracleDMLKeys::type_key_return OracleDML::type_key()
    {
        return m_gOracleDMLKeys->type_key();
    }

    OracleDML_OracleDMLKeys::last_key_return OracleDML::last_key()
    {
        return m_gOracleDMLKeys->last_key();
    }

    OracleDML_OracleDMLKeys::pivot_key_return OracleDML::pivot_key()
    {
        return m_gOracleDMLKeys->pivot_key();
    }

    OracleDML_OracleDMLCommons::bind_variable_return OracleDML::bind_variable()
    {
        return m_gOracleDMLCommons->bind_variable();
    }

    OracleDML_OracleDMLKeys::enable_key_return OracleDML::enable_key()
    {
        return m_gOracleDMLKeys->enable_key();
    }

    OracleDML_OracleDMLCommons::attribute_name_return OracleDML::attribute_name()
    {
        return m_gOracleDMLCommons->attribute_name();
    }

    OracleDML_OracleDMLKeys::oid_key_return OracleDML::oid_key()
    {
        return m_gOracleDMLKeys->oid_key();
    }

    OracleDML_OracleDMLKeys::dbtimezone_key_return OracleDML::dbtimezone_key()
    {
        return m_gOracleDMLKeys->dbtimezone_key();
    }

    OracleDML_OracleDMLKeys::urowid_key_return OracleDML::urowid_key()
    {
        return m_gOracleDMLKeys->urowid_key();
    }

    OracleDML_OracleDMLKeys::to_number_key_return OracleDML::to_number_key()
    {
        return m_gOracleDMLKeys->to_number_key();
    }

    OracleDML_OracleDMLKeys::siblings_key_return OracleDML::siblings_key()
    {
        return m_gOracleDMLKeys->siblings_key();
    }

    OracleDML_OracleDMLKeys::convert_key_return OracleDML::convert_key()
    {
        return m_gOracleDMLKeys->convert_key();
    }

    OracleDML_OracleDMLKeys::unlimited_key_return OracleDML::unlimited_key()
    {
        return m_gOracleDMLKeys->unlimited_key();
    }

    OracleDML_OracleDMLKeys::parallel_key_return OracleDML::parallel_key()
    {
        return m_gOracleDMLKeys->parallel_key();
    }

    OracleDML_OracleDMLKeys::rowidtochar_key_return OracleDML::rowidtochar_key()
    {
        return m_gOracleDMLKeys->rowidtochar_key();
    }

    OracleDML_OracleDMLCommons::greater_than_or_equals_op_return OracleDML::greater_than_or_equals_op()
    {
        return m_gOracleDMLCommons->greater_than_or_equals_op();
    }

    OracleDML_OracleDMLKeys::depth_key_return OracleDML::depth_key()
    {
        return m_gOracleDMLKeys->depth_key();
    }

    OracleDML_OracleDMLKeys::merge_key_return OracleDML::merge_key()
    {
        return m_gOracleDMLKeys->merge_key();
    }

    OracleDML_OracleDMLKeys::to_key_return OracleDML::to_key()
    {
        return m_gOracleDMLKeys->to_key();
    }

    OracleDML_OracleDMLKeys::savepoint_key_return OracleDML::savepoint_key()
    {
        return m_gOracleDMLKeys->savepoint_key();
    }

    OracleDML_OracleDMLKeys::guard_key_return OracleDML::guard_key()
    {
        return m_gOracleDMLKeys->guard_key();
    }

    OracleDML_OracleDMLKeys::language_key_return OracleDML::language_key()
    {
        return m_gOracleDMLKeys->language_key();
    }

    OracleDML_OracleDMLKeys::using_key_return OracleDML::using_key()
    {
        return m_gOracleDMLKeys->using_key();
    }

    OracleDML_OracleDMLKeys::current_time_key_return OracleDML::current_time_key()
    {
        return m_gOracleDMLKeys->current_time_key();
    }

    OracleDML_OracleDMLKeys::distinct_key_return OracleDML::distinct_key()
    {
        return m_gOracleDMLKeys->distinct_key();
    }

    OracleDML_OracleDMLKeys::integer_key_return OracleDML::integer_key()
    {
        return m_gOracleDMLKeys->integer_key();
    }

    OracleDML_OracleDMLKeys::decrement_key_return OracleDML::decrement_key()
    {
        return m_gOracleDMLKeys->decrement_key();
    }

    OracleDML_OracleDMLKeys::out_key_return OracleDML::out_key()
    {
        return m_gOracleDMLKeys->out_key();
    }

    OracleDML_OracleDMLKeys::definer_key_return OracleDML::definer_key()
    {
        return m_gOracleDMLKeys->definer_key();
    }

    OracleDML_OracleDMLKeys::nan_key_return OracleDML::nan_key()
    {
        return m_gOracleDMLKeys->nan_key();
    }

    OracleDML_OracleDMLKeys::immediate_key_return OracleDML::immediate_key()
    {
        return m_gOracleDMLKeys->immediate_key();
    }

    OracleDML_OracleDMLCommons::concatenation_op_return OracleDML::concatenation_op()
    {
        return m_gOracleDMLCommons->concatenation_op();
    }

    OracleDML_OracleDMLCommons::multiset_op_return OracleDML::multiset_op()
    {
        return m_gOracleDMLCommons->multiset_op();
    }

    OracleDML_OracleDMLKeys::timeout_key_return OracleDML::timeout_key()
    {
        return m_gOracleDMLKeys->timeout_key();
    }

    OracleDML_OracleDMLKeys::versions_key_return OracleDML::versions_key()
    {
        return m_gOracleDMLKeys->versions_key();
    }

    OracleDML_OracleDMLKeys::customdatum_key_return OracleDML::customdatum_key()
    {
        return m_gOracleDMLKeys->customdatum_key();
    }

    OracleDML_OracleDMLKeys::nchar_key_return OracleDML::nchar_key()
    {
        return m_gOracleDMLKeys->nchar_key();
    }

    OracleDML_OracleDMLKeys::binary_float_infinity_key_return OracleDML::binary_float_infinity_key()
    {
        return m_gOracleDMLKeys->binary_float_infinity_key();
    }

    OracleDML_OracleDMLKeys::order_key_return OracleDML::order_key()
    {
        return m_gOracleDMLKeys->order_key();
    }

    OracleDML_OracleDMLKeys::full_key_return OracleDML::full_key()
    {
        return m_gOracleDMLKeys->full_key();
    }

    OracleDML_OracleDMLKeys::percent_type_key_return OracleDML::percent_type_key()
    {
        return m_gOracleDMLKeys->percent_type_key();
    }

    OracleDML_OracleDMLKeys::referencing_key_return OracleDML::referencing_key()
    {
        return m_gOracleDMLKeys->referencing_key();
    }

    OracleDML_OracleDMLKeys::substring_key_return OracleDML::substring_key()
    {
        return m_gOracleDMLKeys->substring_key();
    }

    OracleDML_OracleDMLKeys::xml_key_return OracleDML::xml_key()
    {
        return m_gOracleDMLKeys->xml_key();
    }

    OracleDML_OracleDMLCommons::variable_name_return OracleDML::variable_name()
    {
        return m_gOracleDMLCommons->variable_name();
    }

    OracleDML_OracleDMLKeys::update_key_return OracleDML::update_key()
    {
        return m_gOracleDMLKeys->update_key();
    }

    OracleDML_OracleDMLKeys::package_key_return OracleDML::package_key()
    {
        return m_gOracleDMLKeys->package_key();
    }

    OracleDML_OracleDMLKeys::simple_integer_key_return OracleDML::simple_integer_key()
    {
        return m_gOracleDMLKeys->simple_integer_key();
    }

    OracleDML_OracleDMLKeys::decompose_key_return OracleDML::decompose_key()
    {
        return m_gOracleDMLKeys->decompose_key();
    }

    OracleDML_OracleDMLKeys::xmltable_key_return OracleDML::xmltable_key()
    {
        return m_gOracleDMLKeys->xmltable_key();
    }

    OracleDML_OracleDMLKeys::timezone_hour_key_return OracleDML::timezone_hour_key()
    {
        return m_gOracleDMLKeys->timezone_hour_key();
    }

    OracleDML_OracleDMLCommons::char_set_name_return OracleDML::char_set_name()
    {
        return m_gOracleDMLCommons->char_set_name();
    }

    OracleDML_OracleDMLCommons::parameter_name_return OracleDML::parameter_name()
    {
        return m_gOracleDMLCommons->parameter_name();
    }

    OracleDML_OracleDMLKeys::save_key_return OracleDML::save_key()
    {
        return m_gOracleDMLKeys->save_key();
    }

    OracleDML_OracleDMLCommons::constant_return OracleDML::constant()
    {
        return m_gOracleDMLCommons->constant();
    }

    OracleDML_OracleDMLKeys::where_key_return OracleDML::where_key()
    {
        return m_gOracleDMLKeys->where_key();
    }

    OracleDML_OracleDMLKeys::union_key_return OracleDML::union_key()
    {
        return m_gOracleDMLKeys->union_key();
    }

    OracleDML_OracleDMLKeys::xmlelement_key_return OracleDML::xmlelement_key()
    {
        return m_gOracleDMLKeys->xmlelement_key();
    }

    OracleDML_OracleDMLKeys::position_key_return OracleDML::position_key()
    {
        return m_gOracleDMLKeys->position_key();
    }

    OracleDML_OracleDMLCommons::quoted_string_return OracleDML::quoted_string()
    {
        return m_gOracleDMLCommons->quoted_string();
    }

    OracleDML_OracleDMLCommons::numeric_return OracleDML::numeric()
    {
        return m_gOracleDMLCommons->numeric();
    }

    OracleDML_OracleDMLKeys::varying_key_return OracleDML::varying_key()
    {
        return m_gOracleDMLKeys->varying_key();
    }

    OracleDML_OracleDMLKeys::least_key_return OracleDML::least_key()
    {
        return m_gOracleDMLKeys->least_key();
    }

    OracleDML_OracleDMLKeys::compatibility_key_return OracleDML::compatibility_key()
    {
        return m_gOracleDMLKeys->compatibility_key();
    }

    OracleDML_OracleDMLKeys::last_value_key_return OracleDML::last_value_key()
    {
        return m_gOracleDMLKeys->last_value_key();
    }

    OracleDML_OracleDMLKeys::infinite_key_return OracleDML::infinite_key()
    {
        return m_gOracleDMLKeys->infinite_key();
    }

    OracleDML_OracleDMLKeys::values_key_return OracleDML::values_key()
    {
        return m_gOracleDMLKeys->values_key();
    }

    OracleDML_OracleDMLKeys::restrict_references_key_return OracleDML::restrict_references_key()
    {
        return m_gOracleDMLKeys->restrict_references_key();
    }

    OracleDML_OracleDMLKeys::current_date_key_return OracleDML::current_date_key()
    {
        return m_gOracleDMLKeys->current_date_key();
    }

    OracleDML_OracleDMLKeys::until_key_return OracleDML::until_key()
    {
        return m_gOracleDMLKeys->until_key();
    }

    OracleDML_OracleDMLKeys::collate_key_return OracleDML::collate_key()
    {
        return m_gOracleDMLKeys->collate_key();
    }

    OracleDML_OracleDMLKeys::sqrt_key_return OracleDML::sqrt_key()
    {
        return m_gOracleDMLKeys->sqrt_key();
    }

    OracleDML_OracleDMLKeys::isolation_key_return OracleDML::isolation_key()
    {
        return m_gOracleDMLKeys->isolation_key();
    }

    OracleDML_OracleDMLKeys::reject_key_return OracleDML::reject_key()
    {
        return m_gOracleDMLKeys->reject_key();
    }

    OracleDML_OracleDMLKeys::begin_key_return OracleDML::begin_key()
    {
        return m_gOracleDMLKeys->begin_key();
    }

    OracleDML_OracleDMLKeys::xmlserialize_key_return OracleDML::xmlserialize_key()
    {
        return m_gOracleDMLKeys->xmlserialize_key();
    }

    OracleDML_OracleDMLKeys::search_key_return OracleDML::search_key()
    {
        return m_gOracleDMLKeys->search_key();
    }

    OracleDML_OracleDMLKeys::over_key_return OracleDML::over_key()
    {
        return m_gOracleDMLKeys->over_key();
    }

    OracleDML_OracleDMLKeys::hour_key_return OracleDML::hour_key()
    {
        return m_gOracleDMLKeys->hour_key();
    }

    OracleDML_OracleDMLKeys::start_key_return OracleDML::start_key()
    {
        return m_gOracleDMLKeys->start_key();
    }

    OracleDML_OracleDMLCommons::function_argument_return OracleDML::function_argument()
    {
        return m_gOracleDMLCommons->function_argument();
    }

    OracleDML_OracleDMLKeys::binary_double_nan_key_return OracleDML::binary_double_nan_key()
    {
        return m_gOracleDMLKeys->binary_double_nan_key();
    }

    OracleDML_OracleDMLKeys::cost_key_return OracleDML::cost_key()
    {
        return m_gOracleDMLKeys->cost_key();
    }

    OracleDML_OracleDMLKeys::binary_float_key_return OracleDML::binary_float_key()
    {
        return m_gOracleDMLKeys->binary_float_key();
    }

    OracleDML_OracleDMLKeys::logon_key_return OracleDML::logon_key()
    {
        return m_gOracleDMLKeys->logon_key();
    }

    OracleDML_OracleDMLKeys::noaudit_key_return OracleDML::noaudit_key()
    {
        return m_gOracleDMLKeys->noaudit_key();
    }

    OracleDML_OracleDMLKeys::partial_key_return OracleDML::partial_key()
    {
        return m_gOracleDMLKeys->partial_key();
    }

    OracleDML_OracleDMLKeys::system_user_key_return OracleDML::system_user_key()
    {
        return m_gOracleDMLKeys->system_user_key();
    }

    OracleDML_OracleDMLKeys::statement_id_key_return OracleDML::statement_id_key()
    {
        return m_gOracleDMLKeys->statement_id_key();
    }

    OracleDML_OracleDMLKeys::trigger_key_return OracleDML::trigger_key()
    {
        return m_gOracleDMLKeys->trigger_key();
    }

    OracleDML_OracleDMLKeys::locked_key_return OracleDML::locked_key()
    {
        return m_gOracleDMLKeys->locked_key();
    }

    OracleDML_OracleDMLKeys::grant_key_return OracleDML::grant_key()
    {
        return m_gOracleDMLKeys->grant_key();
    }

    OracleDML_OracleDMLKeys::associate_key_return OracleDML::associate_key()
    {
        return m_gOracleDMLKeys->associate_key();
    }

    OracleDML_OracleDMLKeys::logoff_key_return OracleDML::logoff_key()
    {
        return m_gOracleDMLKeys->logoff_key();
    }

    OracleDML_OracleDMLKeys::inout_key_return OracleDML::inout_key()
    {
        return m_gOracleDMLKeys->inout_key();
    }

    OracleDML_OracleDMLKeys::zone_key_return OracleDML::zone_key()
    {
        return m_gOracleDMLKeys->zone_key();
    }

    OracleDML_OracleDMLKeys::minvalue_key_return OracleDML::minvalue_key()
    {
        return m_gOracleDMLKeys->minvalue_key();
    }

    OracleDML_OracleDMLKeys::rpad_key_return OracleDML::rpad_key()
    {
        return m_gOracleDMLKeys->rpad_key();
    }

    OracleDML_OracleDMLKeys::inner_key_return OracleDML::inner_key()
    {
        return m_gOracleDMLKeys->inner_key();
    }

    OracleDML_OracleDMLCommons::type_spec_return OracleDML::type_spec()
    {
        return m_gOracleDMLCommons->type_spec();
    }

    OracleDML_OracleDMLKeys::drop_key_return OracleDML::drop_key()
    {
        return m_gOracleDMLKeys->drop_key();
    }

    OracleDML_OracleDMLKeys::or_key_return OracleDML::or_key()
    {
        return m_gOracleDMLKeys->or_key();
    }

    OracleDML_OracleDMLKeys::xmlquery_key_return OracleDML::xmlquery_key()
    {
        return m_gOracleDMLKeys->xmlquery_key();
    }

    OracleDML_OracleDMLKeys::character_key_return OracleDML::character_key()
    {
        return m_gOracleDMLKeys->character_key();
    }

    OracleDML_OracleDMLKeys::chartorowid_key_return OracleDML::chartorowid_key()
    {
        return m_gOracleDMLKeys->chartorowid_key();
    }

    OracleDML_OracleDMLKeys::updated_key_return OracleDML::updated_key()
    {
        return m_gOracleDMLKeys->updated_key();
    }

    OracleDML_OracleDMLKeys::nocopy_key_return OracleDML::nocopy_key()
    {
        return m_gOracleDMLKeys->nocopy_key();
    }

    OracleDML_OracleDMLCommons::implementation_type_name_return OracleDML::implementation_type_name()
    {
        return m_gOracleDMLCommons->implementation_type_name();
    }

    OracleDML_OracleDMLKeys::hash_key_return OracleDML::hash_key()
    {
        return m_gOracleDMLKeys->hash_key();
    }

    OracleDML_OracleDMLCommons::collection_name_return OracleDML::collection_name()
    {
        return m_gOracleDMLCommons->collection_name();
    }

    OracleDML_OracleDMLCommons::label_name_return OracleDML::label_name()
    {
        return m_gOracleDMLCommons->label_name();
    }

    OracleDML_OracleDMLKeys::whenever_key_return OracleDML::whenever_key()
    {
        return m_gOracleDMLKeys->whenever_key();
    }

    OracleDML_OracleDMLKeys::matched_key_return OracleDML::matched_key()
    {
        return m_gOracleDMLKeys->matched_key();
    }

    OracleDML_OracleDMLKeys::array_key_return OracleDML::array_key()
    {
        return m_gOracleDMLKeys->array_key();
    }

    OracleDML_OracleDMLKeys::failure_key_return OracleDML::failure_key()
    {
        return m_gOracleDMLKeys->failure_key();
    }

    OracleDML_OracleDMLCommons::partition_extension_clause_return OracleDML::partition_extension_clause()
    {
        return m_gOracleDMLCommons->partition_extension_clause();
    }

    OracleDML_OracleDMLKeys::uid_key_return OracleDML::uid_key()
    {
        return m_gOracleDMLKeys->uid_key();
    }

    OracleDML_OracleDMLKeys::insert_key_return OracleDML::insert_key()
    {
        return m_gOracleDMLKeys->insert_key();
    }

    OracleDML_OracleDMLCommons::current_of_clause_return OracleDML::current_of_clause()
    {
        return m_gOracleDMLCommons->current_of_clause();
    }

    OracleDML_OracleDMLKeys::show_key_return OracleDML::show_key()
    {
        return m_gOracleDMLKeys->show_key();
    }

    OracleDML_OracleDMLKeys::string_key_return OracleDML::string_key()
    {
        return m_gOracleDMLKeys->string_key();
    }

    OracleDML_OracleDMLKeys::rtrim_key_return OracleDML::rtrim_key()
    {
        return m_gOracleDMLKeys->rtrim_key();
    }

    OracleDML_OracleDMLKeys::stddev_key_return OracleDML::stddev_key()
    {
        return m_gOracleDMLKeys->stddev_key();
    }

    OracleDML_OracleDMLKeys::xmlnamespaces_key_return OracleDML::xmlnamespaces_key()
    {
        return m_gOracleDMLKeys->xmlnamespaces_key();
    }

    OracleDML_OracleDMLKeys::db_role_change_key_return OracleDML::db_role_change_key()
    {
        return m_gOracleDMLKeys->db_role_change_key();
    }

    OracleDML_OracleDMLKeys::binary_float_min_normal_key_return OracleDML::binary_float_min_normal_key()
    {
        return m_gOracleDMLKeys->binary_float_min_normal_key();
    }

    OracleDML_OracleDMLKeys::servererror_key_return OracleDML::servererror_key()
    {
        return m_gOracleDMLKeys->servererror_key();
    }

    OracleDML_OracleDMLKeys::smallint_key_return OracleDML::smallint_key()
    {
        return m_gOracleDMLKeys->smallint_key();
    }

    OracleDML_OracleDMLKeys::elsif_key_return OracleDML::elsif_key()
    {
        return m_gOracleDMLKeys->elsif_key();
    }

    OracleDML_OracleDMLKeys::max_key_return OracleDML::max_key()
    {
        return m_gOracleDMLKeys->max_key();
    }

    OracleDML_OracleDMLKeys::statement_key_return OracleDML::statement_key()
    {
        return m_gOracleDMLKeys->statement_key();
    }

    OracleDML_OracleDMLKeys::keep_key_return OracleDML::keep_key()
    {
        return m_gOracleDMLKeys->keep_key();
    }

    OracleDML_OracleDMLKeys::xmlroot_key_return OracleDML::xmlroot_key()
    {
        return m_gOracleDMLKeys->xmlroot_key();
    }

    OracleDML_OracleDMLCommons::savepoint_name_return OracleDML::savepoint_name()
    {
        return m_gOracleDMLCommons->savepoint_name();
    }

    OracleDML_OracleDMLKeys::c_key_return OracleDML::c_key()
    {
        return m_gOracleDMLKeys->c_key();
    }

    OracleDML_OracleDMLKeys::use_key_return OracleDML::use_key()
    {
        return m_gOracleDMLKeys->use_key();
    }

    OracleDML_OracleDMLKeys::on_key_return OracleDML::on_key()
    {
        return m_gOracleDMLKeys->on_key();
    }

    OracleDML_OracleDMLKeys::xmlexists_key_return OracleDML::xmlexists_key()
    {
        return m_gOracleDMLKeys->xmlexists_key();
    }

    OracleDML_OracleDMLKeys::following_key_return OracleDML::following_key()
    {
        return m_gOracleDMLKeys->following_key();
    }

    OracleDML_OracleDMLCommons::record_name_return OracleDML::record_name()
    {
        return m_gOracleDMLCommons->record_name();
    }

    OracleDML_OracleDMLKeys::self_key_return OracleDML::self_key()
    {
        return m_gOracleDMLKeys->self_key();
    }

    OracleDML_OracleDMLKeys::corresponding_key_return OracleDML::corresponding_key()
    {
        return m_gOracleDMLKeys->corresponding_key();
    }

    OracleDML_OracleDMLKeys::under_key_return OracleDML::under_key()
    {
        return m_gOracleDMLKeys->under_key();
    }

    OracleDML_OracleDMLKeys::resumable_key_return OracleDML::resumable_key()
    {
        return m_gOracleDMLKeys->resumable_key();
    }

    OracleDML_OracleDMLKeys::log_key_return OracleDML::log_key()
    {
        return m_gOracleDMLKeys->log_key();
    }

    OracleDML_OracleDMLKeys::like4_key_return OracleDML::like4_key()
    {
        return m_gOracleDMLKeys->like4_key();
    }

    OracleDML_OracleDMLKeys::nomaxvalue_key_return OracleDML::nomaxvalue_key()
    {
        return m_gOracleDMLKeys->nomaxvalue_key();
    }

    OracleDML_OracleDMLKeys::autonomous_transaction_key_return OracleDML::autonomous_transaction_key()
    {
        return m_gOracleDMLKeys->autonomous_transaction_key();
    }

    OracleDML_OracleDMLKeys::percent_key_return OracleDML::percent_key()
    {
        return m_gOracleDMLKeys->percent_key();
    }

    OracleDML_OracleDMLKeys::mode_key_return OracleDML::mode_key()
    {
        return m_gOracleDMLKeys->mode_key();
    }

    OracleDML_OracleDMLKeys::xmlcast_key_return OracleDML::xmlcast_key()
    {
        return m_gOracleDMLKeys->xmlcast_key();
    }

    OracleDML_OracleDMLKeys::loop_key_return OracleDML::loop_key()
    {
        return m_gOracleDMLKeys->loop_key();
    }

    OracleDML_OracleDMLKeys::ascii_key_return OracleDML::ascii_key()
    {
        return m_gOracleDMLKeys->ascii_key();
    }

    OracleDML_OracleDMLKeys::to_date_key_return OracleDML::to_date_key()
    {
        return m_gOracleDMLKeys->to_date_key();
    }

    OracleDML_OracleDMLKeys::sqldata_key_return OracleDML::sqldata_key()
    {
        return m_gOracleDMLKeys->sqldata_key();
    }

    OracleDML_OracleDMLKeys::pls_integer_key_return OracleDML::pls_integer_key()
    {
        return m_gOracleDMLKeys->pls_integer_key();
    }

    OracleDML_OracleDMLKeys::hide_key_return OracleDML::hide_key()
    {
        return m_gOracleDMLKeys->hide_key();
    }

    OracleDML_OracleDMLKeys::int_key_return OracleDML::int_key()
    {
        return m_gOracleDMLKeys->int_key();
    }

    OracleDML_OracleDMLKeys::trim_key_return OracleDML::trim_key()
    {
        return m_gOracleDMLKeys->trim_key();
    }

    OracleDML_OracleDMLKeys::schema_key_return OracleDML::schema_key()
    {
        return m_gOracleDMLKeys->schema_key();
    }

    OracleDML_OracleDMLKeys::indent_key_return OracleDML::indent_key()
    {
        return m_gOracleDMLKeys->indent_key();
    }

    OracleDML_OracleDMLKeys::like_key_return OracleDML::like_key()
    {
        return m_gOracleDMLKeys->like_key();
    }

    OracleDML_OracleDMLKeys::timezone_abbr_key_return OracleDML::timezone_abbr_key()
    {
        return m_gOracleDMLKeys->timezone_abbr_key();
    }

    OracleDML_OracleDMLKeys::varchar2_key_return OracleDML::varchar2_key()
    {
        return m_gOracleDMLKeys->varchar2_key();
    }

    OracleDML_OracleDMLKeys::binary_float_min_subnormal_key_return OracleDML::binary_float_min_subnormal_key()
    {
        return m_gOracleDMLKeys->binary_float_min_subnormal_key();
    }

    OracleDML_OracleDMLKeys::auto_key_return OracleDML::auto_key()
    {
        return m_gOracleDMLKeys->auto_key();
    }

    OracleDML_OracleDMLKeys::preceding_key_return OracleDML::preceding_key()
    {
        return m_gOracleDMLKeys->preceding_key();
    }

    OracleDML_OracleDMLKeys::xmlforest_key_return OracleDML::xmlforest_key()
    {
        return m_gOracleDMLKeys->xmlforest_key();
    }

    OracleDML_OracleDMLCommons::function_name_return OracleDML::function_name()
    {
        return m_gOracleDMLCommons->function_name();
    }

    OracleDML_OracleDMLKeys::binary_float_nan_key_return OracleDML::binary_float_nan_key()
    {
        return m_gOracleDMLKeys->binary_float_nan_key();
    }

    OracleDML_OracleDMLKeys::binary_double_max_subnormal_key_return OracleDML::binary_double_max_subnormal_key()
    {
        return m_gOracleDMLKeys->binary_double_max_subnormal_key();
    }

    OracleDML_OracleDMLKeys::minute_key_return OracleDML::minute_key()
    {
        return m_gOracleDMLKeys->minute_key();
    }

    OracleDML_OracleDMLKeys::having_key_return OracleDML::having_key()
    {
        return m_gOracleDMLKeys->having_key();
    }

    OracleDML_OracleDMLKeys::level_key_return OracleDML::level_key()
    {
        return m_gOracleDMLKeys->level_key();
    }

    OracleDML_OracleDMLKeys::old_key_return OracleDML::old_key()
    {
        return m_gOracleDMLKeys->old_key();
    }

    OracleDML_OracleDMLKeys::group_key_return OracleDML::group_key()
    {
        return m_gOracleDMLKeys->group_key();
    }

    OracleDML_OracleDMLKeys::varchar_key_return OracleDML::varchar_key()
    {
        return m_gOracleDMLKeys->varchar_key();
    }

    OracleDML_OracleDMLKeys::binary_float_max_normal_key_return OracleDML::binary_float_max_normal_key()
    {
        return m_gOracleDMLKeys->binary_float_max_normal_key();
    }

    OracleDML_OracleDMLKeys::module_key_return OracleDML::module_key()
    {
        return m_gOracleDMLKeys->module_key();
    }

    OracleDML_OracleDMLKeys::variance_key_return OracleDML::variance_key()
    {
        return m_gOracleDMLKeys->variance_key();
    }

    OracleDML_OracleDMLKeys::timestamp_unconstrained_key_return OracleDML::timestamp_unconstrained_key()
    {
        return m_gOracleDMLKeys->timestamp_unconstrained_key();
    }

    OracleDML_OracleDMLKeys::off_key_return OracleDML::off_key()
    {
        return m_gOracleDMLKeys->off_key();
    }

    OracleDML_OracleDMLKeys::dsinterval_unconstrained_key_return OracleDML::dsinterval_unconstrained_key()
    {
        return m_gOracleDMLKeys->dsinterval_unconstrained_key();
    }

    OracleDML_OracleDMLKeys::cross_key_return OracleDML::cross_key()
    {
        return m_gOracleDMLKeys->cross_key();
    }

    OracleDML_OracleDMLKeys::naturaln_key_return OracleDML::naturaln_key()
    {
        return m_gOracleDMLKeys->naturaln_key();
    }

    OracleDML_OracleDMLKeys::real_key_return OracleDML::real_key()
    {
        return m_gOracleDMLKeys->real_key();
    }

    OracleDML_OracleDMLKeys::alter_key_return OracleDML::alter_key()
    {
        return m_gOracleDMLKeys->alter_key();
    }

    OracleDML_OracleDMLKeys::aggregate_key_return OracleDML::aggregate_key()
    {
        return m_gOracleDMLKeys->aggregate_key();
    }

    OracleDML_OracleDMLKeys::double_key_return OracleDML::double_key()
    {
        return m_gOracleDMLKeys->double_key();
    }

    OracleDML_OracleDMLKeys::rollback_key_return OracleDML::rollback_key()
    {
        return m_gOracleDMLKeys->rollback_key();
    }

    OracleDML_OracleDMLKeys::by_key_return OracleDML::by_key()
    {
        return m_gOracleDMLKeys->by_key();
    }

    OracleDML_OracleDMLKeys::success_key_return OracleDML::success_key()
    {
        return m_gOracleDMLKeys->success_key();
    }

    OracleDML_OracleDMLKeys::exception_key_return OracleDML::exception_key()
    {
        return m_gOracleDMLKeys->exception_key();
    }

    OracleDML_OracleDMLKeys::range_key_return OracleDML::range_key()
    {
        return m_gOracleDMLKeys->range_key();
    }

    OracleDML_OracleDMLCommons::type_name_return OracleDML::type_name()
    {
        return m_gOracleDMLCommons->type_name();
    }

    OracleDML_OracleDMLCommons::xml_column_name_return OracleDML::xml_column_name()
    {
        return m_gOracleDMLCommons->xml_column_name();
    }

    OracleDML_OracleDMLKeys::bfile_key_return OracleDML::bfile_key()
    {
        return m_gOracleDMLKeys->bfile_key();
    }

    OracleDML_OracleDMLKeys::plan_key_return OracleDML::plan_key()
    {
        return m_gOracleDMLKeys->plan_key();
    }

    OracleDML_OracleDMLKeys::bit_length_key_return OracleDML::bit_length_key()
    {
        return m_gOracleDMLKeys->bit_length_key();
    }

    OracleDML_OracleDMLKeys::vsize_key_return OracleDML::vsize_key()
    {
        return m_gOracleDMLKeys->vsize_key();
    }

    OracleDML_OracleDMLKeys::case_key_return OracleDML::case_key()
    {
        return m_gOracleDMLKeys->case_key();
    }

    OracleDML_OracleDMLCommons::constraint_name_return OracleDML::constraint_name()
    {
        return m_gOracleDMLCommons->constraint_name();
    }

    OracleDML_OracleDMLKeys::include_key_return OracleDML::include_key()
    {
        return m_gOracleDMLKeys->include_key();
    }

    OracleDML_OracleDMLKeys::increment_key_return OracleDML::increment_key()
    {
        return m_gOracleDMLKeys->increment_key();
    }

    OracleDML_OracleDMLKeys::escape_key_return OracleDML::escape_key()
    {
        return m_gOracleDMLKeys->escape_key();
    }

/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
bool OracleDML::msynpred( antlr3::ClassForwarder< synpred41_OracleDML >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred41_OracleDML_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool OracleDML::msynpred( antlr3::ClassForwarder< synpred46_OracleDML >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred46_OracleDML_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool OracleDML::msynpred( antlr3::ClassForwarder< synpred24_OracleDML >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred24_OracleDML_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool OracleDML::msynpred( antlr3::ClassForwarder< synpred25_OracleDML >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred25_OracleDML_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool OracleDML::msynpred( antlr3::ClassForwarder< synpred28_OracleDML >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred28_OracleDML_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool OracleDML::msynpred( antlr3::ClassForwarder< synpred20_OracleDML >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred20_OracleDML_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool OracleDML::msynpred( antlr3::ClassForwarder< synpred33_OracleDML >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred33_OracleDML_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool OracleDML::msynpred( antlr3::ClassForwarder< synpred23_OracleDML >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred23_OracleDML_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool OracleDML::msynpred( antlr3::ClassForwarder< synpred16_OracleDML >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred16_OracleDML_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool OracleDML::msynpred( antlr3::ClassForwarder< synpred50_OracleDML >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred50_OracleDML_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool OracleDML::msynpred( antlr3::ClassForwarder< synpred42_OracleDML >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred42_OracleDML_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool OracleDML::msynpred( antlr3::ClassForwarder< synpred39_OracleDML >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred39_OracleDML_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool OracleDML::msynpred( antlr3::ClassForwarder< synpred12_OracleDML >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred12_OracleDML_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool OracleDML::msynpred( antlr3::ClassForwarder< synpred31_OracleDML >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred31_OracleDML_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool OracleDML::msynpred( antlr3::ClassForwarder< synpred15_OracleDML >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred15_OracleDML_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool OracleDML::msynpred( antlr3::ClassForwarder< synpred13_OracleDML >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred13_OracleDML_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool OracleDML::msynpred( antlr3::ClassForwarder< synpred17_OracleDML >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred17_OracleDML_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool OracleDML::msynpred( antlr3::ClassForwarder< synpred18_OracleDML >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred18_OracleDML_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool OracleDML::msynpred( antlr3::ClassForwarder< synpred32_OracleDML >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred32_OracleDML_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool OracleDML::msynpred( antlr3::ClassForwarder< synpred4_OracleDML >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred4_OracleDML_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool OracleDML::msynpred( antlr3::ClassForwarder< synpred54_OracleDML >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred54_OracleDML_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool OracleDML::msynpred( antlr3::ClassForwarder< synpred6_OracleDML >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred6_OracleDML_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool OracleDML::msynpred( antlr3::ClassForwarder< synpred3_OracleDML >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred3_OracleDML_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool OracleDML::msynpred( antlr3::ClassForwarder< synpred48_OracleDML >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred48_OracleDML_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool OracleDML::msynpred( antlr3::ClassForwarder< synpred11_OracleDML >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred11_OracleDML_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool OracleDML::msynpred( antlr3::ClassForwarder< synpred2_OracleDML >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred2_OracleDML_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool OracleDML::msynpred( antlr3::ClassForwarder< synpred30_OracleDML >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred30_OracleDML_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool OracleDML::msynpred( antlr3::ClassForwarder< synpred5_OracleDML >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred5_OracleDML_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool OracleDML::msynpred( antlr3::ClassForwarder< synpred53_OracleDML >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred53_OracleDML_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool OracleDML::msynpred( antlr3::ClassForwarder< synpred10_OracleDML >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred10_OracleDML_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool OracleDML::msynpred( antlr3::ClassForwarder< synpred45_OracleDML >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred45_OracleDML_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool OracleDML::msynpred( antlr3::ClassForwarder< synpred21_OracleDML >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred21_OracleDML_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool OracleDML::msynpred( antlr3::ClassForwarder< synpred52_OracleDML >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred52_OracleDML_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool OracleDML::msynpred( antlr3::ClassForwarder< synpred44_OracleDML >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred44_OracleDML_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool OracleDML::msynpred( antlr3::ClassForwarder< synpred19_OracleDML >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred19_OracleDML_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool OracleDML::msynpred( antlr3::ClassForwarder< synpred22_OracleDML >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred22_OracleDML_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool OracleDML::msynpred( antlr3::ClassForwarder< synpred43_OracleDML >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred43_OracleDML_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool OracleDML::msynpred( antlr3::ClassForwarder< synpred51_OracleDML >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred51_OracleDML_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool OracleDML::msynpred( antlr3::ClassForwarder< synpred1_OracleDML >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred1_OracleDML_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool OracleDML::msynpred( antlr3::ClassForwarder< synpred49_OracleDML >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred49_OracleDML_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool OracleDML::msynpred( antlr3::ClassForwarder< synpred14_OracleDML >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred14_OracleDML_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool OracleDML::msynpred( antlr3::ClassForwarder< synpred26_OracleDML >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred26_OracleDML_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool OracleDML::msynpred( antlr3::ClassForwarder< synpred34_OracleDML >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred34_OracleDML_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool OracleDML::msynpred( antlr3::ClassForwarder< synpred29_OracleDML >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred29_OracleDML_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool OracleDML::msynpred( antlr3::ClassForwarder< synpred27_OracleDML >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred27_OracleDML_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

/* End of syntactic predicates
 * ==============================================
 */

}

/* End of code
 * =============================================================================
 */
