/** \file
 *  This C++ header file was generated by $ANTLR version 3.5.3-SNAPSHOT
 *
 *     -  From the grammar source file : OracleDMLCommons.g
 *     -                            On : 2018-09-16 12:09:08
 *     -                for the parser : OracleDML_OracleDMLCommonsParser
 *
 * Editing it, at least manually, is not wise.
 *
 * C++ language generator and runtime by Gokulakannan Somasundaram ( heavy lifting from C Run-time by Jim Idle )
 *
 *
 * The parser OracleDML_OracleDMLCommons has the callable functions (rules) shown below,
 * which will invoke the code for the associated rule in the source grammar
 * assuming that the input stream is pointing to a token/text stream that could begin
 * this rule.
 *
 * For instance if you call the first (topmost) rule in a parser grammar, you will
 * get the results of a full parse, but calling a rule half way through the grammar will
 * allow you to pass part of a full token stream to the parser, such as for syntax checking
 * in editors and so on.
 *
 */
// [The "BSD license"]
// Copyright (c) 2005-2009 Gokulakannan Somasundaram. 
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

#ifndef	_OracleDML_OracleDMLCommons_H
#define _OracleDML_OracleDMLCommons_H
/* =============================================================================
 * Standard antlr3 C++ runtime definitions
 */
#include <antlr3.hpp>

/* End of standard antlr 3 runtime definitions
 * =============================================================================
 */


        #include "OracleDMLTraits.hpp"





/* ========================
 * BACKTRACKING IS ENABLED
 * ========================
 */

namespace  Antlr3BackendImpl  {

// Include delegator definition classes
//
class OracleDML; 

typedef OracleDML_OracleDMLCommonsTraits OracleDML_OracleDMLCommonsImplTraits;

 struct synpred1_OracleDMLCommons {}; 
 struct synpred2_OracleDMLCommons {}; 
 struct synpred3_OracleDMLCommons {}; 
 struct synpred4_OracleDMLCommons {}; 
 struct synpred5_OracleDMLCommons {}; 
 struct synpred6_OracleDMLCommons {}; 
 struct synpred7_OracleDMLCommons {}; 
 struct synpred8_OracleDMLCommons {}; 
 struct synpred9_OracleDMLCommons {}; 
 struct synpred10_OracleDMLCommons {}; 
 struct synpred11_OracleDMLCommons {}; 
 struct synpred12_OracleDMLCommons {}; 
 struct synpred13_OracleDMLCommons {}; 
 struct synpred14_OracleDMLCommons {}; 
 struct synpred15_OracleDMLCommons {}; 
 struct synpred16_OracleDMLCommons {}; 
 struct synpred17_OracleDMLCommons {}; 
 struct synpred18_OracleDMLCommons {}; 
 struct synpred19_OracleDMLCommons {}; 
 struct synpred20_OracleDMLCommons {}; 
 struct synpred21_OracleDMLCommons {}; 
 struct synpred22_OracleDMLCommons {}; 

class OracleDML_OracleDMLCommonsTokens
{
public:
	/** Symbolic definitions of all the tokens that the parser will work with.
	 *
	 * Antlr will define EOF, but we can't use that as it it is too common in
	 * in C header files and that would be confusing. There is no way to filter this out at the moment
	 * so we just undef it here for now. That isn't the value we get back from C recognizers
	 * anyway. We are looking for ANTLR_TOKEN_EOF.
	 */
	enum Tokens : ANTLR_UINT32
	{
		EOF_TOKEN = OracleDML_OracleDMLCommonsImplTraits::CommonTokenType::TOKEN_EOF
		, ADD_VK = 4 
		, AFTER_VK = 5 
		, AGENT_VK = 6 
		, AGGREGATE_VK = 7 
		, ALIAS = 8 
		, AMPERSAND = 9 
		, ANALYZE_VK = 10 
		, ANY_ELEMENT = 11 
		, ANY_MODE = 12 
		, APPROXIMATE_NUM_LIT = 13 
		, ARGUMENT = 14 
		, ARGUMENTS = 15 
		, ASSIGN = 16 
		, ASSIGN_OP = 17 
		, ASSOCIATE_VK = 18 
		, ASTERISK = 19 
		, ATTRIBUTE_NAME = 20 
		, AT_SIGN = 21 
		, AT_VK = 22 
		, AUDIT_VK = 23 
		, AUTHID_VK = 24 
		, AUTOMATIC_VK = 25 
		, AUTONOMOUS_TRANSACTION_VK = 26 
		, AUTO_VK = 27 
		, BATCH_VK = 28 
		, BEFORE_VK = 29 
		, BFILE_VK = 30 
		, BINARY_DOUBLE_VK = 31 
		, BINARY_FLOAT_VK = 32 
		, BINARY_INTEGER_VK = 33 
		, BINDVAR = 34 
		, BIT_STRING_LIT = 35 
		, BIT_VK = 36 
		, BLOB_VK = 37 
		, BLOCK_VK = 38 
		, BODY_VK = 39 
		, BOOLEAN_VK = 40 
		, BOTH_VK = 41 
		, BREADTH_VK = 42 
		, BULK_VK = 43 
		, BYTE_VK = 44 
		, CACHE_VK = 45 
		, CALL_VK = 46 
		, CANONICAL_VK = 47 
		, CARRET_OPERATOR_PART = 48 
		, CASCADE_VK = 49 
		, CASCATED_ELEMENT = 50 
		, CAST_VK = 51 
		, CHARACTER_VK = 52 
		, CHAR_CS_VK = 53 
		, CHAR_SET_NAME = 54 
		, CHAR_STRING = 55 
		, CHAR_STRING_PERL = 56 
		, CHAR_VK = 57 
		, CHR_VK = 58 
		, CLOB_VK = 59 
		, CLOSE_VK = 60 
		, CLUSTER_VK = 61 
		, COLLECTION_MODE = 62 
		, COLLECTION_NAME = 63 
		, COLLECT_VK = 64 
		, COLON = 65 
		, COLUMNS = 66 
		, COLUMN_NAME = 67 
		, COMMA = 68 
		, COMMENT = 69 
		, COMMENT_VK = 70 
		, COMMITTED_VK = 71 
		, COMMIT_VK = 72 
		, COMPATIBILITY_VK = 73 
		, COMPILE_VK = 74 
		, COMPOUND_VK = 75 
		, CONCATENATION_OP = 76 
		, CONDITIONAL_INSERT = 77 
		, CONSTANT_VK = 78 
		, CONSTRAINT_NAME = 79 
		, CONSTRUCTOR_VK = 80 
		, CONTENT_VK = 81 
		, CONTEXT_VK = 82 
		, CONTINUE_VK = 83 
		, CONVERT_VK = 84 
		, CORRUPT_XID_ALL_VK = 85 
		, CORRUPT_XID_VK = 86 
		, COST_CLASS_NAME = 87 
		, COST_VK = 88 
		, COUNT_VK = 89 
		, CROSS_VK = 90 
		, CUBE_VK = 91 
		, CURRENT_USER_VK = 92 
		, CURRENT_VK = 93 
		, CURSOR_NAME = 94 
		, CUSTOMDATUM_VK = 95 
		, CUSTOM_TYPE = 96 
		, CYCLE_VK = 97 
		, C_VK = 98 
		, DATABASE_VK = 99 
		, DATETIME_OP = 100 
		, DAY_VK = 101 
		, DBTIMEZONE_VK = 102 
		, DB_ROLE_CHANGE_VK = 103 
		, DDL_VK = 104 
		, DEBUG_VK = 105 
		, DECIMAL_VK = 106 
		, DECOMPOSE_VK = 107 
		, DECREMENT_VK = 108 
		, DEC_VK = 109 
		, DEFAULTS_VK = 110 
		, DEFERRED_VK = 111 
		, DEFINER_VK = 112 
		, DELIMITED_ID = 113 
		, DENSE_RANK_VK = 114 
		, DEPTH_VK = 115 
		, DETERMINISTIC_VK = 116 
		, DIMENSION_VK = 117 
		, DIRECT_MODE = 118 
		, DISABLE_VK = 119 
		, DISASSOCIATE_VK = 120 
		, DOCUMENT_VK = 121 
		, DOT_ASTERISK = 122 
		, DOUBLE_ASTERISK = 123 
		, DOUBLE_PERIOD = 124 
		, DOUBLE_VK = 125 
		, DSINTERVAL_UNCONSTRAINED_VK = 126 
		, ELEMENT = 127 
		, ELEMENTS_MODE = 128 
		, ENABLE_VK = 129 
		, ENCODING_VK = 130 
		, ENTITYESCAPING_VK = 131 
		, EQUALS_OP = 132 
		, EVALNAME_VK = 133 
		, EXACT_NUM_LIT = 134 
		, EXCEPTIONS_VK = 135 
		, EXCEPTION_INIT_VK = 136 
		, EXCEPTION_NAME = 137 
		, EXCLAMATION_OPERATOR_PART = 138 
		, EXCLUDE_VK = 139 
		, EXECUTE_VK = 140 
		, EXIT_VK = 141 
		, EXPLAIN_STATEMENT = 142 
		, EXPR = 143 
		, EXPR_LIST = 144 
		, EXTERNAL_VK = 145 
		, EXTRACT_VK = 146 
		, FACTORING = 147 
		, FINAL_VK = 148 
		, FIRST_VALUE_VK = 149 
		, FIRST_VK = 150 
		, FLOAT_VK = 151 
		, FOLLOWING_VK = 152 
		, FOLLOWS_VK = 153 
		, FORALL_VK = 154 
		, FORCE_VK = 155 
		, FOR_MULTI_COLUMN = 156 
		, FOR_NOTATION = 157 
		, FOR_SINGLE_COLUMN = 158 
		, FULL_VK = 159 
		, FUNCTION_ENABLING_OVER = 160 
		, FUNCTION_ENABLING_USING = 161 
		, FUNCTION_ENABLING_WITHIN_OR_OVER = 162 
		, FUNCTION_NAME = 163 
		, GREATER_THAN_OP = 164 
		, GREATER_THAN_OR_EQUALS_OP = 165 
		, GROUPING_VK = 166 
		, GROUPIN_SET = 167 
		, GROUP_BY_CLAUSE = 168 
		, GROUP_BY_ELEMENT = 169 
		, HASH_VK = 170 
		, HEX_STRING_LIT = 171 
		, HIDE_VK = 172 
		, HIERARCHICAL = 173 
		, HOSTED_VARIABLE = 174 
		, HOSTED_VARIABLE_NAME = 175 
		, HOSTED_VARIABLE_ROUTINE_CALL = 176 
		, HOUR_VK = 177 
		, ID = 178 
		, IGNORE_VK = 179 
		, IMMEDIATE_VK = 180 
		, IMPLEMENTATION_TYPE_NAME = 181 
		, INCLUDE_VK = 182 
		, INCLUDING_VK = 183 
		, INCREMENT_VK = 184 
		, INDENT_VK = 185 
		, INDEX_NAME = 186 
		, INLINE_VK = 187 
		, INNER_VK = 188 
		, INOUT_VK = 189 
		, INSTANTIABLE_VK = 190 
		, INSTEAD_VK = 191 
		, INTEGER_VK = 192 
		, INTERVAL_DATATYPE = 193 
		, INTRODUCER = 194 
		, INT_VK = 195 
		, INVALIDATE_VK = 196 
		, ISOLATION_VK = 197 
		, IS_A_SET = 198 
		, IS_EMPTY = 199 
		, IS_INFINITE = 200 
		, IS_NAN = 201 
		, IS_NOT_A_SET = 202 
		, IS_NOT_EMPTY = 203 
		, IS_NOT_INFINITE = 204 
		, IS_NOT_NAN = 205 
		, IS_NOT_NULL = 206 
		, IS_NOT_OF_TYPE = 207 
		, IS_NOT_PRESENT = 208 
		, IS_NULL = 209 
		, IS_OF_TYPE = 210 
		, IS_PRESENT = 211 
		, ITERATE_VK = 212 
		, JAVA_VK = 213 
		, JOIN_DEF = 214 
		, KEEP_VK = 215 
		, LABEL_NAME = 216 
		, LANGUAGE_VK = 217 
		, LAST_VALUE_VK = 218 
		, LAST_VK = 219 
		, LEADING_VK = 220 
		, LEFT_BRACKET = 221 
		, LEFT_PAREN = 222 
		, LEFT_VK = 223 
		, LESS_THAN_OP = 224 
		, LESS_THAN_OR_EQUALS_OP = 225 
		, LIBRARY_VK = 226 
		, LIKE2_VK = 227 
		, LIKE4_VK = 228 
		, LIKEC_VK = 229 
		, LIMIT_VK = 230 
		, LINK_NAME = 231 
		, LOCAL_VK = 232 
		, LOCK_TABLE_ELEMENT = 233 
		, LOGIC_EXPR = 234 
		, LOGOFF_VK = 235 
		, LOGON_VK = 236 
		, LOG_VK = 237 
		, LONG_VK = 238 
		, LOOP_VK = 239 
		, MAIN_MODEL = 240 
		, MAIN_MODEL_NAME = 241 
		, MAP_VK = 242 
		, MAXVALUE_VK = 243 
		, MEASURES_VK = 244 
		, MEMBER_VK = 245 
		, MERGE_INSERT = 246 
		, MERGE_UPDATE = 247 
		, MERGE_VK = 248 
		, MINUS_SIGN = 249 
		, MINUTE_VK = 250 
		, MINVALUE_VK = 251 
		, MLSLABEL_VK = 252 
		, MODEL_COLUMN = 253 
		, MODEL_COLUMNS = 254 
		, MODEL_EXPRESSION = 255 
		, MODEL_RULE = 256 
		, MODEL_RULES = 257 
		, MODIFY_VK = 258 
		, MONTH_VK = 259 
		, MULTI_TABLE_MODE = 260 
		, NAME_VK = 261 
		, NATIONAL_CHAR_STRING_LIT = 262 
		, NATIVE_DATATYPE = 263 
		, NATURALN_VK = 264 
		, NATURAL_VK = 265 
		, NAV_VK = 266 
		, NCHAR_CS_VK = 267 
		, NCHAR_VK = 268 
		, NCLOB_VK = 269 
		, NESTED_EXPR = 270 
		, NESTED_SUBQUERY = 271 
		, NESTED_VK = 272 
		, NEWLINE = 273 
		, NEW_VK = 274 
		, NOAUDIT_VK = 275 
		, NOCACHE_VK = 276 
		, NOCOPY_VK = 277 
		, NOCYCLE_VK = 278 
		, NOENTITYESCAPING_VK = 279 
		, NOMAXVALUE_VK = 280 
		, NOMINVALUE_VK = 281 
		, NOORDER_VK = 282 
		, NOSCHEMACHECK_VK = 283 
		, NOT_BETWEEN = 284 
		, NOT_EQUAL_OP = 285 
		, NOT_IN = 286 
		, NOT_LIKE = 287 
		, NO_VK = 288 
		, NULLS_VK = 289 
		, NUMBER_VK = 290 
		, NUMERIC_VK = 291 
		, NVARCHAR2_VK = 292 
		, OBJECT_VK = 293 
		, OFF_VK = 294 
		, OLD_VK = 295 
		, ONLY_VK = 296 
		, OPEN_VK = 297 
		, ORADATA_VK = 298 
		, ORDER_BY_ELEMENT = 299 
		, ORDER_BY_ELEMENTS = 300 
		, ORDINALITY_VK = 301 
		, OUT_VK = 302 
		, OVERRIDING_VK = 303 
		, OVER_VK = 304 
		, PACKAGE_NAME = 305 
		, PACKAGE_VK = 306 
		, PARALLEL_ENABLE_VK = 307 
		, PARAMETERS_VK = 308 
		, PARAMETER_NAME = 309 
		, PARENT_VK = 310 
		, PARTITION_VK = 311 
		, PASSING_VK = 312 
		, PERCENT = 313 
		, PERCENT_FOUND_VK = 314 
		, PERCENT_ISOPEN_VK = 315 
		, PERCENT_NOTFOUND_VK = 316 
		, PERCENT_ROWCOUNT_VK = 317 
		, PERCENT_ROWTYPE_VK = 318 
		, PERCENT_TYPE_VK = 319 
		, PERIOD = 320 
		, PIPELINED_VK = 321 
		, PIVOT_ALIAS = 322 
		, PIVOT_ELEMENT = 323 
		, PIVOT_IN_ELEMENT = 324 
		, PIVOT_VK = 325 
		, PLSQL_NON_RESERVED_CAST = 326 
		, PLSQL_NON_RESERVED_CONNECT_BY_ROOT = 327 
		, PLSQL_NON_RESERVED_ELSIF = 328 
		, PLSQL_NON_RESERVED_MODEL = 329 
		, PLSQL_NON_RESERVED_MULTISET = 330 
		, PLSQL_NON_RESERVED_PIVOT = 331 
		, PLSQL_NON_RESERVED_UNPIVOT = 332 
		, PLSQL_NON_RESERVED_USING = 333 
		, PLSQL_RESERVED_COLAUTH = 334 
		, PLSQL_RESERVED_COMPRESS = 335 
		, PLSQL_RESERVED_CRASH = 336 
		, PLSQL_RESERVED_EXCLUSIVE = 337 
		, PLSQL_RESERVED_IDENTIFIED = 338 
		, PLSQL_RESERVED_IF = 339 
		, PLSQL_RESERVED_INDEX = 340 
		, PLSQL_RESERVED_INDEXES = 341 
		, PLSQL_RESERVED_LOCK = 342 
		, PLSQL_RESERVED_MINUS = 343 
		, PLSQL_RESERVED_MODE = 344 
		, PLSQL_RESERVED_NOCOMPRESS = 345 
		, PLSQL_RESERVED_NOWAIT = 346 
		, PLSQL_RESERVED_RESOURCE = 347 
		, PLSQL_RESERVED_SHARE = 348 
		, PLSQL_RESERVED_START = 349 
		, PLSQL_RESERVED_TABAUTH = 350 
		, PLSQL_RESERVED_VIEWS = 351 
		, PLS_INTEGER_VK = 352 
		, PLUS_SIGN = 353 
		, POSITIVEN_VK = 354 
		, POSITIVE_VK = 355 
		, PRAGMA_VK = 356 
		, PRECEDING_VK = 357 
		, PRECISION = 358 
		, PRECISION_VK = 359 
		, PREDICTION_FUNCTION = 360 
		, PROCEDURE_NAME = 361 
		, PROMPT = 362 
		, QS_ANGLE = 363 
		, QS_BRACE = 364 
		, QS_BRACK = 365 
		, QS_OTHER = 366 
		, QS_OTHER_CH = 367 
		, QS_PAREN = 368 
		, QUERY_NAME = 369 
		, QUESTION_MARK = 370 
		, QUOTE = 371 
		, RAISE_VK = 372 
		, RANGE_VK = 373 
		, RAW_VK = 374 
		, READ_VK = 375 
		, REAL_VK = 376 
		, RECORD_NAME = 377 
		, REFERENCE_MODEL_NAME = 378 
		, REFERENCE_VK = 379 
		, REFERENCING_VK = 380 
		, REF_VK = 381 
		, REGULAR_ID = 382 
		, REJECT_VK = 383 
		, RELIES_ON_VK = 384 
		, RENAME_VK = 385 
		, REPLACE_VK = 386 
		, RESPECT_VK = 387 
		, RESTRICT_REFERENCES_VK = 388 
		, RESULT_CACHE_VK = 389 
		, RETURN_VK = 390 
		, REUSE_VK = 391 
		, REVERSE_VK = 392 
		, RIGHT_BRACKET = 393 
		, RIGHT_PAREN = 394 
		, RIGHT_VK = 395 
		, ROLLBACK_SEGMENT_NAME = 396 
		, ROLLBACK_VK = 397 
		, ROLLUP_VK = 398 
		, ROUTINE_CALL = 399 
		, ROUTINE_NAME = 400 
		, ROWID_VK = 401 
		, ROWS_VK = 402 
		, ROW_VK = 403 
		, RULES_VK = 404 
		, SAMPLE_VK = 405 
		, SAVEPOINT_NAME = 406 
		, SAVEPOINT_VK = 407 
		, SCHEMACHECK_VK = 408 
		, SCHEMA_NAME = 409 
		, SCHEMA_VK = 410 
		, SCN_VK = 411 
		, SEARCHED_CASE = 412 
		, SEARCH_VK = 413 
		, SECOND_VK = 414 
		, SEED_VK = 415 
		, SELECTED_TABLEVIEW = 416 
		, SELECT_ITEM = 417 
		, SELECT_LIST = 418 
		, SELECT_MODE = 419 
		, SELECT_STATEMENT = 420 
		, SELF_VK = 421 
		, SEMICOLON = 422 
		, SEPARATOR = 423 
		, SEQUENCE_NAME = 424 
		, SEQUENCE_VK = 425 
		, SEQUENTIAL_VK = 426 
		, SERIALIZABLE_VK = 427 
		, SERIALLY_REUSABLE_VK = 428 
		, SERVERERROR_VK = 429 
		, SESSIONTIMEZONE_VK = 430 
		, SET_VK = 431 
		, SHOW_VK = 432 
		, SHUTDOWN_VK = 433 
		, SIBLINGS_VK = 434 
		, SIGNTYPE_VK = 435 
		, SIMPLE_CASE = 436 
		, SIMPLE_INTEGER_VK = 437 
		, SIMPLE_LETTER = 438 
		, SINGLE_TABLE_MODE = 439 
		, SINGLE_VK = 440 
		, SKIP_VK = 441 
		, SMALLINT_VK = 442 
		, SOLIDUS = 443 
		, SOME_VK = 444 
		, SPACE = 445 
		, SPECIFICATION_VK = 446 
		, SQL92_RESERVED_ALL = 447 
		, SQL92_RESERVED_ALTER = 448 
		, SQL92_RESERVED_AND = 449 
		, SQL92_RESERVED_ANY = 450 
		, SQL92_RESERVED_AS = 451 
		, SQL92_RESERVED_ASC = 452 
		, SQL92_RESERVED_BEGIN = 453 
		, SQL92_RESERVED_BETWEEN = 454 
		, SQL92_RESERVED_BY = 455 
		, SQL92_RESERVED_CASE = 456 
		, SQL92_RESERVED_CHECK = 457 
		, SQL92_RESERVED_CONNECT = 458 
		, SQL92_RESERVED_CREATE = 459 
		, SQL92_RESERVED_CURRENT = 460 
		, SQL92_RESERVED_CURSOR = 461 
		, SQL92_RESERVED_DATE = 462 
		, SQL92_RESERVED_DECLARE = 463 
		, SQL92_RESERVED_DEFAULT = 464 
		, SQL92_RESERVED_DELETE = 465 
		, SQL92_RESERVED_DESC = 466 
		, SQL92_RESERVED_DISTINCT = 467 
		, SQL92_RESERVED_DROP = 468 
		, SQL92_RESERVED_ELSE = 469 
		, SQL92_RESERVED_END = 470 
		, SQL92_RESERVED_EXCEPTION = 471 
		, SQL92_RESERVED_EXISTS = 472 
		, SQL92_RESERVED_FALSE = 473 
		, SQL92_RESERVED_FETCH = 474 
		, SQL92_RESERVED_FOR = 475 
		, SQL92_RESERVED_FROM = 476 
		, SQL92_RESERVED_GOTO = 477 
		, SQL92_RESERVED_GRANT = 478 
		, SQL92_RESERVED_GROUP = 479 
		, SQL92_RESERVED_HAVING = 480 
		, SQL92_RESERVED_IN = 481 
		, SQL92_RESERVED_INSERT = 482 
		, SQL92_RESERVED_INTERSECT = 483 
		, SQL92_RESERVED_INTO = 484 
		, SQL92_RESERVED_IS = 485 
		, SQL92_RESERVED_LIKE = 486 
		, SQL92_RESERVED_NOT = 487 
		, SQL92_RESERVED_NULL = 488 
		, SQL92_RESERVED_OF = 489 
		, SQL92_RESERVED_ON = 490 
		, SQL92_RESERVED_OPTION = 491 
		, SQL92_RESERVED_OR = 492 
		, SQL92_RESERVED_ORDER = 493 
		, SQL92_RESERVED_OVERLAPS = 494 
		, SQL92_RESERVED_PRIOR = 495 
		, SQL92_RESERVED_PROCEDURE = 496 
		, SQL92_RESERVED_PUBLIC = 497 
		, SQL92_RESERVED_REVOKE = 498 
		, SQL92_RESERVED_SELECT = 499 
		, SQL92_RESERVED_SIZE = 500 
		, SQL92_RESERVED_TABLE = 501 
		, SQL92_RESERVED_THE = 502 
		, SQL92_RESERVED_THEN = 503 
		, SQL92_RESERVED_TO = 504 
		, SQL92_RESERVED_TRUE = 505 
		, SQL92_RESERVED_UNION = 506 
		, SQL92_RESERVED_UNIQUE = 507 
		, SQL92_RESERVED_UPDATE = 508 
		, SQL92_RESERVED_VALUES = 509 
		, SQL92_RESERVED_VIEW = 510 
		, SQL92_RESERVED_WHEN = 511 
		, SQL92_RESERVED_WHERE = 512 
		, SQL92_RESERVED_WITH = 513 
		, SQLDATA_VK = 514 
		, STANDALONE_VK = 515 
		, STANDARD_FUNCTION = 516 
		, STARTUP_VK = 517 
		, STATIC_RETURNING = 518 
		, STATIC_VK = 519 
		, STATISTICS_VK = 520 
		, STRING_VK = 521 
		, SUBMULTISET_VK = 522 
		, SUBPARTITION_VK = 523 
		, SUBQUERY = 524 
		, SUSPEND_VK = 525 
		, TABLEVIEW_NAME = 526 
		, TABLE_ELEMENT = 527 
		, TABLE_EXPRESSION = 528 
		, TABLE_REF = 529 
		, TABLE_REF_ELEMENT = 530 
		, TABLE_VAR_NAME = 531 
		, TILDE_OPERATOR_PART = 532 
		, TIMESTAMP_LTZ_UNCONSTRAINED_VK = 533 
		, TIMESTAMP_TZ_UNCONSTRAINED_VK = 534 
		, TIMESTAMP_UNCONSTRAINED_VK = 535 
		, TIMESTAMP_VK = 536 
		, TIMEZONE_ABBR_VK = 537 
		, TIMEZONE_HOUR_VK = 538 
		, TIMEZONE_MINUTE_VK = 539 
		, TIMEZONE_REGION_VK = 540 
		, TIME_VK = 541 
		, TRAILING_VK = 542 
		, TRANSLATE_VK = 543 
		, TREAT_VK = 544 
		, TRIGGER_NAME = 545 
		, TRIM_VK = 546 
		, TRUNCATE_VK = 547 
		, TYPE_NAME = 548 
		, TYPE_VK = 549 
		, T_BINDVAR_NAME = 550 
		, T_COLUMN_ALIAS = 551 
		, T_COLUMN_LIST = 552 
		, T_COLUMN_NAME = 553 
		, T_COND_AND = 554 
		, T_COND_AND_SEQ = 555 
		, T_COND_BETWEEN = 556 
		, T_COND_COMPARISON = 557 
		, T_COND_EQUALS_PATH = 558 
		, T_COND_EXISTS = 559 
		, T_COND_GROUP_COMPARISON = 560 
		, T_COND_IN = 561 
		, T_COND_IS = 562 
		, T_COND_IS_ANY = 563 
		, T_COND_IS_A_SET = 564 
		, T_COND_IS_EMPTY = 565 
		, T_COND_IS_OF_TYPE = 566 
		, T_COND_IS_PRESENT = 567 
		, T_COND_LIKE = 568 
		, T_COND_MEMEBER = 569 
		, T_COND_NOT = 570 
		, T_COND_OR = 571 
		, T_COND_OR_SEQ = 572 
		, T_COND_PAREN = 573 
		, T_COND_REGEXP_LIKE = 574 
		, T_COND_SUBMULTISET = 575 
		, T_COND_UNDER_PATH = 576 
		, T_DBLINK_NAME = 577 
		, T_DECL = 578 
		, T_FOR_UPDATE_CLAUSE = 579 
		, T_FROM = 580 
		, T_FUNCTION_NAME = 581 
		, T_GROUP_BY = 582 
		, T_HIERARCHICAL = 583 
		, T_IDENTIFIER = 584 
		, T_JOINING_CLAUSE = 585 
		, T_MODEL = 586 
		, T_OPERATOR_BINARY = 587 
		, T_OPERATOR_PART = 588 
		, T_OPERATOR_UNARY = 589 
		, T_ORDER_BY_CLAUSE = 590 
		, T_PACKAGE_NAME = 591 
		, T_RESERVED = 592 
		, T_SCHEMA_NAME = 593 
		, T_SELECT = 594 
		, T_SELECT_COLUMN = 595 
		, T_SUBQUERY = 596 
		, T_TABLE_ALIAS = 597 
		, T_TABLE_CAST = 598 
		, T_TABLE_NAME = 599 
		, T_TABLE_REF = 600 
		, T_UNION = 601 
		, T_UNKNOWN = 602 
		, T_USE = 603 
		, T_WHERE = 604 
		, T_WITH = 605 
		, UNARY_OPERATOR = 606 
		, UNBOUNDED_VK = 607 
		, UNDERSCORE = 608 
		, UNDER_VK = 609 
		, UNLIMITED_VK = 610 
		, UNPIVOT_IN_ELEMENT = 611 
		, UNPIVOT_VK = 612 
		, UNSIGNED_INTEGER = 613 
		, UNTIL_VK = 614 
		, UPDATED_VK = 615 
		, UPSERT_VK = 616 
		, UROWID_VK = 617 
		, VALIDATE_VK = 618 
		, VALUE_VK = 619 
		, VARCHAR2_VK = 620 
		, VARCHAR_VK = 621 
		, VARIABLE_NAME = 622 
		, VECTOR_EXPR = 623 
		, VERSIONS_VK = 624 
		, VERSION_VK = 625 
		, VERTICAL_BAR = 626 
		, WAIT_VK = 627 
		, WELLFORMED_VK = 628 
		, WITHIN_VK = 629 
		, WORK_VK = 630 
		, WRITE_VK = 631 
		, XMLAGG_VK = 632 
		, XMLATTRIBUTES_VK = 633 
		, XMLCAST_VK = 634 
		, XMLCOLATTVAL_VK = 635 
		, XMLELEMENT_VK = 636 
		, XMLEXISTS_VK = 637 
		, XMLFOREST_VK = 638 
		, XMLNAMESPACES_VK = 639 
		, XMLPARSE_VK = 640 
		, XMLPI_VK = 641 
		, XMLQUERY_VK = 642 
		, XMLROOT_VK = 643 
		, XMLSERIALIZE_VK = 644 
		, XMLTABLE_VK = 645 
		, XML_ALIAS = 646 
		, XML_COLUMN = 647 
		, XML_COLUMN_NAME = 648 
		, XML_ELEMENT = 649 
		, XML_VK = 650 
		, YEAR_VK = 651 
		, YES_VK = 652 
		, YMINTERVAL_UNCONSTRAINED_VK = 653 
		, ZV = 654 
		, CONJUNCTION = 665 
		, DISJUNCTION = 667 
	};
};

/** Context tracking structure for OracleDML_OracleDMLCommons
 */
class OracleDML_OracleDMLCommons : public OracleDML_OracleDMLCommonsImplTraits::BaseParserType
    , public OracleDML_OracleDMLCommonsTokens
{
public:
	typedef OracleDML_OracleDMLCommonsImplTraits ImplTraits;
	typedef OracleDML_OracleDMLCommons ComponentType;
	typedef ComponentType::StreamType StreamType;
	typedef OracleDML_OracleDMLCommonsImplTraits::BaseParserType BaseType;
	typedef ImplTraits::RecognizerSharedStateType<StreamType> RecognizerSharedStateType;
	typedef StreamType InputType;
	typedef OracleDML_OracleDMLCommonsImplTraits::CommonTokenType CommonTokenType;
	typedef OracleDML_OracleDMLCommonsImplTraits::TreeAdaptorType TreeAdaptorType;

	static const bool IsFiltered = false;


private:	
	OracleDML*	 m_gOracleDML;
public:
    OracleDML_OracleDMLCommons(InputType* instream, OracleDML* gOracleDML);
    OracleDML_OracleDMLCommons(InputType* instream, RecognizerSharedStateType* state, OracleDML* gOracleDML);

    void init(InputType* instream , OracleDML* gOracleDML );
    static ANTLR_UINT8** getTokenNames();


    struct partition_extension_clause_return : public OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType BaseType;
        partition_extension_clause_return()
            : BaseType()
            {}
        partition_extension_clause_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        partition_extension_clause_return( partition_extension_clause_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~partition_extension_clause_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        partition_extension_clause_return&
        operator=( partition_extension_clause_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct column_alias_return : public OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType BaseType;
        column_alias_return()
            : BaseType()
            {}
        column_alias_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        column_alias_return( column_alias_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~column_alias_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        column_alias_return&
        operator=( column_alias_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct table_alias_return : public OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType BaseType;
        table_alias_return()
            : BaseType()
            {}
        table_alias_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        table_alias_return( table_alias_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~table_alias_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        table_alias_return&
        operator=( table_alias_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct alias_quoted_string_return : public OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType BaseType;
        alias_quoted_string_return()
            : BaseType()
            {}
        alias_quoted_string_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        alias_quoted_string_return( alias_quoted_string_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~alias_quoted_string_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        alias_quoted_string_return&
        operator=( alias_quoted_string_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct where_clause_return : public OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType BaseType;
        where_clause_return()
            : BaseType()
            {}
        where_clause_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        where_clause_return( where_clause_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~where_clause_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        where_clause_return&
        operator=( where_clause_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct current_of_clause_return : public OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType BaseType;
        current_of_clause_return()
            : BaseType()
            {}
        current_of_clause_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        current_of_clause_return( current_of_clause_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~current_of_clause_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        current_of_clause_return&
        operator=( current_of_clause_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct into_clause_return : public OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType BaseType;
        into_clause_return()
            : BaseType()
            {}
        into_clause_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        into_clause_return( into_clause_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~into_clause_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        into_clause_return&
        operator=( into_clause_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct xml_column_name_return : public OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType BaseType;
        xml_column_name_return()
            : BaseType()
            {}
        xml_column_name_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        xml_column_name_return( xml_column_name_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~xml_column_name_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        xml_column_name_return&
        operator=( xml_column_name_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct cost_class_name_return : public OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType BaseType;
        cost_class_name_return()
            : BaseType()
            {}
        cost_class_name_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        cost_class_name_return( cost_class_name_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~cost_class_name_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        cost_class_name_return&
        operator=( cost_class_name_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct attribute_name_return : public OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType BaseType;
        attribute_name_return()
            : BaseType()
            {}
        attribute_name_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        attribute_name_return( attribute_name_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~attribute_name_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        attribute_name_return&
        operator=( attribute_name_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct savepoint_name_return : public OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType BaseType;
        savepoint_name_return()
            : BaseType()
            {}
        savepoint_name_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        savepoint_name_return( savepoint_name_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~savepoint_name_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        savepoint_name_return&
        operator=( savepoint_name_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct rollback_segment_name_return : public OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType BaseType;
        rollback_segment_name_return()
            : BaseType()
            {}
        rollback_segment_name_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        rollback_segment_name_return( rollback_segment_name_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~rollback_segment_name_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        rollback_segment_name_return&
        operator=( rollback_segment_name_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct package_name_return : public OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType BaseType;
        package_name_return()
            : BaseType()
            {}
        package_name_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        package_name_return( package_name_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~package_name_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        package_name_return&
        operator=( package_name_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct implementation_type_name_return : public OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType BaseType;
        implementation_type_name_return()
            : BaseType()
            {}
        implementation_type_name_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        implementation_type_name_return( implementation_type_name_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~implementation_type_name_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        implementation_type_name_return&
        operator=( implementation_type_name_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct parameter_name_return : public OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType BaseType;
        parameter_name_return()
            : BaseType()
            {}
        parameter_name_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        parameter_name_return( parameter_name_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~parameter_name_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        parameter_name_return&
        operator=( parameter_name_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct reference_model_name_return : public OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType BaseType;
        reference_model_name_return()
            : BaseType()
            {}
        reference_model_name_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        reference_model_name_return( reference_model_name_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~reference_model_name_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        reference_model_name_return&
        operator=( reference_model_name_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct main_model_name_return : public OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType BaseType;
        main_model_name_return()
            : BaseType()
            {}
        main_model_name_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        main_model_name_return( main_model_name_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~main_model_name_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        main_model_name_return&
        operator=( main_model_name_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct aggregate_function_name_return : public OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType BaseType;
        aggregate_function_name_return()
            : BaseType()
            {}
        aggregate_function_name_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        aggregate_function_name_return( aggregate_function_name_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~aggregate_function_name_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        aggregate_function_name_return&
        operator=( aggregate_function_name_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct query_name_return : public OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType BaseType;
        query_name_return()
            : BaseType()
            {}
        query_name_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        query_name_return( query_name_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~query_name_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        query_name_return&
        operator=( query_name_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct constraint_name_return : public OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType BaseType;
        constraint_name_return()
            : BaseType()
            {}
        constraint_name_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        constraint_name_return( constraint_name_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~constraint_name_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        constraint_name_return&
        operator=( constraint_name_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct label_name_return : public OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType BaseType;
        label_name_return()
            : BaseType()
            {}
        label_name_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        label_name_return( label_name_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~label_name_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        label_name_return&
        operator=( label_name_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct type_name_return : public OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType BaseType;
        type_name_return()
            : BaseType()
            {}
        type_name_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        type_name_return( type_name_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~type_name_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        type_name_return&
        operator=( type_name_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct sequence_name_return : public OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType BaseType;
        sequence_name_return()
            : BaseType()
            {}
        sequence_name_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        sequence_name_return( sequence_name_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~sequence_name_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        sequence_name_return&
        operator=( sequence_name_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct exception_name_return : public OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType BaseType;
        exception_name_return()
            : BaseType()
            {}
        exception_name_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        exception_name_return( exception_name_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~exception_name_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        exception_name_return&
        operator=( exception_name_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct function_name_return : public OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType BaseType;
        function_name_return()
            : BaseType()
            {}
        function_name_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        function_name_return( function_name_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~function_name_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        function_name_return&
        operator=( function_name_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct procedure_name_return : public OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType BaseType;
        procedure_name_return()
            : BaseType()
            {}
        procedure_name_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        procedure_name_return( procedure_name_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~procedure_name_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        procedure_name_return&
        operator=( procedure_name_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct trigger_name_return : public OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType BaseType;
        trigger_name_return()
            : BaseType()
            {}
        trigger_name_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        trigger_name_return( trigger_name_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~trigger_name_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        trigger_name_return&
        operator=( trigger_name_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct variable_name_return : public OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType BaseType;
        variable_name_return()
            : BaseType()
            {}
        variable_name_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        variable_name_return( variable_name_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~variable_name_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        variable_name_return&
        operator=( variable_name_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct index_name_return : public OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType BaseType;
        index_name_return()
            : BaseType()
            {}
        index_name_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        index_name_return( index_name_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~index_name_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        index_name_return&
        operator=( index_name_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct cursor_name_return : public OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType BaseType;
        cursor_name_return()
            : BaseType()
            {}
        cursor_name_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        cursor_name_return( cursor_name_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~cursor_name_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        cursor_name_return&
        operator=( cursor_name_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct record_name_return : public OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType BaseType;
        record_name_return()
            : BaseType()
            {}
        record_name_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        record_name_return( record_name_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~record_name_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        record_name_return&
        operator=( record_name_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct collection_name_return : public OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType BaseType;
        collection_name_return()
            : BaseType()
            {}
        collection_name_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        collection_name_return( collection_name_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~collection_name_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        collection_name_return&
        operator=( collection_name_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct link_name_return : public OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType BaseType;
        link_name_return()
            : BaseType()
            {}
        link_name_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        link_name_return( link_name_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~link_name_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        link_name_return&
        operator=( link_name_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct column_name_return : public OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType BaseType;
        column_name_return()
            : BaseType()
            {}
        column_name_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        column_name_return( column_name_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~column_name_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        column_name_return&
        operator=( column_name_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct tableview_name_return : public OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType BaseType;
        tableview_name_return()
            : BaseType()
            {}
        tableview_name_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        tableview_name_return( tableview_name_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~tableview_name_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        tableview_name_return&
        operator=( tableview_name_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct char_set_name_return : public OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType BaseType;
        char_set_name_return()
            : BaseType()
            {}
        char_set_name_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        char_set_name_return( char_set_name_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~char_set_name_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        char_set_name_return&
        operator=( char_set_name_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct keep_clause_return : public OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType BaseType;
        keep_clause_return()
            : BaseType()
            {}
        keep_clause_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        keep_clause_return( keep_clause_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~keep_clause_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        keep_clause_return&
        operator=( keep_clause_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct function_argument_return : public OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType BaseType;
        function_argument_return()
            : BaseType()
            {}
        function_argument_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        function_argument_return( function_argument_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~function_argument_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        function_argument_return&
        operator=( function_argument_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct function_argument_analytic_return : public OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType BaseType;
        function_argument_analytic_return()
            : BaseType()
            {}
        function_argument_analytic_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        function_argument_analytic_return( function_argument_analytic_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~function_argument_analytic_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        function_argument_analytic_return&
        operator=( function_argument_analytic_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct function_argument_modeling_return : public OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType BaseType;
        function_argument_modeling_return()
            : BaseType()
            {}
        function_argument_modeling_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        function_argument_modeling_return( function_argument_modeling_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~function_argument_modeling_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        function_argument_modeling_return&
        operator=( function_argument_modeling_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct respect_or_ignore_nulls_return : public OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType BaseType;
        respect_or_ignore_nulls_return()
            : BaseType()
            {}
        respect_or_ignore_nulls_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        respect_or_ignore_nulls_return( respect_or_ignore_nulls_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~respect_or_ignore_nulls_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        respect_or_ignore_nulls_return&
        operator=( respect_or_ignore_nulls_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct argument_return : public OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType BaseType;
        argument_return()
            : BaseType()
            {}
        argument_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        argument_return( argument_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~argument_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        argument_return&
        operator=( argument_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct type_spec_return : public OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType BaseType;
        type_spec_return()
            : BaseType()
            {}
        type_spec_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        type_spec_return( type_spec_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~type_spec_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        type_spec_return&
        operator=( type_spec_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct datatype_return : public OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType BaseType;
        datatype_return()
            : BaseType()
            {}
        datatype_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        datatype_return( datatype_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~datatype_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        datatype_return&
        operator=( datatype_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct precision_part_return : public OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType BaseType;
        precision_part_return()
            : BaseType()
            {}
        precision_part_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        precision_part_return( precision_part_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~precision_part_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        precision_part_return&
        operator=( precision_part_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct native_datatype_element_return : public OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType BaseType;
        native_datatype_element_return()
            : BaseType()
            {}
        native_datatype_element_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        native_datatype_element_return( native_datatype_element_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~native_datatype_element_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        native_datatype_element_return&
        operator=( native_datatype_element_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct bind_variable_return : public OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType BaseType;
        bind_variable_return()
            : BaseType()
            {}
        bind_variable_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        bind_variable_return( bind_variable_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~bind_variable_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        bind_variable_return&
        operator=( bind_variable_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct general_element_return : public OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType BaseType;
        general_element_return()
            : BaseType()
            {}
        general_element_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        general_element_return( general_element_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~general_element_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        general_element_return&
        operator=( general_element_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct general_element_part_return : public OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType BaseType;
        general_element_part_return()
            : BaseType()
            {}
        general_element_part_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        general_element_part_return( general_element_part_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~general_element_part_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        general_element_part_return&
        operator=( general_element_part_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct table_element_return : public OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType BaseType;
        table_element_return()
            : BaseType()
            {}
        table_element_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        table_element_return( table_element_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~table_element_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        table_element_return&
        operator=( table_element_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct constant_return : public OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType BaseType;
        constant_return()
            : BaseType()
            {}
        constant_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        constant_return( constant_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~constant_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        constant_return&
        operator=( constant_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct numeric_return : public OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType BaseType;
        numeric_return()
            : BaseType()
            {}
        numeric_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        numeric_return( numeric_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~numeric_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        numeric_return&
        operator=( numeric_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct quoted_string_return : public OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType BaseType;
        quoted_string_return()
            : BaseType()
            {}
        quoted_string_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        quoted_string_return( quoted_string_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~quoted_string_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        quoted_string_return&
        operator=( quoted_string_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct id_return : public OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType BaseType;
        id_return()
            : BaseType()
            {}
        id_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        id_return( id_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~id_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        id_return&
        operator=( id_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct id_expression_return : public OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType BaseType;
        id_expression_return()
            : BaseType()
            {}
        id_expression_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        id_expression_return( id_expression_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~id_expression_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        id_expression_return&
        operator=( id_expression_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct not_equal_op_return : public OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType BaseType;
        not_equal_op_return()
            : BaseType()
            {}
        not_equal_op_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        not_equal_op_return( not_equal_op_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~not_equal_op_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        not_equal_op_return&
        operator=( not_equal_op_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct greater_than_or_equals_op_return : public OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType BaseType;
        greater_than_or_equals_op_return()
            : BaseType()
            {}
        greater_than_or_equals_op_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        greater_than_or_equals_op_return( greater_than_or_equals_op_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~greater_than_or_equals_op_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        greater_than_or_equals_op_return&
        operator=( greater_than_or_equals_op_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct less_than_or_equals_op_return : public OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType BaseType;
        less_than_or_equals_op_return()
            : BaseType()
            {}
        less_than_or_equals_op_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        less_than_or_equals_op_return( less_than_or_equals_op_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~less_than_or_equals_op_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        less_than_or_equals_op_return&
        operator=( less_than_or_equals_op_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct concatenation_op_return : public OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType BaseType;
        concatenation_op_return()
            : BaseType()
            {}
        concatenation_op_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        concatenation_op_return( concatenation_op_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~concatenation_op_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        concatenation_op_return&
        operator=( concatenation_op_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct multiset_op_return : public OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType BaseType;
        multiset_op_return()
            : BaseType()
            {}
        multiset_op_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        multiset_op_return( multiset_op_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~multiset_op_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        multiset_op_return&
        operator=( multiset_op_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


    struct outer_join_sign_return : public OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType
    {
    public:
        typedef OracleDML_OracleDMLCommonsImplTraits::RuleReturnValueType BaseType;
        outer_join_sign_return()
            : BaseType()
            {}
        outer_join_sign_return( BaseParserType* parser )
            : BaseType(parser)
            {}
        outer_join_sign_return( outer_join_sign_return&& other )
            : BaseType(other)
        {
            tree = std::move(other.tree);
        }
        ~outer_join_sign_return()
        {
            //if(tree != NULL)
            //    delete tree;
        }

        outer_join_sign_return&
        operator=( outer_join_sign_return&& other )
        {
            BaseType::operator=( other );
            tree = std::move(other.tree);
        	return *this;
        }

        ImplTraits::TreeTypePtr tree;
    };


     OracleDML_OracleDMLCommons::partition_extension_clause_return partition_extension_clause (); 
     OracleDML_OracleDMLCommons::column_alias_return column_alias (); 
     OracleDML_OracleDMLCommons::table_alias_return table_alias (); 
     OracleDML_OracleDMLCommons::alias_quoted_string_return alias_quoted_string (int toraTokenType, int usageType); 
     OracleDML_OracleDMLCommons::where_clause_return where_clause (); 
     OracleDML_OracleDMLCommons::current_of_clause_return current_of_clause (); 
     OracleDML_OracleDMLCommons::into_clause_return into_clause (); 
     OracleDML_OracleDMLCommons::xml_column_name_return xml_column_name (); 
     OracleDML_OracleDMLCommons::cost_class_name_return cost_class_name (); 
     OracleDML_OracleDMLCommons::attribute_name_return attribute_name (); 
     OracleDML_OracleDMLCommons::savepoint_name_return savepoint_name (); 
     OracleDML_OracleDMLCommons::rollback_segment_name_return rollback_segment_name (); 
     OracleDML_OracleDMLCommons::package_name_return package_name (); 
     OracleDML_OracleDMLCommons::implementation_type_name_return implementation_type_name (); 
     OracleDML_OracleDMLCommons::parameter_name_return parameter_name (); 
     OracleDML_OracleDMLCommons::reference_model_name_return reference_model_name (); 
     OracleDML_OracleDMLCommons::main_model_name_return main_model_name (); 
     OracleDML_OracleDMLCommons::aggregate_function_name_return aggregate_function_name (); 
     OracleDML_OracleDMLCommons::query_name_return query_name (); 
     OracleDML_OracleDMLCommons::constraint_name_return constraint_name (); 
     OracleDML_OracleDMLCommons::label_name_return label_name (); 
     OracleDML_OracleDMLCommons::type_name_return type_name (); 
     OracleDML_OracleDMLCommons::sequence_name_return sequence_name (); 
     OracleDML_OracleDMLCommons::exception_name_return exception_name (); 
     OracleDML_OracleDMLCommons::function_name_return function_name (); 
     OracleDML_OracleDMLCommons::procedure_name_return procedure_name (); 
     OracleDML_OracleDMLCommons::trigger_name_return trigger_name (); 
     OracleDML_OracleDMLCommons::variable_name_return variable_name (); 
     OracleDML_OracleDMLCommons::index_name_return index_name (); 
     OracleDML_OracleDMLCommons::cursor_name_return cursor_name (); 
     OracleDML_OracleDMLCommons::record_name_return record_name (); 
     OracleDML_OracleDMLCommons::collection_name_return collection_name (); 
     OracleDML_OracleDMLCommons::link_name_return link_name (); 
     OracleDML_OracleDMLCommons::column_name_return column_name (); 
     OracleDML_OracleDMLCommons::tableview_name_return tableview_name (); 
     OracleDML_OracleDMLCommons::char_set_name_return char_set_name (); 
     OracleDML_OracleDMLCommons::keep_clause_return keep_clause (); 
     OracleDML_OracleDMLCommons::function_argument_return function_argument (); 
     OracleDML_OracleDMLCommons::function_argument_analytic_return function_argument_analytic (); 
     OracleDML_OracleDMLCommons::function_argument_modeling_return function_argument_modeling (); 
     OracleDML_OracleDMLCommons::respect_or_ignore_nulls_return respect_or_ignore_nulls (); 
     OracleDML_OracleDMLCommons::argument_return argument (); 
     OracleDML_OracleDMLCommons::type_spec_return type_spec (); 
     OracleDML_OracleDMLCommons::datatype_return datatype (); 
     OracleDML_OracleDMLCommons::precision_part_return precision_part (); 
     OracleDML_OracleDMLCommons::native_datatype_element_return native_datatype_element (); 
     OracleDML_OracleDMLCommons::bind_variable_return bind_variable (); 
     OracleDML_OracleDMLCommons::general_element_return general_element (); 
     OracleDML_OracleDMLCommons::general_element_part_return general_element_part (); 
     OracleDML_OracleDMLCommons::table_element_return table_element (); 
     OracleDML_OracleDMLCommons::constant_return constant (); 
     OracleDML_OracleDMLCommons::numeric_return numeric (); 
     OracleDML_OracleDMLCommons::quoted_string_return quoted_string (); 
     OracleDML_OracleDMLCommons::id_return id (int toraTokenType, int usageType); 
     OracleDML_OracleDMLCommons::id_expression_return id_expression (int toraTokenType, int usageType); 
     OracleDML_OracleDMLCommons::not_equal_op_return not_equal_op (); 
     OracleDML_OracleDMLCommons::greater_than_or_equals_op_return greater_than_or_equals_op (); 
     OracleDML_OracleDMLCommons::less_than_or_equals_op_return less_than_or_equals_op (); 
     OracleDML_OracleDMLCommons::concatenation_op_return concatenation_op (); 
     OracleDML_OracleDMLCommons::multiset_op_return multiset_op (); 
     OracleDML_OracleDMLCommons::outer_join_sign_return outer_join_sign (); 






















      bool msynpred( antlr3::ClassForwarder< synpred1_OracleDMLCommons > );
        void msynpred1_OracleDMLCommons_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred2_OracleDMLCommons > );
        void msynpred2_OracleDMLCommons_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred3_OracleDMLCommons > );
        void msynpred3_OracleDMLCommons_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred4_OracleDMLCommons > );
        void msynpred4_OracleDMLCommons_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred5_OracleDMLCommons > );
        void msynpred5_OracleDMLCommons_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred6_OracleDMLCommons > );
        void msynpred6_OracleDMLCommons_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred7_OracleDMLCommons > );
        void msynpred7_OracleDMLCommons_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred8_OracleDMLCommons > );
        void msynpred8_OracleDMLCommons_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred9_OracleDMLCommons > );
        void msynpred9_OracleDMLCommons_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred10_OracleDMLCommons > );
        void msynpred10_OracleDMLCommons_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred11_OracleDMLCommons > );
        void msynpred11_OracleDMLCommons_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred12_OracleDMLCommons > );
        void msynpred12_OracleDMLCommons_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred13_OracleDMLCommons > );
        void msynpred13_OracleDMLCommons_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred14_OracleDMLCommons > );
        void msynpred14_OracleDMLCommons_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred15_OracleDMLCommons > );
        void msynpred15_OracleDMLCommons_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred16_OracleDMLCommons > );
        void msynpred16_OracleDMLCommons_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred17_OracleDMLCommons > );
        void msynpred17_OracleDMLCommons_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred18_OracleDMLCommons > );
        void msynpred18_OracleDMLCommons_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred19_OracleDMLCommons > );
        void msynpred19_OracleDMLCommons_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred20_OracleDMLCommons > );
        void msynpred20_OracleDMLCommons_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred21_OracleDMLCommons > );
        void msynpred21_OracleDMLCommons_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred22_OracleDMLCommons > );
        void msynpred22_OracleDMLCommons_fragment ();
    // Delegated rules

    const char *    getGrammarFileName();
    void            reset();
    ~OracleDML_OracleDMLCommons();

};

// Function protoypes for the constructor functions that external translation units
// such as delegators and delegates may wish to call.
//
extern ANTLR_UINT8*   OracleDMLTokenNames[];


/* End of token definitions for OracleDML_OracleDMLCommons
 * =============================================================================
 */

}

#endif

/* END - Note:Keep extra line feed to satisfy UNIX systems */
